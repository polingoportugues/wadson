const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["assets/solana-vendor-E3c5Mf0a.js", "assets/react-vendor-1qCqAHqt.js", "assets/core-C7HL8QDL.js", "assets/pixi-vendor-CD9TR_py.js", "assets/lit-element-bcC7X8ka.js", "assets/index-Zw94n4Z1.js", "assets/mui-vendor-DDV5n_UM.js", "assets/utils-vendor-Dn72NG2i.js", "assets/state-vendor-Cp_ttFKi.js", "assets/index-t-8BKzI0.js"]))) => i.map(i => d[i]);
import {
    k as q4,
    s as bS,
    a as vS,
    B as Et,
    b as Ve,
    E as Ed,
    c as jW,
    d as RW,
    r as MW,
    h as DW,
    e as LW,
    f as UW
} from "./solana-vendor-E3c5Mf0a.js";
import {
    r as v,
    j as d,
    R as at,
    a as Zo,
    b as Uv
} from "./mui-vendor-DDV5n_UM.js";
import {
    _ as ma
} from "./pixi-vendor-CD9TR_py.js";
import {
    r as FW,
    p as jn,
    g as Oa,
    b as xS
} from "./react-vendor-1qCqAHqt.js";
import {
    f as BW,
    d as z,
    l as pi,
    m as ES
} from "./utils-vendor-Dn72NG2i.js";
import {
    w as WW
} from "./state-vendor-Cp_ttFKi.js";

function zW(t) {
    if (typeof window > "u") return;
    const e = r => t(r.detail);
    return window.addEventListener("eip6963:announceProvider", e), window.dispatchEvent(new CustomEvent("eip6963:requestProvider")), () => window.removeEventListener("eip6963:announceProvider", e)
}

function qW() {
    const t = new Set;
    let e = [];
    const r = () => zW(i => {
        e.some(({
            info: s
        }) => s.uuid === i.info.uuid) || (e = [...e, i], t.forEach(s => s(e, {
            added: [i]
        })))
    });
    let n = r();
    return {
        _listeners() {
            return t
        },
        clear() {
            t.forEach(i => i([], {
                removed: [...e]
            })), e = []
        },
        destroy() {
            this.clear(), t.clear(), n == null || n()
        },
        findProvider({
            rdns: i
        }) {
            return e.find(s => s.info.rdns === i)
        },
        getProviders() {
            return e
        },
        reset() {
            this.clear(), n == null || n(), n = r()
        },
        subscribe(i, {
            emitImmediately: s
        } = {}) {
            return t.add(i), s && i(e, {
                added: e
            }), () => t.delete(i)
        }
    }
}
var Ke = {},
    wf = {
        exports: {}
    },
    HW = wf.exports,
    G8;

function VW() {
    return G8 || (G8 = 1, function(t, e) {
        (function(r, n) {
            var i = "1.0.40",
                s = "",
                a = "?",
                o = "function",
                c = "undefined",
                l = "object",
                u = "string",
                h = "major",
                f = "model",
                p = "name",
                g = "type",
                m = "vendor",
                y = "version",
                w = "architecture",
                x = "console",
                E = "mobile",
                _ = "tablet",
                b = "smarttv",
                A = "wearable",
                I = "embedded",
                T = 500,
                C = "Amazon",
                $ = "Apple",
                P = "ASUS",
                N = "BlackBerry",
                R = "Browser",
                D = "Chrome",
                S = "Edge",
                O = "Firefox",
                M = "Google",
                U = "Huawei",
                k = "LG",
                F = "Microsoft",
                q = "Motorola",
                W = "Opera",
                K = "Samsung",
                H = "Sharp",
                j = "Sony",
                V = "Xiaomi",
                Y = "Zebra",
                X = "Facebook",
                ne = "Chromium OS",
                ae = "Mac OS",
                ue = " Browser",
                he = function(Ue, De) {
                    var We = {};
                    for (var dt in Ue) De[dt] && De[dt].length % 2 === 0 ? We[dt] = De[dt].concat(Ue[dt]) : We[dt] = Ue[dt];
                    return We
                },
                fe = function(Ue) {
                    for (var De = {}, We = 0; We < Ue.length; We++) De[Ue[We].toUpperCase()] = Ue[We];
                    return De
                },
                de = function(Ue, De) {
                    return typeof Ue === u ? ye(De).indexOf(ye(Ue)) !== -1 : !1
                },
                ye = function(Ue) {
                    return Ue.toLowerCase()
                },
                Be = function(Ue) {
                    return typeof Ue === u ? Ue.replace(/[^\d\.]/g, s).split(".")[0] : n
                },
                ce = function(Ue, De) {
                    if (typeof Ue === u) return Ue = Ue.replace(/^\s\s*/, s), typeof De === c ? Ue : Ue.substring(0, T)
                },
                Ie = function(Ue, De) {
                    for (var We = 0, dt, He, ut, Ye, we, vt; We < De.length && !we;) {
                        var Lt = De[We],
                            _t = De[We + 1];
                        for (dt = He = 0; dt < Lt.length && !we && Lt[dt];)
                            if (we = Lt[dt++].exec(Ue), we)
                                for (ut = 0; ut < _t.length; ut++) vt = we[++He], Ye = _t[ut], typeof Ye === l && Ye.length > 0 ? Ye.length === 2 ? typeof Ye[1] == o ? this[Ye[0]] = Ye[1].call(this, vt) : this[Ye[0]] = Ye[1] : Ye.length === 3 ? typeof Ye[1] === o && !(Ye[1].exec && Ye[1].test) ? this[Ye[0]] = vt ? Ye[1].call(this, vt, Ye[2]) : n : this[Ye[0]] = vt ? vt.replace(Ye[1], Ye[2]) : n : Ye.length === 4 && (this[Ye[0]] = vt ? Ye[3].call(this, vt.replace(Ye[1], Ye[2])) : n) : this[Ye] = vt || n;
                        We += 2
                    }
                },
                xe = function(Ue, De) {
                    for (var We in De)
                        if (typeof De[We] === l && De[We].length > 0) {
                            for (var dt = 0; dt < De[We].length; dt++)
                                if (de(De[We][dt], Ue)) return We === a ? n : We
                        } else if (de(De[We], Ue)) return We === a ? n : We;
                    return De.hasOwnProperty("*") ? De["*"] : Ue
                },
                ie = {
                    "1.0": "/8",
                    1.2: "/1",
                    1.3: "/3",
                    "2.0": "/412",
                    "2.0.2": "/416",
                    "2.0.3": "/417",
                    "2.0.4": "/419",
                    "?": "/"
                },
                Ee = {
                    ME: "4.90",
                    "NT 3.11": "NT3.51",
                    "NT 4.0": "NT4.0",
                    2e3: "NT 5.0",
                    XP: ["NT 5.1", "NT 5.2"],
                    Vista: "NT 6.0",
                    7: "NT 6.1",
                    8: "NT 6.2",
                    8.1: "NT 6.3",
                    10: ["NT 6.4", "NT 10.0"],
                    RT: "ARM"
                },
                ft = {
                    browser: [
                        [/\b(?:crmo|crios)\/([\w\.]+)/i],
                        [y, [p, "Chrome"]],
                        [/edg(?:e|ios|a)?\/([\w\.]+)/i],
                        [y, [p, "Edge"]],
                        [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i],
                        [p, y],
                        [/opios[\/ ]+([\w\.]+)/i],
                        [y, [p, W + " Mini"]],
                        [/\bop(?:rg)?x\/([\w\.]+)/i],
                        [y, [p, W + " GX"]],
                        [/\bopr\/([\w\.]+)/i],
                        [y, [p, W]],
                        [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i],
                        [y, [p, "Baidu"]],
                        [/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i],
                        [y, [p, "Maxthon"]],
                        [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i, /(heytap|ovi|115)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i],
                        [p, y],
                        [/quark(?:pc)?\/([-\w\.]+)/i],
                        [y, [p, "Quark"]],
                        [/\bddg\/([\w\.]+)/i],
                        [y, [p, "DuckDuckGo"]],
                        [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],
                        [y, [p, "UC" + R]],
                        [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i],
                        [y, [p, "WeChat"]],
                        [/konqueror\/([\w\.]+)/i],
                        [y, [p, "Konqueror"]],
                        [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],
                        [y, [p, "IE"]],
                        [/ya(?:search)?browser\/([\w\.]+)/i],
                        [y, [p, "Yandex"]],
                        [/slbrowser\/([\w\.]+)/i],
                        [y, [p, "Smart Lenovo " + R]],
                        [/(avast|avg)\/([\w\.]+)/i],
                        [
                            [p, /(.+)/, "$1 Secure " + R], y
                        ],
                        [/\bfocus\/([\w\.]+)/i],
                        [y, [p, O + " Focus"]],
                        [/\bopt\/([\w\.]+)/i],
                        [y, [p, W + " Touch"]],
                        [/coc_coc\w+\/([\w\.]+)/i],
                        [y, [p, "Coc Coc"]],
                        [/dolfin\/([\w\.]+)/i],
                        [y, [p, "Dolphin"]],
                        [/coast\/([\w\.]+)/i],
                        [y, [p, W + " Coast"]],
                        [/miuibrowser\/([\w\.]+)/i],
                        [y, [p, "MIUI" + ue]],
                        [/fxios\/([\w\.-]+)/i],
                        [y, [p, O]],
                        [/\bqihoobrowser\/?([\w\.]*)/i],
                        [y, [p, "360"]],
                        [/\b(qq)\/([\w\.]+)/i],
                        [
                            [p, /(.+)/, "$1Browser"], y
                        ],
                        [/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i],
                        [
                            [p, /(.+)/, "$1" + ue], y
                        ],
                        [/samsungbrowser\/([\w\.]+)/i],
                        [y, [p, K + " Internet"]],
                        [/metasr[\/ ]?([\d\.]+)/i],
                        [y, [p, "Sogou Explorer"]],
                        [/(sogou)mo\w+\/([\d\.]+)/i],
                        [
                            [p, "Sogou Mobile"], y
                        ],
                        [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i],
                        [p, y],
                        [/(lbbrowser|rekonq)/i, /\[(linkedin)app\]/i],
                        [p],
                        [/ome\/([\w\.]+) \w* ?(iron) saf/i, /ome\/([\w\.]+).+qihu (360)[es]e/i],
                        [y, p],
                        [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],
                        [
                            [p, X], y
                        ],
                        [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i],
                        [p, y],
                        [/\bgsa\/([\w\.]+) .*safari\//i],
                        [y, [p, "GSA"]],
                        [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i],
                        [y, [p, "TikTok"]],
                        [/headlesschrome(?:\/([\w\.]+)| )/i],
                        [y, [p, D + " Headless"]],
                        [/ wv\).+(chrome)\/([\w\.]+)/i],
                        [
                            [p, D + " WebView"], y
                        ],
                        [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],
                        [y, [p, "Android " + R]],
                        [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],
                        [p, y],
                        [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i],
                        [y, [p, "Mobile Safari"]],
                        [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i],
                        [y, p],
                        [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],
                        [p, [y, xe, ie]],
                        [/(webkit|khtml)\/([\w\.]+)/i],
                        [p, y],
                        [/(navigator|netscape\d?)\/([-\w\.]+)/i],
                        [
                            [p, "Netscape"], y
                        ],
                        [/(wolvic|librewolf)\/([\w\.]+)/i],
                        [p, y],
                        [/mobile vr; rv:([\w\.]+)\).+firefox/i],
                        [y, [p, O + " Reality"]],
                        [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i],
                        [p, [y, /_/g, "."]],
                        [/(cobalt)\/([\w\.]+)/i],
                        [p, [y, /master.|lts./, ""]]
                    ],
                    cpu: [
                        [/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],
                        [
                            [w, "amd64"]
                        ],
                        [/(ia32(?=;))/i],
                        [
                            [w, ye]
                        ],
                        [/((?:i[346]|x)86)[;\)]/i],
                        [
                            [w, "ia32"]
                        ],
                        [/\b(aarch64|arm(v?8e?l?|_?64))\b/i],
                        [
                            [w, "arm64"]
                        ],
                        [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],
                        [
                            [w, "armhf"]
                        ],
                        [/windows (ce|mobile); ppc;/i],
                        [
                            [w, "arm"]
                        ],
                        [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],
                        [
                            [w, /ower/, s, ye]
                        ],
                        [/(sun4\w)[;\)]/i],
                        [
                            [w, "sparc"]
                        ],
                        [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i],
                        [
                            [w, ye]
                        ]
                    ],
                    device: [
                        [/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i],
                        [f, [m, K],
                            [g, _]
                        ],
                        [/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]((?!sm-[lr])[-\w]+)/i, /sec-(sgh\w+)/i],
                        [f, [m, K],
                            [g, E]
                        ],
                        [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i],
                        [f, [m, $],
                            [g, E]
                        ],
                        [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i],
                        [f, [m, $],
                            [g, _]
                        ],
                        [/(macintosh);/i],
                        [f, [m, $]],
                        [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],
                        [f, [m, H],
                            [g, E]
                        ],
                        [/(?:honor)([-\w ]+)[;\)]/i],
                        [f, [m, "Honor"],
                            [g, E]
                        ],
                        [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],
                        [f, [m, U],
                            [g, _]
                        ],
                        [/(?:huawei)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i],
                        [f, [m, U],
                            [g, E]
                        ],
                        [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i],
                        [
                            [f, /_/g, " "],
                            [m, V],
                            [g, E]
                        ],
                        [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i],
                        [
                            [f, /_/g, " "],
                            [m, V],
                            [g, _]
                        ],
                        [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i],
                        [f, [m, "OPPO"],
                            [g, E]
                        ],
                        [/\b(opd2\d{3}a?) bui/i],
                        [f, [m, "OPPO"],
                            [g, _]
                        ],
                        [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i],
                        [f, [m, "Vivo"],
                            [g, E]
                        ],
                        [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i],
                        [f, [m, "Realme"],
                            [g, E]
                        ],
                        [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i],
                        [f, [m, q],
                            [g, E]
                        ],
                        [/\b(mz60\d|xoom[2 ]{0,2}) build\//i],
                        [f, [m, q],
                            [g, _]
                        ],
                        [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i],
                        [f, [m, k],
                            [g, _]
                        ],
                        [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i],
                        [f, [m, k],
                            [g, E]
                        ],
                        [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i],
                        [f, [m, "Lenovo"],
                            [g, _]
                        ],
                        [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i],
                        [
                            [f, /_/g, " "],
                            [m, "Nokia"],
                            [g, E]
                        ],
                        [/(pixel c)\b/i],
                        [f, [m, M],
                            [g, _]
                        ],
                        [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],
                        [f, [m, M],
                            [g, E]
                        ],
                        [/droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i],
                        [f, [m, j],
                            [g, E]
                        ],
                        [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i],
                        [
                            [f, "Xperia Tablet"],
                            [m, j],
                            [g, _]
                        ],
                        [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i],
                        [f, [m, "OnePlus"],
                            [g, E]
                        ],
                        [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i],
                        [f, [m, C],
                            [g, _]
                        ],
                        [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],
                        [
                            [f, /(.+)/g, "Fire Phone $1"],
                            [m, C],
                            [g, E]
                        ],
                        [/(playbook);[-\w\),; ]+(rim)/i],
                        [f, m, [g, _]],
                        [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i],
                        [f, [m, N],
                            [g, E]
                        ],
                        [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i],
                        [f, [m, P],
                            [g, _]
                        ],
                        [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],
                        [f, [m, P],
                            [g, E]
                        ],
                        [/(nexus 9)/i],
                        [f, [m, "HTC"],
                            [g, _]
                        ],
                        [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i],
                        [m, [f, /_/g, " "],
                            [g, E]
                        ],
                        [/droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i],
                        [f, [m, "TCL"],
                            [g, _]
                        ],
                        [/(itel) ((\w+))/i],
                        [
                            [m, ye], f, [g, xe, {
                                tablet: ["p10001l", "w7001"],
                                "*": "mobile"
                            }]
                        ],
                        [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],
                        [f, [m, "Acer"],
                            [g, _]
                        ],
                        [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i],
                        [f, [m, "Meizu"],
                            [g, E]
                        ],
                        [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i],
                        [f, [m, "Ulefone"],
                            [g, E]
                        ],
                        [/; (energy ?\w+)(?: bui|\))/i, /; energizer ([\w ]+)(?: bui|\))/i],
                        [f, [m, "Energizer"],
                            [g, E]
                        ],
                        [/; cat (b35);/i, /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i],
                        [f, [m, "Cat"],
                            [g, E]
                        ],
                        [/((?:new )?andromax[\w- ]+)(?: bui|\))/i],
                        [f, [m, "Smartfren"],
                            [g, E]
                        ],
                        [/droid.+; (a(?:015|06[35]|142p?))/i],
                        [f, [m, "Nothing"],
                            [g, E]
                        ],
                        [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i, /; (imo) ((?!tab)[\w ]+?)(?: bui|\))/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i],
                        [m, f, [g, E]],
                        [/(imo) (tab \w+)/i, /(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i],
                        [m, f, [g, _]],
                        [/(surface duo)/i],
                        [f, [m, F],
                            [g, _]
                        ],
                        [/droid [\d\.]+; (fp\du?)(?: b|\))/i],
                        [f, [m, "Fairphone"],
                            [g, E]
                        ],
                        [/(u304aa)/i],
                        [f, [m, "AT&T"],
                            [g, E]
                        ],
                        [/\bsie-(\w*)/i],
                        [f, [m, "Siemens"],
                            [g, E]
                        ],
                        [/\b(rct\w+) b/i],
                        [f, [m, "RCA"],
                            [g, _]
                        ],
                        [/\b(venue[\d ]{2,7}) b/i],
                        [f, [m, "Dell"],
                            [g, _]
                        ],
                        [/\b(q(?:mv|ta)\w+) b/i],
                        [f, [m, "Verizon"],
                            [g, _]
                        ],
                        [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],
                        [f, [m, "Barnes & Noble"],
                            [g, _]
                        ],
                        [/\b(tm\d{3}\w+) b/i],
                        [f, [m, "NuVision"],
                            [g, _]
                        ],
                        [/\b(k88) b/i],
                        [f, [m, "ZTE"],
                            [g, _]
                        ],
                        [/\b(nx\d{3}j) b/i],
                        [f, [m, "ZTE"],
                            [g, E]
                        ],
                        [/\b(gen\d{3}) b.+49h/i],
                        [f, [m, "Swiss"],
                            [g, E]
                        ],
                        [/\b(zur\d{3}) b/i],
                        [f, [m, "Swiss"],
                            [g, _]
                        ],
                        [/\b((zeki)?tb.*\b) b/i],
                        [f, [m, "Zeki"],
                            [g, _]
                        ],
                        [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i],
                        [
                            [m, "Dragon Touch"], f, [g, _]
                        ],
                        [/\b(ns-?\w{0,9}) b/i],
                        [f, [m, "Insignia"],
                            [g, _]
                        ],
                        [/\b((nxa|next)-?\w{0,9}) b/i],
                        [f, [m, "NextBook"],
                            [g, _]
                        ],
                        [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],
                        [
                            [m, "Voice"], f, [g, E]
                        ],
                        [/\b(lvtel\-)?(v1[12]) b/i],
                        [
                            [m, "LvTel"], f, [g, E]
                        ],
                        [/\b(ph-1) /i],
                        [f, [m, "Essential"],
                            [g, E]
                        ],
                        [/\b(v(100md|700na|7011|917g).*\b) b/i],
                        [f, [m, "Envizen"],
                            [g, _]
                        ],
                        [/\b(trio[-\w\. ]+) b/i],
                        [f, [m, "MachSpeed"],
                            [g, _]
                        ],
                        [/\btu_(1491) b/i],
                        [f, [m, "Rotor"],
                            [g, _]
                        ],
                        [/(shield[\w ]+) b/i],
                        [f, [m, "Nvidia"],
                            [g, _]
                        ],
                        [/(sprint) (\w+)/i],
                        [m, f, [g, E]],
                        [/(kin\.[onetw]{3})/i],
                        [
                            [f, /\./g, " "],
                            [m, F],
                            [g, E]
                        ],
                        [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],
                        [f, [m, Y],
                            [g, _]
                        ],
                        [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],
                        [f, [m, Y],
                            [g, E]
                        ],
                        [/smart-tv.+(samsung)/i],
                        [m, [g, b]],
                        [/hbbtv.+maple;(\d+)/i],
                        [
                            [f, /^/, "SmartTV"],
                            [m, K],
                            [g, b]
                        ],
                        [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],
                        [
                            [m, k],
                            [g, b]
                        ],
                        [/(apple) ?tv/i],
                        [m, [f, $ + " TV"],
                            [g, b]
                        ],
                        [/crkey/i],
                        [
                            [f, D + "cast"],
                            [m, M],
                            [g, b]
                        ],
                        [/droid.+aft(\w+)( bui|\))/i],
                        [f, [m, C],
                            [g, b]
                        ],
                        [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i],
                        [f, [m, H],
                            [g, b]
                        ],
                        [/(bravia[\w ]+)( bui|\))/i],
                        [f, [m, j],
                            [g, b]
                        ],
                        [/(mitv-\w{5}) bui/i],
                        [f, [m, V],
                            [g, b]
                        ],
                        [/Hbbtv.*(technisat) (.*);/i],
                        [m, f, [g, b]],
                        [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i],
                        [
                            [m, ce],
                            [f, ce],
                            [g, b]
                        ],
                        [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],
                        [
                            [g, b]
                        ],
                        [/(ouya)/i, /(nintendo) ([wids3utch]+)/i],
                        [m, f, [g, x]],
                        [/droid.+; (shield) bui/i],
                        [f, [m, "Nvidia"],
                            [g, x]
                        ],
                        [/(playstation [345portablevi]+)/i],
                        [f, [m, j],
                            [g, x]
                        ],
                        [/\b(xbox(?: one)?(?!; xbox))[\); ]/i],
                        [f, [m, F],
                            [g, x]
                        ],
                        [/\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i],
                        [f, [m, K],
                            [g, A]
                        ],
                        [/((pebble))app/i],
                        [m, f, [g, A]],
                        [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i],
                        [f, [m, $],
                            [g, A]
                        ],
                        [/droid.+; (glass) \d/i],
                        [f, [m, M],
                            [g, A]
                        ],
                        [/droid.+; (wt63?0{2,3})\)/i],
                        [f, [m, Y],
                            [g, A]
                        ],
                        [/droid.+; (glass) \d/i],
                        [f, [m, M],
                            [g, A]
                        ],
                        [/(pico) (4|neo3(?: link|pro)?)/i],
                        [m, f, [g, A]],
                        [/; (quest( \d| pro)?)/i],
                        [f, [m, X],
                            [g, A]
                        ],
                        [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],
                        [m, [g, I]],
                        [/(aeobc)\b/i],
                        [f, [m, C],
                            [g, I]
                        ],
                        [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i],
                        [f, [g, E]],
                        [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i],
                        [f, [g, _]],
                        [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],
                        [
                            [g, _]
                        ],
                        [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i],
                        [
                            [g, E]
                        ],
                        [/(android[-\w\. ]{0,9});.+buil/i],
                        [f, [m, "Generic"]]
                    ],
                    engine: [
                        [/windows.+ edge\/([\w\.]+)/i],
                        [y, [p, S + "HTML"]],
                        [/(arkweb)\/([\w\.]+)/i],
                        [p, y],
                        [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],
                        [y, [p, "Blink"]],
                        [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i],
                        [p, y],
                        [/rv\:([\w\.]{1,9})\b.+(gecko)/i],
                        [y, p]
                    ],
                    os: [
                        [/microsoft (windows) (vista|xp)/i],
                        [p, y],
                        [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i],
                        [p, [y, xe, Ee]],
                        [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i],
                        [
                            [y, xe, Ee],
                            [p, "Windows"]
                        ],
                        [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i],
                        [
                            [y, /_/g, "."],
                            [p, "iOS"]
                        ],
                        [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i],
                        [
                            [p, ae],
                            [y, /_/g, "."]
                        ],
                        [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],
                        [y, p],
                        [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish|openharmony)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i],
                        [p, y],
                        [/\(bb(10);/i],
                        [y, [p, N]],
                        [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],
                        [y, [p, "Symbian"]],
                        [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i],
                        [y, [p, O + " OS"]],
                        [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],
                        [y, [p, "webOS"]],
                        [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i],
                        [y, [p, "watchOS"]],
                        [/crkey\/([\d\.]+)/i],
                        [y, [p, D + "cast"]],
                        [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i],
                        [
                            [p, ne], y
                        ],
                        [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i],
                        [p, y],
                        [/(sunos) ?([\w\.\d]*)/i],
                        [
                            [p, "Solaris"], y
                        ],
                        [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i],
                        [p, y]
                    ]
                },
                Ae = function(Ue, De) {
                    if (typeof Ue === l && (De = Ue, Ue = n), !(this instanceof Ae)) return new Ae(Ue, De).getResult();
                    var We = typeof r !== c && r.navigator ? r.navigator : n,
                        dt = Ue || (We && We.userAgent ? We.userAgent : s),
                        He = We && We.userAgentData ? We.userAgentData : n,
                        ut = De ? he(ft, De) : ft,
                        Ye = We && We.userAgent == dt;
                    return this.getBrowser = function() {
                        var we = {};
                        return we[p] = n, we[y] = n, Ie.call(we, dt, ut.browser), we[h] = Be(we[y]), Ye && We && We.brave && typeof We.brave.isBrave == o && (we[p] = "Brave"), we
                    }, this.getCPU = function() {
                        var we = {};
                        return we[w] = n, Ie.call(we, dt, ut.cpu), we
                    }, this.getDevice = function() {
                        var we = {};
                        return we[m] = n, we[f] = n, we[g] = n, Ie.call(we, dt, ut.device), Ye && !we[g] && He && He.mobile && (we[g] = E), Ye && we[f] == "Macintosh" && We && typeof We.standalone !== c && We.maxTouchPoints && We.maxTouchPoints > 2 && (we[f] = "iPad", we[g] = _), we
                    }, this.getEngine = function() {
                        var we = {};
                        return we[p] = n, we[y] = n, Ie.call(we, dt, ut.engine), we
                    }, this.getOS = function() {
                        var we = {};
                        return we[p] = n, we[y] = n, Ie.call(we, dt, ut.os), Ye && !we[p] && He && He.platform && He.platform != "Unknown" && (we[p] = He.platform.replace(/chrome os/i, ne).replace(/macos/i, ae)), we
                    }, this.getResult = function() {
                        return {
                            ua: this.getUA(),
                            browser: this.getBrowser(),
                            engine: this.getEngine(),
                            os: this.getOS(),
                            device: this.getDevice(),
                            cpu: this.getCPU()
                        }
                    }, this.getUA = function() {
                        return dt
                    }, this.setUA = function(we) {
                        return dt = typeof we === u && we.length > T ? ce(we, T) : we, this
                    }, this.setUA(dt), this
                };
            Ae.VERSION = i, Ae.BROWSER = fe([p, y, h]), Ae.CPU = fe([w]), Ae.DEVICE = fe([f, m, g, x, E, b, _, A, I]), Ae.ENGINE = Ae.OS = fe([p, y]), t.exports && (e = t.exports = Ae), e.UAParser = Ae;
            var Le = typeof r !== c && (r.jQuery || r.Zepto);
            if (Le && !Le.ua) {
                var Te = new Ae;
                Le.ua = Te.getResult(), Le.ua.get = function() {
                    return Te.getUA()
                }, Le.ua.set = function(Ue) {
                    Te.setUA(Ue);
                    var De = Te.getResult();
                    for (var We in De) Le.ua[We] = De[We]
                }
            }
        })(typeof window == "object" ? window : HW)
    }(wf, wf.exports)), wf.exports
}
var K8;

function GW() {
    if (K8) return Ke;
    K8 = 1, Object.defineProperty(Ke, "__esModule", {
        value: !0
    });

    function t(oe) {
        return oe && typeof oe == "object" && "default" in oe ? oe.default : oe
    }
    var e = FW(),
        r = t(e),
        n = VW(),
        i = new n,
        s = i.getBrowser(),
        a = i.getCPU(),
        o = i.getDevice(),
        c = i.getEngine(),
        l = i.getOS(),
        u = i.getUA(),
        h = function(Z) {
            return i.setUA(Z)
        },
        f = function(Z) {
            if (!Z) {
                console.error("No userAgent string was provided");
                return
            }
            var te = new n(Z);
            return {
                UA: te,
                browser: te.getBrowser(),
                cpu: te.getCPU(),
                device: te.getDevice(),
                engine: te.getEngine(),
                os: te.getOS(),
                ua: te.getUA(),
                setUserAgent: function(ke) {
                    return te.setUA(ke)
                }
            }
        },
        p = Object.freeze({
            ClientUAInstance: i,
            browser: s,
            cpu: a,
            device: o,
            engine: c,
            os: l,
            ua: u,
            setUa: h,
            parseUserAgent: f
        });

    function g(oe, Z) {
        var te = Object.keys(oe);
        if (Object.getOwnPropertySymbols) {
            var ge = Object.getOwnPropertySymbols(oe);
            Z && (ge = ge.filter(function(ke) {
                return Object.getOwnPropertyDescriptor(oe, ke).enumerable
            })), te.push.apply(te, ge)
        }
        return te
    }

    function m(oe) {
        for (var Z = 1; Z < arguments.length; Z++) {
            var te = arguments[Z] != null ? arguments[Z] : {};
            Z % 2 ? g(Object(te), !0).forEach(function(ge) {
                _(oe, ge, te[ge])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(oe, Object.getOwnPropertyDescriptors(te)) : g(Object(te)).forEach(function(ge) {
                Object.defineProperty(oe, ge, Object.getOwnPropertyDescriptor(te, ge))
            })
        }
        return oe
    }

    function y(oe) {
        "@babel/helpers - typeof";
        return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? y = function(Z) {
            return typeof Z
        } : y = function(Z) {
            return Z && typeof Symbol == "function" && Z.constructor === Symbol && Z !== Symbol.prototype ? "symbol" : typeof Z
        }, y(oe)
    }

    function w(oe, Z) {
        if (!(oe instanceof Z)) throw new TypeError("Cannot call a class as a function")
    }

    function x(oe, Z) {
        for (var te = 0; te < Z.length; te++) {
            var ge = Z[te];
            ge.enumerable = ge.enumerable || !1, ge.configurable = !0, "value" in ge && (ge.writable = !0), Object.defineProperty(oe, ge.key, ge)
        }
    }

    function E(oe, Z, te) {
        return Z && x(oe.prototype, Z), oe
    }

    function _(oe, Z, te) {
        return Z in oe ? Object.defineProperty(oe, Z, {
            value: te,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : oe[Z] = te, oe
    }

    function b() {
        return b = Object.assign || function(oe) {
            for (var Z = 1; Z < arguments.length; Z++) {
                var te = arguments[Z];
                for (var ge in te) Object.prototype.hasOwnProperty.call(te, ge) && (oe[ge] = te[ge])
            }
            return oe
        }, b.apply(this, arguments)
    }

    function A(oe, Z) {
        if (typeof Z != "function" && Z !== null) throw new TypeError("Super expression must either be null or a function");
        oe.prototype = Object.create(Z && Z.prototype, {
            constructor: {
                value: oe,
                writable: !0,
                configurable: !0
            }
        }), Z && T(oe, Z)
    }

    function I(oe) {
        return I = Object.setPrototypeOf ? Object.getPrototypeOf : function(te) {
            return te.__proto__ || Object.getPrototypeOf(te)
        }, I(oe)
    }

    function T(oe, Z) {
        return T = Object.setPrototypeOf || function(ge, ke) {
            return ge.__proto__ = ke, ge
        }, T(oe, Z)
    }

    function C(oe, Z) {
        if (oe == null) return {};
        var te = {},
            ge = Object.keys(oe),
            ke, Ft;
        for (Ft = 0; Ft < ge.length; Ft++) ke = ge[Ft], !(Z.indexOf(ke) >= 0) && (te[ke] = oe[ke]);
        return te
    }

    function $(oe, Z) {
        if (oe == null) return {};
        var te = C(oe, Z),
            ge, ke;
        if (Object.getOwnPropertySymbols) {
            var Ft = Object.getOwnPropertySymbols(oe);
            for (ke = 0; ke < Ft.length; ke++) ge = Ft[ke], !(Z.indexOf(ge) >= 0) && Object.prototype.propertyIsEnumerable.call(oe, ge) && (te[ge] = oe[ge])
        }
        return te
    }

    function P(oe) {
        if (oe === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return oe
    }

    function N(oe, Z) {
        if (Z && (typeof Z == "object" || typeof Z == "function")) return Z;
        if (Z !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
        return P(oe)
    }

    function R(oe, Z) {
        return D(oe) || S(oe, Z) || O(oe, Z) || U()
    }

    function D(oe) {
        if (Array.isArray(oe)) return oe
    }

    function S(oe, Z) {
        var te = oe == null ? null : typeof Symbol < "u" && oe[Symbol.iterator] || oe["@@iterator"];
        if (te != null) {
            var ge = [],
                ke = !0,
                Ft = !1,
                Gr, vi;
            try {
                for (te = te.call(oe); !(ke = (Gr = te.next()).done) && (ge.push(Gr.value), !(Z && ge.length === Z)); ke = !0);
            } catch (q0) {
                Ft = !0, vi = q0
            } finally {
                try {
                    !ke && te.return != null && te.return()
                } finally {
                    if (Ft) throw vi
                }
            }
            return ge
        }
    }

    function O(oe, Z) {
        if (oe) {
            if (typeof oe == "string") return M(oe, Z);
            var te = Object.prototype.toString.call(oe).slice(8, -1);
            if (te === "Object" && oe.constructor && (te = oe.constructor.name), te === "Map" || te === "Set") return Array.from(oe);
            if (te === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(te)) return M(oe, Z)
        }
    }

    function M(oe, Z) {
        (Z == null || Z > oe.length) && (Z = oe.length);
        for (var te = 0, ge = new Array(Z); te < Z; te++) ge[te] = oe[te];
        return ge
    }

    function U() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    var k = {
            Mobile: "mobile",
            Tablet: "tablet",
            SmartTv: "smarttv",
            Console: "console",
            Wearable: "wearable",
            Embedded: "embedded",
            Browser: void 0
        },
        F = {
            Chrome: "Chrome",
            Firefox: "Firefox",
            Opera: "Opera",
            Yandex: "Yandex",
            Safari: "Safari",
            InternetExplorer: "Internet Explorer",
            Edge: "Edge",
            Chromium: "Chromium",
            Ie: "IE",
            MobileSafari: "Mobile Safari",
            EdgeChromium: "Edge Chromium",
            MIUI: "MIUI Browser",
            SamsungBrowser: "Samsung Browser"
        },
        q = {
            IOS: "iOS",
            Android: "Android",
            WindowsPhone: "Windows Phone",
            Windows: "Windows",
            MAC_OS: "Mac OS"
        },
        W = {
            isMobile: !1,
            isTablet: !1,
            isBrowser: !1,
            isSmartTV: !1,
            isConsole: !1,
            isWearable: !1
        },
        K = function(Z) {
            switch (Z) {
                case k.Mobile:
                    return {
                        isMobile: !0
                    };
                case k.Tablet:
                    return {
                        isTablet: !0
                    };
                case k.SmartTv:
                    return {
                        isSmartTV: !0
                    };
                case k.Console:
                    return {
                        isConsole: !0
                    };
                case k.Wearable:
                    return {
                        isWearable: !0
                    };
                case k.Browser:
                    return {
                        isBrowser: !0
                    };
                case k.Embedded:
                    return {
                        isEmbedded: !0
                    };
                default:
                    return W
            }
        },
        H = function(Z) {
            return h(Z)
        },
        j = function(Z) {
            var te = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none";
            return Z || te
        },
        V = function() {
            return typeof window < "u" && (window.navigator || navigator) ? window.navigator || navigator : !1
        },
        Y = function(Z) {
            var te = V();
            return te && te.platform && (te.platform.indexOf(Z) !== -1 || te.platform === "MacIntel" && te.maxTouchPoints > 1 && !window.MSStream)
        },
        X = function(Z, te, ge, ke, Ft) {
            return {
                isBrowser: Z,
                browserMajorVersion: j(te.major),
                browserFullVersion: j(te.version),
                browserName: j(te.name),
                engineName: j(ge.name),
                engineVersion: j(ge.version),
                osName: j(ke.name),
                osVersion: j(ke.version),
                userAgent: j(Ft)
            }
        },
        ne = function(Z, te, ge, ke) {
            return m({}, Z, {
                vendor: j(te.vendor),
                model: j(te.model),
                os: j(ge.name),
                osVersion: j(ge.version),
                ua: j(ke)
            })
        },
        ae = function(Z, te, ge, ke) {
            return {
                isSmartTV: Z,
                engineName: j(te.name),
                engineVersion: j(te.version),
                osName: j(ge.name),
                osVersion: j(ge.version),
                userAgent: j(ke)
            }
        },
        ue = function(Z, te, ge, ke) {
            return {
                isConsole: Z,
                engineName: j(te.name),
                engineVersion: j(te.version),
                osName: j(ge.name),
                osVersion: j(ge.version),
                userAgent: j(ke)
            }
        },
        he = function(Z, te, ge, ke) {
            return {
                isWearable: Z,
                engineName: j(te.name),
                engineVersion: j(te.version),
                osName: j(ge.name),
                osVersion: j(ge.version),
                userAgent: j(ke)
            }
        },
        fe = function(Z, te, ge, ke, Ft) {
            return {
                isEmbedded: Z,
                vendor: j(te.vendor),
                model: j(te.model),
                engineName: j(ge.name),
                engineVersion: j(ge.version),
                osName: j(ke.name),
                osVersion: j(ke.version),
                userAgent: j(Ft)
            }
        };

    function de(oe) {
        var Z = oe ? f(oe) : p,
            te = Z.device,
            ge = Z.browser,
            ke = Z.engine,
            Ft = Z.os,
            Gr = Z.ua,
            vi = K(te.type),
            q0 = vi.isBrowser,
            NW = vi.isMobile,
            OW = vi.isTablet,
            z8 = vi.isSmartTV,
            q8 = vi.isConsole,
            H8 = vi.isWearable,
            V8 = vi.isEmbedded;
        if (q0) return X(q0, ge, ke, Ft, Gr);
        if (z8) return ae(z8, ke, Ft, Gr);
        if (q8) return ue(q8, ke, Ft, Gr);
        if (NW || OW) return ne(vi, te, Ft, Gr);
        if (H8) return he(H8, ke, Ft, Gr);
        if (V8) return fe(V8, te, ke, Ft, Gr)
    }
    var ye = function(Z) {
            var te = Z.type;
            return te === k.Mobile
        },
        Be = function(Z) {
            var te = Z.type;
            return te === k.Tablet
        },
        ce = function(Z) {
            var te = Z.type;
            return te === k.Mobile || te === k.Tablet
        },
        Ie = function(Z) {
            var te = Z.type;
            return te === k.SmartTv
        },
        xe = function(Z) {
            var te = Z.type;
            return te === k.Browser
        },
        ie = function(Z) {
            var te = Z.type;
            return te === k.Wearable
        },
        Ee = function(Z) {
            var te = Z.type;
            return te === k.Console
        },
        ft = function(Z) {
            var te = Z.type;
            return te === k.Embedded
        },
        Ae = function(Z) {
            var te = Z.vendor;
            return j(te)
        },
        Le = function(Z) {
            var te = Z.model;
            return j(te)
        },
        Te = function(Z) {
            var te = Z.type;
            return j(te, "browser")
        },
        Ue = function(Z) {
            var te = Z.name;
            return te === q.Android
        },
        De = function(Z) {
            var te = Z.name;
            return te === q.Windows
        },
        We = function(Z) {
            var te = Z.name;
            return te === q.MAC_OS
        },
        dt = function(Z) {
            var te = Z.name;
            return te === q.WindowsPhone
        },
        He = function(Z) {
            var te = Z.name;
            return te === q.IOS
        },
        ut = function(Z) {
            var te = Z.version;
            return j(te)
        },
        Ye = function(Z) {
            var te = Z.name;
            return j(te)
        },
        we = function(Z) {
            var te = Z.name;
            return te === F.Chrome
        },
        vt = function(Z) {
            var te = Z.name;
            return te === F.Firefox
        },
        Lt = function(Z) {
            var te = Z.name;
            return te === F.Chromium
        },
        _t = function(Z) {
            var te = Z.name;
            return te === F.Edge
        },
        tr = function(Z) {
            var te = Z.name;
            return te === F.Yandex
        },
        dr = function(Z) {
            var te = Z.name;
            return te === F.Safari || te === F.MobileSafari
        },
        Yt = function(Z) {
            var te = Z.name;
            return te === F.MobileSafari
        },
        Ot = function(Z) {
            var te = Z.name;
            return te === F.Opera
        },
        mt = function(Z) {
            var te = Z.name;
            return te === F.InternetExplorer || te === F.Ie
        },
        ur = function(Z) {
            var te = Z.name;
            return te === F.MIUI
        },
        Vr = function(Z) {
            var te = Z.name;
            return te === F.SamsungBrowser
        },
        pt = function(Z) {
            var te = Z.version;
            return j(te)
        },
        Un = function(Z) {
            var te = Z.major;
            return j(te)
        },
        ei = function(Z) {
            var te = Z.name;
            return j(te)
        },
        ti = function(Z) {
            var te = Z.name;
            return j(te)
        },
        Fn = function(Z) {
            var te = Z.version;
            return j(te)
        },
        L = function() {
            var Z = V(),
                te = Z && Z.userAgent && Z.userAgent.toLowerCase();
            return typeof te == "string" ? /electron/.test(te) : !1
        },
        B = function(Z) {
            return typeof Z == "string" && Z.indexOf("Edg/") !== -1
        },
        Q = function() {
            var Z = V();
            return Z && (/iPad|iPhone|iPod/.test(Z.platform) || Z.platform === "MacIntel" && Z.maxTouchPoints > 1) && !window.MSStream
        },
        G = function() {
            return Y("iPad")
        },
        re = function() {
            return Y("iPhone")
        },
        se = function() {
            return Y("iPod")
        },
        me = function(Z) {
            return j(Z)
        };

    function ve(oe) {
        var Z = oe || p,
            te = Z.device,
            ge = Z.browser,
            ke = Z.os,
            Ft = Z.engine,
            Gr = Z.ua;
        return {
            isSmartTV: Ie(te),
            isConsole: Ee(te),
            isWearable: ie(te),
            isEmbedded: ft(te),
            isMobileSafari: Yt(ge) || G(),
            isChromium: Lt(ge),
            isMobile: ce(te) || G(),
            isMobileOnly: ye(te),
            isTablet: Be(te) || G(),
            isBrowser: xe(te),
            isDesktop: xe(te),
            isAndroid: Ue(ke),
            isWinPhone: dt(ke),
            isIOS: He(ke) || G(),
            isChrome: we(ge),
            isFirefox: vt(ge),
            isSafari: dr(ge),
            isOpera: Ot(ge),
            isIE: mt(ge),
            osVersion: ut(ke),
            osName: Ye(ke),
            fullBrowserVersion: pt(ge),
            browserVersion: Un(ge),
            browserName: ei(ge),
            mobileVendor: Ae(te),
            mobileModel: Le(te),
            engineName: ti(Ft),
            engineVersion: Fn(Ft),
            getUA: me(Gr),
            isEdge: _t(ge) || B(Gr),
            isYandex: tr(ge),
            deviceType: Te(te),
            isIOS13: Q(),
            isIPad13: G(),
            isIPhone13: re(),
            isIPod13: se(),
            isElectron: L(),
            isEdgeChromium: B(Gr),
            isLegacyEdge: _t(ge) && !B(Gr),
            isWindows: De(ke),
            isMacOs: We(ke),
            isMIUI: ur(ge),
            isSamsungBrowser: Vr(ge)
        }
    }
    var Ze = Ie(o),
        kt = Ee(o),
        Re = ie(o),
        ct = ft(o),
        it = Yt(s) || G(),
        lt = Lt(s),
        Se = ce(o) || G(),
        yt = ye(o),
        It = Be(o) || G(),
        Mt = xe(o),
        jt = xe(o),
        sr = Ue(l),
        bt = dt(l),
        St = He(l) || G(),
        Ge = we(s),
        Xe = vt(s),
        mr = dr(s),
        Ut = Ot(s),
        bi = mt(s),
        Gs = ut(l),
        Vd = Ye(l),
        Gd = pt(s),
        ww = Un(s),
        bw = ei(s),
        JB = Ae(o),
        QB = Le(o),
        XB = ti(c),
        eW = Fn(c),
        tW = me(u),
        rW = _t(s) || B(u),
        nW = tr(s),
        iW = Te(o),
        sW = Q(),
        aW = G(),
        oW = re(),
        cW = se(),
        lW = L(),
        dW = B(u),
        uW = _t(s) && !B(u),
        hW = De(l),
        fW = We(l),
        pW = ur(s),
        gW = Vr(s),
        mW = function(Z) {
            if (!Z || typeof Z != "string") {
                console.error("No valid user agent string was provided");
                return
            }
            var te = f(Z),
                ge = te.device,
                ke = te.browser,
                Ft = te.os,
                Gr = te.engine,
                vi = te.ua;
            return ve({
                device: ge,
                browser: ke,
                os: Ft,
                engine: Gr,
                ua: vi
            })
        },
        yW = function(Z) {
            var te = Z.renderWithFragment,
                ge = Z.children,
                ke = $(Z, ["renderWithFragment", "children"]);
            return sr ? te ? r.createElement(e.Fragment, null, ge) : r.createElement("div", ke, ge) : null
        },
        wW = function(Z) {
            var te = Z.renderWithFragment,
                ge = Z.children,
                ke = $(Z, ["renderWithFragment", "children"]);
            return Mt ? te ? r.createElement(e.Fragment, null, ge) : r.createElement("div", ke, ge) : null
        },
        bW = function(Z) {
            var te = Z.renderWithFragment,
                ge = Z.children,
                ke = $(Z, ["renderWithFragment", "children"]);
            return bi ? te ? r.createElement(e.Fragment, null, ge) : r.createElement("div", ke, ge) : null
        },
        vW = function(Z) {
            var te = Z.renderWithFragment,
                ge = Z.children,
                ke = $(Z, ["renderWithFragment", "children"]);
            return St ? te ? r.createElement(e.Fragment, null, ge) : r.createElement("div", ke, ge) : null
        },
        xW = function(Z) {
            var te = Z.renderWithFragment,
                ge = Z.children,
                ke = $(Z, ["renderWithFragment", "children"]);
            return Se ? te ? r.createElement(e.Fragment, null, ge) : r.createElement("div", ke, ge) : null
        },
        EW = function(Z) {
            var te = Z.renderWithFragment,
                ge = Z.children,
                ke = $(Z, ["renderWithFragment", "children"]);
            return It ? te ? r.createElement(e.Fragment, null, ge) : r.createElement("div", ke, ge) : null
        },
        _W = function(Z) {
            var te = Z.renderWithFragment,
                ge = Z.children,
                ke = $(Z, ["renderWithFragment", "children"]);
            return bt ? te ? r.createElement(e.Fragment, null, ge) : r.createElement("div", ke, ge) : null
        },
        CW = function(Z) {
            var te = Z.renderWithFragment,
                ge = Z.children;
            Z.viewClassName, Z.style;
            var ke = $(Z, ["renderWithFragment", "children", "viewClassName", "style"]);
            return yt ? te ? r.createElement(e.Fragment, null, ge) : r.createElement("div", ke, ge) : null
        },
        AW = function(Z) {
            var te = Z.renderWithFragment,
                ge = Z.children,
                ke = $(Z, ["renderWithFragment", "children"]);
            return Ze ? te ? r.createElement(e.Fragment, null, ge) : r.createElement("div", ke, ge) : null
        },
        kW = function(Z) {
            var te = Z.renderWithFragment,
                ge = Z.children,
                ke = $(Z, ["renderWithFragment", "children"]);
            return kt ? te ? r.createElement(e.Fragment, null, ge) : r.createElement("div", ke, ge) : null
        },
        IW = function(Z) {
            var te = Z.renderWithFragment,
                ge = Z.children,
                ke = $(Z, ["renderWithFragment", "children"]);
            return Re ? te ? r.createElement(e.Fragment, null, ge) : r.createElement("div", ke, ge) : null
        },
        $W = function(Z) {
            var te = Z.renderWithFragment,
                ge = Z.children;
            Z.viewClassName, Z.style;
            var ke = Z.condition,
                Ft = $(Z, ["renderWithFragment", "children", "viewClassName", "style", "condition"]);
            return ke ? te ? r.createElement(e.Fragment, null, ge) : r.createElement("div", Ft, ge) : null
        };

    function SW(oe) {
        return function(Z) {
            A(te, Z);

            function te(ge) {
                var ke;
                return w(this, te), ke = N(this, I(te).call(this, ge)), ke.isEventListenerAdded = !1, ke.handleOrientationChange = ke.handleOrientationChange.bind(P(ke)), ke.onOrientationChange = ke.onOrientationChange.bind(P(ke)), ke.onPageLoad = ke.onPageLoad.bind(P(ke)), ke.state = {
                    isLandscape: !1,
                    isPortrait: !1
                }, ke
            }
            return E(te, [{
                key: "handleOrientationChange",
                value: function() {
                    this.isEventListenerAdded || (this.isEventListenerAdded = !0);
                    var ke = window.innerWidth > window.innerHeight ? 90 : 0;
                    this.setState({
                        isPortrait: ke === 0,
                        isLandscape: ke === 90
                    })
                }
            }, {
                key: "onOrientationChange",
                value: function() {
                    this.handleOrientationChange()
                }
            }, {
                key: "onPageLoad",
                value: function() {
                    this.handleOrientationChange()
                }
            }, {
                key: "componentDidMount",
                value: function() {
                    (typeof window > "u" ? "undefined" : y(window)) !== void 0 && Se && (this.isEventListenerAdded ? window.removeEventListener("load", this.onPageLoad, !1) : (this.handleOrientationChange(), window.addEventListener("load", this.onPageLoad, !1)), window.addEventListener("resize", this.onOrientationChange, !1))
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    window.removeEventListener("resize", this.onOrientationChange, !1)
                }
            }, {
                key: "render",
                value: function() {
                    return r.createElement(oe, b({}, this.props, {
                        isLandscape: this.state.isLandscape,
                        isPortrait: this.state.isPortrait
                    }))
                }
            }]), te
        }(r.Component)
    }

    function TW() {
        var oe = e.useState(function() {
                var Ft = window.innerWidth > window.innerHeight ? 90 : 0;
                return {
                    isPortrait: Ft === 0,
                    isLandscape: Ft === 90,
                    orientation: Ft === 0 ? "portrait" : "landscape"
                }
            }),
            Z = R(oe, 2),
            te = Z[0],
            ge = Z[1],
            ke = e.useCallback(function() {
                var Ft = window.innerWidth > window.innerHeight ? 90 : 0,
                    Gr = {
                        isPortrait: Ft === 0,
                        isLandscape: Ft === 90,
                        orientation: Ft === 0 ? "portrait" : "landscape"
                    };
                te.orientation !== Gr.orientation && ge(Gr)
            }, [te.orientation]);
        return e.useEffect(function() {
            return (typeof window > "u" ? "undefined" : y(window)) !== void 0 && Se && (ke(), window.addEventListener("load", ke, !1), window.addEventListener("resize", ke, !1)),
                function() {
                    window.removeEventListener("resize", ke, !1), window.removeEventListener("load", ke, !1)
                }
        }, [ke]), te
    }

    function W8(oe) {
        var Z = oe || window.navigator.userAgent;
        return f(Z)
    }

    function PW(oe) {
        var Z = oe || window.navigator.userAgent,
            te = W8(Z),
            ge = ve(te);
        return [ge, te]
    }
    return Ke.AndroidView = yW, Ke.BrowserTypes = F, Ke.BrowserView = wW, Ke.ConsoleView = kW, Ke.CustomView = $W, Ke.IEView = bW, Ke.IOSView = vW, Ke.MobileOnlyView = CW, Ke.MobileView = xW, Ke.OsTypes = q, Ke.SmartTVView = AW, Ke.TabletView = EW, Ke.WearableView = IW, Ke.WinPhoneView = _W, Ke.browserName = bw, Ke.browserVersion = ww, Ke.deviceDetect = de, Ke.deviceType = iW, Ke.engineName = XB, Ke.engineVersion = eW, Ke.fullBrowserVersion = Gd, Ke.getSelectorsByUserAgent = mW, Ke.getUA = tW, Ke.isAndroid = sr, Ke.isBrowser = Mt, Ke.isChrome = Ge, Ke.isChromium = lt, Ke.isConsole = kt, Ke.isDesktop = jt, Ke.isEdge = rW, Ke.isEdgeChromium = dW, Ke.isElectron = lW, Ke.isEmbedded = ct, Ke.isFirefox = Xe, Ke.isIE = bi, Ke.isIOS = St, Ke.isIOS13 = sW, Ke.isIPad13 = aW, Ke.isIPhone13 = oW, Ke.isIPod13 = cW, Ke.isLegacyEdge = uW, Ke.isMIUI = pW, Ke.isMacOs = fW, Ke.isMobile = Se, Ke.isMobileOnly = yt, Ke.isMobileSafari = it, Ke.isOpera = Ut, Ke.isSafari = mr, Ke.isSamsungBrowser = gW, Ke.isSmartTV = Ze, Ke.isTablet = It, Ke.isWearable = Re, Ke.isWinPhone = bt, Ke.isWindows = hW, Ke.isYandex = nW, Ke.mobileModel = QB, Ke.mobileVendor = JB, Ke.osName = Vd, Ke.osVersion = Gs, Ke.parseUserAgent = f, Ke.setUserAgent = H, Ke.useDeviceData = W8, Ke.useDeviceSelectors = PW, Ke.useMobileOrientation = TW, Ke.withOrientationChange = SW, Ke
}
var gr = GW();
const _S = "2.33.2";
let Uh = {
        getDocsUrl: ({
            docsBaseUrl: t,
            docsPath: e = "",
            docsSlug: r
        }) => e ? `${t??"https://viem.sh"}${e}${r?`#${r}`:""}` : void 0,
        version: `viem@${_S}`
    },
    be = class Fv extends Error {
        constructor(e, r = {}) {
            var o;
            const n = (() => {
                    var c;
                    return r.cause instanceof Fv ? r.cause.details : (c = r.cause) != null && c.message ? r.cause.message : r.details
                })(),
                i = r.cause instanceof Fv && r.cause.docsPath || r.docsPath,
                s = (o = Uh.getDocsUrl) == null ? void 0 : o.call(Uh, { ...r,
                    docsPath: i
                }),
                a = [e || "An error occurred.", "", ...r.metaMessages ? [...r.metaMessages, ""] : [], ...s ? [`Docs: ${s}`] : [], ...n ? [`Details: ${n}`] : [], ...Uh.version ? [`Version: ${Uh.version}`] : []].join(`
`);
            super(a, r.cause ? {
                cause: r.cause
            } : void 0), Object.defineProperty(this, "details", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }), Object.defineProperty(this, "docsPath", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }), Object.defineProperty(this, "metaMessages", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }), Object.defineProperty(this, "shortMessage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }), Object.defineProperty(this, "version", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }), Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "BaseError"
            }), this.details = n, this.docsPath = i, this.metaMessages = r.metaMessages, this.name = r.name ? ? this.name, this.shortMessage = e, this.version = _S
        }
        walk(e) {
            return CS(this, e)
        }
    };

function CS(t, e) {
    return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause !== void 0 ? CS(t.cause, e) : e ? null : t
}
const zr = (t, e, r) => JSON.stringify(t, (n, i) => typeof i == "bigint" ? i.toString() : i, r),
    KW = t => t,
    Gp = t => t;
class Kl extends be {
    constructor({
        body: e,
        cause: r,
        details: n,
        headers: i,
        status: s,
        url: a
    }) {
        super("HTTP request failed.", {
            cause: r,
            details: n,
            metaMessages: [s && `Status: ${s}`, `URL: ${Gp(a)}`, e && `Request body: ${zr(e)}`].filter(Boolean),
            name: "HttpRequestError"
        }), Object.defineProperty(this, "body", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "headers", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "status", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "url", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.body = e, this.headers = i, this.status = s, this.url = a
    }
}
class H4 extends be {
    constructor({
        body: e,
        error: r,
        url: n
    }) {
        super("RPC Request failed.", {
            cause: r,
            details: r.message,
            metaMessages: [`URL: ${Gp(n)}`, `Request body: ${zr(e)}`],
            name: "RpcRequestError"
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.code = r.code, this.data = r.data
    }
}
class Y8 extends be {
    constructor({
        body: e,
        url: r
    }) {
        super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [`URL: ${Gp(r)}`, `Request body: ${zr(e)}`],
            name: "TimeoutError"
        })
    }
}
const YW = -1;
class Wi extends be {
    constructor(e, {
        code: r,
        docsPath: n,
        metaMessages: i,
        name: s,
        shortMessage: a
    }) {
        super(a, {
            cause: e,
            docsPath: n,
            metaMessages: i || (e == null ? void 0 : e.metaMessages),
            name: s || "RpcError"
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.name = s || e.name, this.code = e instanceof H4 ? e.code : r ? ? YW
    }
}
class ds extends Wi {
    constructor(e, r) {
        super(e, r), Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.data = r.data
    }
}
class ep extends Wi {
    constructor(e) {
        super(e, {
            code: ep.code,
            name: "ParseRpcError",
            shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        })
    }
}
Object.defineProperty(ep, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32700
});
class tp extends Wi {
    constructor(e) {
        super(e, {
            code: tp.code,
            name: "InvalidRequestRpcError",
            shortMessage: "JSON is not a valid request object."
        })
    }
}
Object.defineProperty(tp, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32600
});
class rp extends Wi {
    constructor(e, {
        method: r
    } = {}) {
        super(e, {
            code: rp.code,
            name: "MethodNotFoundRpcError",
            shortMessage: `The method${r?` "${r}"`:""} does not exist / is not available.`
        })
    }
}
Object.defineProperty(rp, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32601
});
class np extends Wi {
    constructor(e) {
        super(e, {
            code: np.code,
            name: "InvalidParamsRpcError",
            shortMessage: ["Invalid parameters were provided to the RPC method.", "Double check you have provided the correct parameters."].join(`
`)
        })
    }
}
Object.defineProperty(np, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32602
});
class nd extends Wi {
    constructor(e) {
        super(e, {
            code: nd.code,
            name: "InternalRpcError",
            shortMessage: "An internal error was received."
        })
    }
}
Object.defineProperty(nd, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32603
});
class id extends Wi {
    constructor(e) {
        super(e, {
            code: id.code,
            name: "InvalidInputRpcError",
            shortMessage: ["Missing or invalid parameters.", "Double check you have provided the correct parameters."].join(`
`)
        })
    }
}
Object.defineProperty(id, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32e3
});
class ip extends Wi {
    constructor(e) {
        super(e, {
            code: ip.code,
            name: "ResourceNotFoundRpcError",
            shortMessage: "Requested resource not found."
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ResourceNotFoundRpcError"
        })
    }
}
Object.defineProperty(ip, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32001
});
class sp extends Wi {
    constructor(e) {
        super(e, {
            code: sp.code,
            name: "ResourceUnavailableRpcError",
            shortMessage: "Requested resource not available."
        })
    }
}
Object.defineProperty(sp, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32002
});
class Ku extends Wi {
    constructor(e) {
        super(e, {
            code: Ku.code,
            name: "TransactionRejectedRpcError",
            shortMessage: "Transaction creation failed."
        })
    }
}
Object.defineProperty(Ku, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32003
});
class Dl extends Wi {
    constructor(e, {
        method: r
    } = {}) {
        super(e, {
            code: Dl.code,
            name: "MethodNotSupportedRpcError",
            shortMessage: `Method${r?` "${r}"`:""} is not supported.`
        })
    }
}
Object.defineProperty(Dl, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32004
});
class Yu extends Wi {
    constructor(e) {
        super(e, {
            code: Yu.code,
            name: "LimitExceededRpcError",
            shortMessage: "Request exceeds defined limit."
        })
    }
}
Object.defineProperty(Yu, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32005
});
class ap extends Wi {
    constructor(e) {
        super(e, {
            code: ap.code,
            name: "JsonRpcVersionUnsupportedError",
            shortMessage: "Version of JSON-RPC protocol is not supported."
        })
    }
}
Object.defineProperty(ap, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32006
});
class Yl extends ds {
    constructor(e) {
        super(e, {
            code: Yl.code,
            name: "UserRejectedRequestError",
            shortMessage: "User rejected the request."
        })
    }
}
Object.defineProperty(Yl, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4001
});
class op extends ds {
    constructor(e) {
        super(e, {
            code: op.code,
            name: "UnauthorizedProviderError",
            shortMessage: "The requested method and/or account has not been authorized by the user."
        })
    }
}
Object.defineProperty(op, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4100
});
class cp extends ds {
    constructor(e, {
        method: r
    } = {}) {
        super(e, {
            code: cp.code,
            name: "UnsupportedProviderMethodError",
            shortMessage: `The Provider does not support the requested method${r?` " ${r}"`:""}.`
        })
    }
}
Object.defineProperty(cp, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4200
});
class lp extends ds {
    constructor(e) {
        super(e, {
            code: lp.code,
            name: "ProviderDisconnectedError",
            shortMessage: "The Provider is disconnected from all chains."
        })
    }
}
Object.defineProperty(lp, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4900
});
class dp extends ds {
    constructor(e) {
        super(e, {
            code: dp.code,
            name: "ChainDisconnectedError",
            shortMessage: "The Provider is not connected to the requested chain."
        })
    }
}
Object.defineProperty(dp, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4901
});
class up extends ds {
    constructor(e) {
        super(e, {
            code: up.code,
            name: "SwitchChainError",
            shortMessage: "An error occurred when attempting to switch chain."
        })
    }
}
Object.defineProperty(up, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4902
});
class Zu extends ds {
    constructor(e) {
        super(e, {
            code: Zu.code,
            name: "UnsupportedNonOptionalCapabilityError",
            shortMessage: "This Wallet does not support a capability that was not marked as optional."
        })
    }
}
Object.defineProperty(Zu, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 5700
});
class hp extends ds {
    constructor(e) {
        super(e, {
            code: hp.code,
            name: "UnsupportedChainIdError",
            shortMessage: "This Wallet does not support the requested chain ID."
        })
    }
}
Object.defineProperty(hp, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 5710
});
class fp extends ds {
    constructor(e) {
        super(e, {
            code: fp.code,
            name: "DuplicateIdError",
            shortMessage: "There is already a bundle submitted with this ID."
        })
    }
}
Object.defineProperty(fp, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 5720
});
class pp extends ds {
    constructor(e) {
        super(e, {
            code: pp.code,
            name: "UnknownBundleIdError",
            shortMessage: "This bundle id is unknown / has not been submitted"
        })
    }
}
Object.defineProperty(pp, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 5730
});
class gp extends ds {
    constructor(e) {
        super(e, {
            code: gp.code,
            name: "BundleTooLargeError",
            shortMessage: "The call bundle is too large for the Wallet to process."
        })
    }
}
Object.defineProperty(gp, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 5740
});
class mp extends ds {
    constructor(e) {
        super(e, {
            code: mp.code,
            name: "AtomicReadyWalletRejectedUpgradeError",
            shortMessage: "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade."
        })
    }
}
Object.defineProperty(mp, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 5750
});
class Ju extends ds {
    constructor(e) {
        super(e, {
            code: Ju.code,
            name: "AtomicityNotSupportedError",
            shortMessage: "The wallet does not support atomic execution but the request requires it."
        })
    }
}
Object.defineProperty(Ju, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 5760
});
class ZW extends Wi {
    constructor(e) {
        super(e, {
            name: "UnknownRpcError",
            shortMessage: "An unknown RPC error occurred."
        })
    }
}
let AS = class extends be {
    constructor({
        max: e,
        min: r,
        signed: n,
        size: i,
        value: s
    }) {
        super(`Number "${s}" is not in safe ${i?`${i*8}-bit ${n?"signed":"unsigned"} `:""}integer range ${e?`(${r} to ${e})`:`(above ${r})`}`, {
            name: "IntegerOutOfRangeError"
        })
    }
};
class JW extends be {
    constructor(e) {
        super(`Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
            name: "InvalidBytesBooleanError"
        })
    }
}
class QW extends be {
    constructor(e) {
        super(`Hex value "${e}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`, {
            name: "InvalidHexBooleanError"
        })
    }
}
let XW = class extends be {
        constructor({
            givenSize: e,
            maxSize: r
        }) {
            super(`Size cannot exceed ${r} bytes. Given size: ${e} bytes.`, {
                name: "SizeOverflowError"
            })
        }
    },
    kS = class extends be {
        constructor({
            offset: e,
            position: r,
            size: n
        }) {
            super(`Slice ${r==="start"?"starting":"ending"} at offset "${e}" is out-of-bounds (size: ${n}).`, {
                name: "SliceOffsetOutOfBoundsError"
            })
        }
    },
    IS = class extends be {
        constructor({
            size: e,
            targetSize: r,
            type: n
        }) {
            super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${r}).`, {
                name: "SizeExceedsPaddingSizeError"
            })
        }
    };
class Z8 extends be {
    constructor({
        size: e,
        targetSize: r,
        type: n
    }) {
        super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} is expected to be ${r} ${n} long, but is ${e} ${n} long.`, {
            name: "InvalidBytesLengthError"
        })
    }
}

function qo(t, {
    dir: e,
    size: r = 32
} = {}) {
    return typeof t == "string" ? Qc(t, {
        dir: e,
        size: r
    }) : ez(t, {
        dir: e,
        size: r
    })
}

function Qc(t, {
    dir: e,
    size: r = 32
} = {}) {
    if (r === null) return t;
    const n = t.replace("0x", "");
    if (n.length > r * 2) throw new IS({
        size: Math.ceil(n.length / 2),
        targetSize: r,
        type: "hex"
    });
    return `0x${n[e==="right"?"padEnd":"padStart"](r*2,"0")}`
}

function ez(t, {
    dir: e,
    size: r = 32
} = {}) {
    if (r === null) return t;
    if (t.length > r) throw new IS({
        size: t.length,
        targetSize: r,
        type: "bytes"
    });
    const n = new Uint8Array(r);
    for (let i = 0; i < r; i++) {
        const s = e === "right";
        n[s ? i : r - i - 1] = t[s ? i : t.length - i - 1]
    }
    return n
}

function Jn(t, {
    strict: e = !0
} = {}) {
    return !t || typeof t != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith("0x")
}

function Rr(t) {
    return Jn(t, {
        strict: !1
    }) ? Math.ceil((t.length - 2) / 2) : t.length
}

function Ho(t, {
    dir: e = "left"
} = {}) {
    let r = typeof t == "string" ? t.replace("0x", "") : t,
        n = 0;
    for (let i = 0; i < r.length - 1 && r[e === "left" ? i : r.length - i - 1].toString() === "0"; i++) n++;
    return r = e === "left" ? r.slice(n) : r.slice(0, r.length - n), typeof t == "string" ? (r.length === 1 && e === "right" && (r = `${r}0`), `0x${r.length%2===1?`0${r}`:r}`) : r
}
const tz = new TextEncoder;

function dh(t, e = {}) {
    return typeof t == "number" || typeof t == "bigint" ? nz(t, e) : typeof t == "boolean" ? rz(t, e) : Jn(t) ? Ns(t, e) : Zl(t, e)
}

function rz(t, e = {}) {
    const r = new Uint8Array(1);
    return r[0] = Number(t), typeof e.size == "number" ? (Us(r, {
        size: e.size
    }), qo(r, {
        size: e.size
    })) : r
}
const bo = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};

function J8(t) {
    if (t >= bo.zero && t <= bo.nine) return t - bo.zero;
    if (t >= bo.A && t <= bo.F) return t - (bo.A - 10);
    if (t >= bo.a && t <= bo.f) return t - (bo.a - 10)
}

function Ns(t, e = {}) {
    let r = t;
    e.size && (Us(r, {
        size: e.size
    }), r = qo(r, {
        dir: "right",
        size: e.size
    }));
    let n = r.slice(2);
    n.length % 2 && (n = `0${n}`);
    const i = n.length / 2,
        s = new Uint8Array(i);
    for (let a = 0, o = 0; a < i; a++) {
        const c = J8(n.charCodeAt(o++)),
            l = J8(n.charCodeAt(o++));
        if (c === void 0 || l === void 0) throw new be(`Invalid byte sequence ("${n[o-2]}${n[o-1]}" in "${n}").`);
        s[a] = c * 16 + l
    }
    return s
}

function nz(t, e) {
    const r = nt(t, e);
    return Ns(r)
}

function Zl(t, e = {}) {
    const r = tz.encode(t);
    return typeof e.size == "number" ? (Us(r, {
        size: e.size
    }), qo(r, {
        dir: "right",
        size: e.size
    })) : r
}

function Us(t, {
    size: e
}) {
    if (Rr(t) > e) throw new XW({
        givenSize: Rr(t),
        maxSize: e
    })
}

function ss(t, e = {}) {
    const {
        signed: r
    } = e;
    e.size && Us(t, {
        size: e.size
    });
    const n = BigInt(t);
    if (!r) return n;
    const i = (t.length - 2) / 2,
        s = (1 n << BigInt(i) * 8 n - 1 n) - 1 n;
    return n <= s ? n : n - BigInt(`0x${"f".padStart(i*2,"f")}`) - 1 n
}

function iz(t, e = {}) {
    let r = t;
    if (e.size && (Us(r, {
            size: e.size
        }), r = Ho(r)), Ho(r) === "0x00") return !1;
    if (Ho(r) === "0x01") return !0;
    throw new QW(r)
}

function va(t, e = {}) {
    return Number(ss(t, e))
}

function sz(t, e = {}) {
    let r = Ns(t);
    return e.size && (Us(r, {
        size: e.size
    }), r = Ho(r, {
        dir: "right"
    })), new TextDecoder().decode(r)
}
const az = Array.from({
    length: 256
}, (t, e) => e.toString(16).padStart(2, "0"));

function cn(t, e = {}) {
    return typeof t == "number" || typeof t == "bigint" ? nt(t, e) : typeof t == "string" ? sd(t, e) : typeof t == "boolean" ? V4(t, e) : ln(t, e)
}

function V4(t, e = {}) {
    const r = `0x${Number(t)}`;
    return typeof e.size == "number" ? (Us(r, {
        size: e.size
    }), qo(r, {
        size: e.size
    })) : r
}

function ln(t, e = {}) {
    let r = "";
    for (let i = 0; i < t.length; i++) r += az[t[i]];
    const n = `0x${r}`;
    return typeof e.size == "number" ? (Us(n, {
        size: e.size
    }), qo(n, {
        dir: "right",
        size: e.size
    })) : n
}

function nt(t, e = {}) {
    const {
        signed: r,
        size: n
    } = e, i = BigInt(t);
    let s;
    n ? r ? s = (1 n << BigInt(n) * 8 n - 1 n) - 1 n : s = 2 n ** (BigInt(n) * 8 n) - 1 n : typeof t == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
    const a = typeof s == "bigint" && r ? -s - 1 n : 0;
    if (s && i > s || i < a) {
        const c = typeof t == "bigint" ? "n" : "";
        throw new AS({
            max: s ? `${s}${c}` : void 0,
            min: `${a}${c}`,
            signed: r,
            size: n,
            value: `${t}${c}`
        })
    }
    const o = `0x${(r&&i<0?(1n<<BigInt(n*8))+BigInt(i):i).toString(16)}`;
    return n ? qo(o, {
        size: n
    }) : o
}
const oz = new TextEncoder;

function sd(t, e = {}) {
    const r = oz.encode(t);
    return ln(r, e)
}
let Kp = class extends Map {
    constructor(e) {
        super(), Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.maxSize = e
    }
    get(e) {
        const r = super.get(e);
        return super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r
    }
    set(e, r) {
        if (super.set(e, r), this.maxSize && this.size > this.maxSize) {
            const n = this.keys().next().value;
            n && this.delete(n)
        }
        return this
    }
};
const H0 = new Kp(8192);

function cz(t, {
    enabled: e = !0,
    id: r
}) {
    if (!e || !r) return t();
    if (H0.get(r)) return H0.get(r);
    const n = t().finally(() => H0.delete(r));
    return H0.set(r, n), n
}
async function fm(t) {
    return new Promise(e => setTimeout(e, t))
}

function pm(t, {
    delay: e = 100,
    retryCount: r = 2,
    shouldRetry: n = () => !0
} = {}) {
    return new Promise((i, s) => {
        const a = async ({
            count: o = 0
        } = {}) => {
            const c = async ({
                error: l
            }) => {
                const u = typeof e == "function" ? e({
                    count: o,
                    error: l
                }) : e;
                u && await fm(u), a({
                    count: o + 1
                })
            };
            try {
                const l = await t();
                i(l)
            } catch (l) {
                if (o < r && await n({
                        count: o,
                        error: l
                    })) return c({
                    error: l
                });
                s(l)
            }
        };
        a()
    })
}

function lz(t, e = {}) {
    return async (r, n = {}) => {
        var h;
        const {
            dedupe: i = !1,
            methods: s,
            retryDelay: a = 150,
            retryCount: o = 3,
            uid: c
        } = { ...e,
            ...n
        }, {
            method: l
        } = r;
        if ((h = s == null ? void 0 : s.exclude) != null && h.includes(l)) throw new Dl(new Error("method not supported"), {
            method: l
        });
        if (s != null && s.include && !s.include.includes(l)) throw new Dl(new Error("method not supported"), {
            method: l
        });
        const u = i ? sd(`${c}.${zr(r)}`) : void 0;
        return cz(() => pm(async () => {
            try {
                return await t(r)
            } catch (f) {
                const p = f;
                switch (p.code) {
                    case ep.code:
                        throw new ep(p);
                    case tp.code:
                        throw new tp(p);
                    case rp.code:
                        throw new rp(p, {
                            method: r.method
                        });
                    case np.code:
                        throw new np(p);
                    case nd.code:
                        throw new nd(p);
                    case id.code:
                        throw new id(p);
                    case ip.code:
                        throw new ip(p);
                    case sp.code:
                        throw new sp(p);
                    case Ku.code:
                        throw new Ku(p);
                    case Dl.code:
                        throw new Dl(p, {
                            method: r.method
                        });
                    case Yu.code:
                        throw new Yu(p);
                    case ap.code:
                        throw new ap(p);
                    case Yl.code:
                        throw new Yl(p);
                    case op.code:
                        throw new op(p);
                    case cp.code:
                        throw new cp(p);
                    case lp.code:
                        throw new lp(p);
                    case dp.code:
                        throw new dp(p);
                    case up.code:
                        throw new up(p);
                    case Zu.code:
                        throw new Zu(p);
                    case hp.code:
                        throw new hp(p);
                    case fp.code:
                        throw new fp(p);
                    case pp.code:
                        throw new pp(p);
                    case gp.code:
                        throw new gp(p);
                    case mp.code:
                        throw new mp(p);
                    case Ju.code:
                        throw new Ju(p);
                    case 5e3:
                        throw new Yl(p);
                    default:
                        throw f instanceof be ? f : new ZW(p)
                }
            }
        }, {
            delay: ({
                count: f,
                error: p
            }) => {
                var g;
                if (p && p instanceof Kl) {
                    const m = (g = p == null ? void 0 : p.headers) == null ? void 0 : g.get("Retry-After");
                    if (m != null && m.match(/\d/)) return Number.parseInt(m) * 1e3
                }
                return ~~(1 << f) * a
            },
            retryCount: o,
            shouldRetry: ({
                error: f
            }) => dz(f)
        }), {
            enabled: i,
            id: u
        })
    }
}

function dz(t) {
    return "code" in t && typeof t.code == "number" ? t.code === -1 || t.code === Yu.code || t.code === nd.code : t instanceof Kl && t.status ? t.status === 403 || t.status === 408 || t.status === 413 || t.status === 429 || t.status === 500 || t.status === 502 || t.status === 503 || t.status === 504 : !0
}
const uz = "1.0.8";
let us = class Bv extends Error {
    constructor(e, r = {}) {
        var a;
        const n = r.cause instanceof Bv ? r.cause.details : (a = r.cause) != null && a.message ? r.cause.message : r.details,
            i = r.cause instanceof Bv && r.cause.docsPath || r.docsPath,
            s = [e || "An error occurred.", "", ...r.metaMessages ? [...r.metaMessages, ""] : [], ...i ? [`Docs: https://abitype.dev${i}`] : [], ...n ? [`Details: ${n}`] : [], `Version: abitype@${uz}`].join(`
`);
        super(s), Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiTypeError"
        }), r.cause && (this.cause = r.cause), this.details = n, this.docsPath = i, this.metaMessages = r.metaMessages, this.shortMessage = e
    }
};

function hc(t, e) {
    const r = t.exec(e);
    return r == null ? void 0 : r.groups
}
const $S = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
    SS = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,
    TS = /^\(.+?\).*?$/,
    Q8 = /^tuple(?<array>(\[(\d*)\])*)$/;

function Wv(t) {
    let e = t.type;
    if (Q8.test(t.type) && "components" in t) {
        e = "(";
        const r = t.components.length;
        for (let i = 0; i < r; i++) {
            const s = t.components[i];
            e += Wv(s), i < r - 1 && (e += ", ")
        }
        const n = hc(Q8, t.type);
        return e += `)${(n==null?void 0:n.array)??""}`, Wv({ ...t,
            type: e
        })
    }
    return "indexed" in t && t.indexed && (e = `${e} indexed`), t.name ? `${e} ${t.name}` : e
}

function Fh(t) {
    let e = "";
    const r = t.length;
    for (let n = 0; n < r; n++) {
        const i = t[n];
        e += Wv(i), n !== r - 1 && (e += ", ")
    }
    return e
}

function gm(t) {
    var e;
    return t.type === "function" ? `function ${t.name}(${Fh(t.inputs)})${t.stateMutability&&t.stateMutability!=="nonpayable"?` ${t.stateMutability}`:""}${(e=t.outputs)!=null&&e.length?` returns (${Fh(t.outputs)})`:""}` : t.type === "event" ? `event ${t.name}(${Fh(t.inputs)})` : t.type === "error" ? `error ${t.name}(${Fh(t.inputs)})` : t.type === "constructor" ? `constructor(${Fh(t.inputs)})${t.stateMutability==="payable"?" payable":""}` : t.type === "fallback" ? `fallback() external${t.stateMutability==="payable"?" payable":""}` : "receive() external payable"
}
const PS = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;

function hz(t) {
    return PS.test(t)
}

function fz(t) {
    return hc(PS, t)
}
const NS = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;

function pz(t) {
    return NS.test(t)
}

function gz(t) {
    return hc(NS, t)
}
const OS = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;

function mz(t) {
    return OS.test(t)
}

function yz(t) {
    return hc(OS, t)
}
const jS = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;

function G4(t) {
    return jS.test(t)
}

function wz(t) {
    return hc(jS, t)
}
const RS = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;

function bz(t) {
    return RS.test(t)
}

function vz(t) {
    return hc(RS, t)
}
const MS = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;

function xz(t) {
    return MS.test(t)
}

function Ez(t) {
    return hc(MS, t)
}
const _z = /^receive\(\) external payable$/;

function Cz(t) {
    return _z.test(t)
}
const Az = new Set(["indexed"]),
    zv = new Set(["calldata", "memory", "storage"]);
class kz extends us {
    constructor({
        signature: e
    }) {
        super("Failed to parse ABI item.", {
            details: `parseAbiItem(${JSON.stringify(e,null,2)})`,
            docsPath: "/api/human#parseabiitem-1"
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidAbiItemError"
        })
    }
}
class Iz extends us {
    constructor({
        type: e
    }) {
        super("Unknown type.", {
            metaMessages: [`Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnknownTypeError"
        })
    }
}
class $z extends us {
    constructor({
        type: e
    }) {
        super("Unknown type.", {
            metaMessages: [`Type "${e}" is not a valid ABI type.`]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnknownSolidityTypeError"
        })
    }
}
class Sz extends us {
    constructor({
        param: e
    }) {
        super("Invalid ABI parameter.", {
            details: e
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidParameterError"
        })
    }
}
class Tz extends us {
    constructor({
        param: e,
        name: r
    }) {
        super("Invalid ABI parameter.", {
            details: e,
            metaMessages: [`"${r}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SolidityProtectedKeywordError"
        })
    }
}
class Pz extends us {
    constructor({
        param: e,
        type: r,
        modifier: n
    }) {
        super("Invalid ABI parameter.", {
            details: e,
            metaMessages: [`Modifier "${n}" not allowed${r?` in "${r}" type`:""}.`]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidModifierError"
        })
    }
}
class Nz extends us {
    constructor({
        param: e,
        type: r,
        modifier: n
    }) {
        super("Invalid ABI parameter.", {
            details: e,
            metaMessages: [`Modifier "${n}" not allowed${r?` in "${r}" type`:""}.`, `Data location can only be specified for array, struct, or mapping types, but "${n}" was given.`]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidFunctionModifierError"
        })
    }
}
class Oz extends us {
    constructor({
        abiParameter: e
    }) {
        super("Invalid ABI parameter.", {
            details: JSON.stringify(e, null, 2),
            metaMessages: ["ABI parameter type is invalid."]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidAbiTypeParameterError"
        })
    }
}
class uh extends us {
    constructor({
        signature: e,
        type: r
    }) {
        super(`Invalid ${r} signature.`, {
            details: e
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidSignatureError"
        })
    }
}
class jz extends us {
    constructor({
        signature: e
    }) {
        super("Unknown signature.", {
            details: e
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnknownSignatureError"
        })
    }
}
class Rz extends us {
    constructor({
        signature: e
    }) {
        super("Invalid struct signature.", {
            details: e,
            metaMessages: ["No properties exist."]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidStructSignatureError"
        })
    }
}
class Mz extends us {
    constructor({
        type: e
    }) {
        super("Circular reference detected.", {
            metaMessages: [`Struct "${e}" is a circular reference.`]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "CircularReferenceError"
        })
    }
}
class Dz extends us {
    constructor({
        current: e,
        depth: r
    }) {
        super("Unbalanced parentheses.", {
            metaMessages: [`"${e.trim()}" has too many ${r>0?"opening":"closing"} parentheses.`],
            details: `Depth "${r}"`
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidParenthesisError"
        })
    }
}

function Lz(t, e, r) {
    let n = "";
    if (r)
        for (const i of Object.entries(r)) {
            if (!i) continue;
            let s = "";
            for (const a of i[1]) s += `[${a.type}${a.name?`:${a.name}`:""}]`;
            n += `(${i[0]}{${s}})`
        }
    return e ? `${e}:${t}${n}` : t
}
const vw = new Map([
    ["address", {
        type: "address"
    }],
    ["bool", {
        type: "bool"
    }],
    ["bytes", {
        type: "bytes"
    }],
    ["bytes32", {
        type: "bytes32"
    }],
    ["int", {
        type: "int256"
    }],
    ["int256", {
        type: "int256"
    }],
    ["string", {
        type: "string"
    }],
    ["uint", {
        type: "uint256"
    }],
    ["uint8", {
        type: "uint8"
    }],
    ["uint16", {
        type: "uint16"
    }],
    ["uint24", {
        type: "uint24"
    }],
    ["uint32", {
        type: "uint32"
    }],
    ["uint64", {
        type: "uint64"
    }],
    ["uint96", {
        type: "uint96"
    }],
    ["uint112", {
        type: "uint112"
    }],
    ["uint160", {
        type: "uint160"
    }],
    ["uint192", {
        type: "uint192"
    }],
    ["uint256", {
        type: "uint256"
    }],
    ["address owner", {
        type: "address",
        name: "owner"
    }],
    ["address to", {
        type: "address",
        name: "to"
    }],
    ["bool approved", {
        type: "bool",
        name: "approved"
    }],
    ["bytes _data", {
        type: "bytes",
        name: "_data"
    }],
    ["bytes data", {
        type: "bytes",
        name: "data"
    }],
    ["bytes signature", {
        type: "bytes",
        name: "signature"
    }],
    ["bytes32 hash", {
        type: "bytes32",
        name: "hash"
    }],
    ["bytes32 r", {
        type: "bytes32",
        name: "r"
    }],
    ["bytes32 root", {
        type: "bytes32",
        name: "root"
    }],
    ["bytes32 s", {
        type: "bytes32",
        name: "s"
    }],
    ["string name", {
        type: "string",
        name: "name"
    }],
    ["string symbol", {
        type: "string",
        name: "symbol"
    }],
    ["string tokenURI", {
        type: "string",
        name: "tokenURI"
    }],
    ["uint tokenId", {
        type: "uint256",
        name: "tokenId"
    }],
    ["uint8 v", {
        type: "uint8",
        name: "v"
    }],
    ["uint256 balance", {
        type: "uint256",
        name: "balance"
    }],
    ["uint256 tokenId", {
        type: "uint256",
        name: "tokenId"
    }],
    ["uint256 value", {
        type: "uint256",
        name: "value"
    }],
    ["event:address indexed from", {
        type: "address",
        name: "from",
        indexed: !0
    }],
    ["event:address indexed to", {
        type: "address",
        name: "to",
        indexed: !0
    }],
    ["event:uint indexed tokenId", {
        type: "uint256",
        name: "tokenId",
        indexed: !0
    }],
    ["event:uint256 indexed tokenId", {
        type: "uint256",
        name: "tokenId",
        indexed: !0
    }]
]);

function qv(t, e = {}) {
    if (mz(t)) return Uz(t, e);
    if (pz(t)) return Fz(t, e);
    if (hz(t)) return Bz(t, e);
    if (bz(t)) return Wz(t, e);
    if (xz(t)) return zz(t);
    if (Cz(t)) return {
        type: "receive",
        stateMutability: "payable"
    };
    throw new jz({
        signature: t
    })
}

function Uz(t, e = {}) {
    const r = yz(t);
    if (!r) throw new uh({
        signature: t,
        type: "function"
    });
    const n = la(r.parameters),
        i = [],
        s = n.length;
    for (let o = 0; o < s; o++) i.push(ad(n[o], {
        modifiers: zv,
        structs: e,
        type: "function"
    }));
    const a = [];
    if (r.returns) {
        const o = la(r.returns),
            c = o.length;
        for (let l = 0; l < c; l++) a.push(ad(o[l], {
            modifiers: zv,
            structs: e,
            type: "function"
        }))
    }
    return {
        name: r.name,
        type: "function",
        stateMutability: r.stateMutability ? ? "nonpayable",
        inputs: i,
        outputs: a
    }
}

function Fz(t, e = {}) {
    const r = gz(t);
    if (!r) throw new uh({
        signature: t,
        type: "event"
    });
    const n = la(r.parameters),
        i = [],
        s = n.length;
    for (let a = 0; a < s; a++) i.push(ad(n[a], {
        modifiers: Az,
        structs: e,
        type: "event"
    }));
    return {
        name: r.name,
        type: "event",
        inputs: i
    }
}

function Bz(t, e = {}) {
    const r = fz(t);
    if (!r) throw new uh({
        signature: t,
        type: "error"
    });
    const n = la(r.parameters),
        i = [],
        s = n.length;
    for (let a = 0; a < s; a++) i.push(ad(n[a], {
        structs: e,
        type: "error"
    }));
    return {
        name: r.name,
        type: "error",
        inputs: i
    }
}

function Wz(t, e = {}) {
    const r = vz(t);
    if (!r) throw new uh({
        signature: t,
        type: "constructor"
    });
    const n = la(r.parameters),
        i = [],
        s = n.length;
    for (let a = 0; a < s; a++) i.push(ad(n[a], {
        structs: e,
        type: "constructor"
    }));
    return {
        type: "constructor",
        stateMutability: r.stateMutability ? ? "nonpayable",
        inputs: i
    }
}

function zz(t) {
    const e = Ez(t);
    if (!e) throw new uh({
        signature: t,
        type: "fallback"
    });
    return {
        type: "fallback",
        stateMutability: e.stateMutability ? ? "nonpayable"
    }
}
const qz = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
    Hz = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
    Vz = /^u?int$/;

function ad(t, e) {
    var h, f;
    const r = Lz(t, e == null ? void 0 : e.type, e == null ? void 0 : e.structs);
    if (vw.has(r)) return vw.get(r);
    const n = TS.test(t),
        i = hc(n ? Hz : qz, t);
    if (!i) throw new Sz({
        param: t
    });
    if (i.name && Kz(i.name)) throw new Tz({
        param: t,
        name: i.name
    });
    const s = i.name ? {
            name: i.name
        } : {},
        a = i.modifier === "indexed" ? {
            indexed: !0
        } : {},
        o = (e == null ? void 0 : e.structs) ? ? {};
    let c, l = {};
    if (n) {
        c = "tuple";
        const p = la(i.type),
            g = [],
            m = p.length;
        for (let y = 0; y < m; y++) g.push(ad(p[y], {
            structs: o
        }));
        l = {
            components: g
        }
    } else if (i.type in o) c = "tuple", l = {
        components: o[i.type]
    };
    else if (Vz.test(i.type)) c = `${i.type}256`;
    else if (c = i.type, (e == null ? void 0 : e.type) !== "struct" && !DS(c)) throw new $z({
        type: c
    });
    if (i.modifier) {
        if (!((f = (h = e == null ? void 0 : e.modifiers) == null ? void 0 : h.has) != null && f.call(h, i.modifier))) throw new Pz({
            param: t,
            type: e == null ? void 0 : e.type,
            modifier: i.modifier
        });
        if (zv.has(i.modifier) && !Yz(c, !!i.array)) throw new Nz({
            param: t,
            type: e == null ? void 0 : e.type,
            modifier: i.modifier
        })
    }
    const u = {
        type: `${c}${i.array??""}`,
        ...s,
        ...a,
        ...l
    };
    return vw.set(r, u), u
}

function la(t, e = [], r = "", n = 0) {
    const i = t.trim().length;
    for (let s = 0; s < i; s++) {
        const a = t[s],
            o = t.slice(s + 1);
        switch (a) {
            case ",":
                return n === 0 ? la(o, [...e, r.trim()]) : la(o, e, `${r}${a}`, n);
            case "(":
                return la(o, e, `${r}${a}`, n + 1);
            case ")":
                return la(o, e, `${r}${a}`, n - 1);
            default:
                return la(o, e, `${r}${a}`, n)
        }
    }
    if (r === "") return e;
    if (n !== 0) throw new Dz({
        current: r,
        depth: n
    });
    return e.push(r.trim()), e
}

function DS(t) {
    return t === "address" || t === "bool" || t === "function" || t === "string" || $S.test(t) || SS.test(t)
}
const Gz = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;

function Kz(t) {
    return t === "address" || t === "bool" || t === "function" || t === "string" || t === "tuple" || $S.test(t) || SS.test(t) || Gz.test(t)
}

function Yz(t, e) {
    return e || t === "bytes" || t === "string" || t === "tuple"
}

function LS(t) {
    const e = {},
        r = t.length;
    for (let a = 0; a < r; a++) {
        const o = t[a];
        if (!G4(o)) continue;
        const c = wz(o);
        if (!c) throw new uh({
            signature: o,
            type: "struct"
        });
        const l = c.properties.split(";"),
            u = [],
            h = l.length;
        for (let f = 0; f < h; f++) {
            const g = l[f].trim();
            if (!g) continue;
            const m = ad(g, {
                type: "struct"
            });
            u.push(m)
        }
        if (!u.length) throw new Rz({
            signature: o
        });
        e[c.name] = u
    }
    const n = {},
        i = Object.entries(e),
        s = i.length;
    for (let a = 0; a < s; a++) {
        const [o, c] = i[a];
        n[o] = US(c, e)
    }
    return n
}
const Zz = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;

function US(t, e, r = new Set) {
    const n = [],
        i = t.length;
    for (let s = 0; s < i; s++) {
        const a = t[s];
        if (TS.test(a.type)) n.push(a);
        else {
            const c = hc(Zz, a.type);
            if (!(c != null && c.type)) throw new Oz({
                abiParameter: a
            });
            const {
                array: l,
                type: u
            } = c;
            if (u in e) {
                if (r.has(u)) throw new Mz({
                    type: u
                });
                n.push({ ...a,
                    type: `tuple${l??""}`,
                    components: US(e[u] ? ? [], e, new Set([...r, u]))
                })
            } else if (DS(u)) n.push(a);
            else throw new Iz({
                type: u
            })
        }
    }
    return n
}

function FS(t) {
    const e = LS(t),
        r = [],
        n = t.length;
    for (let i = 0; i < n; i++) {
        const s = t[i];
        G4(s) || r.push(qv(s, e))
    }
    return r
}

function X8(t) {
    let e;
    if (typeof t == "string") e = qv(t);
    else {
        const r = LS(t),
            n = t.length;
        for (let i = 0; i < n; i++) {
            const s = t[i];
            if (!G4(s)) {
                e = qv(s, r);
                break
            }
        }
    }
    if (!e) throw new kz({
        signature: t
    });
    return e
}
const Jz = "0.1.1";

function Qz() {
    return Jz
}
let Hr = class Hv extends Error {
    constructor(e, r = {}) {
        const n = (() => {
                var c;
                if (r.cause instanceof Hv) {
                    if (r.cause.details) return r.cause.details;
                    if (r.cause.shortMessage) return r.cause.shortMessage
                }
                return r.cause && "details" in r.cause && typeof r.cause.details == "string" ? r.cause.details : (c = r.cause) != null && c.message ? r.cause.message : r.details
            })(),
            i = r.cause instanceof Hv && r.cause.docsPath || r.docsPath,
            a = `https://oxlib.sh${i??""}`,
            o = [e || "An error occurred.", ...r.metaMessages ? ["", ...r.metaMessages] : [], ...n || i ? ["", n ? `Details: ${n}` : void 0, i ? `See: ${a}` : void 0] : []].filter(c => typeof c == "string").join(`
`);
        super(o, r.cause ? {
            cause: r.cause
        } : void 0), Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "docs", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseError"
        }), Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: `ox@${Qz()}`
        }), this.cause = r.cause, this.details = n, this.docs = a, this.docsPath = i, this.shortMessage = e
    }
    walk(e) {
        return BS(this, e)
    }
};

function BS(t, e) {
    return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause ? BS(t.cause, e) : e ? null : t
}
const Xz = "#__bigint";

function eq(t, e, r) {
    return JSON.stringify(t, (n, i) => typeof i == "bigint" ? i.toString() + Xz : i, r)
}

function tq(t, e) {
    if (tE(t) > e) throw new uq({
        givenSize: tE(t),
        maxSize: e
    })
}
const vo = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};

function eE(t) {
    if (t >= vo.zero && t <= vo.nine) return t - vo.zero;
    if (t >= vo.A && t <= vo.F) return t - (vo.A - 10);
    if (t >= vo.a && t <= vo.f) return t - (vo.a - 10)
}

function rq(t, e = {}) {
    const {
        dir: r,
        size: n = 32
    } = e;
    if (n === 0) return t;
    if (t.length > n) throw new hq({
        size: t.length,
        targetSize: n,
        type: "Bytes"
    });
    const i = new Uint8Array(n);
    for (let s = 0; s < n; s++) {
        const a = r === "right";
        i[a ? s : n - s - 1] = t[a ? s : t.length - s - 1]
    }
    return i
}

function K4(t, e) {
    if (Os(t) > e) throw new yq({
        givenSize: Os(t),
        maxSize: e
    })
}

function nq(t, e) {
    if (typeof e == "number" && e > 0 && e > Os(t) - 1) throw new VS({
        offset: e,
        position: "start",
        size: Os(t)
    })
}

function iq(t, e, r) {
    if (typeof e == "number" && typeof r == "number" && Os(t) !== r - e) throw new VS({
        offset: r,
        position: "end",
        size: Os(t)
    })
}

function WS(t, e = {}) {
    const {
        dir: r,
        size: n = 32
    } = e;
    if (n === 0) return t;
    const i = t.replace("0x", "");
    if (i.length > n * 2) throw new wq({
        size: Math.ceil(i.length / 2),
        targetSize: n,
        type: "Hex"
    });
    return `0x${i[r==="right"?"padEnd":"padStart"](n*2,"0")}`
}
const sq = new TextEncoder;

function aq(t) {
    return t instanceof Uint8Array ? t : typeof t == "string" ? cq(t) : oq(t)
}

function oq(t) {
    return t instanceof Uint8Array ? t : new Uint8Array(t)
}

function cq(t, e = {}) {
    const {
        size: r
    } = e;
    let n = t;
    r && (K4(t, r), n = cd(t, r));
    let i = n.slice(2);
    i.length % 2 && (i = `0${i}`);
    const s = i.length / 2,
        a = new Uint8Array(s);
    for (let o = 0, c = 0; o < s; o++) {
        const l = eE(i.charCodeAt(c++)),
            u = eE(i.charCodeAt(c++));
        if (l === void 0 || u === void 0) throw new Hr(`Invalid byte sequence ("${i[c-2]}${i[c-1]}" in "${i}").`);
        a[o] = l * 16 + u
    }
    return a
}

function lq(t, e = {}) {
    const {
        size: r
    } = e, n = sq.encode(t);
    return typeof r == "number" ? (tq(n, r), dq(n, r)) : n
}

function dq(t, e) {
    return rq(t, {
        dir: "right",
        size: e
    })
}

function tE(t) {
    return t.length
}
let uq = class extends Hr {
        constructor({
            givenSize: e,
            maxSize: r
        }) {
            super(`Size cannot exceed \`${r}\` bytes. Given size: \`${e}\` bytes.`), Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "Bytes.SizeOverflowError"
            })
        }
    },
    hq = class extends Hr {
        constructor({
            size: e,
            targetSize: r,
            type: n
        }) {
            super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${r}\`).`), Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "Bytes.SizeExceedsPaddingSizeError"
            })
        }
    };
const fq = new TextEncoder,
    pq = Array.from({
        length: 256
    }, (t, e) => e.toString(16).padStart(2, "0"));

function gq(t, e = {}) {
    const {
        strict: r = !1
    } = e;
    if (!t) throw new rE(t);
    if (typeof t != "string") throw new rE(t);
    if (r && !/^0x[0-9a-fA-F]*$/.test(t)) throw new nE(t);
    if (!t.startsWith("0x")) throw new nE(t)
}

function lo(...t) {
    return `0x${t.reduce((e,r)=>e+r.replace("0x",""),"")}`
}

function zS(t, e = {}) {
    const r = `0x${Number(t)}`;
    return typeof e.size == "number" ? (K4(r, e.size), od(r, e.size)) : r
}

function qS(t, e = {}) {
    let r = "";
    for (let i = 0; i < t.length; i++) r += pq[t[i]];
    const n = `0x${r}`;
    return typeof e.size == "number" ? (K4(n, e.size), cd(n, e.size)) : n
}

function si(t, e = {}) {
    const {
        signed: r,
        size: n
    } = e, i = BigInt(t);
    let s;
    n ? r ? s = (1 n << BigInt(n) * 8 n - 1 n) - 1 n : s = 2 n ** (BigInt(n) * 8 n) - 1 n : typeof t == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
    const a = typeof s == "bigint" && r ? -s - 1 n : 0;
    if (s && i > s || i < a) {
        const l = typeof t == "bigint" ? "n" : "";
        throw new HS({
            max: s ? `${s}${l}` : void 0,
            min: `${a}${l}`,
            signed: r,
            size: n,
            value: `${t}${l}`
        })
    }
    const c = `0x${(r&&i<0?(1n<<BigInt(n*8))+BigInt(i):i).toString(16)}`;
    return n ? od(c, n) : c
}

function Y4(t, e = {}) {
    return qS(fq.encode(t), e)
}

function od(t, e) {
    return WS(t, {
        dir: "left",
        size: e
    })
}

function cd(t, e) {
    return WS(t, {
        dir: "right",
        size: e
    })
}

function Z4(t, e, r, n = {}) {
    const {
        strict: i
    } = n;
    nq(t, e);
    const s = `0x${t.replace("0x","").slice((e??0)*2,(r??t.length)*2)}`;
    return i && iq(s, e, r), s
}

function Os(t) {
    return Math.ceil((t.length - 2) / 2)
}

function mq(t, e = {}) {
    const {
        strict: r = !1
    } = e;
    try {
        return gq(t, {
            strict: r
        }), !0
    } catch {
        return !1
    }
}
let HS = class extends Hr {
    constructor({
        max: e,
        min: r,
        signed: n,
        size: i,
        value: s
    }) {
        super(`Number \`${s}\` is not in safe${i?` ${i*8}-bit`:""}${n?" signed":" unsigned"} integer range ${e?`(\`${r}\` to \`${e}\`)`:`(above \`${r}\`)`}`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.IntegerOutOfRangeError"
        })
    }
};
class rE extends Hr {
    constructor(e) {
        super(`Value \`${typeof e=="object"?eq(e):e}\` of type \`${typeof e}\` is an invalid hex type.`, {
            metaMessages: ['Hex types must be represented as `"0x${string}"`.']
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.InvalidHexTypeError"
        })
    }
}
class nE extends Hr {
    constructor(e) {
        super(`Value \`${e}\` is an invalid hex value.`, {
            metaMessages: ['Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).']
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.InvalidHexValueError"
        })
    }
}
let yq = class extends Hr {
    constructor({
        givenSize: e,
        maxSize: r
    }) {
        super(`Size cannot exceed \`${r}\` bytes. Given size: \`${e}\` bytes.`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeOverflowError"
        })
    }
};
class VS extends Hr {
    constructor({
        offset: e,
        position: r,
        size: n
    }) {
        super(`Slice ${r==="start"?"starting":"ending"} at offset \`${e}\` is out-of-bounds (size: \`${n}\`).`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SliceOffsetOutOfBoundsError"
        })
    }
}
let wq = class extends Hr {
    constructor({
        size: e,
        targetSize: r,
        type: n
    }) {
        super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${r}\`).`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Hex.SizeExceedsPaddingSizeError"
        })
    }
};

function bq(t) {
    return {
        address: t.address,
        amount: si(t.amount),
        index: si(t.index),
        validatorIndex: si(t.validatorIndex)
    }
}

function GS(t) {
    return { ...typeof t.baseFeePerGas == "bigint" && {
            baseFeePerGas: si(t.baseFeePerGas)
        },
        ...typeof t.blobBaseFee == "bigint" && {
            blobBaseFee: si(t.blobBaseFee)
        },
        ...typeof t.feeRecipient == "string" && {
            feeRecipient: t.feeRecipient
        },
        ...typeof t.gasLimit == "bigint" && {
            gasLimit: si(t.gasLimit)
        },
        ...typeof t.number == "bigint" && {
            number: si(t.number)
        },
        ...typeof t.prevRandao == "bigint" && {
            prevRandao: si(t.prevRandao)
        },
        ...typeof t.time == "bigint" && {
            time: si(t.time)
        },
        ...t.withdrawals && {
            withdrawals: t.withdrawals.map(bq)
        }
    }
}

function qr(t) {
    return typeof t == "string" ? {
        address: t,
        type: "json-rpc"
    } : t
}
const Vv = [{
        inputs: [{
            components: [{
                name: "target",
                type: "address"
            }, {
                name: "allowFailure",
                type: "bool"
            }, {
                name: "callData",
                type: "bytes"
            }],
            name: "calls",
            type: "tuple[]"
        }],
        name: "aggregate3",
        outputs: [{
            components: [{
                name: "success",
                type: "bool"
            }, {
                name: "returnData",
                type: "bytes"
            }],
            name: "returnData",
            type: "tuple[]"
        }],
        stateMutability: "view",
        type: "function"
    }],
    Gv = [{
        name: "query",
        type: "function",
        stateMutability: "view",
        inputs: [{
            type: "tuple[]",
            name: "queries",
            components: [{
                type: "address",
                name: "sender"
            }, {
                type: "string[]",
                name: "urls"
            }, {
                type: "bytes",
                name: "data"
            }]
        }],
        outputs: [{
            type: "bool[]",
            name: "failures"
        }, {
            type: "bytes[]",
            name: "responses"
        }]
    }, {
        name: "HttpError",
        type: "error",
        inputs: [{
            type: "uint16",
            name: "status"
        }, {
            type: "string",
            name: "message"
        }]
    }],
    KS = [{
        inputs: [],
        name: "ResolverNotFound",
        type: "error"
    }, {
        inputs: [],
        name: "ResolverWildcardNotSupported",
        type: "error"
    }, {
        inputs: [],
        name: "ResolverNotContract",
        type: "error"
    }, {
        inputs: [{
            name: "returnData",
            type: "bytes"
        }],
        name: "ResolverError",
        type: "error"
    }, {
        inputs: [{
            components: [{
                name: "status",
                type: "uint16"
            }, {
                name: "message",
                type: "string"
            }],
            name: "errors",
            type: "tuple[]"
        }],
        name: "HttpError",
        type: "error"
    }],
    YS = [...KS, {
        name: "resolve",
        type: "function",
        stateMutability: "view",
        inputs: [{
            name: "name",
            type: "bytes"
        }, {
            name: "data",
            type: "bytes"
        }],
        outputs: [{
            name: "",
            type: "bytes"
        }, {
            name: "address",
            type: "address"
        }]
    }, {
        name: "resolve",
        type: "function",
        stateMutability: "view",
        inputs: [{
            name: "name",
            type: "bytes"
        }, {
            name: "data",
            type: "bytes"
        }, {
            name: "gateways",
            type: "string[]"
        }],
        outputs: [{
            name: "",
            type: "bytes"
        }, {
            name: "address",
            type: "address"
        }]
    }],
    vq = [...KS, {
        name: "reverse",
        type: "function",
        stateMutability: "view",
        inputs: [{
            type: "bytes",
            name: "reverseName"
        }],
        outputs: [{
            type: "string",
            name: "resolvedName"
        }, {
            type: "address",
            name: "resolvedAddress"
        }, {
            type: "address",
            name: "reverseResolver"
        }, {
            type: "address",
            name: "resolver"
        }]
    }, {
        name: "reverse",
        type: "function",
        stateMutability: "view",
        inputs: [{
            type: "bytes",
            name: "reverseName"
        }, {
            type: "string[]",
            name: "gateways"
        }],
        outputs: [{
            type: "string",
            name: "resolvedName"
        }, {
            type: "address",
            name: "resolvedAddress"
        }, {
            type: "address",
            name: "reverseResolver"
        }, {
            type: "address",
            name: "resolver"
        }]
    }],
    iE = [{
        name: "text",
        type: "function",
        stateMutability: "view",
        inputs: [{
            name: "name",
            type: "bytes32"
        }, {
            name: "key",
            type: "string"
        }],
        outputs: [{
            name: "",
            type: "string"
        }]
    }],
    sE = [{
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [{
            name: "name",
            type: "bytes32"
        }],
        outputs: [{
            name: "",
            type: "address"
        }]
    }, {
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [{
            name: "name",
            type: "bytes32"
        }, {
            name: "coinType",
            type: "uint256"
        }],
        outputs: [{
            name: "",
            type: "bytes"
        }]
    }],
    aE = [{
        inputs: [{
            name: "_signer",
            type: "address"
        }, {
            name: "_hash",
            type: "bytes32"
        }, {
            name: "_signature",
            type: "bytes"
        }],
        stateMutability: "nonpayable",
        type: "constructor"
    }, {
        inputs: [{
            name: "_signer",
            type: "address"
        }, {
            name: "_hash",
            type: "bytes32"
        }, {
            name: "_signature",
            type: "bytes"
        }],
        outputs: [{
            type: "bool"
        }],
        stateMutability: "nonpayable",
        type: "function",
        name: "isValidSig"
    }],
    ZPe = [{
        type: "event",
        name: "Approval",
        inputs: [{
            indexed: !0,
            name: "owner",
            type: "address"
        }, {
            indexed: !0,
            name: "spender",
            type: "address"
        }, {
            indexed: !1,
            name: "value",
            type: "uint256"
        }]
    }, {
        type: "event",
        name: "Transfer",
        inputs: [{
            indexed: !0,
            name: "from",
            type: "address"
        }, {
            indexed: !0,
            name: "to",
            type: "address"
        }, {
            indexed: !1,
            name: "value",
            type: "uint256"
        }]
    }, {
        type: "function",
        name: "allowance",
        stateMutability: "view",
        inputs: [{
            name: "owner",
            type: "address"
        }, {
            name: "spender",
            type: "address"
        }],
        outputs: [{
            type: "uint256"
        }]
    }, {
        type: "function",
        name: "approve",
        stateMutability: "nonpayable",
        inputs: [{
            name: "spender",
            type: "address"
        }, {
            name: "amount",
            type: "uint256"
        }],
        outputs: [{
            type: "bool"
        }]
    }, {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [{
            name: "account",
            type: "address"
        }],
        outputs: [{
            type: "uint256"
        }]
    }, {
        type: "function",
        name: "decimals",
        stateMutability: "view",
        inputs: [],
        outputs: [{
            type: "uint8"
        }]
    }, {
        type: "function",
        name: "name",
        stateMutability: "view",
        inputs: [],
        outputs: [{
            type: "string"
        }]
    }, {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [{
            type: "string"
        }]
    }, {
        type: "function",
        name: "totalSupply",
        stateMutability: "view",
        inputs: [],
        outputs: [{
            type: "uint256"
        }]
    }, {
        type: "function",
        name: "transfer",
        stateMutability: "nonpayable",
        inputs: [{
            name: "recipient",
            type: "address"
        }, {
            name: "amount",
            type: "uint256"
        }],
        outputs: [{
            type: "bool"
        }]
    }, {
        type: "function",
        name: "transferFrom",
        stateMutability: "nonpayable",
        inputs: [{
            name: "sender",
            type: "address"
        }, {
            name: "recipient",
            type: "address"
        }, {
            name: "amount",
            type: "uint256"
        }],
        outputs: [{
            type: "bool"
        }]
    }],
    xq = "0x82ad56cb",
    ZS = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe",
    Eq = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe",
    _q = "0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
class Kv extends be {
    constructor({
        blockNumber: e,
        chain: r,
        contract: n
    }) {
        super(`Chain "${r.name}" does not support contract "${n.name}".`, {
            metaMessages: ["This could be due to any of the following:", ...e && n.blockCreated && n.blockCreated > e ? [`- The contract "${n.name}" was not deployed until block ${n.blockCreated} (current block ${e}).`] : [`- The chain does not have the contract "${n.name}" configured.`]],
            name: "ChainDoesNotSupportContract"
        })
    }
}
class Cq extends be {
    constructor({
        chain: e,
        currentChainId: r
    }) {
        super(`The current chain of the wallet (id: ${r}) does not match the target chain for the transaction (id: ${e.id} – ${e.name}).`, {
            metaMessages: [`Current Chain ID:  ${r}`, `Expected Chain ID: ${e.id} – ${e.name}`],
            name: "ChainMismatchError"
        })
    }
}
class Aq extends be {
    constructor() {
        super(["No chain was provided to the request.", "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."].join(`
`), {
            name: "ChainNotFoundError"
        })
    }
}
class JS extends be {
    constructor() {
        super("No chain was provided to the Client.", {
            name: "ClientChainNotConfiguredError"
        })
    }
}
const QS = {
        1: "An `assert` condition failed.",
        17: "Arithmetic operation resulted in underflow or overflow.",
        18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
        33: "Attempted to convert to an invalid type.",
        34: "Attempted to access a storage byte array that is incorrectly encoded.",
        49: "Performed `.pop()` on an empty array",
        50: "Array index is out of bounds.",
        65: "Allocated too much memory or created an array which is too large.",
        81: "Attempted to call a zero-initialized variable of internal function type."
    },
    XS = {
        inputs: [{
            name: "message",
            type: "string"
        }],
        name: "Error",
        type: "error"
    },
    kq = {
        inputs: [{
            name: "reason",
            type: "uint256"
        }],
        name: "Panic",
        type: "error"
    };

function xa(t, {
    includeName: e = !1
} = {}) {
    if (t.type !== "function" && t.type !== "event" && t.type !== "error") throw new Dq(t.type);
    return `${t.name}(${_1(t.inputs,{includeName:e})})`
}

function _1(t, {
    includeName: e = !1
} = {}) {
    return t ? t.map(r => Iq(r, {
        includeName: e
    })).join(e ? ", " : ",") : ""
}

function Iq(t, {
    includeName: e
}) {
    return t.type.startsWith("tuple") ? `(${_1(t.components,{includeName:e})})${t.type.slice(5)}` : t.type + (e && t.name ? ` ${t.name}` : "")
}
class $q extends be {
    constructor({
        docsPath: e
    }) {
        super(["A constructor was not found on the ABI.", "Make sure you are using the correct ABI and that the constructor exists on it."].join(`
`), {
            docsPath: e,
            name: "AbiConstructorNotFoundError"
        })
    }
}
class oE extends be {
    constructor({
        docsPath: e
    }) {
        super(["Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.", "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."].join(`
`), {
            docsPath: e,
            name: "AbiConstructorParamsNotFoundError"
        })
    }
}
class eT extends be {
    constructor({
        data: e,
        params: r,
        size: n
    }) {
        super([`Data size of ${n} bytes is too small for given parameters.`].join(`
`), {
            metaMessages: [`Params: (${_1(r,{includeName:!0})})`, `Data:   ${e} (${n} bytes)`],
            name: "AbiDecodingDataSizeTooSmallError"
        }), Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "params", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "size", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.data = e, this.params = r, this.size = n
    }
}
class Yp extends be {
    constructor() {
        super('Cannot decode zero data ("0x") with ABI parameters.', {
            name: "AbiDecodingZeroDataError"
        })
    }
}
class Sq extends be {
    constructor({
        expectedLength: e,
        givenLength: r,
        type: n
    }) {
        super([`ABI encoding array length mismatch for type ${n}.`, `Expected length: ${e}`, `Given length: ${r}`].join(`
`), {
            name: "AbiEncodingArrayLengthMismatchError"
        })
    }
}
class Tq extends be {
    constructor({
        expectedSize: e,
        value: r
    }) {
        super(`Size of bytes "${r}" (bytes${Rr(r)}) does not match expected size (bytes${e}).`, {
            name: "AbiEncodingBytesSizeMismatchError"
        })
    }
}
class tT extends be {
    constructor({
        expectedLength: e,
        givenLength: r
    }) {
        super(["ABI encoding params/values length mismatch.", `Expected length (params): ${e}`, `Given length (values): ${r}`].join(`
`), {
            name: "AbiEncodingLengthMismatchError"
        })
    }
}
class Pq extends be {
    constructor(e, {
        docsPath: r
    }) {
        super([`Arguments (\`args\`) were provided to "${e}", but "${e}" on the ABI does not contain any parameters (\`inputs\`).`, "Cannot encode error result without knowing what the parameter types are.", "Make sure you are using the correct ABI and that the inputs exist on it."].join(`
`), {
            docsPath: r,
            name: "AbiErrorInputsNotFoundError"
        })
    }
}
class cE extends be {
    constructor(e, {
        docsPath: r
    } = {}) {
        super([`Error ${e?`"${e}" `:""}not found on ABI.`, "Make sure you are using the correct ABI and that the error exists on it."].join(`
`), {
            docsPath: r,
            name: "AbiErrorNotFoundError"
        })
    }
}
class rT extends be {
    constructor(e, {
        docsPath: r
    }) {
        super([`Encoded error signature "${e}" not found on ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`].join(`
`), {
            docsPath: r,
            name: "AbiErrorSignatureNotFoundError"
        }), Object.defineProperty(this, "signature", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.signature = e
    }
}
class Nq extends be {
    constructor({
        docsPath: e
    }) {
        super("Cannot extract event signature from empty topics.", {
            docsPath: e,
            name: "AbiEventSignatureEmptyTopicsError"
        })
    }
}
class nT extends be {
    constructor(e, {
        docsPath: r
    }) {
        super([`Encoded event signature "${e}" not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`].join(`
`), {
            docsPath: r,
            name: "AbiEventSignatureNotFoundError"
        })
    }
}
class lE extends be {
    constructor(e, {
        docsPath: r
    } = {}) {
        super([`Event ${e?`"${e}" `:""}not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it."].join(`
`), {
            docsPath: r,
            name: "AbiEventNotFoundError"
        })
    }
}
class Qu extends be {
    constructor(e, {
        docsPath: r
    } = {}) {
        super([`Function ${e?`"${e}" `:""}not found on ABI.`, "Make sure you are using the correct ABI and that the function exists on it."].join(`
`), {
            docsPath: r,
            name: "AbiFunctionNotFoundError"
        })
    }
}
class iT extends be {
    constructor(e, {
        docsPath: r
    }) {
        super([`Function "${e}" does not contain any \`outputs\` on ABI.`, "Cannot decode function result without knowing what the parameter types are.", "Make sure you are using the correct ABI and that the function exists on it."].join(`
`), {
            docsPath: r,
            name: "AbiFunctionOutputsNotFoundError"
        })
    }
}
class Oq extends be {
    constructor(e, {
        docsPath: r
    }) {
        super([`Encoded function signature "${e}" not found on ABI.`, "Make sure you are using the correct ABI and that the function exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`].join(`
`), {
            docsPath: r,
            name: "AbiFunctionSignatureNotFoundError"
        })
    }
}
class jq extends be {
    constructor(e, r) {
        super("Found ambiguous types in overloaded ABI items.", {
            metaMessages: [`\`${e.type}\` in \`${xa(e.abiItem)}\`, and`, `\`${r.type}\` in \`${xa(r.abiItem)}\``, "", "These types encode differently and cannot be distinguished at runtime.", "Remove one of the ambiguous items in the ABI."],
            name: "AbiItemAmbiguityError"
        })
    }
}
let sT = class extends be {
    constructor({
        expectedSize: e,
        givenSize: r
    }) {
        super(`Expected bytes${e}, got bytes${r}.`, {
            name: "BytesSizeMismatchError"
        })
    }
};
class yp extends be {
    constructor({
        abiItem: e,
        data: r,
        params: n,
        size: i
    }) {
        super([`Data size of ${i} bytes is too small for non-indexed event parameters.`].join(`
`), {
            metaMessages: [`Params: (${_1(n,{includeName:!0})})`, `Data:   ${r} (${i} bytes)`],
            name: "DecodeLogDataMismatch"
        }), Object.defineProperty(this, "abiItem", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "params", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "size", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.abiItem = e, this.data = r, this.params = n, this.size = i
    }
}
class C1 extends be {
    constructor({
        abiItem: e,
        param: r
    }) {
        super([`Expected a topic for indexed event parameter${r.name?` "${r.name}"`:""} on event "${xa(e,{includeName:!0})}".`].join(`
`), {
            name: "DecodeLogTopicsMismatch"
        }), Object.defineProperty(this, "abiItem", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.abiItem = e
    }
}
class Rq extends be {
    constructor(e, {
        docsPath: r
    }) {
        super([`Type "${e}" is not a valid encoding type.`, "Please provide a valid ABI type."].join(`
`), {
            docsPath: r,
            name: "InvalidAbiEncodingType"
        })
    }
}
class Mq extends be {
    constructor(e, {
        docsPath: r
    }) {
        super([`Type "${e}" is not a valid decoding type.`, "Please provide a valid ABI type."].join(`
`), {
            docsPath: r,
            name: "InvalidAbiDecodingType"
        })
    }
}
let aT = class extends be {
    constructor(e) {
        super([`Value "${e}" is not a valid array.`].join(`
`), {
            name: "InvalidArrayError"
        })
    }
};
class Dq extends be {
    constructor(e) {
        super([`"${e}" is not a valid definition type.`, 'Valid types: "function", "event", "error"'].join(`
`), {
            name: "InvalidDefinitionTypeError"
        })
    }
}
class Lq extends be {
    constructor(e) {
        super(`Type "${e}" is not supported for packed encoding.`, {
            name: "UnsupportedPackedAbiType"
        })
    }
}

function Xu(t, e, r, {
    strict: n
} = {}) {
    return Jn(t, {
        strict: !1
    }) ? mm(t, e, r, {
        strict: n
    }) : lT(t, e, r, {
        strict: n
    })
}

function oT(t, e) {
    if (typeof e == "number" && e > 0 && e > Rr(t) - 1) throw new kS({
        offset: e,
        position: "start",
        size: Rr(t)
    })
}

function cT(t, e, r) {
    if (typeof e == "number" && typeof r == "number" && Rr(t) !== r - e) throw new kS({
        offset: r,
        position: "end",
        size: Rr(t)
    })
}

function lT(t, e, r, {
    strict: n
} = {}) {
    oT(t, e);
    const i = t.slice(e, r);
    return n && cT(i, e, r), i
}

function mm(t, e, r, {
    strict: n
} = {}) {
    oT(t, e);
    const i = `0x${t.replace("0x","").slice((e??0)*2,(r??t.length)*2)}`;
    return n && cT(i, e, r), i
}

function Pn(t, e) {
    const r = e || "hex",
        n = q4(Jn(t, {
            strict: !1
        }) ? dh(t) : t);
    return r === "bytes" ? n : cn(n)
}
const Uq = t => Pn(dh(t));

function Fq(t) {
    return Uq(t)
}

function Bq(t) {
    let e = !0,
        r = "",
        n = 0,
        i = "",
        s = !1;
    for (let a = 0; a < t.length; a++) {
        const o = t[a];
        if (["(", ")", ","].includes(o) && (e = !0), o === "(" && n++, o === ")" && n--, !!e) {
            if (n === 0) {
                if (o === " " && ["event", "function", ""].includes(i)) i = "";
                else if (i += o, o === ")") {
                    s = !0;
                    break
                }
                continue
            }
            if (o === " ") {
                t[a - 1] !== "," && r !== "," && r !== ",(" && (r = "", e = !1);
                continue
            }
            i += o, r += o
        }
    }
    if (!s) throw new be("Unable to normalize signature.");
    return i
}
const Wq = t => {
    const e = typeof t == "string" ? t : gm(t);
    return Bq(e)
};

function dT(t) {
    return Fq(Wq(t))
}
const Zp = t => Xu(dT(t), 0, 4);
let Jo = class extends be {
    constructor({
        address: e
    }) {
        super(`Address "${e}" is invalid.`, {
            metaMessages: ["- Address must be a hex value of 20 bytes (40 hex characters).", "- Address must match its checksum counterpart."],
            name: "InvalidAddressError"
        })
    }
};
const zq = /^0x[a-fA-F0-9]{40}$/,
    xw = new Kp(8192);

function gi(t, e) {
    const {
        strict: r = !0
    } = e ? ? {}, n = `${t}.${r}`;
    if (xw.has(n)) return xw.get(n);
    const i = zq.test(t) ? t.toLowerCase() === t ? !0 : r ? Jp(t) === t : !0 : !1;
    return xw.set(n, i), i
}
const Ew = new Kp(8192);

function Jp(t, e) {
    if (Ew.has(`${t}.${e}`)) return Ew.get(`${t}.${e}`);
    const r = t.substring(2).toLowerCase(),
        n = Pn(Zl(r), "bytes"),
        i = r.split("");
    for (let a = 0; a < 40; a += 2) n[a >> 1] >> 4 >= 8 && i[a] && (i[a] = i[a].toUpperCase()), (n[a >> 1] & 15) >= 8 && i[a + 1] && (i[a + 1] = i[a + 1].toUpperCase());
    const s = `0x${i.join("")}`;
    return Ew.set(`${t}.${e}`, s), s
}

function Zr(t, e) {
    if (!gi(t, {
            strict: !1
        })) throw new Jo({
        address: t
    });
    return Jp(t, e)
}
class dE extends be {
    constructor({
        offset: e
    }) {
        super(`Offset \`${e}\` cannot be negative.`, {
            name: "NegativeOffsetError"
        })
    }
}
class uT extends be {
    constructor({
        length: e,
        position: r
    }) {
        super(`Position \`${r}\` is out of bounds (\`0 < position < ${e}\`).`, {
            name: "PositionOutOfBoundsError"
        })
    }
}
class qq extends be {
    constructor({
        count: e,
        limit: r
    }) {
        super(`Recursive read limit of \`${r}\` exceeded (recursive read count: \`${e}\`).`, {
            name: "RecursiveReadLimitExceededError"
        })
    }
}
const Hq = {
    bytes: new Uint8Array,
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    positionReadCount: new Map,
    recursiveReadCount: 0,
    recursiveReadLimit: Number.POSITIVE_INFINITY,
    assertReadLimit() {
        if (this.recursiveReadCount >= this.recursiveReadLimit) throw new qq({
            count: this.recursiveReadCount + 1,
            limit: this.recursiveReadLimit
        })
    },
    assertPosition(t) {
        if (t < 0 || t > this.bytes.length - 1) throw new uT({
            length: this.bytes.length,
            position: t
        })
    },
    decrementPosition(t) {
        if (t < 0) throw new dE({
            offset: t
        });
        const e = this.position - t;
        this.assertPosition(e), this.position = e
    },
    getReadCount(t) {
        return this.positionReadCount.get(t || this.position) || 0
    },
    incrementPosition(t) {
        if (t < 0) throw new dE({
            offset: t
        });
        const e = this.position + t;
        this.assertPosition(e), this.position = e
    },
    inspectByte(t) {
        const e = t ? ? this.position;
        return this.assertPosition(e), this.bytes[e]
    },
    inspectBytes(t, e) {
        const r = e ? ? this.position;
        return this.assertPosition(r + t - 1), this.bytes.subarray(r, r + t)
    },
    inspectUint8(t) {
        const e = t ? ? this.position;
        return this.assertPosition(e), this.bytes[e]
    },
    inspectUint16(t) {
        const e = t ? ? this.position;
        return this.assertPosition(e + 1), this.dataView.getUint16(e)
    },
    inspectUint24(t) {
        const e = t ? ? this.position;
        return this.assertPosition(e + 2), (this.dataView.getUint16(e) << 8) + this.dataView.getUint8(e + 2)
    },
    inspectUint32(t) {
        const e = t ? ? this.position;
        return this.assertPosition(e + 3), this.dataView.getUint32(e)
    },
    pushByte(t) {
        this.assertPosition(this.position), this.bytes[this.position] = t, this.position++
    },
    pushBytes(t) {
        this.assertPosition(this.position + t.length - 1), this.bytes.set(t, this.position), this.position += t.length
    },
    pushUint8(t) {
        this.assertPosition(this.position), this.bytes[this.position] = t, this.position++
    },
    pushUint16(t) {
        this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, t), this.position += 2
    },
    pushUint24(t) {
        this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, t >> 8), this.dataView.setUint8(this.position + 2, t & 255), this.position += 3
    },
    pushUint32(t) {
        this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, t), this.position += 4
    },
    readByte() {
        this.assertReadLimit(), this._touch();
        const t = this.inspectByte();
        return this.position++, t
    },
    readBytes(t, e) {
        this.assertReadLimit(), this._touch();
        const r = this.inspectBytes(t);
        return this.position += e ? ? t, r
    },
    readUint8() {
        this.assertReadLimit(), this._touch();
        const t = this.inspectUint8();
        return this.position += 1, t
    },
    readUint16() {
        this.assertReadLimit(), this._touch();
        const t = this.inspectUint16();
        return this.position += 2, t
    },
    readUint24() {
        this.assertReadLimit(), this._touch();
        const t = this.inspectUint24();
        return this.position += 3, t
    },
    readUint32() {
        this.assertReadLimit(), this._touch();
        const t = this.inspectUint32();
        return this.position += 4, t
    },
    get remaining() {
        return this.bytes.length - this.position
    },
    setPosition(t) {
        const e = this.position;
        return this.assertPosition(t), this.position = t, () => this.position = e
    },
    _touch() {
        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;
        const t = this.getReadCount();
        this.positionReadCount.set(this.position, t + 1), t > 0 && this.recursiveReadCount++
    }
};

function J4(t, {
    recursiveReadLimit: e = 8192
} = {}) {
    const r = Object.create(Hq);
    return r.bytes = t, r.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength), r.positionReadCount = new Map, r.recursiveReadLimit = e, r
}

function Vq(t, e = {}) {
    typeof e.size < "u" && Us(t, {
        size: e.size
    });
    const r = ln(t, e);
    return ss(r, e)
}

function Gq(t, e = {}) {
    let r = t;
    if (typeof e.size < "u" && (Us(r, {
            size: e.size
        }), r = Ho(r)), r.length > 1 || r[0] > 1) throw new JW(r);
    return !!r[0]
}

function Vo(t, e = {}) {
    typeof e.size < "u" && Us(t, {
        size: e.size
    });
    const r = ln(t, e);
    return va(r, e)
}

function Kq(t, e = {}) {
    let r = t;
    return typeof e.size < "u" && (Us(r, {
        size: e.size
    }), r = Ho(r, {
        dir: "right"
    })), new TextDecoder().decode(r)
}

function as(t) {
    return typeof t[0] == "string" ? cl(t) : Yq(t)
}

function Yq(t) {
    let e = 0;
    for (const i of t) e += i.length;
    const r = new Uint8Array(e);
    let n = 0;
    for (const i of t) r.set(i, n), n += i.length;
    return r
}

function cl(t) {
    return `0x${t.reduce((e,r)=>e+r.replace("0x",""),"")}`
}
const Zq = /^(.*)\[([0-9]*)\]$/,
    hT = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
    Q4 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

function fc(t, e) {
    if (t.length !== e.length) throw new tT({
        expectedLength: t.length,
        givenLength: e.length
    });
    const r = Jq({
            params: t,
            values: e
        }),
        n = e6(r);
    return n.length === 0 ? "0x" : n
}

function Jq({
    params: t,
    values: e
}) {
    const r = [];
    for (let n = 0; n < t.length; n++) r.push(X4({
        param: t[n],
        value: e[n]
    }));
    return r
}

function X4({
    param: t,
    value: e
}) {
    const r = t6(t.type);
    if (r) {
        const [n, i] = r;
        return Xq(e, {
            length: n,
            param: { ...t,
                type: i
            }
        })
    }
    if (t.type === "tuple") return iH(e, {
        param: t
    });
    if (t.type === "address") return Qq(e);
    if (t.type === "bool") return tH(e);
    if (t.type.startsWith("uint") || t.type.startsWith("int")) {
        const n = t.type.startsWith("int"),
            [, , i = "256"] = Q4.exec(t.type) ? ? [];
        return rH(e, {
            signed: n,
            size: Number(i)
        })
    }
    if (t.type.startsWith("bytes")) return eH(e, {
        param: t
    });
    if (t.type === "string") return nH(e);
    throw new Rq(t.type, {
        docsPath: "/docs/contract/encodeAbiParameters"
    })
}

function e6(t) {
    let e = 0;
    for (let s = 0; s < t.length; s++) {
        const {
            dynamic: a,
            encoded: o
        } = t[s];
        a ? e += 32 : e += Rr(o)
    }
    const r = [],
        n = [];
    let i = 0;
    for (let s = 0; s < t.length; s++) {
        const {
            dynamic: a,
            encoded: o
        } = t[s];
        a ? (r.push(nt(e + i, {
            size: 32
        })), n.push(o), i += Rr(o)) : r.push(o)
    }
    return as([...r, ...n])
}

function Qq(t) {
    if (!gi(t)) throw new Jo({
        address: t
    });
    return {
        dynamic: !1,
        encoded: Qc(t.toLowerCase())
    }
}

function Xq(t, {
    length: e,
    param: r
}) {
    const n = e === null;
    if (!Array.isArray(t)) throw new aT(t);
    if (!n && t.length !== e) throw new Sq({
        expectedLength: e,
        givenLength: t.length,
        type: `${r.type}[${e}]`
    });
    let i = !1;
    const s = [];
    for (let a = 0; a < t.length; a++) {
        const o = X4({
            param: r,
            value: t[a]
        });
        o.dynamic && (i = !0), s.push(o)
    }
    if (n || i) {
        const a = e6(s);
        if (n) {
            const o = nt(s.length, {
                size: 32
            });
            return {
                dynamic: !0,
                encoded: s.length > 0 ? as([o, a]) : o
            }
        }
        if (i) return {
            dynamic: !0,
            encoded: a
        }
    }
    return {
        dynamic: !1,
        encoded: as(s.map(({
            encoded: a
        }) => a))
    }
}

function eH(t, {
    param: e
}) {
    const [, r] = e.type.split("bytes"), n = Rr(t);
    if (!r) {
        let i = t;
        return n % 32 !== 0 && (i = Qc(i, {
            dir: "right",
            size: Math.ceil((t.length - 2) / 2 / 32) * 32
        })), {
            dynamic: !0,
            encoded: as([Qc(nt(n, {
                size: 32
            })), i])
        }
    }
    if (n !== Number.parseInt(r)) throw new Tq({
        expectedSize: Number.parseInt(r),
        value: t
    });
    return {
        dynamic: !1,
        encoded: Qc(t, {
            dir: "right"
        })
    }
}

function tH(t) {
    if (typeof t != "boolean") throw new be(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);
    return {
        dynamic: !1,
        encoded: Qc(V4(t))
    }
}

function rH(t, {
    signed: e,
    size: r = 256
}) {
    if (typeof r == "number") {
        const n = 2 n ** (BigInt(r) - (e ? 1 n : 0 n)) - 1 n,
            i = e ? -n - 1 n : 0 n;
        if (t > n || t < i) throw new AS({
            max: n.toString(),
            min: i.toString(),
            signed: e,
            size: r / 8,
            value: t.toString()
        })
    }
    return {
        dynamic: !1,
        encoded: nt(t, {
            size: 32,
            signed: e
        })
    }
}

function nH(t) {
    const e = sd(t),
        r = Math.ceil(Rr(e) / 32),
        n = [];
    for (let i = 0; i < r; i++) n.push(Qc(Xu(e, i * 32, (i + 1) * 32), {
        dir: "right"
    }));
    return {
        dynamic: !0,
        encoded: as([Qc(nt(Rr(e), {
            size: 32
        })), ...n])
    }
}

function iH(t, {
    param: e
}) {
    let r = !1;
    const n = [];
    for (let i = 0; i < e.components.length; i++) {
        const s = e.components[i],
            a = Array.isArray(t) ? i : s.name,
            o = X4({
                param: s,
                value: t[a]
            });
        n.push(o), o.dynamic && (r = !0)
    }
    return {
        dynamic: r,
        encoded: r ? e6(n) : as(n.map(({
            encoded: i
        }) => i))
    }
}

function t6(t) {
    const e = t.match(/^(.*)\[(\d+)?\]$/);
    return e ? [e[2] ? Number(e[2]) : null, e[1]] : void 0
}

function hh(t, e) {
    const r = typeof e == "string" ? Ns(e) : e,
        n = J4(r);
    if (Rr(r) === 0 && t.length > 0) throw new Yp;
    if (Rr(e) && Rr(e) < 32) throw new eT({
        data: typeof e == "string" ? e : ln(e),
        params: t,
        size: Rr(e)
    });
    let i = 0;
    const s = [];
    for (let a = 0; a < t.length; ++a) {
        const o = t[a];
        n.setPosition(i);
        const [c, l] = Ru(n, o, {
            staticPosition: 0
        });
        i += l, s.push(c)
    }
    return s
}

function Ru(t, e, {
    staticPosition: r
}) {
    const n = t6(e.type);
    if (n) {
        const [i, s] = n;
        return aH(t, { ...e,
            type: s
        }, {
            length: i,
            staticPosition: r
        })
    }
    if (e.type === "tuple") return dH(t, e, {
        staticPosition: r
    });
    if (e.type === "address") return sH(t);
    if (e.type === "bool") return oH(t);
    if (e.type.startsWith("bytes")) return cH(t, e, {
        staticPosition: r
    });
    if (e.type.startsWith("uint") || e.type.startsWith("int")) return lH(t, e);
    if (e.type === "string") return uH(t, {
        staticPosition: r
    });
    throw new Mq(e.type, {
        docsPath: "/docs/contract/decodeAbiParameters"
    })
}
const uE = 32,
    Yv = 32;

function sH(t) {
    const e = t.readBytes(32);
    return [Jp(ln(lT(e, -20))), 32]
}

function aH(t, e, {
    length: r,
    staticPosition: n
}) {
    if (!r) {
        const a = Vo(t.readBytes(Yv)),
            o = n + a,
            c = o + uE;
        t.setPosition(o);
        const l = Vo(t.readBytes(uE)),
            u = wp(e);
        let h = 0;
        const f = [];
        for (let p = 0; p < l; ++p) {
            t.setPosition(c + (u ? p * 32 : h));
            const [g, m] = Ru(t, e, {
                staticPosition: c
            });
            h += m, f.push(g)
        }
        return t.setPosition(n + 32), [f, 32]
    }
    if (wp(e)) {
        const a = Vo(t.readBytes(Yv)),
            o = n + a,
            c = [];
        for (let l = 0; l < r; ++l) {
            t.setPosition(o + l * 32);
            const [u] = Ru(t, e, {
                staticPosition: o
            });
            c.push(u)
        }
        return t.setPosition(n + 32), [c, 32]
    }
    let i = 0;
    const s = [];
    for (let a = 0; a < r; ++a) {
        const [o, c] = Ru(t, e, {
            staticPosition: n + i
        });
        i += c, s.push(o)
    }
    return [s, i]
}

function oH(t) {
    return [Gq(t.readBytes(32), {
        size: 32
    }), 32]
}

function cH(t, e, {
    staticPosition: r
}) {
    const [n, i] = e.type.split("bytes");
    if (!i) {
        const a = Vo(t.readBytes(32));
        t.setPosition(r + a);
        const o = Vo(t.readBytes(32));
        if (o === 0) return t.setPosition(r + 32), ["0x", 32];
        const c = t.readBytes(o);
        return t.setPosition(r + 32), [ln(c), 32]
    }
    return [ln(t.readBytes(Number.parseInt(i), 32)), 32]
}

function lH(t, e) {
    const r = e.type.startsWith("int"),
        n = Number.parseInt(e.type.split("int")[1] || "256"),
        i = t.readBytes(32);
    return [n > 48 ? Vq(i, {
        signed: r
    }) : Vo(i, {
        signed: r
    }), 32]
}

function dH(t, e, {
    staticPosition: r
}) {
    const n = e.components.length === 0 || e.components.some(({
            name: a
        }) => !a),
        i = n ? [] : {};
    let s = 0;
    if (wp(e)) {
        const a = Vo(t.readBytes(Yv)),
            o = r + a;
        for (let c = 0; c < e.components.length; ++c) {
            const l = e.components[c];
            t.setPosition(o + s);
            const [u, h] = Ru(t, l, {
                staticPosition: o
            });
            s += h, i[n ? c : l == null ? void 0 : l.name] = u
        }
        return t.setPosition(r + 32), [i, 32]
    }
    for (let a = 0; a < e.components.length; ++a) {
        const o = e.components[a],
            [c, l] = Ru(t, o, {
                staticPosition: r
            });
        i[n ? a : o == null ? void 0 : o.name] = c, s += l
    }
    return [i, s]
}

function uH(t, {
    staticPosition: e
}) {
    const r = Vo(t.readBytes(32)),
        n = e + r;
    t.setPosition(n);
    const i = Vo(t.readBytes(32));
    if (i === 0) return t.setPosition(e + 32), ["", 32];
    const s = t.readBytes(i, 32),
        a = Kq(Ho(s));
    return t.setPosition(e + 32), [a, 32]
}

function wp(t) {
    var n;
    const {
        type: e
    } = t;
    if (e === "string" || e === "bytes" || e.endsWith("[]")) return !0;
    if (e === "tuple") return (n = t.components) == null ? void 0 : n.some(wp);
    const r = t6(t.type);
    return !!(r && wp({ ...t,
        type: r[1]
    }))
}

function fT(t) {
    const {
        abi: e,
        data: r
    } = t, n = Xu(r, 0, 4);
    if (n === "0x") throw new Yp;
    const s = [...e || [], XS, kq].find(a => a.type === "error" && n === Zp(xa(a)));
    if (!s) throw new rT(n, {
        docsPath: "/docs/contract/decodeErrorResult"
    });
    return {
        abiItem: s,
        args: "inputs" in s && s.inputs && s.inputs.length > 0 ? hh(s.inputs, Xu(r, 4)) : void 0,
        errorName: s.name
    }
}

function pT({
    abiItem: t,
    args: e,
    includeFunctionName: r = !0,
    includeName: n = !1
}) {
    if ("name" in t && "inputs" in t && t.inputs) return `${r?t.name:""}(${t.inputs.map((i,s)=>`${n&&i.name?`${i.name}: `:""}${typeof e[s]=="object"?zr(e[s]):e[s]}`).join(", ")})`
}
const A1 = dT;

function _d(t) {
    const {
        abi: e,
        args: r = [],
        name: n
    } = t, i = Jn(n, {
        strict: !1
    }), s = e.filter(o => i ? o.type === "function" ? Zp(o) === n : o.type === "event" ? A1(o) === n : !1 : "name" in o && o.name === n);
    if (s.length === 0) return;
    if (s.length === 1) return s[0];
    let a;
    for (const o of s) {
        if (!("inputs" in o)) continue;
        if (!r || r.length === 0) {
            if (!o.inputs || o.inputs.length === 0) return o;
            continue
        }
        if (!o.inputs || o.inputs.length === 0 || o.inputs.length !== r.length) continue;
        if (r.every((l, u) => {
                const h = "inputs" in o && o.inputs[u];
                return h ? Zv(l, h) : !1
            })) {
            if (a && "inputs" in a && a.inputs) {
                const l = gT(o.inputs, a.inputs, r);
                if (l) throw new jq({
                    abiItem: o,
                    type: l[0]
                }, {
                    abiItem: a,
                    type: l[1]
                })
            }
            a = o
        }
    }
    return a || s[0]
}

function Zv(t, e) {
    const r = typeof t,
        n = e.type;
    switch (n) {
        case "address":
            return gi(t, {
                strict: !1
            });
        case "bool":
            return r === "boolean";
        case "function":
            return r === "string";
        case "string":
            return r === "string";
        default:
            return n === "tuple" && "components" in e ? Object.values(e.components).every((i, s) => Zv(Object.values(t)[s], i)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(n) ? r === "number" || r === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(n) ? r === "string" || t instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(n) ? Array.isArray(t) && t.every(i => Zv(i, { ...e,
                type: n.replace(/(\[[0-9]{0,}\])$/, "")
            })) : !1
    }
}

function gT(t, e, r) {
    for (const n in t) {
        const i = t[n],
            s = e[n];
        if (i.type === "tuple" && s.type === "tuple" && "components" in i && "components" in s) return gT(i.components, s.components, r[n]);
        const a = [i.type, s.type];
        if (a.includes("address") && a.includes("bytes20") ? !0 : a.includes("address") && a.includes("string") ? gi(r[n], {
                strict: !1
            }) : a.includes("address") && a.includes("bytes") ? gi(r[n], {
                strict: !1
            }) : !1) return a
    }
}
const mT = {
        gwei: 9,
        wei: 18
    },
    hH = {
        ether: -9,
        wei: 9
    };

function Nn(t, e) {
    let r = t.toString();
    const n = r.startsWith("-");
    n && (r = r.slice(1)), r = r.padStart(e, "0");
    let [i, s] = [r.slice(0, r.length - e), r.slice(r.length - e)];
    return s = s.replace(/(0+)$/, ""), `${n?"-":""}${i||"0"}${s?`.${s}`:""}`
}

function Cd(t, e = "wei") {
    return Nn(t, mT[e])
}

function Di(t, e = "wei") {
    return Nn(t, hH[e])
}
class fH extends be {
    constructor({
        address: e
    }) {
        super(`State for account "${e}" is set multiple times.`, {
            name: "AccountStateConflictError"
        })
    }
}
class pH extends be {
    constructor() {
        super("state and stateDiff are set on the same account.", {
            name: "StateAssignmentConflictError"
        })
    }
}

function hE(t) {
    return t.reduce((e, {
        slot: r,
        value: n
    }) => `${e}        ${r}: ${n}
`, "")
}

function gH(t) {
    return t.reduce((e, {
        address: r,
        ...n
    }) => {
        let i = `${e}    ${r}:
`;
        return n.nonce && (i += `      nonce: ${n.nonce}
`), n.balance && (i += `      balance: ${n.balance}
`), n.code && (i += `      code: ${n.code}
`), n.state && (i += `      state:
`, i += hE(n.state)), n.stateDiff && (i += `      stateDiff:
`, i += hE(n.stateDiff)), i
    }, `  State Override:
`).slice(0, -1)
}

function Qp(t) {
    const e = Object.entries(t).map(([n, i]) => i === void 0 || i === !1 ? null : [n, i]).filter(Boolean),
        r = e.reduce((n, [i]) => Math.max(n, i.length), 0);
    return e.map(([n, i]) => `  ${`${n}:`.padEnd(r+1)}  ${i}`).join(`
`)
}
class mH extends be {
    constructor() {
        super(["Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.", "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."].join(`
`), {
            name: "FeeConflictError"
        })
    }
}
class yH extends be {
    constructor({
        transaction: e
    }) {
        super("Cannot infer a transaction type from provided transaction.", {
            metaMessages: ["Provided Transaction:", "{", Qp(e), "}", "", "To infer the type, either provide:", "- a `type` to the Transaction, or", "- an EIP-1559 Transaction with `maxFeePerGas`, or", "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or", "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or", "- an EIP-7702 Transaction with `authorizationList`, or", "- a Legacy Transaction with `gasPrice`"],
            name: "InvalidSerializableTransactionError"
        })
    }
}
class wH extends be {
    constructor(e, {
        account: r,
        docsPath: n,
        chain: i,
        data: s,
        gas: a,
        gasPrice: o,
        maxFeePerGas: c,
        maxPriorityFeePerGas: l,
        nonce: u,
        to: h,
        value: f
    }) {
        var g;
        const p = Qp({
            chain: i && `${i==null?void 0:i.name} (id: ${i==null?void 0:i.id})`,
            from: r == null ? void 0 : r.address,
            to: h,
            value: typeof f < "u" && `${Cd(f)} ${((g=i==null?void 0:i.nativeCurrency)==null?void 0:g.symbol)||"ETH"}`,
            data: s,
            gas: a,
            gasPrice: typeof o < "u" && `${Di(o)} gwei`,
            maxFeePerGas: typeof c < "u" && `${Di(c)} gwei`,
            maxPriorityFeePerGas: typeof l < "u" && `${Di(l)} gwei`,
            nonce: u
        });
        super(e.shortMessage, {
            cause: e,
            docsPath: n,
            metaMessages: [...e.metaMessages ? [...e.metaMessages, " "] : [], "Request Arguments:", p].filter(Boolean),
            name: "TransactionExecutionError"
        }), Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.cause = e
    }
}
class yT extends be {
    constructor({
        blockHash: e,
        blockNumber: r,
        blockTag: n,
        hash: i,
        index: s
    }) {
        let a = "Transaction";
        n && s !== void 0 && (a = `Transaction at block time "${n}" at index "${s}"`), e && s !== void 0 && (a = `Transaction at block hash "${e}" at index "${s}"`), r && s !== void 0 && (a = `Transaction at block number "${r}" at index "${s}"`), i && (a = `Transaction with hash "${i}"`), super(`${a} could not be found.`, {
            name: "TransactionNotFoundError"
        })
    }
}
class wT extends be {
    constructor({
        hash: e
    }) {
        super(`Transaction receipt with hash "${e}" could not be found. The Transaction may not be processed on a block yet.`, {
            name: "TransactionReceiptNotFoundError"
        })
    }
}
class bH extends be {
    constructor({
        hash: e
    }) {
        super(`Timed out while waiting for transaction with hash "${e}" to be confirmed.`, {
            name: "WaitForTransactionReceiptTimeoutError"
        })
    }
}
class bT extends be {
    constructor(e, {
        account: r,
        docsPath: n,
        chain: i,
        data: s,
        gas: a,
        gasPrice: o,
        maxFeePerGas: c,
        maxPriorityFeePerGas: l,
        nonce: u,
        to: h,
        value: f,
        stateOverride: p
    }) {
        var y;
        const g = r ? qr(r) : void 0;
        let m = Qp({
            from: g == null ? void 0 : g.address,
            to: h,
            value: typeof f < "u" && `${Cd(f)} ${((y=i==null?void 0:i.nativeCurrency)==null?void 0:y.symbol)||"ETH"}`,
            data: s,
            gas: a,
            gasPrice: typeof o < "u" && `${Di(o)} gwei`,
            maxFeePerGas: typeof c < "u" && `${Di(c)} gwei`,
            maxPriorityFeePerGas: typeof l < "u" && `${Di(l)} gwei`,
            nonce: u
        });
        p && (m += `
${gH(p)}`), super(e.shortMessage, {
            cause: e,
            docsPath: n,
            metaMessages: [...e.metaMessages ? [...e.metaMessages, " "] : [], "Raw Call Arguments:", m].filter(Boolean),
            name: "CallExecutionError"
        }), Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.cause = e
    }
}
class vH extends be {
    constructor(e, {
        abi: r,
        args: n,
        contractAddress: i,
        docsPath: s,
        functionName: a,
        sender: o
    }) {
        const c = _d({
                abi: r,
                args: n,
                name: a
            }),
            l = c ? pT({
                abiItem: c,
                args: n,
                includeFunctionName: !1,
                includeName: !1
            }) : void 0,
            u = c ? xa(c, {
                includeName: !0
            }) : void 0,
            h = Qp({
                address: i && KW(i),
                function: u,
                args: l && l !== "()" && `${[...Array((a==null?void 0:a.length)??0).keys()].map(()=>" ").join("")}${l}`,
                sender: o
            });
        super(e.shortMessage || `An unknown error occurred while executing the contract function "${a}".`, {
            cause: e,
            docsPath: s,
            metaMessages: [...e.metaMessages ? [...e.metaMessages, " "] : [], h && "Contract Call:", h].filter(Boolean),
            name: "ContractFunctionExecutionError"
        }), Object.defineProperty(this, "abi", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "args", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "contractAddress", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "formattedArgs", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "functionName", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "sender", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.abi = r, this.args = n, this.cause = e, this.contractAddress = i, this.functionName = a, this.sender = o
    }
}
class Jv extends be {
    constructor({
        abi: e,
        data: r,
        functionName: n,
        message: i
    }) {
        let s, a, o, c;
        if (r && r !== "0x") try {
            a = fT({
                abi: e,
                data: r
            });
            const {
                abiItem: u,
                errorName: h,
                args: f
            } = a;
            if (h === "Error") c = f[0];
            else if (h === "Panic") {
                const [p] = f;
                c = QS[p]
            } else {
                const p = u ? xa(u, {
                        includeName: !0
                    }) : void 0,
                    g = u && f ? pT({
                        abiItem: u,
                        args: f,
                        includeFunctionName: !1,
                        includeName: !1
                    }) : void 0;
                o = [p ? `Error: ${p}` : "", g && g !== "()" ? `       ${[...Array((h==null?void 0:h.length)??0).keys()].map(()=>" ").join("")}${g}` : ""]
            }
        } catch (u) {
            s = u
        } else i && (c = i);
        let l;
        s instanceof rT && (l = s.signature, o = [`Unable to decode signature "${l}" as it was not found on the provided ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${l}.`]), super(c && c !== "execution reverted" || l ? [`The contract function "${n}" reverted with the following ${l?"signature":"reason"}:`, c || l].join(`
`) : `The contract function "${n}" reverted.`, {
            cause: s,
            metaMessages: o,
            name: "ContractFunctionRevertedError"
        }), Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "raw", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "reason", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "signature", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.data = a, this.raw = r, this.reason = c, this.signature = l
    }
}
class xH extends be {
    constructor({
        functionName: e
    }) {
        super(`The contract function "${e}" returned no data ("0x").`, {
            metaMessages: ["This could be due to any of the following:", `  - The contract does not have the function "${e}",`, "  - The parameters passed to the contract function may be invalid, or", "  - The address is not a contract."],
            name: "ContractFunctionZeroDataError"
        })
    }
}
class EH extends be {
    constructor({
        factory: e
    }) {
        super(`Deployment for counterfactual contract call failed${e?` for factory "${e}".`:""}`, {
            metaMessages: ["Please ensure:", "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).", "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."],
            name: "CounterfactualDeploymentFailedError"
        })
    }
}
class k1 extends be {
    constructor({
        data: e,
        message: r
    }) {
        super(r || "", {
            name: "RawContractError"
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: 3
        }), Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.data = e
    }
}
const _w = "/docs/contract/decodeFunctionResult";

function Ad(t) {
    const {
        abi: e,
        args: r,
        functionName: n,
        data: i
    } = t;
    let s = e[0];
    if (n) {
        const o = _d({
            abi: e,
            args: r,
            name: n
        });
        if (!o) throw new Qu(n, {
            docsPath: _w
        });
        s = o
    }
    if (s.type !== "function") throw new Qu(void 0, {
        docsPath: _w
    });
    if (!s.outputs) throw new iT(s.name, {
        docsPath: _w
    });
    const a = hh(s.outputs, i);
    if (a && a.length > 1) return a;
    if (a && a.length === 1) return a[0]
}
const Cw = "/docs/contract/encodeDeployData";

function I1(t) {
    const {
        abi: e,
        args: r,
        bytecode: n
    } = t;
    if (!r || r.length === 0) return n;
    const i = e.find(a => "type" in a && a.type === "constructor");
    if (!i) throw new $q({
        docsPath: Cw
    });
    if (!("inputs" in i)) throw new oE({
        docsPath: Cw
    });
    if (!i.inputs || i.inputs.length === 0) throw new oE({
        docsPath: Cw
    });
    const s = fc(i.inputs, r);
    return cl([n, s])
}
const fE = "/docs/contract/encodeFunctionData";

function _H(t) {
    const {
        abi: e,
        args: r,
        functionName: n
    } = t;
    let i = e[0];
    if (n) {
        const s = _d({
            abi: e,
            args: r,
            name: n
        });
        if (!s) throw new Qu(n, {
            docsPath: fE
        });
        i = s
    }
    if (i.type !== "function") throw new Qu(void 0, {
        docsPath: fE
    });
    return {
        abi: [i],
        functionName: Zp(xa(i))
    }
}

function hs(t) {
    const {
        args: e
    } = t, {
        abi: r,
        functionName: n
    } = (() => {
        var o;
        return t.abi.length === 1 && ((o = t.functionName) != null && o.startsWith("0x")) ? t : _H(t)
    })(), i = r[0], s = n, a = "inputs" in i && i.inputs ? fc(i.inputs, e ? ? []) : void 0;
    return cl([s, a ? ? "0x"])
}

function fh({
    blockNumber: t,
    chain: e,
    contract: r
}) {
    var i;
    const n = (i = e == null ? void 0 : e.contracts) == null ? void 0 : i[r];
    if (!n) throw new Kv({
        chain: e,
        contract: {
            name: r
        }
    });
    if (t && n.blockCreated && n.blockCreated > t) throw new Kv({
        blockNumber: t,
        chain: e,
        contract: {
            name: r,
            blockCreated: n.blockCreated
        }
    });
    return n.address
}
class Ll extends be {
    constructor({
        cause: e,
        message: r
    } = {}) {
        var i;
        const n = (i = r == null ? void 0 : r.replace("execution reverted: ", "")) == null ? void 0 : i.replace("execution reverted", "");
        super(`Execution reverted ${n?`with reason: ${n}`:"for an unknown reason"}.`, {
            cause: e,
            name: "ExecutionRevertedError"
        })
    }
}
Object.defineProperty(Ll, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 3
});
Object.defineProperty(Ll, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /execution reverted/
});
class ym extends be {
    constructor({
        cause: e,
        maxFeePerGas: r
    } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${r?` = ${Di(r)} gwei`:""}) cannot be higher than the maximum allowed value (2^256-1).`, {
            cause: e,
            name: "FeeCapTooHighError"
        })
    }
}
Object.defineProperty(ym, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class Qv extends be {
    constructor({
        cause: e,
        maxFeePerGas: r
    } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${r?` = ${Di(r)}`:""} gwei) cannot be lower than the block base fee.`, {
            cause: e,
            name: "FeeCapTooLowError"
        })
    }
}
Object.defineProperty(Qv, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class Xv extends be {
    constructor({
        cause: e,
        nonce: r
    } = {}) {
        super(`Nonce provided for the transaction ${r?`(${r}) `:""}is higher than the next one expected.`, {
            cause: e,
            name: "NonceTooHighError"
        })
    }
}
Object.defineProperty(Xv, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /nonce too high/
});
class e3 extends be {
    constructor({
        cause: e,
        nonce: r
    } = {}) {
        super([`Nonce provided for the transaction ${r?`(${r}) `:""}is lower than the current nonce of the account.`, "Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join(`
`), {
            cause: e,
            name: "NonceTooLowError"
        })
    }
}
Object.defineProperty(e3, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /nonce too low|transaction already imported|already known/
});
class t3 extends be {
    constructor({
        cause: e,
        nonce: r
    } = {}) {
        super(`Nonce provided for the transaction ${r?`(${r}) `:""}exceeds the maximum allowed nonce.`, {
            cause: e,
            name: "NonceMaxValueError"
        })
    }
}
Object.defineProperty(t3, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /nonce has max value/
});
class r3 extends be {
    constructor({
        cause: e
    } = {}) {
        super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join(`
`), {
            cause: e,
            metaMessages: ["This error could arise when the account does not have enough funds to:", " - pay for the total gas fee,", " - pay for the value to send.", " ", "The cost of the transaction is calculated as `gas * gas fee + value`, where:", " - `gas` is the amount of gas needed for transaction to execute,", " - `gas fee` is the gas fee,", " - `value` is the amount of ether to send to the recipient."],
            name: "InsufficientFundsError"
        })
    }
}
Object.defineProperty(r3, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /insufficient funds|exceeds transaction sender account balance/
});
class n3 extends be {
    constructor({
        cause: e,
        gas: r
    } = {}) {
        super(`The amount of gas ${r?`(${r}) `:""}provided for the transaction exceeds the limit allowed for the block.`, {
            cause: e,
            name: "IntrinsicGasTooHighError"
        })
    }
}
Object.defineProperty(n3, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /intrinsic gas too high|gas limit reached/
});
class i3 extends be {
    constructor({
        cause: e,
        gas: r
    } = {}) {
        super(`The amount of gas ${r?`(${r}) `:""}provided for the transaction is too low.`, {
            cause: e,
            name: "IntrinsicGasTooLowError"
        })
    }
}
Object.defineProperty(i3, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /intrinsic gas too low/
});
class s3 extends be {
    constructor({
        cause: e
    }) {
        super("The transaction type is not supported for this chain.", {
            cause: e,
            name: "TransactionTypeNotSupportedError"
        })
    }
}
Object.defineProperty(s3, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /transaction type not valid/
});
class wm extends be {
    constructor({
        cause: e,
        maxPriorityFeePerGas: r,
        maxFeePerGas: n
    } = {}) {
        super([`The provided tip (\`maxPriorityFeePerGas\`${r?` = ${Di(r)} gwei`:""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n?` = ${Di(n)} gwei`:""}).`].join(`
`), {
            cause: e,
            name: "TipAboveFeeCapError"
        })
    }
}
Object.defineProperty(wm, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class Xp extends be {
    constructor({
        cause: e
    }) {
        super(`An error occurred while executing: ${e==null?void 0:e.shortMessage}`, {
            cause: e,
            name: "UnknownNodeError"
        })
    }
}

function $1(t, e) {
    const r = (t.details || "").toLowerCase(),
        n = t instanceof be ? t.walk(i => (i == null ? void 0 : i.code) === Ll.code) : t;
    return n instanceof be ? new Ll({
        cause: t,
        message: n.details
    }) : Ll.nodeMessage.test(r) ? new Ll({
        cause: t,
        message: t.details
    }) : ym.nodeMessage.test(r) ? new ym({
        cause: t,
        maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
    }) : Qv.nodeMessage.test(r) ? new Qv({
        cause: t,
        maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
    }) : Xv.nodeMessage.test(r) ? new Xv({
        cause: t,
        nonce: e == null ? void 0 : e.nonce
    }) : e3.nodeMessage.test(r) ? new e3({
        cause: t,
        nonce: e == null ? void 0 : e.nonce
    }) : t3.nodeMessage.test(r) ? new t3({
        cause: t,
        nonce: e == null ? void 0 : e.nonce
    }) : r3.nodeMessage.test(r) ? new r3({
        cause: t
    }) : n3.nodeMessage.test(r) ? new n3({
        cause: t,
        gas: e == null ? void 0 : e.gas
    }) : i3.nodeMessage.test(r) ? new i3({
        cause: t,
        gas: e == null ? void 0 : e.gas
    }) : s3.nodeMessage.test(r) ? new s3({
        cause: t
    }) : wm.nodeMessage.test(r) ? new wm({
        cause: t,
        maxFeePerGas: e == null ? void 0 : e.maxFeePerGas,
        maxPriorityFeePerGas: e == null ? void 0 : e.maxPriorityFeePerGas
    }) : new Xp({
        cause: t
    })
}

function vT(t, {
    docsPath: e,
    ...r
}) {
    const n = (() => {
        const i = $1(t, r);
        return i instanceof Xp ? t : i
    })();
    return new bT(n, {
        docsPath: e,
        ...r
    })
}

function S1(t, {
    format: e
}) {
    if (!e) return {};
    const r = {};

    function n(s) {
        const a = Object.keys(s);
        for (const o of a) o in t && (r[o] = t[o]), s[o] && typeof s[o] == "object" && !Array.isArray(s[o]) && n(s[o])
    }
    const i = e(t || {});
    return n(i), r
}
const CH = {
    legacy: "0x0",
    eip2930: "0x1",
    eip1559: "0x2",
    eip4844: "0x3",
    eip7702: "0x4"
};

function ph(t) {
    const e = {};
    return typeof t.authorizationList < "u" && (e.authorizationList = AH(t.authorizationList)), typeof t.accessList < "u" && (e.accessList = t.accessList), typeof t.blobVersionedHashes < "u" && (e.blobVersionedHashes = t.blobVersionedHashes), typeof t.blobs < "u" && (typeof t.blobs[0] != "string" ? e.blobs = t.blobs.map(r => ln(r)) : e.blobs = t.blobs), typeof t.data < "u" && (e.data = t.data), typeof t.from < "u" && (e.from = t.from), typeof t.gas < "u" && (e.gas = nt(t.gas)), typeof t.gasPrice < "u" && (e.gasPrice = nt(t.gasPrice)), typeof t.maxFeePerBlobGas < "u" && (e.maxFeePerBlobGas = nt(t.maxFeePerBlobGas)), typeof t.maxFeePerGas < "u" && (e.maxFeePerGas = nt(t.maxFeePerGas)), typeof t.maxPriorityFeePerGas < "u" && (e.maxPriorityFeePerGas = nt(t.maxPriorityFeePerGas)), typeof t.nonce < "u" && (e.nonce = nt(t.nonce)), typeof t.to < "u" && (e.to = t.to), typeof t.type < "u" && (e.type = CH[t.type]), typeof t.value < "u" && (e.value = nt(t.value)), e
}

function AH(t) {
    return t.map(e => ({
        address: e.address,
        r: e.r ? nt(BigInt(e.r)) : e.r,
        s: e.s ? nt(BigInt(e.s)) : e.s,
        chainId: nt(e.chainId),
        nonce: nt(e.nonce),
        ...typeof e.yParity < "u" ? {
            yParity: nt(e.yParity)
        } : {},
        ...typeof e.v < "u" && typeof e.yParity > "u" ? {
            v: nt(e.v)
        } : {}
    }))
}

function r6() {
    let t = () => {},
        e = () => {};
    return {
        promise: new Promise((n, i) => {
            t = n, e = i
        }),
        resolve: t,
        reject: e
    }
}
const Aw = new Map;

function xT({
    fn: t,
    id: e,
    shouldSplitBatch: r,
    wait: n = 0,
    sort: i
}) {
    const s = async () => {
            const u = c();
            a();
            const h = u.map(({
                args: f
            }) => f);
            h.length !== 0 && t(h).then(f => {
                i && Array.isArray(f) && f.sort(i);
                for (let p = 0; p < u.length; p++) {
                    const {
                        resolve: g
                    } = u[p];
                    g == null || g([f[p], f])
                }
            }).catch(f => {
                for (let p = 0; p < u.length; p++) {
                    const {
                        reject: g
                    } = u[p];
                    g == null || g(f)
                }
            })
        },
        a = () => Aw.delete(e),
        o = () => c().map(({
            args: u
        }) => u),
        c = () => Aw.get(e) || [],
        l = u => Aw.set(e, [...c(), u]);
    return {
        flush: a,
        async schedule(u) {
            const {
                promise: h,
                resolve: f,
                reject: p
            } = r6();
            return (r == null ? void 0 : r([...o(), u])) && s(), c().length > 0 ? (l({
                args: u,
                resolve: f,
                reject: p
            }), h) : (l({
                args: u,
                resolve: f,
                reject: p
            }), setTimeout(s, n), h)
        }
    }
}

function pE(t) {
    if (!(!t || t.length === 0)) return t.reduce((e, {
        slot: r,
        value: n
    }) => {
        if (r.length !== 66) throw new Z8({
            size: r.length,
            targetSize: 66,
            type: "hex"
        });
        if (n.length !== 66) throw new Z8({
            size: n.length,
            targetSize: 66,
            type: "hex"
        });
        return e[r] = n, e
    }, {})
}

function kH(t) {
    const {
        balance: e,
        nonce: r,
        state: n,
        stateDiff: i,
        code: s
    } = t, a = {};
    if (s !== void 0 && (a.code = s), e !== void 0 && (a.balance = nt(e)), r !== void 0 && (a.nonce = nt(r)), n !== void 0 && (a.state = pE(n)), i !== void 0) {
        if (a.state) throw new pH;
        a.stateDiff = pE(i)
    }
    return a
}

function n6(t) {
    if (!t) return;
    const e = {};
    for (const {
            address: r,
            ...n
        } of t) {
        if (!gi(r, {
                strict: !1
            })) throw new Jo({
            address: r
        });
        if (e[r]) throw new fH({
            address: r
        });
        e[r] = kH(n)
    }
    return e
}
const IH = 2 n ** 256 n - 1 n;

function kd(t) {
    const {
        account: e,
        gasPrice: r,
        maxFeePerGas: n,
        maxPriorityFeePerGas: i,
        to: s
    } = t, a = e ? qr(e) : void 0;
    if (a && !gi(a.address)) throw new Jo({
        address: a.address
    });
    if (s && !gi(s)) throw new Jo({
        address: s
    });
    if (typeof r < "u" && (typeof n < "u" || typeof i < "u")) throw new mH;
    if (n && n > IH) throw new ym({
        maxFeePerGas: n
    });
    if (i && n && i > n) throw new wm({
        maxFeePerGas: n,
        maxPriorityFeePerGas: i
    })
}
async function e0(t, e) {
    var R, D, S, O;
    const {
        account: r = t.account,
        authorizationList: n,
        batch: i = !!((R = t.batch) != null && R.multicall),
        blockNumber: s,
        blockTag: a = t.experimental_blockTag ? ? "latest",
        accessList: o,
        blobs: c,
        blockOverrides: l,
        code: u,
        data: h,
        factory: f,
        factoryData: p,
        gas: g,
        gasPrice: m,
        maxFeePerBlobGas: y,
        maxFeePerGas: w,
        maxPriorityFeePerGas: x,
        nonce: E,
        to: _,
        value: b,
        stateOverride: A,
        ...I
    } = e, T = r ? qr(r) : void 0;
    if (u && (f || p)) throw new be("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
    if (u && _) throw new be("Cannot provide both `code` & `to` as parameters.");
    const C = u && h,
        $ = f && p && _ && h,
        P = C || $,
        N = C ? TH({
            code: u,
            data: h
        }) : $ ? PH({
            data: h,
            factory: f,
            factoryData: p,
            to: _
        }) : h;
    try {
        kd(e);
        const U = (typeof s == "bigint" ? nt(s) : void 0) || a,
            k = l ? GS(l) : void 0,
            F = n6(A),
            q = (O = (S = (D = t.chain) == null ? void 0 : D.formatters) == null ? void 0 : S.transactionRequest) == null ? void 0 : O.format,
            K = (q || ph)({ ...S1(I, {
                    format: q
                }),
                from: T == null ? void 0 : T.address,
                accessList: o,
                authorizationList: n,
                blobs: c,
                data: N,
                gas: g,
                gasPrice: m,
                maxFeePerBlobGas: y,
                maxFeePerGas: w,
                maxPriorityFeePerGas: x,
                nonce: E,
                to: P ? void 0 : _,
                value: b
            });
        if (i && $H({
                request: K
            }) && !F && !k) try {
            return await SH(t, { ...K,
                blockNumber: s,
                blockTag: a
            })
        } catch (V) {
            if (!(V instanceof JS) && !(V instanceof Kv)) throw V
        }
        const H = (() => {
                const V = [K, U];
                return F && k ? [...V, F, k] : F ? [...V, F] : k ? [...V, {}, k] : V
            })(),
            j = await t.request({
                method: "eth_call",
                params: H
            });
        return j === "0x" ? {
            data: void 0
        } : {
            data: j
        }
    } catch (M) {
        const U = NH(M),
            {
                offchainLookup: k,
                offchainLookupSignature: F
            } = await ma(async () => {
                const {
                    offchainLookup: q,
                    offchainLookupSignature: W
                } = await Promise.resolve().then(() => FH);
                return {
                    offchainLookup: q,
                    offchainLookupSignature: W
                }
            }, void 0);
        if (t.ccipRead !== !1 && (U == null ? void 0 : U.slice(0, 10)) === F && _) return {
            data: await k(t, {
                data: U,
                to: _
            })
        };
        throw P && (U == null ? void 0 : U.slice(0, 10)) === "0x101bb98d" ? new EH({
            factory: f
        }) : vT(M, { ...e,
            account: T,
            chain: t.chain
        })
    }
}

function $H({
    request: t
}) {
    const {
        data: e,
        to: r,
        ...n
    } = t;
    return !(!e || e.startsWith(xq) || !r || Object.values(n).filter(i => typeof i < "u").length > 0)
}
async function SH(t, e) {
    var m;
    const {
        batchSize: r = 1024,
        wait: n = 0
    } = typeof((m = t.batch) == null ? void 0 : m.multicall) == "object" ? t.batch.multicall: {}, {
        blockNumber: i,
        blockTag: s = t.experimental_blockTag ? ? "latest",
        data: a,
        multicallAddress: o,
        to: c
    } = e;
    let l = o;
    if (!l) {
        if (!t.chain) throw new JS;
        l = fh({
            blockNumber: i,
            chain: t.chain,
            contract: "multicall3"
        })
    }
    const h = (typeof i == "bigint" ? nt(i) : void 0) || s,
        {
            schedule: f
        } = xT({
            id: `${t.uid}.${h}`,
            wait: n,
            shouldSplitBatch(y) {
                return y.reduce((x, {
                    data: E
                }) => x + (E.length - 2), 0) > r * 2
            },
            fn: async y => {
                const w = y.map(_ => ({
                        allowFailure: !0,
                        callData: _.data,
                        target: _.to
                    })),
                    x = hs({
                        abi: Vv,
                        args: [w],
                        functionName: "aggregate3"
                    }),
                    E = await t.request({
                        method: "eth_call",
                        params: [{
                            data: x,
                            to: l
                        }, h]
                    });
                return Ad({
                    abi: Vv,
                    args: [w],
                    functionName: "aggregate3",
                    data: E || "0x"
                })
            }
        }),
        [{
            returnData: p,
            success: g
        }] = await f({
            data: a,
            to: c
        });
    if (!g) throw new k1({
        data: p
    });
    return p === "0x" ? {
        data: void 0
    } : {
        data: p
    }
}

function TH(t) {
    const {
        code: e,
        data: r
    } = t;
    return I1({
        abi: FS(["constructor(bytes, bytes)"]),
        bytecode: ZS,
        args: [e, r]
    })
}

function PH(t) {
    const {
        data: e,
        factory: r,
        factoryData: n,
        to: i
    } = t;
    return I1({
        abi: FS(["constructor(address, bytes, address, bytes)"]),
        bytecode: Eq,
        args: [i, e, r, n]
    })
}

function NH(t) {
    var r;
    if (!(t instanceof be)) return;
    const e = t.walk();
    return typeof(e == null ? void 0 : e.data) == "object" ? (r = e.data) == null ? void 0 : r.data : e.data
}
class OH extends be {
    constructor({
        callbackSelector: e,
        cause: r,
        data: n,
        extraData: i,
        sender: s,
        urls: a
    }) {
        var o;
        super(r.shortMessage || "An error occurred while fetching for an offchain result.", {
            cause: r,
            metaMessages: [...r.metaMessages || [], (o = r.metaMessages) != null && o.length ? "" : [], "Offchain Gateway Call:", a && ["  Gateway URL(s):", ...a.map(c => `    ${Gp(c)}`)], `  Sender: ${s}`, `  Data: ${n}`, `  Callback selector: ${e}`, `  Extra data: ${i}`].flat(),
            name: "OffchainLookupError"
        })
    }
}
class jH extends be {
    constructor({
        result: e,
        url: r
    }) {
        super("Offchain gateway response is malformed. Response data must be a hex value.", {
            metaMessages: [`Gateway URL: ${Gp(r)}`, `Response: ${zr(e)}`],
            name: "OffchainLookupResponseMalformedError"
        })
    }
}
class RH extends be {
    constructor({
        sender: e,
        to: r
    }) {
        super("Reverted sender address does not match target contract address (`to`).", {
            metaMessages: [`Contract address: ${r}`, `OffchainLookup sender address: ${e}`],
            name: "OffchainLookupSenderMismatchError"
        })
    }
}

function t0(t, e) {
    if (!gi(t, {
            strict: !1
        })) throw new Jo({
        address: t
    });
    if (!gi(e, {
            strict: !1
        })) throw new Jo({
        address: e
    });
    return t.toLowerCase() === e.toLowerCase()
}

function ET(t) {
    const {
        abi: e,
        data: r
    } = t, n = Xu(r, 0, 4), i = e.find(s => s.type === "function" && n === Zp(xa(s)));
    if (!i) throw new Oq(n, {
        docsPath: "/docs/contract/decodeFunctionData"
    });
    return {
        functionName: i.name,
        args: "inputs" in i && i.inputs && i.inputs.length > 0 ? hh(i.inputs, Xu(r, 4)) : void 0
    }
}
const kw = "/docs/contract/encodeErrorResult";

function gE(t) {
    const {
        abi: e,
        errorName: r,
        args: n
    } = t;
    let i = e[0];
    if (r) {
        const c = _d({
            abi: e,
            args: n,
            name: r
        });
        if (!c) throw new cE(r, {
            docsPath: kw
        });
        i = c
    }
    if (i.type !== "error") throw new cE(void 0, {
        docsPath: kw
    });
    const s = xa(i),
        a = Zp(s);
    let o = "0x";
    if (n && n.length > 0) {
        if (!i.inputs) throw new Pq(i.name, {
            docsPath: kw
        });
        o = fc(i.inputs, n)
    }
    return cl([a, o])
}
const Iw = "/docs/contract/encodeFunctionResult";

function MH(t) {
    const {
        abi: e,
        functionName: r,
        result: n
    } = t;
    let i = e[0];
    if (r) {
        const a = _d({
            abi: e,
            name: r
        });
        if (!a) throw new Qu(r, {
            docsPath: Iw
        });
        i = a
    }
    if (i.type !== "function") throw new Qu(void 0, {
        docsPath: Iw
    });
    if (!i.outputs) throw new iT(i.name, {
        docsPath: Iw
    });
    const s = (() => {
        if (i.outputs.length === 0) return [];
        if (i.outputs.length === 1) return [n];
        if (Array.isArray(n)) return n;
        throw new aT(n)
    })();
    return fc(i.outputs, s)
}
const T1 = "x-batch-gateway:true";
async function _T(t) {
    const {
        data: e,
        ccipRequest: r
    } = t, {
        args: [n]
    } = ET({
        abi: Gv,
        data: e
    }), i = [], s = [];
    return await Promise.all(n.map(async (a, o) => {
        try {
            s[o] = a.urls.includes(T1) ? await _T({
                data: a.data,
                ccipRequest: r
            }) : await r(a), i[o] = !1
        } catch (c) {
            i[o] = !0, s[o] = DH(c)
        }
    })), MH({
        abi: Gv,
        functionName: "query",
        result: [i, s]
    })
}

function DH(t) {
    return t.name === "HttpRequestError" && t.status ? gE({
        abi: Gv,
        errorName: "HttpError",
        args: [t.status, t.shortMessage]
    }) : gE({
        abi: [XS],
        errorName: "Error",
        args: ["shortMessage" in t ? t.shortMessage : t.message]
    })
}
const LH = "0x556f1830",
    CT = {
        name: "OffchainLookup",
        type: "error",
        inputs: [{
            name: "sender",
            type: "address"
        }, {
            name: "urls",
            type: "string[]"
        }, {
            name: "callData",
            type: "bytes"
        }, {
            name: "callbackFunction",
            type: "bytes4"
        }, {
            name: "extraData",
            type: "bytes"
        }]
    };
async function UH(t, {
    blockNumber: e,
    blockTag: r,
    data: n,
    to: i
}) {
    const {
        args: s
    } = fT({
        data: n,
        abi: [CT]
    }), [a, o, c, l, u] = s, {
        ccipRead: h
    } = t, f = h && typeof(h == null ? void 0 : h.request) == "function" ? h.request : AT;
    try {
        if (!t0(i, a)) throw new RH({
            sender: a,
            to: i
        });
        const p = o.includes(T1) ? await _T({
                data: c,
                ccipRequest: f
            }) : await f({
                data: c,
                sender: a,
                urls: o
            }),
            {
                data: g
            } = await e0(t, {
                blockNumber: e,
                blockTag: r,
                data: as([l, fc([{
                    type: "bytes"
                }, {
                    type: "bytes"
                }], [p, u])]),
                to: i
            });
        return g
    } catch (p) {
        throw new OH({
            callbackSelector: l,
            cause: p,
            data: n,
            extraData: u,
            sender: a,
            urls: o
        })
    }
}
async function AT({
    data: t,
    sender: e,
    urls: r
}) {
    var i;
    let n = new Error("An unknown error occurred.");
    for (let s = 0; s < r.length; s++) {
        const a = r[s],
            o = a.includes("{data}") ? "GET" : "POST",
            c = o === "POST" ? {
                data: t,
                sender: e
            } : void 0,
            l = o === "POST" ? {
                "Content-Type": "application/json"
            } : {};
        try {
            const u = await fetch(a.replace("{sender}", e.toLowerCase()).replace("{data}", t), {
                body: JSON.stringify(c),
                headers: l,
                method: o
            });
            let h;
            if ((i = u.headers.get("Content-Type")) != null && i.startsWith("application/json") ? h = (await u.json()).data : h = await u.text(), !u.ok) {
                n = new Kl({
                    body: c,
                    details: h != null && h.error ? zr(h.error) : u.statusText,
                    headers: u.headers,
                    status: u.status,
                    url: a
                });
                continue
            }
            if (!Jn(h)) {
                n = new jH({
                    result: h,
                    url: a
                });
                continue
            }
            return h
        } catch (u) {
            n = new Kl({
                body: c,
                details: u.message,
                url: a
            })
        }
    }
    throw n
}
const FH = Object.freeze(Object.defineProperty({
    __proto__: null,
    ccipRequest: AT,
    offchainLookup: UH,
    offchainLookupAbiItem: CT,
    offchainLookupSignature: LH
}, Symbol.toStringTag, {
    value: "Module"
}));

function kT({
    chain: t,
    currentChainId: e
}) {
    if (!t) throw new Aq;
    if (e !== t.id) throw new Cq({
        chain: t,
        currentChainId: e
    })
}

function eNe(t) {
    return {
        formatters: void 0,
        fees: void 0,
        serializers: void 0,
        ...t
    }
}

function BH(t, {
    errorInstance: e = new Error("timed out"),
    timeout: r,
    signal: n
}) {
    return new Promise((i, s) => {
        (async () => {
            let a;
            try {
                const o = new AbortController;
                r > 0 && (a = setTimeout(() => {
                    n && o.abort()
                }, r)), i(await t({
                    signal: (o == null ? void 0 : o.signal) || null
                }))
            } catch (o) {
                (o == null ? void 0 : o.name) === "AbortError" && s(e), s(o)
            } finally {
                clearTimeout(a)
            }
        })()
    })
}

function WH() {
    return {
        current: 0,
        take() {
            return this.current++
        },
        reset() {
            this.current = 0
        }
    }
}
const mE = WH();

function zH(t, e = {}) {
    return {
        async request(r) {
            var h;
            const {
                body: n,
                onRequest: i = e.onRequest,
                onResponse: s = e.onResponse,
                timeout: a = e.timeout ? ? 1e4
            } = r, o = { ...e.fetchOptions ? ? {},
                ...r.fetchOptions ? ? {}
            }, {
                headers: c,
                method: l,
                signal: u
            } = o;
            try {
                const f = await BH(async ({
                    signal: g
                }) => {
                    const m = { ...o,
                            body: Array.isArray(n) ? zr(n.map(E => ({
                                jsonrpc: "2.0",
                                id: E.id ? ? mE.take(),
                                ...E
                            }))) : zr({
                                jsonrpc: "2.0",
                                id: n.id ? ? mE.take(),
                                ...n
                            }),
                            headers: {
                                "Content-Type": "application/json",
                                ...c
                            },
                            method: l || "POST",
                            signal: u || (a > 0 ? g : null)
                        },
                        y = new Request(t, m),
                        w = await (i == null ? void 0 : i(y, m)) ? ? { ...m,
                            url: t
                        };
                    return await fetch(w.url ? ? t, w)
                }, {
                    errorInstance: new Y8({
                        body: n,
                        url: t
                    }),
                    timeout: a,
                    signal: !0
                });
                s && await s(f);
                let p;
                if ((h = f.headers.get("Content-Type")) != null && h.startsWith("application/json")) p = await f.json();
                else {
                    p = await f.text();
                    try {
                        p = JSON.parse(p || "{}")
                    } catch (g) {
                        if (f.ok) throw g;
                        p = {
                            error: p
                        }
                    }
                }
                if (!f.ok) throw new Kl({
                    body: n,
                    details: zr(p.error) || f.statusText,
                    headers: f.headers,
                    status: f.status,
                    url: t
                });
                return p
            } catch (f) {
                throw f instanceof Kl || f instanceof Y8 ? f : new Kl({
                    body: n,
                    cause: f,
                    url: t
                })
            }
        }
    }
}
class qH extends be {
    constructor({
        domain: e
    }) {
        super(`Invalid domain "${zr(e)}".`, {
            metaMessages: ["Must be a valid EIP-712 domain."]
        })
    }
}
class HH extends be {
    constructor({
        primaryType: e,
        types: r
    }) {
        super(`Invalid primary type \`${e}\` must be one of \`${JSON.stringify(Object.keys(r))}\`.`, {
            docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
            metaMessages: ["Check that the primary type is a key in `types`."]
        })
    }
}
class VH extends be {
    constructor({
        type: e
    }) {
        super(`Struct type "${e}" is invalid.`, {
            metaMessages: ["Struct type must not be a Solidity type."],
            name: "InvalidStructTypeError"
        })
    }
}

function GH(t) {
    const {
        domain: e = {},
        message: r,
        primaryType: n
    } = t, i = {
        EIP712Domain: NT({
            domain: e
        }),
        ...t.types
    };
    PT({
        domain: e,
        message: r,
        primaryType: n,
        types: i
    });
    const s = ["0x1901"];
    return e && s.push(KH({
        domain: e,
        types: i
    })), n !== "EIP712Domain" && s.push(IT({
        data: r,
        primaryType: n,
        types: i
    })), Pn(as(s))
}

function KH({
    domain: t,
    types: e
}) {
    return IT({
        data: t,
        primaryType: "EIP712Domain",
        types: e
    })
}

function IT({
    data: t,
    primaryType: e,
    types: r
}) {
    const n = $T({
        data: t,
        primaryType: e,
        types: r
    });
    return Pn(n)
}

function $T({
    data: t,
    primaryType: e,
    types: r
}) {
    const n = [{
            type: "bytes32"
        }],
        i = [YH({
            primaryType: e,
            types: r
        })];
    for (const s of r[e]) {
        const [a, o] = TT({
            types: r,
            name: s.name,
            type: s.type,
            value: t[s.name]
        });
        n.push(a), i.push(o)
    }
    return fc(n, i)
}

function YH({
    primaryType: t,
    types: e
}) {
    const r = cn(ZH({
        primaryType: t,
        types: e
    }));
    return Pn(r)
}

function ZH({
    primaryType: t,
    types: e
}) {
    let r = "";
    const n = ST({
        primaryType: t,
        types: e
    });
    n.delete(t);
    const i = [t, ...Array.from(n).sort()];
    for (const s of i) r += `${s}(${e[s].map(({name:a,type:o})=>`
    $ {
        o
    }
    $ {
        a
    }
    `).join(",")})`;
    return r
}

function ST({
    primaryType: t,
    types: e
}, r = new Set) {
    const n = t.match(/^\w*/u),
        i = n == null ? void 0 : n[0];
    if (r.has(i) || e[i] === void 0) return r;
    r.add(i);
    for (const s of e[i]) ST({
        primaryType: s.type,
        types: e
    }, r);
    return r
}

function TT({
    types: t,
    name: e,
    type: r,
    value: n
}) {
    if (t[r] !== void 0) return [{
        type: "bytes32"
    }, Pn($T({
        data: n,
        primaryType: r,
        types: t
    }))];
    if (r === "bytes") return n = `0x${(n.length%2?"0":"")+n.slice(2)}`, [{
        type: "bytes32"
    }, Pn(n)];
    if (r === "string") return [{
        type: "bytes32"
    }, Pn(cn(n))];
    if (r.lastIndexOf("]") === r.length - 1) {
        const i = r.slice(0, r.lastIndexOf("[")),
            s = n.map(a => TT({
                name: e,
                type: i,
                types: t,
                value: a
            }));
        return [{
            type: "bytes32"
        }, Pn(fc(s.map(([a]) => a), s.map(([, a]) => a)))]
    }
    return [{
        type: r
    }, n]
}

function JH(t) {
    const {
        domain: e,
        message: r,
        primaryType: n,
        types: i
    } = t, s = (c, l) => {
        const u = { ...l
        };
        for (const h of c) {
            const {
                name: f,
                type: p
            } = h;
            p === "address" && (u[f] = u[f].toLowerCase())
        }
        return u
    }, a = i.EIP712Domain ? e ? s(i.EIP712Domain, e) : {} : {}, o = (() => {
        if (n !== "EIP712Domain") return s(i[n], r)
    })();
    return zr({
        domain: a,
        message: o,
        primaryType: n,
        types: i
    })
}

function PT(t) {
    const {
        domain: e,
        message: r,
        primaryType: n,
        types: i
    } = t, s = (a, o) => {
        for (const c of a) {
            const {
                name: l,
                type: u
            } = c, h = o[l], f = u.match(Q4);
            if (f && (typeof h == "number" || typeof h == "bigint")) {
                const [m, y, w] = f;
                nt(h, {
                    signed: y === "int",
                    size: Number.parseInt(w) / 8
                })
            }
            if (u === "address" && typeof h == "string" && !gi(h)) throw new Jo({
                address: h
            });
            const p = u.match(hT);
            if (p) {
                const [m, y] = p;
                if (y && Rr(h) !== Number.parseInt(y)) throw new sT({
                    expectedSize: Number.parseInt(y),
                    givenSize: Rr(h)
                })
            }
            const g = i[u];
            g && (QH(u), s(g, h))
        }
    };
    if (i.EIP712Domain && e) {
        if (typeof e != "object") throw new qH({
            domain: e
        });
        s(i.EIP712Domain, e)
    }
    if (n !== "EIP712Domain")
        if (i[n]) s(i[n], r);
        else throw new HH({
            primaryType: n,
            types: i
        })
}

function NT({
    domain: t
}) {
    return [typeof(t == null ? void 0 : t.name) == "string" && {
        name: "name",
        type: "string"
    }, (t == null ? void 0 : t.version) && {
        name: "version",
        type: "string"
    }, (typeof(t == null ? void 0 : t.chainId) == "number" || typeof(t == null ? void 0 : t.chainId) == "bigint") && {
        name: "chainId",
        type: "uint256"
    }, (t == null ? void 0 : t.verifyingContract) && {
        name: "verifyingContract",
        type: "address"
    }, (t == null ? void 0 : t.salt) && {
        name: "salt",
        type: "bytes32"
    }].filter(Boolean)
}

function QH(t) {
    if (t === "address" || t === "bool" || t === "string" || t.startsWith("bytes") || t.startsWith("uint") || t.startsWith("int")) throw new VH({
        type: t
    })
}
const yE = "/docs/contract/decodeEventLog";

function i6(t) {
    const {
        abi: e,
        data: r,
        strict: n,
        topics: i
    } = t, s = n ? ? !0, [a, ...o] = i;
    if (!a) throw new Nq({
        docsPath: yE
    });
    const c = e.find(m => m.type === "event" && a === A1(xa(m)));
    if (!(c && "name" in c) || c.type !== "event") throw new nT(a, {
        docsPath: yE
    });
    const {
        name: l,
        inputs: u
    } = c, h = u == null ? void 0 : u.some(m => !("name" in m && m.name)), f = h ? [] : {}, p = u.map((m, y) => [m, y]).filter(([m]) => "indexed" in m && m.indexed);
    for (let m = 0; m < p.length; m++) {
        const [y, w] = p[m], x = o[m];
        if (!x) throw new C1({
            abiItem: c,
            param: y
        });
        f[h ? w : y.name || w] = XH({
            param: y,
            value: x
        })
    }
    const g = u.filter(m => !("indexed" in m && m.indexed));
    if (g.length > 0) {
        if (r && r !== "0x") try {
            const m = hh(g, r);
            if (m)
                if (h)
                    for (let y = 0; y < u.length; y++) f[y] = f[y] ? ? m.shift();
                else
                    for (let y = 0; y < g.length; y++) f[g[y].name] = m[y]
        } catch (m) {
            if (s) throw m instanceof eT || m instanceof uT ? new yp({
                abiItem: c,
                data: r,
                params: g,
                size: Rr(r)
            }) : m
        } else if (s) throw new yp({
            abiItem: c,
            data: "0x",
            params: g,
            size: 0
        })
    }
    return {
        eventName: l,
        args: Object.values(f).length > 0 ? f : void 0
    }
}

function XH({
    param: t,
    value: e
}) {
    return t.type === "string" || t.type === "bytes" || t.type === "tuple" || t.type.match(/^(.*)\[(\d+)?\]$/) ? e : (hh([t], e) || [])[0]
}
class eV extends be {
    constructor(e) {
        super(`Filter type "${e}" is not supported.`, {
            name: "FilterTypeNotSupportedError"
        })
    }
}
const wE = "/docs/contract/encodeEventTopics";

function r0(t) {
    var c;
    const {
        abi: e,
        eventName: r,
        args: n
    } = t;
    let i = e[0];
    if (r) {
        const l = _d({
            abi: e,
            name: r
        });
        if (!l) throw new lE(r, {
            docsPath: wE
        });
        i = l
    }
    if (i.type !== "event") throw new lE(void 0, {
        docsPath: wE
    });
    const s = xa(i),
        a = A1(s);
    let o = [];
    if (n && "inputs" in i) {
        const l = (c = i.inputs) == null ? void 0 : c.filter(h => "indexed" in h && h.indexed),
            u = Array.isArray(n) ? n : Object.values(n).length > 0 ? (l == null ? void 0 : l.map(h => n[h.name])) ? ? [] : [];
        u.length > 0 && (o = (l == null ? void 0 : l.map((h, f) => Array.isArray(u[f]) ? u[f].map((p, g) => bE({
            param: h,
            value: u[f][g]
        })) : typeof u[f] < "u" && u[f] !== null ? bE({
            param: h,
            value: u[f]
        }) : null)) ? ? [])
    }
    return [a, ...o]
}

function bE({
    param: t,
    value: e
}) {
    if (t.type === "string" || t.type === "bytes") return Pn(dh(e));
    if (t.type === "tuple" || t.type.match(/^(.*)\[(\d+)?\]$/)) throw new eV(t.type);
    return fc([t], [e])
}

function s6(t) {
    const {
        abi: e,
        args: r,
        logs: n,
        strict: i = !0
    } = t, s = (() => {
        if (t.eventName) return Array.isArray(t.eventName) ? t.eventName : [t.eventName]
    })();
    return n.map(a => {
        var o;
        try {
            const c = e.find(u => u.type === "event" && a.topics[0] === A1(u));
            if (!c) return null;
            const l = i6({ ...a,
                abi: [c],
                strict: i
            });
            return s && !s.includes(l.eventName) || !tV({
                args: l.args,
                inputs: c.inputs,
                matchArgs: r
            }) ? null : { ...l,
                ...a
            }
        } catch (c) {
            let l, u;
            if (c instanceof nT) return null;
            if (c instanceof yp || c instanceof C1) {
                if (i) return null;
                l = c.abiItem.name, u = (o = c.abiItem.inputs) == null ? void 0 : o.some(h => !("name" in h && h.name))
            }
            return { ...a,
                args: u ? [] : {},
                eventName: l
            }
        }
    }).filter(Boolean)
}

function tV(t) {
    const {
        args: e,
        inputs: r,
        matchArgs: n
    } = t;
    if (!n) return !0;
    if (!e) return !1;

    function i(s, a, o) {
        try {
            return s.type === "address" ? t0(a, o) : s.type === "string" || s.type === "bytes" ? Pn(dh(a)) === o : a === o
        } catch {
            return !1
        }
    }
    return Array.isArray(e) && Array.isArray(n) ? n.every((s, a) => {
        if (s == null) return !0;
        const o = r[a];
        return o ? (Array.isArray(s) ? s : [s]).some(l => i(o, l, e[a])) : !1
    }) : typeof e == "object" && !Array.isArray(e) && typeof n == "object" && !Array.isArray(n) ? Object.entries(n).every(([s, a]) => {
        if (a == null) return !0;
        const o = r.find(l => l.name === s);
        return o ? (Array.isArray(a) ? a : [a]).some(l => i(o, l, e[s])) : !1
    }) : !1
}

function tNe(t, e) {
    if (t.length !== e.length) throw new tT({
        expectedLength: t.length,
        givenLength: e.length
    });
    const r = [];
    for (let n = 0; n < t.length; n++) {
        const i = t[n],
            s = e[n];
        r.push(OT(i, s))
    }
    return cl(r)
}

function OT(t, e, r = !1) {
    if (t === "address") {
        const a = e;
        if (!gi(a)) throw new Jo({
            address: a
        });
        return qo(a.toLowerCase(), {
            size: r ? 32 : null
        })
    }
    if (t === "string") return sd(e);
    if (t === "bytes") return e;
    if (t === "bool") return qo(V4(e), {
        size: r ? 32 : 1
    });
    const n = t.match(Q4);
    if (n) {
        const [a, o, c = "256"] = n, l = Number.parseInt(c) / 8;
        return nt(e, {
            size: r ? 32 : l,
            signed: o === "int"
        })
    }
    const i = t.match(hT);
    if (i) {
        const [a, o] = i;
        if (Number.parseInt(o) !== (e.length - 2) / 2) throw new sT({
            expectedSize: Number.parseInt(o),
            givenSize: (e.length - 2) / 2
        });
        return qo(e, {
            dir: "right",
            size: r ? 32 : null
        })
    }
    const s = t.match(Zq);
    if (s && Array.isArray(e)) {
        const [a, o] = s, c = [];
        for (let l = 0; l < e.length; l++) c.push(OT(o, e[l], !0));
        return c.length === 0 ? "0x" : cl(c)
    }
    throw new Lq(t)
}

function rV(t, e = "hex") {
    const r = jT(t),
        n = J4(new Uint8Array(r.length));
    return r.encode(n), e === "hex" ? ln(n.bytes) : n.bytes
}

function jT(t) {
    return Array.isArray(t) ? nV(t.map(e => jT(e))) : iV(t)
}

function nV(t) {
    const e = t.reduce((i, s) => i + s.length, 0),
        r = RT(e);
    return {
        length: e <= 55 ? 1 + e : 1 + r + e,
        encode(i) {
            e <= 55 ? i.pushByte(192 + e) : (i.pushByte(247 + r), r === 1 ? i.pushUint8(e) : r === 2 ? i.pushUint16(e) : r === 3 ? i.pushUint24(e) : i.pushUint32(e));
            for (const {
                    encode: s
                } of t) s(i)
        }
    }
}

function iV(t) {
    const e = typeof t == "string" ? Ns(t) : t,
        r = RT(e.length);
    return {
        length: e.length === 1 && e[0] < 128 ? 1 : e.length <= 55 ? 1 + e.length : 1 + r + e.length,
        encode(i) {
            e.length === 1 && e[0] < 128 ? i.pushBytes(e) : e.length <= 55 ? (i.pushByte(128 + e.length), i.pushBytes(e)) : (i.pushByte(183 + r), r === 1 ? i.pushUint8(e.length) : r === 2 ? i.pushUint16(e.length) : r === 3 ? i.pushUint24(e.length) : i.pushUint32(e.length), i.pushBytes(e))
        }
    }
}

function RT(t) {
    if (t < 2 ** 8) return 1;
    if (t < 2 ** 16) return 2;
    if (t < 2 ** 24) return 3;
    if (t < 2 ** 32) return 4;
    throw new be("Length is too large.")
}

function sV(t) {
    const {
        chainId: e,
        nonce: r,
        to: n
    } = t, i = t.contractAddress ? ? t.address, s = Pn(cl(["0x05", rV([e ? nt(e) : "0x", i, r ? nt(r) : "0x"])]));
    return n === "bytes" ? Ns(s) : s
}

function aV(t) {
    const e = Pn(`0x${t.substring(4)}`).substring(26);
    return Jp(`0x${e}`)
}
async function oV({
    hash: t,
    signature: e
}) {
    const r = Jn(t) ? t : cn(t),
        {
            secp256k1: n
        } = await ma(async () => {
            const {
                secp256k1: a
            } = await
            import ("./solana-vendor-E3c5Mf0a.js").then(o => o.m);
            return {
                secp256k1: a
            }
        }, __vite__mapDeps([0, 1]));
    return `0x${(()=>{if(typeof e=="object"&&"r"in e&&"s"in e){const{r:l,s:u,v:h,yParity:f}=e,p=Number(f??h),g=vE(p);return new n.Signature(ss(l),ss(u)).addRecoveryBit(g)}const a=Jn(e)?e:cn(e);if(Rr(a)!==65)throw new Error("invalid signature length");const o=va(`
    0x $ {
        a.slice(130)
    }
    `),c=vE(o);return n.Signature.fromCompact(a.substring(2,130)).addRecoveryBit(c)})().recoverPublicKey(r.substring(2)).toHex(!1)}`
}

function vE(t) {
    if (t === 0 || t === 1) return t;
    if (t === 27) return 0;
    if (t === 28) return 1;
    throw new Error("Invalid yParityOrV value")
}
async function MT({
    hash: t,
    signature: e
}) {
    return aV(await oV({
        hash: t,
        signature: e
    }))
}
async function DT(t) {
    const {
        authorization: e,
        signature: r
    } = t;
    return MT({
        hash: sV(e),
        signature: r ? ? e
    })
}

function LT(t) {
    const {
        kzg: e
    } = t, r = t.to ? ? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), n = typeof t.blobs[0] == "string" ? t.blobs.map(s => Ns(s)) : t.blobs, i = [];
    for (const s of n) i.push(Uint8Array.from(e.blobToKzgCommitment(s)));
    return r === "bytes" ? i : i.map(s => ln(s))
}

function UT(t) {
    const {
        kzg: e
    } = t, r = t.to ? ? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), n = typeof t.blobs[0] == "string" ? t.blobs.map(a => Ns(a)) : t.blobs, i = typeof t.commitments[0] == "string" ? t.commitments.map(a => Ns(a)) : t.commitments, s = [];
    for (let a = 0; a < n.length; a++) {
        const o = n[a],
            c = i[a];
        s.push(Uint8Array.from(e.computeBlobKzgProof(o, c)))
    }
    return r === "bytes" ? s : s.map(a => ln(a))
}

function cV(t, e) {
    return bS(Jn(t, {
        strict: !1
    }) ? dh(t) : t)
}

function lV(t) {
    const {
        commitment: e,
        version: r = 1
    } = t, n = t.to ? ? (typeof e == "string" ? "hex" : "bytes"), i = cV(e);
    return i.set([r], 0), n === "bytes" ? i : ln(i)
}

function dV(t) {
    const {
        commitments: e,
        version: r
    } = t, n = t.to, i = [];
    for (const s of e) i.push(lV({
        commitment: s,
        to: n,
        version: r
    }));
    return i
}
const xE = 6,
    FT = 32,
    a6 = 4096,
    BT = FT * a6,
    EE = BT * xE - 1 - 1 * a6 * xE;
class uV extends be {
    constructor({
        maxSize: e,
        size: r
    }) {
        super("Blob size is too large.", {
            metaMessages: [`Max: ${e} bytes`, `Given: ${r} bytes`],
            name: "BlobSizeTooLargeError"
        })
    }
}
class hV extends be {
    constructor() {
        super("Blob data must not be empty.", {
            name: "EmptyBlobError"
        })
    }
}

function fV(t) {
    const e = typeof t.data == "string" ? Ns(t.data) : t.data,
        r = Rr(e);
    if (!r) throw new hV;
    if (r > EE) throw new uV({
        maxSize: EE,
        size: r
    });
    const n = [];
    let i = !0,
        s = 0;
    for (; i;) {
        const a = J4(new Uint8Array(BT));
        let o = 0;
        for (; o < a6;) {
            const c = e.slice(s, s + (FT - 1));
            if (a.pushByte(0), a.pushBytes(c), c.length < 31) {
                a.pushByte(128), i = !1;
                break
            }
            o++, s += 31
        }
        n.push(a)
    }
    return n.map(a => ln(a.bytes))
}

function pV(t) {
    const {
        data: e,
        kzg: r,
        to: n
    } = t, i = t.blobs ? ? fV({
        data: e
    }), s = t.commitments ? ? LT({
        blobs: i,
        kzg: r,
        to: n
    }), a = t.proofs ? ? UT({
        blobs: i,
        commitments: s,
        kzg: r,
        to: n
    }), o = [];
    for (let c = 0; c < i.length; c++) o.push({
        blob: i[c],
        commitment: s[c],
        proof: a[c]
    });
    return o
}

function gV(t) {
    if (t.type) return t.type;
    if (typeof t.authorizationList < "u") return "eip7702";
    if (typeof t.blobs < "u" || typeof t.blobVersionedHashes < "u" || typeof t.maxFeePerBlobGas < "u" || typeof t.sidecars < "u") return "eip4844";
    if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u") return "eip1559";
    if (typeof t.gasPrice < "u") return typeof t.accessList < "u" ? "eip2930" : "legacy";
    throw new yH({
        transaction: t
    })
}
const WT = {
    "0x0": "legacy",
    "0x1": "eip2930",
    "0x2": "eip1559",
    "0x3": "eip4844",
    "0x4": "eip7702"
};

function zT(t) {
    const e = { ...t,
        blockHash: t.blockHash ? t.blockHash : null,
        blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
        chainId: t.chainId ? va(t.chainId) : void 0,
        gas: t.gas ? BigInt(t.gas) : void 0,
        gasPrice: t.gasPrice ? BigInt(t.gasPrice) : void 0,
        maxFeePerBlobGas: t.maxFeePerBlobGas ? BigInt(t.maxFeePerBlobGas) : void 0,
        maxFeePerGas: t.maxFeePerGas ? BigInt(t.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: t.maxPriorityFeePerGas ? BigInt(t.maxPriorityFeePerGas) : void 0,
        nonce: t.nonce ? va(t.nonce) : void 0,
        to: t.to ? t.to : null,
        transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
        type: t.type ? WT[t.type] : void 0,
        typeHex: t.type ? t.type : void 0,
        value: t.value ? BigInt(t.value) : void 0,
        v: t.v ? BigInt(t.v) : void 0
    };
    return t.authorizationList && (e.authorizationList = mV(t.authorizationList)), e.yParity = (() => {
        if (t.yParity) return Number(t.yParity);
        if (typeof e.v == "bigint") {
            if (e.v === 0 n || e.v === 27 n) return 0;
            if (e.v === 1 n || e.v === 28 n) return 1;
            if (e.v >= 35 n) return e.v % 2 n === 0 n ? 1 : 0
        }
    })(), e.type === "legacy" && (delete e.accessList, delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas, delete e.yParity), e.type === "eip2930" && (delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas), e.type === "eip1559" && delete e.maxFeePerBlobGas, e
}

function mV(t) {
    return t.map(e => ({
        address: e.address,
        chainId: Number(e.chainId),
        nonce: Number(e.nonce),
        r: e.r,
        s: e.s,
        yParity: Number(e.yParity)
    }))
}

function qT(t) {
    const e = (t.transactions ? ? []).map(r => typeof r == "string" ? r : zT(r));
    return { ...t,
        baseFeePerGas: t.baseFeePerGas ? BigInt(t.baseFeePerGas) : null,
        blobGasUsed: t.blobGasUsed ? BigInt(t.blobGasUsed) : void 0,
        difficulty: t.difficulty ? BigInt(t.difficulty) : void 0,
        excessBlobGas: t.excessBlobGas ? BigInt(t.excessBlobGas) : void 0,
        gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
        gasUsed: t.gasUsed ? BigInt(t.gasUsed) : void 0,
        hash: t.hash ? t.hash : null,
        logsBloom: t.logsBloom ? t.logsBloom : null,
        nonce: t.nonce ? t.nonce : null,
        number: t.number ? BigInt(t.number) : null,
        size: t.size ? BigInt(t.size) : void 0,
        timestamp: t.timestamp ? BigInt(t.timestamp) : void 0,
        transactions: e,
        totalDifficulty: t.totalDifficulty ? BigInt(t.totalDifficulty) : null
    }
}

function Qo(t, {
    args: e,
    eventName: r
} = {}) {
    return { ...t,
        blockHash: t.blockHash ? t.blockHash : null,
        blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
        logIndex: t.logIndex ? Number(t.logIndex) : null,
        transactionHash: t.transactionHash ? t.transactionHash : null,
        transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
        ...r ? {
            args: e,
            eventName: r
        } : {}
    }
}
const HT = {
    "0x0": "reverted",
    "0x1": "success"
};

function yV(t) {
    const e = { ...t,
        blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
        contractAddress: t.contractAddress ? t.contractAddress : null,
        cumulativeGasUsed: t.cumulativeGasUsed ? BigInt(t.cumulativeGasUsed) : null,
        effectiveGasPrice: t.effectiveGasPrice ? BigInt(t.effectiveGasPrice) : null,
        gasUsed: t.gasUsed ? BigInt(t.gasUsed) : null,
        logs: t.logs ? t.logs.map(r => Qo(r)) : null,
        to: t.to ? t.to : null,
        transactionIndex: t.transactionIndex ? va(t.transactionIndex) : null,
        status: t.status ? HT[t.status] : null,
        type: t.type ? WT[t.type] || t.type : null
    };
    return t.blobGasPrice && (e.blobGasPrice = BigInt(t.blobGasPrice)), t.blobGasUsed && (e.blobGasUsed = BigInt(t.blobGasUsed)), e
}
const wV = 3;

function ld(t, {
    abi: e,
    address: r,
    args: n,
    docsPath: i,
    functionName: s,
    sender: a
}) {
    const o = t instanceof k1 ? t : t instanceof be ? t.walk(g => "data" in g) || t.walk() : {},
        {
            code: c,
            data: l,
            details: u,
            message: h,
            shortMessage: f
        } = o,
        p = t instanceof Yp ? new xH({
            functionName: s
        }) : [wV, nd.code].includes(c) && (l || u || h || f) ? new Jv({
            abi: e,
            data: typeof l == "object" ? l.data : l,
            functionName: s,
            message: o instanceof H4 ? u : f ? ? h
        }) : t;
    return new vH(p, {
        abi: e,
        args: n,
        contractAddress: r,
        docsPath: i,
        functionName: s,
        sender: a
    })
}
class bV extends be {
    constructor(e, {
        account: r,
        docsPath: n,
        chain: i,
        data: s,
        gas: a,
        gasPrice: o,
        maxFeePerGas: c,
        maxPriorityFeePerGas: l,
        nonce: u,
        to: h,
        value: f
    }) {
        var g;
        const p = Qp({
            from: r == null ? void 0 : r.address,
            to: h,
            value: typeof f < "u" && `${Cd(f)} ${((g=i==null?void 0:i.nativeCurrency)==null?void 0:g.symbol)||"ETH"}`,
            data: s,
            gas: a,
            gasPrice: typeof o < "u" && `${Di(o)} gwei`,
            maxFeePerGas: typeof c < "u" && `${Di(c)} gwei`,
            maxPriorityFeePerGas: typeof l < "u" && `${Di(l)} gwei`,
            nonce: u
        });
        super(e.shortMessage, {
            cause: e,
            docsPath: n,
            metaMessages: [...e.metaMessages ? [...e.metaMessages, " "] : [], "Estimate Gas Arguments:", p].filter(Boolean),
            name: "EstimateGasExecutionError"
        }), Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.cause = e
    }
}

function vV(t, {
    docsPath: e,
    ...r
}) {
    const n = (() => {
        const i = $1(t, r);
        return i instanceof Xp ? t : i
    })();
    return new bV(n, {
        docsPath: e,
        ...r
    })
}

function VT(t, {
    docsPath: e,
    ...r
}) {
    const n = (() => {
        const i = $1(t, r);
        return i instanceof Xp ? t : i
    })();
    return new wH(n, {
        docsPath: e,
        ...r
    })
}

function ht(t, e, r) {
    const n = t[e.name];
    if (typeof n == "function") return n;
    const i = t[r];
    return typeof i == "function" ? i : s => e(t, s)
}
const xV = `Ethereum Signed Message:
`;

function EV(t) {
    const e = typeof t == "string" ? sd(t) : typeof t.raw == "string" ? t.raw : ln(t.raw),
        r = sd(`${xV}${Rr(e)}`);
    return as([r, e])
}

function GT(t, e) {
    return Pn(EV(t), e)
}
const KT = "0x6492649264926492649264926492649264926492649264926492649264926492";

function _V(t) {
    return mm(t, -32) === KT
}

function CV(t) {
    const {
        address: e,
        data: r,
        signature: n,
        to: i = "hex"
    } = t, s = cl([fc([{
        type: "address"
    }, {
        type: "bytes"
    }, {
        type: "bytes"
    }], [e, r, n]), KT]);
    return i === "hex" ? s : Ns(s)
}
class AV extends be {
    constructor({
        value: e
    }) {
        super(`Number \`${e}\` is not a valid decimal number.`, {
            name: "InvalidDecimalNumberError"
        })
    }
}

function kV(t, e) {
    if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(t)) throw new AV({
        value: t
    });
    let [r, n = "0"] = t.split(".");
    const i = r.startsWith("-");
    if (i && (r = r.slice(1)), n = n.replace(/(0+)$/, ""), e === 0) Math.round(+`.${n}`) === 1 && (r = `${BigInt(r)+1n}`), n = "";
    else if (n.length > e) {
        const [s, a, o] = [n.slice(0, e - 1), n.slice(e - 1, e), n.slice(e)], c = Math.round(+`${a}.${o}`);
        c > 9 ? n = `${BigInt(s)+BigInt(1)}0`.padStart(s.length + 1, "0") : n = `${s}${c}`, n.length > e && (n = n.slice(1), r = `${BigInt(r)+1n}`), n = n.slice(0, e)
    } else n = n.padEnd(e, "0");
    return BigInt(`${i?"-":""}${r}${n}`)
}

function YT(t, e = "wei") {
    return kV(t, mT[e])
}
async function o6(t, {
    address: e,
    blockTag: r = "latest",
    blockNumber: n
}) {
    const i = await t.request({
        method: "eth_getTransactionCount",
        params: [e, typeof n == "bigint" ? nt(n) : r]
    }, {
        dedupe: !!n
    });
    return va(i)
}

function rNe(t) {
    const {
        source: e
    } = t, r = new Map, n = new Kp(8192), i = new Map, s = ({
        address: a,
        chainId: o
    }) => `${a}.${o}`;
    return {
        async consume({
            address: a,
            chainId: o,
            client: c
        }) {
            const l = s({
                    address: a,
                    chainId: o
                }),
                u = this.get({
                    address: a,
                    chainId: o,
                    client: c
                });
            this.increment({
                address: a,
                chainId: o
            });
            const h = await u;
            return await e.set({
                address: a,
                chainId: o
            }, h), n.set(l, h), h
        },
        async increment({
            address: a,
            chainId: o
        }) {
            const c = s({
                    address: a,
                    chainId: o
                }),
                l = r.get(c) ? ? 0;
            r.set(c, l + 1)
        },
        async get({
            address: a,
            chainId: o,
            client: c
        }) {
            const l = s({
                address: a,
                chainId: o
            });
            let u = i.get(l);
            return u || (u = (async () => {
                try {
                    const f = await e.get({
                            address: a,
                            chainId: o,
                            client: c
                        }),
                        p = n.get(l) ? ? 0;
                    return p > 0 && f <= p ? p + 1 : (n.delete(l), f)
                } finally {
                    this.reset({
                        address: a,
                        chainId: o
                    })
                }
            })(), i.set(l, u)), (r.get(l) ? ? 0) + await u
        },
        reset({
            address: a,
            chainId: o
        }) {
            const c = s({
                address: a,
                chainId: o
            });
            r.delete(c), i.delete(c)
        }
    }
}
const IV = {
        path: "/api/v1/analytics_events",
        method: "POST"
    },
    $V = {
        path: "/api/v1/apps/:app_id",
        method: "GET"
    },
    SV = {
        path: "/api/v1/funding/coinbase_on_ramp/init",
        method: "POST"
    },
    TV = {
        path: "/api/v1/funding/coinbase_on_ramp/status",
        method: "GET"
    },
    PV = {
        path: "/api/v1/apps/:app_id/cross-app/connections",
        method: "GET"
    },
    NV = {
        path: "/api/v1/custom_jwt_account/authenticate",
        method: "POST"
    },
    OV = {
        path: "/api/v1/farcaster/init",
        method: "POST"
    },
    jV = {
        path: "/api/v1/farcaster/authenticate",
        method: "POST"
    },
    RV = {
        path: "/api/v1/farcaster/link",
        method: "POST"
    },
    MV = {
        path: "/api/v1/farcaster/unlink",
        method: "POST"
    },
    DV = {
        path: "/api/v1/farcaster/status",
        method: "GET"
    },
    LV = {
        path: "/api/v2/farcaster/init",
        method: "POST"
    },
    UV = {
        path: "/api/v2/farcaster/authenticate",
        method: "POST"
    },
    FV = {
        path: "/api/v1/guest/authenticate",
        method: "POST"
    },
    BV = {
        path: "/api/v1/mfa/passkeys/init",
        method: "POST"
    },
    WV = {
        path: "/api/v1/mfa/passwordless_sms/init",
        method: "POST"
    },
    zV = {
        path: "/api/v1/oauth/authenticate",
        method: "POST"
    },
    qV = {
        path: "/api/v1/oauth/init",
        method: "POST"
    },
    HV = {
        path: "/api/v1/oauth/link",
        method: "POST"
    },
    VV = {
        path: "/api/v1/oauth/unlink",
        method: "POST"
    },
    GV = {
        path: "/api/v1/passkeys/link",
        method: "POST"
    },
    KV = {
        path: "/api/v1/passkeys/authenticate",
        method: "POST"
    },
    YV = {
        path: "/api/v1/passkeys/register",
        method: "POST"
    },
    ZV = {
        path: "/api/v1/passkeys/authenticate/init",
        method: "POST"
    },
    JV = {
        path: "/api/v1/passkeys/register/init",
        method: "POST"
    },
    QV = {
        path: "/api/v1/passkeys/link/init",
        method: "POST"
    },
    XV = {
        path: "/api/v1/passwordless/authenticate",
        method: "POST"
    },
    eG = {
        path: "/api/v1/passwordless/init",
        method: "POST"
    },
    tG = {
        path: "/api/v1/passwordless/link",
        method: "POST"
    },
    rG = {
        path: "/api/v1/passwordless/unlink",
        method: "POST"
    },
    nG = {
        path: "/api/v1/passwordless/update",
        method: "POST"
    },
    iG = {
        path: "/api/v1/passwordless_sms/authenticate",
        method: "POST"
    },
    sG = {
        path: "/api/v1/passwordless_sms/init",
        method: "POST"
    },
    aG = {
        path: "/api/v1/passwordless_sms/link",
        method: "POST"
    },
    oG = {
        path: "/api/v1/passwordless_sms/unlink",
        method: "POST"
    },
    cG = {
        path: "/api/v1/passwordless_sms/update",
        method: "POST"
    },
    lG = {
        path: "/api/v1/embedded_wallets/:address/recovery/key_material",
        method: "POST"
    },
    dG = {
        path: "/api/v1/recovery/oauth/init",
        method: "POST"
    },
    uG = {
        path: "/api/v1/recovery/oauth/authenticate",
        method: "POST"
    },
    hG = {
        path: "/api/v1/recovery/oauth/init_icloud",
        method: "POST"
    },
    fG = {
        path: "/api/v1/recovery/configuration_icloud",
        method: "POST"
    },
    pG = (t, e) => e ? Object.entries(e).reduce((r, [n, i]) => r.replace(`:${n}`, `${i}`), t) : t,
    _E = {
        path: "/api/v1/sessions",
        method: "POST"
    },
    gG = {
        path: "/api/v1/sessions/logout",
        method: "POST"
    },
    mG = {
        path: "/api/v1/apps/:app_id/smart_wallets",
        method: "GET"
    },
    ZT = {
        path: "/api/v1/siwe/init",
        method: "POST"
    },
    yG = {
        path: "/api/v1/siwe/authenticate",
        method: "POST"
    },
    wG = {
        path: "/api/v1/siwe/link",
        method: "POST"
    },
    bG = {
        path: "/api/v1/siwe/link_smart_wallet",
        method: "POST"
    },
    vG = {
        path: "/api/v1/siwe/unlink",
        method: "POST"
    },
    xG = {
        path: "/api/v1/siws/init",
        method: "POST"
    },
    EG = {
        path: "/api/v1/siws/authenticate",
        method: "POST"
    },
    _G = {
        path: "/api/v1/siws/link",
        method: "POST"
    },
    CG = {
        path: "/api/v1/siws/unlink",
        method: "POST"
    },
    AG = {
        path: "/api/v1/users/me/accept_terms",
        method: "POST"
    },
    kG = {
        path: "/api/v1/plugins/moonpay_on_ramp/sign",
        method: "POST"
    },
    IG = {
        path: "/api/v1/wallets",
        method: "POST"
    },
    $w = {
        path: "/api/v1/wallets/:wallet_id/rpc",
        method: "POST"
    },
    $G = {
        path: "/api/v1/wallets/revoke",
        method: "POST"
    };
var wt, CE = ((wt = {}).OAUTH_ACCOUNT_SUSPENDED = "oauth_account_suspended", wt.MISSING_OR_INVALID_PRIVY_APP_ID = "missing_or_invalid_privy_app_id", wt.MISSING_OR_INVALID_PRIVY_CLIENT_ID = "missing_or_invalid_privy_client_id", wt.MISSING_OR_INVALID_PRIVY_ACCOUNT_ID = "missing_or_invalid_privy_account_id", wt.MISSING_OR_INVALID_TOKEN = "missing_or_invalid_token", wt.MISSING_OR_INVALID_MFA = "missing_or_invalid_mfa", wt.EXPIRED_OR_INVALID_MFA_TOKEN = "expired_or_invalid_mfa_token", wt.INVALID_DATA = "invalid_data", wt.INVALID_CREDENTIALS = "invalid_credentials", wt.INVALID_CAPTCHA = "invalid_captcha", wt.LINKED_TO_ANOTHER_USER = "linked_to_another_user", wt.ALLOWLIST_REJECTED = "allowlist_rejected", wt.CANNOT_UNLINK_EMBEDDED_WALLET = "cannot_unlink_embedded_wallet", wt.CANNOT_UNLINK_SOLE_ACCOUNT = "cannot_unlink_sole_account", wt.CANNOT_LINK_MORE_OF_TYPE = "cannot_link_more_of_type", wt.LINKED_ACCOUNT_NOT_FOUND = "linked_account_not_found", wt.TOO_MANY_REQUESTS = "too_many_requests", wt.INVALID_ORIGIN = "invalid_origin", wt.MISSING_ORIGIN = "missing_origin", wt.INVALID_NATIVE_APP_ID = "invalid_native_app_id", wt.TOKEN_ALREADY_USED = "token_already_used", wt.ALREADY_LOGGED_OUT = "already_logged_out", wt.NOT_SUPPORTED = "not_supported", wt.USER_UNSUBSCRIBED = "user_unsubscribed", wt.MAX_APPS_REACHED = "max_apps_reached", wt.USER_LIMIT_REACHED = "max_accounts_reached", wt.DEVICE_REVOKED = "device_revoked", wt.WALLET_PASSWORD_EXISTS = "wallet_password_exists", wt.OAUTH_STATE_MISMATCH = "oauth_state_mismatch", wt.MAX_DENYLIST_ENTRIES_REACHED = "max_denylist_entries_reached", wt.MAX_TEST_ACCOUNTS_REACHED = "max_test_accounts_reached", wt.DISALLOWED_LOGIN_METHOD = "disallowed_login_method", wt.DISALLOWED_PLUS_EMAIL = "disallowed_plus_email", wt.DISALLOWED_RECOVERY_METHOD = "disallowed_recovery_method", wt.LEGACY_DASHBOARD_LOGIN_CONFIGURATION = "legacy_dashboard_login_configuration", wt.CANNOT_SET_PASSWORD = "cannot_set_password", wt.INVALID_PKCE_PARAMETERS = "invalid_pkce_parameters", wt.INVALID_APP_URL_SCHEME_CONFIGURATION = "invalid_app_url_scheme_configuration", wt.CROSS_APP_CONNECTION_NOT_ALLOWED = "cross_app_connection_not_allowed", wt.USER_DOES_NOT_EXIST = "user_does_not_exist", wt.ALREADY_EXISTS = "resource_already_exists", wt.ACCOUNT_TRANSFER_REQUIRED = "account_transfer_required", wt.USER_HAS_NOT_DELEGATED_WALLET = "user_has_not_delegated_wallet", wt.FEATURE_NOT_ENABLED = "feature_not_enabled", wt.INSUFFICIENT_FUNDS = "insufficient_funds", wt.TRANSACTION_BROADCAST_FAILURE = "transaction_broadcast_failure", wt.INVALID_POLICY_FORMAT = "invalid_policy_format", wt.POLICY_VIOLATION = "policy_violation", wt.AUTHORIZATION_KEY_HAS_ASSOCIATED_WALLETS = "authorization_key_has_associated_wallets", wt.INVALID_REQUEST = "invalid_request", wt);

function AE(t, e) {
    t = t.split("-"), e = e.split("-");
    for (var r = t[0].split("."), n = e[0].split("."), i = 0; i < 3; i++) {
        var s = Number(r[i]),
            a = Number(n[i]);
        if (s > a) return 1;
        if (a > s) return -1;
        if (!isNaN(s) && isNaN(a)) return 1;
        if (isNaN(s) && !isNaN(a)) return -1
    }
    return t[1] && e[1] ? t[1] > e[1] ? 1 : t[1] < e[1] ? -1 : 0 : !t[1] && e[1] ? 1 : t[1] && !e[1] ? -1 : 0
}
var SG = {}.constructor;

function Jl(t) {
    return t != null && t.constructor === SG
}

function a3(t) {
    "@babel/helpers - typeof";
    return a3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    } : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }, a3(t)
}

function P1(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function TG(t, e) {
    for (var r = 0; r < e.length; r++) {
        var n = e[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
    }
}

function N1(t, e, r) {
    return e && TG(t.prototype, e), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}
var PG = "1.2.0",
    NG = "1.7.35",
    kE = " ext. ",
    OG = /^\d+$/,
    wn = function() {
        function t(e) {
            P1(this, t), JT(e), this.metadata = e, QT.call(this, e)
        }
        return N1(t, [{
            key: "getCountries",
            value: function() {
                return Object.keys(this.metadata.countries).filter(function(r) {
                    return r !== "001"
                })
            }
        }, {
            key: "getCountryMetadata",
            value: function(r) {
                return this.metadata.countries[r]
            }
        }, {
            key: "nonGeographic",
            value: function() {
                if (!(this.v1 || this.v2 || this.v3)) return this.metadata.nonGeographic || this.metadata.nonGeographical
            }
        }, {
            key: "hasCountry",
            value: function(r) {
                return this.getCountryMetadata(r) !== void 0
            }
        }, {
            key: "hasCallingCode",
            value: function(r) {
                if (this.getCountryCodesForCallingCode(r)) return !0;
                if (this.nonGeographic()) {
                    if (this.nonGeographic()[r]) return !0
                } else {
                    var n = this.countryCallingCodes()[r];
                    if (n && n.length === 1 && n[0] === "001") return !0
                }
            }
        }, {
            key: "isNonGeographicCallingCode",
            value: function(r) {
                return this.nonGeographic() ? !!this.nonGeographic()[r] : !this.getCountryCodesForCallingCode(r)
            }
        }, {
            key: "country",
            value: function(r) {
                return this.selectNumberingPlan(r)
            }
        }, {
            key: "selectNumberingPlan",
            value: function(r, n) {
                if (r && OG.test(r) && (n = r, r = null), r && r !== "001") {
                    if (!this.hasCountry(r)) throw new Error("Unknown country: ".concat(r));
                    this.numberingPlan = new IE(this.getCountryMetadata(r), this)
                } else if (n) {
                    if (!this.hasCallingCode(n)) throw new Error("Unknown calling code: ".concat(n));
                    this.numberingPlan = new IE(this.getNumberingPlanMetadata(n), this)
                } else this.numberingPlan = void 0;
                return this
            }
        }, {
            key: "getCountryCodesForCallingCode",
            value: function(r) {
                var n = this.countryCallingCodes()[r];
                if (n) return n.length === 1 && n[0].length === 3 ? void 0 : n
            }
        }, {
            key: "getCountryCodeForCallingCode",
            value: function(r) {
                var n = this.getCountryCodesForCallingCode(r);
                if (n) return n[0]
            }
        }, {
            key: "getNumberingPlanMetadata",
            value: function(r) {
                var n = this.getCountryCodeForCallingCode(r);
                if (n) return this.getCountryMetadata(n);
                if (this.nonGeographic()) {
                    var i = this.nonGeographic()[r];
                    if (i) return i
                } else {
                    var s = this.countryCallingCodes()[r];
                    if (s && s.length === 1 && s[0] === "001") return this.metadata.countries["001"]
                }
            }
        }, {
            key: "countryCallingCode",
            value: function() {
                return this.numberingPlan.callingCode()
            }
        }, {
            key: "IDDPrefix",
            value: function() {
                return this.numberingPlan.IDDPrefix()
            }
        }, {
            key: "defaultIDDPrefix",
            value: function() {
                return this.numberingPlan.defaultIDDPrefix()
            }
        }, {
            key: "nationalNumberPattern",
            value: function() {
                return this.numberingPlan.nationalNumberPattern()
            }
        }, {
            key: "possibleLengths",
            value: function() {
                return this.numberingPlan.possibleLengths()
            }
        }, {
            key: "formats",
            value: function() {
                return this.numberingPlan.formats()
            }
        }, {
            key: "nationalPrefixForParsing",
            value: function() {
                return this.numberingPlan.nationalPrefixForParsing()
            }
        }, {
            key: "nationalPrefixTransformRule",
            value: function() {
                return this.numberingPlan.nationalPrefixTransformRule()
            }
        }, {
            key: "leadingDigits",
            value: function() {
                return this.numberingPlan.leadingDigits()
            }
        }, {
            key: "hasTypes",
            value: function() {
                return this.numberingPlan.hasTypes()
            }
        }, {
            key: "type",
            value: function(r) {
                return this.numberingPlan.type(r)
            }
        }, {
            key: "ext",
            value: function() {
                return this.numberingPlan.ext()
            }
        }, {
            key: "countryCallingCodes",
            value: function() {
                return this.v1 ? this.metadata.country_phone_code_to_countries : this.metadata.country_calling_codes
            }
        }, {
            key: "chooseCountryByCountryCallingCode",
            value: function(r) {
                return this.selectNumberingPlan(r)
            }
        }, {
            key: "hasSelectedNumberingPlan",
            value: function() {
                return this.numberingPlan !== void 0
            }
        }]), t
    }(),
    IE = function() {
        function t(e, r) {
            P1(this, t), this.globalMetadataObject = r, this.metadata = e, QT.call(this, r.metadata)
        }
        return N1(t, [{
            key: "callingCode",
            value: function() {
                return this.metadata[0]
            }
        }, {
            key: "getDefaultCountryMetadataForRegion",
            value: function() {
                return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode())
            }
        }, {
            key: "IDDPrefix",
            value: function() {
                if (!(this.v1 || this.v2)) return this.metadata[1]
            }
        }, {
            key: "defaultIDDPrefix",
            value: function() {
                if (!(this.v1 || this.v2)) return this.metadata[12]
            }
        }, {
            key: "nationalNumberPattern",
            value: function() {
                return this.v1 || this.v2 ? this.metadata[1] : this.metadata[2]
            }
        }, {
            key: "possibleLengths",
            value: function() {
                if (!this.v1) return this.metadata[this.v2 ? 2 : 3]
            }
        }, {
            key: "_getFormats",
            value: function(r) {
                return r[this.v1 ? 2 : this.v2 ? 3 : 4]
            }
        }, {
            key: "formats",
            value: function() {
                var r = this,
                    n = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];
                return n.map(function(i) {
                    return new jG(i, r)
                })
            }
        }, {
            key: "nationalPrefix",
            value: function() {
                return this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5]
            }
        }, {
            key: "_getNationalPrefixFormattingRule",
            value: function(r) {
                return r[this.v1 ? 4 : this.v2 ? 5 : 6]
            }
        }, {
            key: "nationalPrefixFormattingRule",
            value: function() {
                return this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion())
            }
        }, {
            key: "_nationalPrefixForParsing",
            value: function() {
                return this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7]
            }
        }, {
            key: "nationalPrefixForParsing",
            value: function() {
                return this._nationalPrefixForParsing() || this.nationalPrefix()
            }
        }, {
            key: "nationalPrefixTransformRule",
            value: function() {
                return this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8]
            }
        }, {
            key: "_getNationalPrefixIsOptionalWhenFormatting",
            value: function() {
                return !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9]
            }
        }, {
            key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
            value: function() {
                return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion())
            }
        }, {
            key: "leadingDigits",
            value: function() {
                return this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10]
            }
        }, {
            key: "types",
            value: function() {
                return this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11]
            }
        }, {
            key: "hasTypes",
            value: function() {
                return this.types() && this.types().length === 0 ? !1 : !!this.types()
            }
        }, {
            key: "type",
            value: function(r) {
                if (this.hasTypes() && $E(this.types(), r)) return new MG($E(this.types(), r), this)
            }
        }, {
            key: "ext",
            value: function() {
                return this.v1 || this.v2 ? kE : this.metadata[13] || kE
            }
        }]), t
    }(),
    jG = function() {
        function t(e, r) {
            P1(this, t), this._format = e, this.metadata = r
        }
        return N1(t, [{
            key: "pattern",
            value: function() {
                return this._format[0]
            }
        }, {
            key: "format",
            value: function() {
                return this._format[1]
            }
        }, {
            key: "leadingDigitsPatterns",
            value: function() {
                return this._format[2] || []
            }
        }, {
            key: "nationalPrefixFormattingRule",
            value: function() {
                return this._format[3] || this.metadata.nationalPrefixFormattingRule()
            }
        }, {
            key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
            value: function() {
                return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat()
            }
        }, {
            key: "nationalPrefixIsMandatoryWhenFormattingInNationalFormat",
            value: function() {
                return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat()
            }
        }, {
            key: "usesNationalPrefix",
            value: function() {
                return !!(this.nationalPrefixFormattingRule() && !RG.test(this.nationalPrefixFormattingRule()))
            }
        }, {
            key: "internationalFormat",
            value: function() {
                return this._format[5] || this.format()
            }
        }]), t
    }(),
    RG = /^\(?\$1\)?$/,
    MG = function() {
        function t(e, r) {
            P1(this, t), this.type = e, this.metadata = r
        }
        return N1(t, [{
            key: "pattern",
            value: function() {
                return this.metadata.v1 ? this.type : this.type[0]
            }
        }, {
            key: "possibleLengths",
            value: function() {
                if (!this.metadata.v1) return this.type[1] || this.metadata.possibleLengths()
            }
        }]), t
    }();

function $E(t, e) {
    switch (e) {
        case "FIXED_LINE":
            return t[0];
        case "MOBILE":
            return t[1];
        case "TOLL_FREE":
            return t[2];
        case "PREMIUM_RATE":
            return t[3];
        case "PERSONAL_NUMBER":
            return t[4];
        case "VOICEMAIL":
            return t[5];
        case "UAN":
            return t[6];
        case "PAGER":
            return t[7];
        case "VOIP":
            return t[8];
        case "SHARED_COST":
            return t[9]
    }
}

function JT(t) {
    if (!t) throw new Error("[libphonenumber-js] `metadata` argument not passed. Check your arguments.");
    if (!Jl(t) || !Jl(t.countries)) throw new Error("[libphonenumber-js] `metadata` argument was passed but it's not a valid metadata. Must be an object having `.countries` child object property. Got ".concat(Jl(t) ? "an object of shape: { " + Object.keys(t).join(", ") + " }" : "a " + DG(t) + ": " + t, "."))
}
var DG = function(e) {
    return a3(e)
};

function O1(t, e) {
    if (e = new wn(e), e.hasCountry(t)) return e.country(t).countryCallingCode();
    throw new Error("Unknown country: ".concat(t))
}

function LG(t, e) {
    return e.countries.hasOwnProperty(t)
}

function QT(t) {
    var e = t.version;
    typeof e == "number" ? (this.v1 = e === 1, this.v2 = e === 2, this.v3 = e === 3, this.v4 = e === 4) : e ? AE(e, PG) === -1 ? this.v2 = !0 : AE(e, NG) === -1 ? this.v3 = !0 : this.v4 = !0 : this.v1 = !0
}

function j1(t, e) {
    return UG(t, void 0, e)
}

function UG(t, e, r) {
    var n = r.type(e),
        i = n && n.possibleLengths() || r.possibleLengths();
    if (!i) return "IS_POSSIBLE";
    var s = t.length,
        a = i[0];
    return a === s ? "IS_POSSIBLE" : a > s ? "TOO_SHORT" : i[i.length - 1] < s ? "TOO_LONG" : i.indexOf(s, 1) >= 0 ? "IS_POSSIBLE" : "INVALID_LENGTH"
}

function FG(t, e, r) {
    if (e === void 0 && (e = {}), r = new wn(r), e.v2) {
        if (!t.countryCallingCode) throw new Error("Invalid phone number object passed");
        r.selectNumberingPlan(t.countryCallingCode)
    } else {
        if (!t.phone) return !1;
        if (t.country) {
            if (!r.hasCountry(t.country)) throw new Error("Unknown country: ".concat(t.country));
            r.country(t.country)
        } else {
            if (!t.countryCallingCode) throw new Error("Invalid phone number object passed");
            r.selectNumberingPlan(t.countryCallingCode)
        }
    }
    if (r.possibleLengths()) return XT(t.phone || t.nationalNumber, r);
    if (t.countryCallingCode && r.isNonGeographicCallingCode(t.countryCallingCode)) return !0;
    throw new Error('Missing "possibleLengths" in metadata. Perhaps the metadata has been generated before v1.0.18.')
}

function XT(t, e) {
    switch (j1(t, e)) {
        case "IS_POSSIBLE":
            return !0;
        default:
            return !1
    }
}

function Xo(t, e) {
    return t = t || "", new RegExp("^(?:" + e + ")$").test(t)
}

function BG(t, e) {
    var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r) return (r = r.call(t)).next.bind(r);
    if (Array.isArray(t) || (r = WG(t)) || e) {
        r && (t = r);
        var n = 0;
        return function() {
            return n >= t.length ? {
                done: !0
            } : {
                done: !1,
                value: t[n++]
            }
        }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function WG(t, e) {
    if (t) {
        if (typeof t == "string") return SE(t, e);
        var r = Object.prototype.toString.call(t).slice(8, -1);
        if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return SE(t, e)
    }
}

function SE(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
    return n
}
var zG = ["MOBILE", "PREMIUM_RATE", "TOLL_FREE", "SHARED_COST", "VOIP", "PERSONAL_NUMBER", "PAGER", "UAN", "VOICEMAIL"];

function c6(t, e, r) {
    if (e = e || {}, !(!t.country && !t.countryCallingCode)) {
        r = new wn(r), r.selectNumberingPlan(t.country, t.countryCallingCode);
        var n = e.v2 ? t.nationalNumber : t.phone;
        if (Xo(n, r.nationalNumberPattern())) {
            if (Sw(n, "FIXED_LINE", r)) return r.type("MOBILE") && r.type("MOBILE").pattern() === "" || !r.type("MOBILE") || Sw(n, "MOBILE", r) ? "FIXED_LINE_OR_MOBILE" : "FIXED_LINE";
            for (var i = BG(zG), s; !(s = i()).done;) {
                var a = s.value;
                if (Sw(n, a, r)) return a
            }
        }
    }
}

function Sw(t, e, r) {
    return e = r.type(e), !e || !e.pattern() || e.possibleLengths() && e.possibleLengths().indexOf(t.length) < 0 ? !1 : Xo(t, e.pattern())
}

function qG(t, e, r) {
    if (e = e || {}, r = new wn(r), r.selectNumberingPlan(t.country, t.countryCallingCode), r.hasTypes()) return c6(t, e, r.metadata) !== void 0;
    var n = e.v2 ? t.nationalNumber : t.phone;
    return Xo(n, r.nationalNumberPattern())
}

function HG(t, e, r) {
    var n = new wn(r),
        i = n.getCountryCodesForCallingCode(t);
    return i ? i.filter(function(s) {
        return VG(e, s, r)
    }) : []
}

function VG(t, e, r) {
    var n = new wn(r);
    return n.selectNumberingPlan(e), n.numberingPlan.possibleLengths().indexOf(t.length) >= 0
}
var l6 = 2,
    GG = 17,
    KG = 3,
    mi = "0-9０-９٠-٩۰-۹",
    YG = "-‐-―−ー－",
    ZG = "／/",
    JG = "．.",
    QG = "  ­​⁠　",
    XG = "()（）［］\\[\\]",
    eK = "~⁓∼～",
    ya = "".concat(YG).concat(ZG).concat(JG).concat(QG).concat(XG).concat(eK),
    R1 = "+＋",
    tK = new RegExp("([" + mi + "])");

function eP(t, e, r, n) {
    if (e) {
        var i = new wn(n);
        i.selectNumberingPlan(e, r);
        var s = new RegExp(i.IDDPrefix());
        if (t.search(s) === 0) {
            t = t.slice(t.match(s)[0].length);
            var a = t.match(tK);
            if (!(a && a[1] != null && a[1].length > 0 && a[1] === "0")) return t
        }
    }
}

function o3(t, e) {
    if (t && e.numberingPlan.nationalPrefixForParsing()) {
        var r = new RegExp("^(?:" + e.numberingPlan.nationalPrefixForParsing() + ")"),
            n = r.exec(t);
        if (n) {
            var i, s, a = n.length - 1,
                o = a > 0 && n[a];
            if (e.nationalPrefixTransformRule() && o) i = t.replace(r, e.nationalPrefixTransformRule()), a > 1 && (s = n[1]);
            else {
                var c = n[0];
                i = t.slice(c.length), o && (s = n[1])
            }
            var l;
            if (o) {
                var u = t.indexOf(n[1]),
                    h = t.slice(0, u);
                h === e.numberingPlan.nationalPrefix() && (l = e.numberingPlan.nationalPrefix())
            } else l = n[0];
            return {
                nationalNumber: i,
                nationalPrefix: l,
                carrierCode: s
            }
        }
    }
    return {
        nationalNumber: t
    }
}

function c3(t, e) {
    var r = o3(t, e),
        n = r.carrierCode,
        i = r.nationalNumber;
    if (i !== t) {
        if (!rK(t, i, e)) return {
            nationalNumber: t
        };
        if (e.possibleLengths() && !nK(i, e)) return {
            nationalNumber: t
        }
    }
    return {
        nationalNumber: i,
        carrierCode: n
    }
}

function rK(t, e, r) {
    return !(Xo(t, r.nationalNumberPattern()) && !Xo(e, r.nationalNumberPattern()))
}

function nK(t, e) {
    switch (j1(t, e)) {
        case "TOO_SHORT":
        case "INVALID_LENGTH":
            return !1;
        default:
            return !0
    }
}

function tP(t, e, r, n) {
    var i = e ? O1(e, n) : r;
    if (t.indexOf(i) === 0) {
        n = new wn(n), n.selectNumberingPlan(e, r);
        var s = t.slice(i.length),
            a = c3(s, n),
            o = a.nationalNumber,
            c = c3(t, n),
            l = c.nationalNumber;
        if (!Xo(l, n.nationalNumberPattern()) && Xo(o, n.nationalNumberPattern()) || j1(l, n) === "TOO_LONG") return {
            countryCallingCode: i,
            number: s
        }
    }
    return {
        number: t
    }
}

function d6(t, e, r, n) {
    if (!t) return {};
    var i;
    if (t[0] !== "+") {
        var s = eP(t, e, r, n);
        if (s && s !== t) i = !0, t = "+" + s;
        else {
            if (e || r) {
                var a = tP(t, e, r, n),
                    o = a.countryCallingCode,
                    c = a.number;
                if (o) return {
                    countryCallingCodeSource: "FROM_NUMBER_WITHOUT_PLUS_SIGN",
                    countryCallingCode: o,
                    number: c
                }
            }
            return {
                number: t
            }
        }
    }
    if (t[1] === "0") return {};
    n = new wn(n);
    for (var l = 2; l - 1 <= KG && l <= t.length;) {
        var u = t.slice(1, l);
        if (n.hasCallingCode(u)) return n.selectNumberingPlan(u), {
            countryCallingCodeSource: i ? "FROM_NUMBER_WITH_IDD" : "FROM_NUMBER_WITH_PLUS_SIGN",
            countryCallingCode: u,
            number: t.slice(l)
        };
        l++
    }
    return {}
}

function rP(t) {
    return t.replace(new RegExp("[".concat(ya, "]+"), "g"), " ").trim()
}
var nP = /(\$\d)/;

function iP(t, e, r) {
    var n = r.useInternationalFormat,
        i = r.withNationalPrefix;
    r.carrierCode, r.metadata;
    var s = t.replace(new RegExp(e.pattern()), n ? e.internationalFormat() : i && e.nationalPrefixFormattingRule() ? e.format().replace(nP, e.nationalPrefixFormattingRule()) : e.format());
    return n ? rP(s) : s
}
var iK = /^[\d]+(?:[~\u2053\u223C\uFF5E][\d]+)?$/;

function sK(t, e, r) {
    var n = new wn(r);
    if (n.selectNumberingPlan(t, e), n.defaultIDDPrefix()) return n.defaultIDDPrefix();
    if (iK.test(n.IDDPrefix())) return n.IDDPrefix()
}
var aK = ";ext=",
    Kd = function(e) {
        return "([".concat(mi, "]{1,").concat(e, "})")
    };

function sP(t) {
    var e = "20",
        r = "15",
        n = "9",
        i = "6",
        s = "[  \\t,]*",
        a = "[:\\.．]?[  \\t,-]*",
        o = "#?",
        c = "(?:e?xt(?:ensi(?:ó?|ó))?n?|ｅ?ｘｔｎ?|доб|anexo)",
        l = "(?:[xｘ#＃~～]|int|ｉｎｔ)",
        u = "[- ]+",
        h = "[  \\t]*",
        f = "(?:,{2}|;)",
        p = aK + Kd(e),
        g = s + c + a + Kd(e) + o,
        m = s + l + a + Kd(n) + o,
        y = u + Kd(i) + "#",
        w = h + f + a + Kd(r) + o,
        x = h + "(?:,)+" + a + Kd(n) + o;
    return p + "|" + g + "|" + m + "|" + y + "|" + w + "|" + x
}
var oK = "[" + mi + "]{" + l6 + "}",
    cK = "[" + R1 + "]{0,1}(?:[" + ya + "]*[" + mi + "]){3,}[" + ya + mi + "]*",
    lK = new RegExp("^[" + R1 + "]{0,1}(?:[" + ya + "]*[" + mi + "]){1,2}$", "i"),
    dK = cK + "(?:" + sP() + ")?",
    uK = new RegExp("^" + oK + "$|^" + dK + "$", "i");

function hK(t) {
    return t.length >= l6 && uK.test(t)
}

function fK(t) {
    return lK.test(t)
}

function pK(t) {
    var e = t.number,
        r = t.ext;
    if (!e) return "";
    if (e[0] !== "+") throw new Error('"formatRFC3966()" expects "number" to be in E.164 format.');
    return "tel:".concat(e).concat(r ? ";ext=" + r : "")
}

function gK(t, e) {
    var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r) return (r = r.call(t)).next.bind(r);
    if (Array.isArray(t) || (r = mK(t)) || e) {
        r && (t = r);
        var n = 0;
        return function() {
            return n >= t.length ? {
                done: !0
            } : {
                done: !1,
                value: t[n++]
            }
        }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function mK(t, e) {
    if (t) {
        if (typeof t == "string") return TE(t, e);
        var r = Object.prototype.toString.call(t).slice(8, -1);
        if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return TE(t, e)
    }
}

function TE(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
    return n
}

function PE(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        e && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(t, i).enumerable
        })), r.push.apply(r, n)
    }
    return r
}

function NE(t) {
    for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? PE(Object(r), !0).forEach(function(n) {
            yK(t, n, r[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : PE(Object(r)).forEach(function(n) {
            Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
        })
    }
    return t
}

function yK(t, e, r) {
    return e in t ? Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = r, t
}
var OE = {
    formatExtension: function(e, r, n) {
        return "".concat(e).concat(n.ext()).concat(r)
    }
};

function wK(t, e, r, n) {
    if (r ? r = NE(NE({}, OE), r) : r = OE, n = new wn(n), t.country && t.country !== "001") {
        if (!n.hasCountry(t.country)) throw new Error("Unknown country: ".concat(t.country));
        n.country(t.country)
    } else if (t.countryCallingCode) n.selectNumberingPlan(t.countryCallingCode);
    else return t.phone || "";
    var i = n.countryCallingCode(),
        s = r.v2 ? t.nationalNumber : t.phone,
        a;
    switch (e) {
        case "NATIONAL":
            return s ? (a = bm(s, t.carrierCode, "NATIONAL", n, r), Tw(a, t.ext, n, r.formatExtension)) : "";
        case "INTERNATIONAL":
            return s ? (a = bm(s, null, "INTERNATIONAL", n, r), a = "+".concat(i, " ").concat(a), Tw(a, t.ext, n, r.formatExtension)) : "+".concat(i);
        case "E.164":
            return "+".concat(i).concat(s);
        case "RFC3966":
            return pK({
                number: "+".concat(i).concat(s),
                ext: t.ext
            });
        case "IDD":
            if (!r.fromCountry) return;
            var o = vK(s, t.carrierCode, i, r.fromCountry, n);
            return Tw(o, t.ext, n, r.formatExtension);
        default:
            throw new Error('Unknown "format" argument passed to "formatNumber()": "'.concat(e, '"'))
    }
}

function bm(t, e, r, n, i) {
    var s = bK(n.formats(), t);
    return s ? iP(t, s, {
        useInternationalFormat: r === "INTERNATIONAL",
        withNationalPrefix: !(s.nationalPrefixIsOptionalWhenFormattingInNationalFormat() && i && i.nationalPrefix === !1),
        carrierCode: e,
        metadata: n
    }) : t
}

function bK(t, e) {
    for (var r = gK(t), n; !(n = r()).done;) {
        var i = n.value;
        if (i.leadingDigitsPatterns().length > 0) {
            var s = i.leadingDigitsPatterns()[i.leadingDigitsPatterns().length - 1];
            if (e.search(s) !== 0) continue
        }
        if (Xo(e, i.pattern())) return i
    }
}

function Tw(t, e, r, n) {
    return e ? n(t, e, r) : t
}

function vK(t, e, r, n, i) {
    var s = O1(n, i.metadata);
    if (s === r) {
        var a = bm(t, e, "NATIONAL", i);
        return r === "1" ? r + " " + a : a
    }
    var o = sK(n, void 0, i.metadata);
    if (o) return "".concat(o, " ").concat(r, " ").concat(bm(t, null, "INTERNATIONAL", i))
}

function jE(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        e && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(t, i).enumerable
        })), r.push.apply(r, n)
    }
    return r
}

function RE(t) {
    for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? jE(Object(r), !0).forEach(function(n) {
            xK(t, n, r[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : jE(Object(r)).forEach(function(n) {
            Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
        })
    }
    return t
}

function xK(t, e, r) {
    return e in t ? Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = r, t
}

function EK(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function _K(t, e) {
    for (var r = 0; r < e.length; r++) {
        var n = e[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
    }
}

function CK(t, e, r) {
    return e && _K(t.prototype, e), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}
var u6 = function() {
        function t(e, r, n) {
            if (EK(this, t), !e) throw new TypeError("First argument is required");
            if (typeof e != "string") throw new TypeError("First argument must be a string");
            if (e[0] === "+" && !r) throw new TypeError("`metadata` argument not passed");
            if (Jl(r) && Jl(r.countries)) {
                n = r;
                var i = e;
                if (!IK.test(i)) throw new Error('Invalid `number` argument passed: must consist of a "+" followed by digits');
                var s = d6(i, void 0, void 0, n),
                    a = s.countryCallingCode,
                    o = s.number;
                if (r = o, e = a, !r) throw new Error("Invalid `number` argument passed: too short")
            }
            if (!r) throw new TypeError("`nationalNumber` argument is required");
            if (typeof r != "string") throw new TypeError("`nationalNumber` argument must be a string");
            JT(n);
            var c = kK(e, n),
                l = c.country,
                u = c.countryCallingCode;
            this.country = l, this.countryCallingCode = u, this.nationalNumber = r, this.number = "+" + this.countryCallingCode + this.nationalNumber, this.getMetadata = function() {
                return n
            }
        }
        return CK(t, [{
            key: "setExt",
            value: function(r) {
                this.ext = r
            }
        }, {
            key: "getPossibleCountries",
            value: function() {
                return this.country ? [this.country] : HG(this.countryCallingCode, this.nationalNumber, this.getMetadata())
            }
        }, {
            key: "isPossible",
            value: function() {
                return FG(this, {
                    v2: !0
                }, this.getMetadata())
            }
        }, {
            key: "isValid",
            value: function() {
                return qG(this, {
                    v2: !0
                }, this.getMetadata())
            }
        }, {
            key: "isNonGeographic",
            value: function() {
                var r = new wn(this.getMetadata());
                return r.isNonGeographicCallingCode(this.countryCallingCode)
            }
        }, {
            key: "isEqual",
            value: function(r) {
                return this.number === r.number && this.ext === r.ext
            }
        }, {
            key: "getType",
            value: function() {
                return c6(this, {
                    v2: !0
                }, this.getMetadata())
            }
        }, {
            key: "format",
            value: function(r, n) {
                return wK(this, r, n ? RE(RE({}, n), {}, {
                    v2: !0
                }) : {
                    v2: !0
                }, this.getMetadata())
            }
        }, {
            key: "formatNational",
            value: function(r) {
                return this.format("NATIONAL", r)
            }
        }, {
            key: "formatInternational",
            value: function(r) {
                return this.format("INTERNATIONAL", r)
            }
        }, {
            key: "getURI",
            value: function(r) {
                return this.format("RFC3966", r)
            }
        }]), t
    }(),
    AK = function(e) {
        return /^[A-Z]{2}$/.test(e)
    };

function kK(t, e) {
    var r, n, i = new wn(e);
    return AK(t) ? (r = t, i.selectNumberingPlan(r), n = i.countryCallingCode()) : n = t, {
        country: r,
        countryCallingCode: n
    }
}
var IK = /^\+\d+$/;

function l3(t) {
    "@babel/helpers - typeof";
    return l3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    } : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }, l3(t)
}

function $K(t, e, r) {
    return Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}

function SK(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function TK(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(t, "prototype", {
        writable: !1
    }), e && bp(t, e)
}

function PK(t) {
    var e = oP();
    return function() {
        var n = vp(t),
            i;
        if (e) {
            var s = vp(this).constructor;
            i = Reflect.construct(n, arguments, s)
        } else i = n.apply(this, arguments);
        return NK(this, i)
    }
}

function NK(t, e) {
    if (e && (l3(e) === "object" || typeof e == "function")) return e;
    if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return aP(t)
}

function aP(t) {
    if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t
}

function d3(t) {
    var e = typeof Map == "function" ? new Map : void 0;
    return d3 = function(n) {
        if (n === null || !OK(n)) return n;
        if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof e < "u") {
            if (e.has(n)) return e.get(n);
            e.set(n, i)
        }

        function i() {
            return jg(n, arguments, vp(this).constructor)
        }
        return i.prototype = Object.create(n.prototype, {
            constructor: {
                value: i,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), bp(i, n)
    }, d3(t)
}

function jg(t, e, r) {
    return oP() ? jg = Reflect.construct : jg = function(i, s, a) {
        var o = [null];
        o.push.apply(o, s);
        var c = Function.bind.apply(i, o),
            l = new c;
        return a && bp(l, a.prototype), l
    }, jg.apply(null, arguments)
}

function oP() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
    } catch {
        return !1
    }
}

function OK(t) {
    return Function.toString.call(t).indexOf("[native code]") !== -1
}

function bp(t, e) {
    return bp = Object.setPrototypeOf || function(n, i) {
        return n.__proto__ = i, n
    }, bp(t, e)
}

function vp(t) {
    return vp = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
        return r.__proto__ || Object.getPrototypeOf(r)
    }, vp(t)
}
var jo = function(t) {
        TK(r, t);
        var e = PK(r);

        function r(n) {
            var i;
            return SK(this, r), i = e.call(this, n), Object.setPrototypeOf(aP(i), r.prototype), i.name = i.constructor.name, i
        }
        return $K(r)
    }(d3(Error)),
    ME = new RegExp("(?:" + sP() + ")$", "i");

function jK(t) {
    var e = t.search(ME);
    if (e < 0) return {};
    for (var r = t.slice(0, e), n = t.match(ME), i = 1; i < n.length;) {
        if (n[i]) return {
            number: r,
            ext: n[i]
        };
        i++
    }
}

function RK(t, e) {
    var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r) return (r = r.call(t)).next.bind(r);
    if (Array.isArray(t) || (r = MK(t)) || e) {
        r && (t = r);
        var n = 0;
        return function() {
            return n >= t.length ? {
                done: !0
            } : {
                done: !1,
                value: t[n++]
            }
        }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function MK(t, e) {
    if (t) {
        if (typeof t == "string") return DE(t, e);
        var r = Object.prototype.toString.call(t).slice(8, -1);
        if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return DE(t, e)
    }
}

function DE(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
    return n
}
var DK = {
    0: "0",
    1: "1",
    2: "2",
    3: "3",
    4: "4",
    5: "5",
    6: "6",
    7: "7",
    8: "8",
    9: "9",
    "０": "0",
    "１": "1",
    "２": "2",
    "３": "3",
    "４": "4",
    "５": "5",
    "６": "6",
    "７": "7",
    "８": "8",
    "９": "9",
    "٠": "0",
    "١": "1",
    "٢": "2",
    "٣": "3",
    "٤": "4",
    "٥": "5",
    "٦": "6",
    "٧": "7",
    "٨": "8",
    "٩": "9",
    "۰": "0",
    "۱": "1",
    "۲": "2",
    "۳": "3",
    "۴": "4",
    "۵": "5",
    "۶": "6",
    "۷": "7",
    "۸": "8",
    "۹": "9"
};

function cP(t) {
    return DK[t]
}

function vm(t) {
    for (var e = "", r = RK(t.split("")), n; !(n = r()).done;) {
        var i = n.value,
            s = cP(i);
        s && (e += s)
    }
    return e
}

function LK(t, e) {
    var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r) return (r = r.call(t)).next.bind(r);
    if (Array.isArray(t) || (r = UK(t)) || e) {
        r && (t = r);
        var n = 0;
        return function() {
            return n >= t.length ? {
                done: !0
            } : {
                done: !1,
                value: t[n++]
            }
        }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function UK(t, e) {
    if (t) {
        if (typeof t == "string") return LE(t, e);
        var r = Object.prototype.toString.call(t).slice(8, -1);
        if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return LE(t, e)
    }
}

function LE(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
    return n
}

function UE(t) {
    for (var e = "", r = LK(t.split("")), n; !(n = r()).done;) {
        var i = n.value;
        e += FK(i, e) || ""
    }
    return e
}

function FK(t, e, r) {
    return t === "+" ? e ? void 0 : "+" : cP(t)
}

function BK(t, e) {
    var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r) return (r = r.call(t)).next.bind(r);
    if (Array.isArray(t) || (r = WK(t)) || e) {
        r && (t = r);
        var n = 0;
        return function() {
            return n >= t.length ? {
                done: !0
            } : {
                done: !1,
                value: t[n++]
            }
        }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function WK(t, e) {
    if (t) {
        if (typeof t == "string") return FE(t, e);
        var r = Object.prototype.toString.call(t).slice(8, -1);
        if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return FE(t, e)
    }
}

function FE(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
    return n
}

function lP(t, e) {
    var r = e.countries;
    e.defaultCountry;
    var n = e.metadata;
    n = new wn(n);
    for (var i = BK(r), s; !(s = i()).done;) {
        var a = s.value;
        if (n.country(a), n.leadingDigits()) {
            if (t && t.search(n.leadingDigits()) === 0) return a
        } else if (c6({
                phone: t,
                country: a
            }, void 0, n.metadata)) return a
    }
}

function dP(t, e) {
    var r = e.nationalNumber,
        n = e.defaultCountry,
        i = e.metadata,
        s = i.getCountryCodesForCallingCode(t);
    if (s) return s.length === 1 ? s[0] : lP(r, {
        countries: s,
        defaultCountry: n,
        metadata: i.metadata
    })
}
var uP = "+",
    zK = "[\\-\\.\\(\\)]?",
    BE = "([" + mi + "]|" + zK + ")",
    qK = "^\\" + uP + BE + "*[" + mi + "]" + BE + "*$",
    HK = new RegExp(qK, "g"),
    u3 = mi,
    VK = "[" + u3 + "]+((\\-)*[" + u3 + "])*",
    GK = "a-zA-Z",
    KK = "[" + GK + "]+((\\-)*[" + u3 + "])*",
    YK = "^(" + VK + "\\.)*" + KK + "\\.?$",
    ZK = new RegExp(YK, "g"),
    WE = "tel:",
    h3 = ";phone-context=",
    JK = ";isub=";

function QK(t) {
    var e = t.indexOf(h3);
    if (e < 0) return null;
    var r = e + h3.length;
    if (r >= t.length) return "";
    var n = t.indexOf(";", r);
    return n >= 0 ? t.substring(r, n) : t.substring(r)
}

function XK(t) {
    return t === null ? !0 : t.length === 0 ? !1 : HK.test(t) || ZK.test(t)
}

function eY(t, e) {
    var r = e.extractFormattedPhoneNumber,
        n = QK(t);
    if (!XK(n)) throw new jo("NOT_A_NUMBER");
    var i;
    if (n === null) i = r(t) || "";
    else {
        i = "", n.charAt(0) === uP && (i += n);
        var s = t.indexOf(WE),
            a;
        s >= 0 ? a = s + WE.length : a = 0;
        var o = t.indexOf(h3);
        i += t.substring(a, o)
    }
    var c = i.indexOf(JK);
    if (c > 0 && (i = i.substring(0, c)), i !== "") return i
}
var tY = 250,
    rY = new RegExp("[" + R1 + mi + "]"),
    nY = new RegExp("[^" + mi + "#]+$");

function iY(t, e, r) {
    if (e = e || {}, r = new wn(r), e.defaultCountry && !r.hasCountry(e.defaultCountry)) throw e.v2 ? new jo("INVALID_COUNTRY") : new Error("Unknown country: ".concat(e.defaultCountry));
    var n = aY(t, e.v2, e.extract),
        i = n.number,
        s = n.ext,
        a = n.error;
    if (!i) {
        if (e.v2) throw a === "TOO_SHORT" ? new jo("TOO_SHORT") : new jo("NOT_A_NUMBER");
        return {}
    }
    var o = cY(i, e.defaultCountry, e.defaultCallingCode, r),
        c = o.country,
        l = o.nationalNumber,
        u = o.countryCallingCode,
        h = o.countryCallingCodeSource,
        f = o.carrierCode;
    if (!r.hasSelectedNumberingPlan()) {
        if (e.v2) throw new jo("INVALID_COUNTRY");
        return {}
    }
    if (!l || l.length < l6) {
        if (e.v2) throw new jo("TOO_SHORT");
        return {}
    }
    if (l.length > GG) {
        if (e.v2) throw new jo("TOO_LONG");
        return {}
    }
    if (e.v2) {
        var p = new u6(u, l, r.metadata);
        return c && (p.country = c), f && (p.carrierCode = f), s && (p.ext = s), p.__countryCallingCodeSource = h, p
    }
    var g = (e.extended ? r.hasSelectedNumberingPlan() : c) ? Xo(l, r.nationalNumberPattern()) : !1;
    return e.extended ? {
        country: c,
        countryCallingCode: u,
        carrierCode: f,
        valid: g,
        possible: g ? !0 : !!(e.extended === !0 && r.possibleLengths() && XT(l, r)),
        phone: l,
        ext: s
    } : g ? oY(c, l, s) : {}
}

function sY(t, e, r) {
    if (t) {
        if (t.length > tY) {
            if (r) throw new jo("TOO_LONG");
            return
        }
        if (e === !1) return t;
        var n = t.search(rY);
        if (!(n < 0)) return t.slice(n).replace(nY, "")
    }
}

function aY(t, e, r) {
    var n = eY(t, {
        extractFormattedPhoneNumber: function(a) {
            return sY(a, r, e)
        }
    });
    if (!n) return {};
    if (!hK(n)) return fK(n) ? {
        error: "TOO_SHORT"
    } : {};
    var i = jK(n);
    return i.ext ? i : {
        number: n
    }
}

function oY(t, e, r) {
    var n = {
        country: t,
        phone: e
    };
    return r && (n.ext = r), n
}

function cY(t, e, r, n) {
    var i = d6(UE(t), e, r, n.metadata),
        s = i.countryCallingCodeSource,
        a = i.countryCallingCode,
        o = i.number,
        c;
    if (a) n.selectNumberingPlan(a);
    else if (o && (e || r)) n.selectNumberingPlan(e, r), e && (c = e), a = r || O1(e, n.metadata);
    else return {};
    if (!o) return {
        countryCallingCodeSource: s,
        countryCallingCode: a
    };
    var l = c3(UE(o), n),
        u = l.nationalNumber,
        h = l.carrierCode,
        f = dP(a, {
            nationalNumber: u,
            defaultCountry: e,
            metadata: n
        });
    return f && (c = f, f === "001" || n.country(c)), {
        country: c,
        countryCallingCode: a,
        countryCallingCodeSource: s,
        nationalNumber: u,
        carrierCode: h
    }
}

function zE(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        e && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(t, i).enumerable
        })), r.push.apply(r, n)
    }
    return r
}

function qE(t) {
    for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? zE(Object(r), !0).forEach(function(n) {
            lY(t, n, r[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : zE(Object(r)).forEach(function(n) {
            Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
        })
    }
    return t
}

function lY(t, e, r) {
    return e in t ? Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = r, t
}

function dY(t, e, r) {
    return iY(t, qE(qE({}, e), {}, {
        v2: !0
    }), r)
}

function HE(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        e && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(t, i).enumerable
        })), r.push.apply(r, n)
    }
    return r
}

function uY(t) {
    for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? HE(Object(r), !0).forEach(function(n) {
            hY(t, n, r[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : HE(Object(r)).forEach(function(n) {
            Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
        })
    }
    return t
}

function hY(t, e, r) {
    return e in t ? Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = r, t
}

function fY(t, e) {
    return yY(t) || mY(t, e) || gY(t, e) || pY()
}

function pY() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function gY(t, e) {
    if (t) {
        if (typeof t == "string") return VE(t, e);
        var r = Object.prototype.toString.call(t).slice(8, -1);
        if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return VE(t, e)
    }
}

function VE(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
    return n
}

function mY(t, e) {
    var r = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r != null) {
        var n = [],
            i = !0,
            s = !1,
            a, o;
        try {
            for (r = r.call(t); !(i = (a = r.next()).done) && (n.push(a.value), !(e && n.length === e)); i = !0);
        } catch (c) {
            s = !0, o = c
        } finally {
            try {
                !i && r.return != null && r.return()
            } finally {
                if (s) throw o
            }
        }
        return n
    }
}

function yY(t) {
    if (Array.isArray(t)) return t
}

function wY(t) {
    var e = Array.prototype.slice.call(t),
        r = fY(e, 4),
        n = r[0],
        i = r[1],
        s = r[2],
        a = r[3],
        o, c, l;
    if (typeof n == "string") o = n;
    else throw new TypeError("A text for parsing must be a string.");
    if (!i || typeof i == "string") a ? (c = s, l = a) : (c = void 0, l = s), i && (c = uY({
        defaultCountry: i
    }, c));
    else if (Jl(i)) s ? (c = i, l = s) : l = i;
    else throw new Error("Invalid second argument: ".concat(i));
    return {
        text: o,
        options: c,
        metadata: l
    }
}

function GE(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        e && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(t, i).enumerable
        })), r.push.apply(r, n)
    }
    return r
}

function KE(t) {
    for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? GE(Object(r), !0).forEach(function(n) {
            bY(t, n, r[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : GE(Object(r)).forEach(function(n) {
            Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
        })
    }
    return t
}

function bY(t, e, r) {
    return e in t ? Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = r, t
}

function vY(t, e, r) {
    e && e.defaultCountry && !LG(e.defaultCountry, r) && (e = KE(KE({}, e), {}, {
        defaultCountry: void 0
    }));
    try {
        return dY(t, e, r)
    } catch (n) {
        if (!(n instanceof jo)) throw n
    }
}

function YE(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        e && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(t, i).enumerable
        })), r.push.apply(r, n)
    }
    return r
}

function ZE(t) {
    for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? YE(Object(r), !0).forEach(function(n) {
            xY(t, n, r[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : YE(Object(r)).forEach(function(n) {
            Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
        })
    }
    return t
}

function xY(t, e, r) {
    return e in t ? Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = r, t
}

function EY() {
    var t = wY(arguments),
        e = t.text,
        r = t.options,
        n = t.metadata;
    r = ZE(ZE({}, r), {}, {
        extract: !1
    });
    var i = vY(e, r, n);
    return i && i.isPossible() || !1
}

function _Y(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function CY(t, e) {
    for (var r = 0; r < e.length; r++) {
        var n = e[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
    }
}

function AY(t, e, r) {
    return e && CY(t.prototype, e), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}
var kY = function() {
    function t(e) {
        var r = e.onCountryChange,
            n = e.onCallingCodeChange;
        _Y(this, t), this.onCountryChange = r, this.onCallingCodeChange = n
    }
    return AY(t, [{
        key: "reset",
        value: function(r) {
            var n = r.country,
                i = r.callingCode;
            this.international = !1, this.missingPlus = !1, this.IDDPrefix = void 0, this.callingCode = void 0, this.digits = "", this.resetNationalSignificantNumber(), this.initCountryAndCallingCode(n, i)
        }
    }, {
        key: "resetNationalSignificantNumber",
        value: function() {
            this.nationalSignificantNumber = this.getNationalDigits(), this.nationalSignificantNumberMatchesInput = !0, this.nationalPrefix = void 0, this.carrierCode = void 0, this.complexPrefixBeforeNationalSignificantNumber = void 0
        }
    }, {
        key: "update",
        value: function(r) {
            for (var n = 0, i = Object.keys(r); n < i.length; n++) {
                var s = i[n];
                this[s] = r[s]
            }
        }
    }, {
        key: "initCountryAndCallingCode",
        value: function(r, n) {
            this.setCountry(r), this.setCallingCode(n)
        }
    }, {
        key: "setCountry",
        value: function(r) {
            this.country = r, this.onCountryChange(r)
        }
    }, {
        key: "setCallingCode",
        value: function(r) {
            this.callingCode = r, this.onCallingCodeChange(r, this.country)
        }
    }, {
        key: "startInternationalNumber",
        value: function(r, n) {
            this.international = !0, this.initCountryAndCallingCode(r, n)
        }
    }, {
        key: "appendDigits",
        value: function(r) {
            this.digits += r
        }
    }, {
        key: "appendNationalSignificantNumberDigits",
        value: function(r) {
            this.nationalSignificantNumber += r
        }
    }, {
        key: "getNationalDigits",
        value: function() {
            return this.international ? this.digits.slice((this.IDDPrefix ? this.IDDPrefix.length : 0) + (this.callingCode ? this.callingCode.length : 0)) : this.digits
        }
    }, {
        key: "getDigitsWithoutInternationalPrefix",
        value: function() {
            return this.international && this.IDDPrefix ? this.digits.slice(this.IDDPrefix.length) : this.digits
        }
    }]), t
}();

function IY(t, e) {
    var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r) return (r = r.call(t)).next.bind(r);
    if (Array.isArray(t) || (r = $Y(t)) || e) {
        r && (t = r);
        var n = 0;
        return function() {
            return n >= t.length ? {
                done: !0
            } : {
                done: !1,
                value: t[n++]
            }
        }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function $Y(t, e) {
    if (t) {
        if (typeof t == "string") return JE(t, e);
        var r = Object.prototype.toString.call(t).slice(8, -1);
        if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return JE(t, e)
    }
}

function JE(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
    return n
}
var ia = "x",
    Pw = new RegExp(ia);

function Rg(t, e) {
    if (e < 1) return "";
    for (var r = ""; e > 1;) e & 1 && (r += t), e >>= 1, t += t;
    return r + t
}

function QE(t, e) {
    return t[e] === ")" && e++, SY(t.slice(0, e))
}

function SY(t) {
    for (var e = [], r = 0; r < t.length;) t[r] === "(" ? e.push(r) : t[r] === ")" && e.pop(), r++;
    var n = 0,
        i = "";
    e.push(t.length);
    for (var s = 0, a = e; s < a.length; s++) {
        var o = a[s];
        i += t.slice(n, o), n = o + 1
    }
    return i
}

function TY(t, e, r) {
    for (var n = IY(r.split("")), i; !(i = n()).done;) {
        var s = i.value;
        if (t.slice(e + 1).search(Pw) < 0) return;
        e = t.search(Pw), t = t.replace(Pw, s)
    }
    return [t, e]
}

function PY(t, e, r) {
    var n = r.metadata,
        i = r.shouldTryNationalPrefixFormattingRule,
        s = r.getSeparatorAfterNationalPrefix,
        a = new RegExp("^(?:".concat(e.pattern(), ")$"));
    if (a.test(t.nationalSignificantNumber)) return OY(t, e, {
        metadata: n,
        shouldTryNationalPrefixFormattingRule: i,
        getSeparatorAfterNationalPrefix: s
    })
}

function NY(t, e) {
    return j1(t, e) === "IS_POSSIBLE"
}

function OY(t, e, r) {
    var n = r.metadata,
        i = r.shouldTryNationalPrefixFormattingRule,
        s = r.getSeparatorAfterNationalPrefix;
    if (t.nationalSignificantNumber, t.international, t.nationalPrefix, t.carrierCode, i(e)) {
        var a = XE(t, e, {
            useNationalPrefixFormattingRule: !0,
            getSeparatorAfterNationalPrefix: s,
            metadata: n
        });
        if (a) return a
    }
    return XE(t, e, {
        useNationalPrefixFormattingRule: !1,
        getSeparatorAfterNationalPrefix: s,
        metadata: n
    })
}

function XE(t, e, r) {
    var n = r.metadata,
        i = r.useNationalPrefixFormattingRule,
        s = r.getSeparatorAfterNationalPrefix,
        a = iP(t.nationalSignificantNumber, e, {
            carrierCode: t.carrierCode,
            useInternationalFormat: t.international,
            withNationalPrefix: i,
            metadata: n
        });
    if (i || (t.nationalPrefix ? a = t.nationalPrefix + s(e) + a : t.complexPrefixBeforeNationalSignificantNumber && (a = t.complexPrefixBeforeNationalSignificantNumber + " " + a)), jY(a, t)) return a
}

function jY(t, e) {
    return vm(t) === e.getNationalDigits()
}

function RY(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function MY(t, e) {
    for (var r = 0; r < e.length; r++) {
        var n = e[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
    }
}

function DY(t, e, r) {
    return e && MY(t.prototype, e), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}
var LY = function() {
    function t() {
        RY(this, t)
    }
    return DY(t, [{
        key: "parse",
        value: function(r) {
            if (this.context = [{
                    or: !0,
                    instructions: []
                }], this.parsePattern(r), this.context.length !== 1) throw new Error("Non-finalized contexts left when pattern parse ended");
            var n = this.context[0],
                i = n.branches,
                s = n.instructions;
            if (i) return {
                op: "|",
                args: i.concat([Nw(s)])
            };
            if (s.length === 0) throw new Error("Pattern is required");
            return s.length === 1 ? s[0] : s
        }
    }, {
        key: "startContext",
        value: function(r) {
            this.context.push(r)
        }
    }, {
        key: "endContext",
        value: function() {
            this.context.pop()
        }
    }, {
        key: "getContext",
        value: function() {
            return this.context[this.context.length - 1]
        }
    }, {
        key: "parsePattern",
        value: function(r) {
            if (!r) throw new Error("Pattern is required");
            var n = r.match(BY);
            if (!n) {
                if (FY.test(r)) throw new Error("Illegal characters found in a pattern: ".concat(r));
                this.getContext().instructions = this.getContext().instructions.concat(r.split(""));
                return
            }
            var i = n[1],
                s = r.slice(0, n.index),
                a = r.slice(n.index + i.length);
            switch (i) {
                case "(?:":
                    s && this.parsePattern(s), this.startContext({
                        or: !0,
                        instructions: [],
                        branches: []
                    });
                    break;
                case ")":
                    if (!this.getContext().or) throw new Error('")" operator must be preceded by "(?:" operator');
                    if (s && this.parsePattern(s), this.getContext().instructions.length === 0) throw new Error('No instructions found after "|" operator in an "or" group');
                    var o = this.getContext(),
                        c = o.branches;
                    c.push(Nw(this.getContext().instructions)), this.endContext(), this.getContext().instructions.push({
                        op: "|",
                        args: c
                    });
                    break;
                case "|":
                    if (!this.getContext().or) throw new Error('"|" operator can only be used inside "or" groups');
                    if (s && this.parsePattern(s), !this.getContext().branches)
                        if (this.context.length === 1) this.getContext().branches = [];
                        else throw new Error('"branches" not found in an "or" group context');
                    this.getContext().branches.push(Nw(this.getContext().instructions)), this.getContext().instructions = [];
                    break;
                case "[":
                    s && this.parsePattern(s), this.startContext({
                        oneOfSet: !0
                    });
                    break;
                case "]":
                    if (!this.getContext().oneOfSet) throw new Error('"]" operator must be preceded by "[" operator');
                    this.endContext(), this.getContext().instructions.push({
                        op: "[]",
                        args: UY(s)
                    });
                    break;
                default:
                    throw new Error("Unknown operator: ".concat(i))
            }
            a && this.parsePattern(a)
        }
    }]), t
}();

function UY(t) {
    for (var e = [], r = 0; r < t.length;) {
        if (t[r] === "-") {
            if (r === 0 || r === t.length - 1) throw new Error("Couldn't parse a one-of set pattern: ".concat(t));
            for (var n = t[r - 1].charCodeAt(0) + 1, i = t[r + 1].charCodeAt(0) - 1, s = n; s <= i;) e.push(String.fromCharCode(s)), s++
        } else e.push(t[r]);
        r++
    }
    return e
}
var FY = /[\(\)\[\]\?\:\|]/,
    BY = new RegExp("(\\||\\(\\?\\:|\\)|\\[|\\])");

function Nw(t) {
    return t.length === 1 ? t[0] : t
}

function e7(t, e) {
    var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r) return (r = r.call(t)).next.bind(r);
    if (Array.isArray(t) || (r = WY(t)) || e) {
        r && (t = r);
        var n = 0;
        return function() {
            return n >= t.length ? {
                done: !0
            } : {
                done: !1,
                value: t[n++]
            }
        }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function WY(t, e) {
    if (t) {
        if (typeof t == "string") return t7(t, e);
        var r = Object.prototype.toString.call(t).slice(8, -1);
        if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return t7(t, e)
    }
}

function t7(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
    return n
}

function zY(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function qY(t, e) {
    for (var r = 0; r < e.length; r++) {
        var n = e[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
    }
}

function HY(t, e, r) {
    return e && qY(t.prototype, e), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}
var VY = function() {
    function t(e) {
        zY(this, t), this.matchTree = new LY().parse(e)
    }
    return HY(t, [{
        key: "match",
        value: function(r) {
            var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                i = n.allowOverflow;
            if (!r) throw new Error("String is required");
            var s = f3(r.split(""), this.matchTree, !0);
            if (s && s.match && delete s.matchedChars, !(s && s.overflow && !i)) return s
        }
    }]), t
}();

function f3(t, e, r) {
    if (typeof e == "string") {
        var n = t.join("");
        return e.indexOf(n) === 0 ? t.length === e.length ? {
            match: !0,
            matchedChars: t
        } : {
            partialMatch: !0
        } : n.indexOf(e) === 0 ? r && t.length > e.length ? {
            overflow: !0
        } : {
            match: !0,
            matchedChars: t.slice(0, e.length)
        } : void 0
    }
    if (Array.isArray(e)) {
        for (var i = t.slice(), s = 0; s < e.length;) {
            var a = e[s],
                o = f3(i, a, r && s === e.length - 1);
            if (o) {
                if (o.overflow) return o;
                if (o.match) {
                    if (i = i.slice(o.matchedChars.length), i.length === 0) return s === e.length - 1 ? {
                        match: !0,
                        matchedChars: t
                    } : {
                        partialMatch: !0
                    }
                } else {
                    if (o.partialMatch) return {
                        partialMatch: !0
                    };
                    throw new Error(`Unsupported match result:
`.concat(JSON.stringify(o, null, 2)))
                }
            } else return;
            s++
        }
        return r ? {
            overflow: !0
        } : {
            match: !0,
            matchedChars: t.slice(0, t.length - i.length)
        }
    }
    switch (e.op) {
        case "|":
            for (var c, l = e7(e.args), u; !(u = l()).done;) {
                var h = u.value,
                    f = f3(t, h, r);
                if (f) {
                    if (f.overflow) return f;
                    if (f.match) return {
                        match: !0,
                        matchedChars: f.matchedChars
                    };
                    if (f.partialMatch) c = !0;
                    else throw new Error(`Unsupported match result:
`.concat(JSON.stringify(f, null, 2)))
                }
            }
            return c ? {
                partialMatch: !0
            } : void 0;
        case "[]":
            for (var p = e7(e.args), g; !(g = p()).done;) {
                var m = g.value;
                if (t[0] === m) return t.length === 1 ? {
                    match: !0,
                    matchedChars: t
                } : r ? {
                    overflow: !0
                } : {
                    match: !0,
                    matchedChars: [m]
                }
            }
            return;
        default:
            throw new Error("Unsupported instruction tree: ".concat(e))
    }
}

function r7(t, e) {
    var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r) return (r = r.call(t)).next.bind(r);
    if (Array.isArray(t) || (r = GY(t)) || e) {
        r && (t = r);
        var n = 0;
        return function() {
            return n >= t.length ? {
                done: !0
            } : {
                done: !1,
                value: t[n++]
            }
        }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function GY(t, e) {
    if (t) {
        if (typeof t == "string") return n7(t, e);
        var r = Object.prototype.toString.call(t).slice(8, -1);
        if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return n7(t, e)
    }
}

function n7(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
    return n
}

function KY(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function YY(t, e) {
    for (var r = 0; r < e.length; r++) {
        var n = e[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
    }
}

function ZY(t, e, r) {
    return e && YY(t.prototype, e), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}
var p3 = "9",
    JY = 15,
    QY = Rg(p3, JY),
    XY = /[- ]/,
    eZ = function() {
        return /\[([^\[\]])*\]/g
    },
    tZ = function() {
        return /\d(?=[^,}][^,}])/g
    },
    rZ = new RegExp("[" + ya + "]*\\$1[" + ya + "]*(\\$\\d[" + ya + "]*)*$"),
    i7 = 3,
    nZ = function() {
        function t(e) {
            e.state;
            var r = e.metadata;
            KY(this, t), this.metadata = r, this.resetFormat()
        }
        return ZY(t, [{
            key: "resetFormat",
            value: function() {
                this.chosenFormat = void 0, this.template = void 0, this.nationalNumberTemplate = void 0, this.populatedNationalNumberTemplate = void 0, this.populatedNationalNumberTemplatePosition = -1
            }
        }, {
            key: "reset",
            value: function(r, n) {
                this.resetFormat(), r ? (this.isNANP = r.callingCode() === "1", this.matchingFormats = r.formats(), n.nationalSignificantNumber && this.narrowDownMatchingFormats(n)) : (this.isNANP = void 0, this.matchingFormats = [])
            }
        }, {
            key: "format",
            value: function(r, n) {
                var i = this;
                if (NY(n.nationalSignificantNumber, this.metadata))
                    for (var s = r7(this.matchingFormats), a; !(a = s()).done;) {
                        var o = a.value,
                            c = PY(n, o, {
                                metadata: this.metadata,
                                shouldTryNationalPrefixFormattingRule: function(u) {
                                    return i.shouldTryNationalPrefixFormattingRule(u, {
                                        international: n.international,
                                        nationalPrefix: n.nationalPrefix
                                    })
                                },
                                getSeparatorAfterNationalPrefix: function(u) {
                                    return i.getSeparatorAfterNationalPrefix(u)
                                }
                            });
                        if (c) return this.resetFormat(), this.chosenFormat = o, this.setNationalNumberTemplate(c.replace(/\d/g, ia), n), this.populatedNationalNumberTemplate = c, this.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(ia), c
                    }
                return this.formatNationalNumberWithNextDigits(r, n)
            }
        }, {
            key: "formatNationalNumberWithNextDigits",
            value: function(r, n) {
                var i = this.chosenFormat,
                    s = this.chooseFormat(n);
                if (s) return s === i ? this.formatNextNationalNumberDigits(r) : this.formatNextNationalNumberDigits(n.getNationalDigits())
            }
        }, {
            key: "narrowDownMatchingFormats",
            value: function(r) {
                var n = this,
                    i = r.nationalSignificantNumber,
                    s = r.nationalPrefix,
                    a = r.international,
                    o = i,
                    c = o.length - i7;
                c < 0 && (c = 0), this.matchingFormats = this.matchingFormats.filter(function(l) {
                    return n.formatSuits(l, a, s) && n.formatMatches(l, o, c)
                }), this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1 && this.resetFormat()
            }
        }, {
            key: "formatSuits",
            value: function(r, n, i) {
                return !(i && !r.usesNationalPrefix() && !r.nationalPrefixIsOptionalWhenFormattingInNationalFormat() || !n && !i && r.nationalPrefixIsMandatoryWhenFormattingInNationalFormat())
            }
        }, {
            key: "formatMatches",
            value: function(r, n, i) {
                var s = r.leadingDigitsPatterns().length;
                if (s === 0) return !0;
                i = Math.min(i, s - 1);
                var a = r.leadingDigitsPatterns()[i];
                if (n.length < i7) try {
                    return new VY(a).match(n, {
                        allowOverflow: !0
                    }) !== void 0
                } catch (o) {
                    return console.error(o), !0
                }
                return new RegExp("^(".concat(a, ")")).test(n)
            }
        }, {
            key: "getFormatFormat",
            value: function(r, n) {
                return n ? r.internationalFormat() : r.format()
            }
        }, {
            key: "chooseFormat",
            value: function(r) {
                for (var n = this, i = function() {
                        var l = a.value;
                        return n.chosenFormat === l ? "break" : rZ.test(n.getFormatFormat(l, r.international)) ? n.createTemplateForFormat(l, r) ? (n.chosenFormat = l, "break") : (n.matchingFormats = n.matchingFormats.filter(function(u) {
                            return u !== l
                        }), "continue") : "continue"
                    }, s = r7(this.matchingFormats.slice()), a; !(a = s()).done;) {
                    var o = i();
                    if (o === "break") break
                }
                return this.chosenFormat || this.resetFormat(), this.chosenFormat
            }
        }, {
            key: "createTemplateForFormat",
            value: function(r, n) {
                if (!(r.pattern().indexOf("|") >= 0)) {
                    var i = this.getTemplateForFormat(r, n);
                    if (i) return this.setNationalNumberTemplate(i, n), !0
                }
            }
        }, {
            key: "getSeparatorAfterNationalPrefix",
            value: function(r) {
                return this.isNANP || r && r.nationalPrefixFormattingRule() && XY.test(r.nationalPrefixFormattingRule()) ? " " : ""
            }
        }, {
            key: "getInternationalPrefixBeforeCountryCallingCode",
            value: function(r, n) {
                var i = r.IDDPrefix,
                    s = r.missingPlus;
                return i ? n && n.spacing === !1 ? i : i + " " : s ? "" : "+"
            }
        }, {
            key: "getTemplate",
            value: function(r) {
                if (this.template) {
                    for (var n = -1, i = 0, s = r.international ? this.getInternationalPrefixBeforeCountryCallingCode(r, {
                            spacing: !1
                        }) : ""; i < s.length + r.getDigitsWithoutInternationalPrefix().length;) n = this.template.indexOf(ia, n + 1), i++;
                    return QE(this.template, n + 1)
                }
            }
        }, {
            key: "setNationalNumberTemplate",
            value: function(r, n) {
                this.nationalNumberTemplate = r, this.populatedNationalNumberTemplate = r, this.populatedNationalNumberTemplatePosition = -1, n.international ? this.template = this.getInternationalPrefixBeforeCountryCallingCode(n).replace(/[\d\+]/g, ia) + Rg(ia, n.callingCode.length) + " " + r : this.template = r
            }
        }, {
            key: "getTemplateForFormat",
            value: function(r, n) {
                var i = n.nationalSignificantNumber,
                    s = n.international,
                    a = n.nationalPrefix,
                    o = n.complexPrefixBeforeNationalSignificantNumber,
                    c = r.pattern();
                c = c.replace(eZ(), "\\d").replace(tZ(), "\\d");
                var l = QY.match(c)[0];
                if (!(i.length > l.length)) {
                    var u = new RegExp("^" + c + "$"),
                        h = i.replace(/\d/g, p3);
                    u.test(h) && (l = h);
                    var f = this.getFormatFormat(r, s),
                        p;
                    if (this.shouldTryNationalPrefixFormattingRule(r, {
                            international: s,
                            nationalPrefix: a
                        })) {
                        var g = f.replace(nP, r.nationalPrefixFormattingRule());
                        if (vm(r.nationalPrefixFormattingRule()) === (a || "") + vm("$1") && (f = g, p = !0, a))
                            for (var m = a.length; m > 0;) f = f.replace(/\d/, ia), m--
                    }
                    var y = l.replace(new RegExp(c), f).replace(new RegExp(p3, "g"), ia);
                    return p || (o ? y = Rg(ia, o.length) + " " + y : a && (y = Rg(ia, a.length) + this.getSeparatorAfterNationalPrefix(r) + y)), s && (y = rP(y)), y
                }
            }
        }, {
            key: "formatNextNationalNumberDigits",
            value: function(r) {
                var n = TY(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition, r);
                if (!n) {
                    this.resetFormat();
                    return
                }
                return this.populatedNationalNumberTemplate = n[0], this.populatedNationalNumberTemplatePosition = n[1], QE(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)
            }
        }, {
            key: "shouldTryNationalPrefixFormattingRule",
            value: function(r, n) {
                var i = n.international,
                    s = n.nationalPrefix;
                if (r.nationalPrefixFormattingRule()) {
                    var a = r.usesNationalPrefix();
                    if (a && s || !a && !i) return !0
                }
            }
        }]), t
    }();

function hP(t, e) {
    return oZ(t) || aZ(t, e) || sZ(t, e) || iZ()
}

function iZ() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function sZ(t, e) {
    if (t) {
        if (typeof t == "string") return s7(t, e);
        var r = Object.prototype.toString.call(t).slice(8, -1);
        if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return s7(t, e)
    }
}

function s7(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
    return n
}

function aZ(t, e) {
    var r = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r != null) {
        var n = [],
            i = !0,
            s = !1,
            a, o;
        try {
            for (r = r.call(t); !(i = (a = r.next()).done) && (n.push(a.value), !(e && n.length === e)); i = !0);
        } catch (c) {
            s = !0, o = c
        } finally {
            try {
                !i && r.return != null && r.return()
            } finally {
                if (s) throw o
            }
        }
        return n
    }
}

function oZ(t) {
    if (Array.isArray(t)) return t
}

function cZ(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function lZ(t, e) {
    for (var r = 0; r < e.length; r++) {
        var n = e[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
    }
}

function dZ(t, e, r) {
    return e && lZ(t.prototype, e), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}
var uZ = "[" + ya + mi + "]+",
    hZ = new RegExp("^" + uZ + "$", "i"),
    fZ = "(?:[" + R1 + "][" + ya + mi + "]*|[" + ya + mi + "]+)",
    pZ = new RegExp("[^" + ya + mi + "]+.*$"),
    gZ = /[^\d\[\]]/,
    mZ = function() {
        function t(e) {
            var r = e.defaultCountry,
                n = e.defaultCallingCode,
                i = e.metadata,
                s = e.onNationalSignificantNumberChange;
            cZ(this, t), this.defaultCountry = r, this.defaultCallingCode = n, this.metadata = i, this.onNationalSignificantNumberChange = s
        }
        return dZ(t, [{
            key: "input",
            value: function(r, n) {
                var i = bZ(r),
                    s = hP(i, 2),
                    a = s[0],
                    o = s[1],
                    c = vm(a),
                    l;
                return o && (n.digits || (n.startInternationalNumber(), c || (l = !0))), c && this.inputDigits(c, n), {
                    digits: c,
                    justLeadingPlus: l
                }
            }
        }, {
            key: "inputDigits",
            value: function(r, n) {
                var i = n.digits,
                    s = i.length < 3 && i.length + r.length >= 3;
                if (n.appendDigits(r), s && this.extractIddPrefix(n), this.isWaitingForCountryCallingCode(n)) {
                    if (!this.extractCountryCallingCode(n)) return
                } else n.appendNationalSignificantNumberDigits(r);
                n.international || this.hasExtractedNationalSignificantNumber || this.extractNationalSignificantNumber(n.getNationalDigits(), function(a) {
                    return n.update(a)
                })
            }
        }, {
            key: "isWaitingForCountryCallingCode",
            value: function(r) {
                var n = r.international,
                    i = r.callingCode;
                return n && !i
            }
        }, {
            key: "extractCountryCallingCode",
            value: function(r) {
                var n = d6("+" + r.getDigitsWithoutInternationalPrefix(), this.defaultCountry, this.defaultCallingCode, this.metadata.metadata),
                    i = n.countryCallingCode,
                    s = n.number;
                if (i) return r.setCallingCode(i), r.update({
                    nationalSignificantNumber: s
                }), !0
            }
        }, {
            key: "reset",
            value: function(r) {
                if (r) {
                    this.hasSelectedNumberingPlan = !0;
                    var n = r._nationalPrefixForParsing();
                    this.couldPossiblyExtractAnotherNationalSignificantNumber = n && gZ.test(n)
                } else this.hasSelectedNumberingPlan = void 0, this.couldPossiblyExtractAnotherNationalSignificantNumber = void 0
            }
        }, {
            key: "extractNationalSignificantNumber",
            value: function(r, n) {
                if (this.hasSelectedNumberingPlan) {
                    var i = o3(r, this.metadata),
                        s = i.nationalPrefix,
                        a = i.nationalNumber,
                        o = i.carrierCode;
                    if (a !== r) return this.onExtractedNationalNumber(s, o, a, r, n), !0
                }
            }
        }, {
            key: "extractAnotherNationalSignificantNumber",
            value: function(r, n, i) {
                if (!this.hasExtractedNationalSignificantNumber) return this.extractNationalSignificantNumber(r, i);
                if (this.couldPossiblyExtractAnotherNationalSignificantNumber) {
                    var s = o3(r, this.metadata),
                        a = s.nationalPrefix,
                        o = s.nationalNumber,
                        c = s.carrierCode;
                    if (o !== n) return this.onExtractedNationalNumber(a, c, o, r, i), !0
                }
            }
        }, {
            key: "onExtractedNationalNumber",
            value: function(r, n, i, s, a) {
                var o, c, l = s.lastIndexOf(i);
                if (l >= 0 && l === s.length - i.length) {
                    c = !0;
                    var u = s.slice(0, l);
                    u !== r && (o = u)
                }
                a({
                    nationalPrefix: r,
                    carrierCode: n,
                    nationalSignificantNumber: i,
                    nationalSignificantNumberMatchesInput: c,
                    complexPrefixBeforeNationalSignificantNumber: o
                }), this.hasExtractedNationalSignificantNumber = !0, this.onNationalSignificantNumberChange()
            }
        }, {
            key: "reExtractNationalSignificantNumber",
            value: function(r) {
                if (this.extractAnotherNationalSignificantNumber(r.getNationalDigits(), r.nationalSignificantNumber, function(n) {
                        return r.update(n)
                    })) return !0;
                if (this.extractIddPrefix(r)) return this.extractCallingCodeAndNationalSignificantNumber(r), !0;
                if (this.fixMissingPlus(r)) return this.extractCallingCodeAndNationalSignificantNumber(r), !0
            }
        }, {
            key: "extractIddPrefix",
            value: function(r) {
                var n = r.international,
                    i = r.IDDPrefix,
                    s = r.digits;
                if (r.nationalSignificantNumber, !(n || i)) {
                    var a = eP(s, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata);
                    if (a !== void 0 && a !== s) return r.update({
                        IDDPrefix: s.slice(0, s.length - a.length)
                    }), this.startInternationalNumber(r, {
                        country: void 0,
                        callingCode: void 0
                    }), !0
                }
            }
        }, {
            key: "fixMissingPlus",
            value: function(r) {
                if (!r.international) {
                    var n = tP(r.digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata),
                        i = n.countryCallingCode;
                    if (n.number, i) return r.update({
                        missingPlus: !0
                    }), this.startInternationalNumber(r, {
                        country: r.country,
                        callingCode: i
                    }), !0
                }
            }
        }, {
            key: "startInternationalNumber",
            value: function(r, n) {
                var i = n.country,
                    s = n.callingCode;
                r.startInternationalNumber(i, s), r.nationalSignificantNumber && (r.resetNationalSignificantNumber(), this.onNationalSignificantNumberChange(), this.hasExtractedNationalSignificantNumber = void 0)
            }
        }, {
            key: "extractCallingCodeAndNationalSignificantNumber",
            value: function(r) {
                this.extractCountryCallingCode(r) && this.extractNationalSignificantNumber(r.getNationalDigits(), function(n) {
                    return r.update(n)
                })
            }
        }]), t
    }();

function yZ(t) {
    var e = t.search(fZ);
    if (!(e < 0)) {
        t = t.slice(e);
        var r;
        return t[0] === "+" && (r = !0, t = t.slice(1)), t = t.replace(pZ, ""), r && (t = "+" + t), t
    }
}

function wZ(t) {
    var e = yZ(t) || "";
    return e[0] === "+" ? [e.slice(1), !0] : [e]
}

function bZ(t) {
    var e = wZ(t),
        r = hP(e, 2),
        n = r[0],
        i = r[1];
    return hZ.test(n) || (n = ""), [n, i]
}

function vZ(t, e) {
    return CZ(t) || _Z(t, e) || EZ(t, e) || xZ()
}

function xZ() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function EZ(t, e) {
    if (t) {
        if (typeof t == "string") return a7(t, e);
        var r = Object.prototype.toString.call(t).slice(8, -1);
        if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return a7(t, e)
    }
}

function a7(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
    return n
}

function _Z(t, e) {
    var r = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r != null) {
        var n = [],
            i = !0,
            s = !1,
            a, o;
        try {
            for (r = r.call(t); !(i = (a = r.next()).done) && (n.push(a.value), !(e && n.length === e)); i = !0);
        } catch (c) {
            s = !0, o = c
        } finally {
            try {
                !i && r.return != null && r.return()
            } finally {
                if (s) throw o
            }
        }
        return n
    }
}

function CZ(t) {
    if (Array.isArray(t)) return t
}

function AZ(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function kZ(t, e) {
    for (var r = 0; r < e.length; r++) {
        var n = e[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
    }
}

function IZ(t, e, r) {
    return e && kZ(t.prototype, e), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}
var fP = function() {
    function t(e, r) {
        AZ(this, t), this.metadata = new wn(r);
        var n = this.getCountryAndCallingCode(e),
            i = vZ(n, 2),
            s = i[0],
            a = i[1];
        this.defaultCountry = s, this.defaultCallingCode = a, this.reset()
    }
    return IZ(t, [{
        key: "getCountryAndCallingCode",
        value: function(r) {
            var n, i;
            return r && (Jl(r) ? (n = r.defaultCountry, i = r.defaultCallingCode) : n = r), n && !this.metadata.hasCountry(n) && (n = void 0), [n, i]
        }
    }, {
        key: "input",
        value: function(r) {
            var n = this.parser.input(r, this.state),
                i = n.digits,
                s = n.justLeadingPlus;
            if (s) this.formattedOutput = "+";
            else if (i) {
                this.determineTheCountryIfNeeded(), this.state.nationalSignificantNumber && this.formatter.narrowDownMatchingFormats(this.state);
                var a;
                if (this.metadata.hasSelectedNumberingPlan() && (a = this.formatter.format(i, this.state)), a === void 0 && this.parser.reExtractNationalSignificantNumber(this.state)) {
                    this.determineTheCountryIfNeeded();
                    var o = this.state.getNationalDigits();
                    o && (a = this.formatter.format(o, this.state))
                }
                this.formattedOutput = a ? this.getFullNumber(a) : this.getNonFormattedNumber()
            }
            return this.formattedOutput
        }
    }, {
        key: "reset",
        value: function() {
            var r = this;
            return this.state = new kY({
                onCountryChange: function(i) {
                    r.country = i
                },
                onCallingCodeChange: function(i, s) {
                    r.metadata.selectNumberingPlan(s, i), r.formatter.reset(r.metadata.numberingPlan, r.state), r.parser.reset(r.metadata.numberingPlan)
                }
            }), this.formatter = new nZ({
                state: this.state,
                metadata: this.metadata
            }), this.parser = new mZ({
                defaultCountry: this.defaultCountry,
                defaultCallingCode: this.defaultCallingCode,
                metadata: this.metadata,
                state: this.state,
                onNationalSignificantNumberChange: function() {
                    r.determineTheCountryIfNeeded(), r.formatter.reset(r.metadata.numberingPlan, r.state)
                }
            }), this.state.reset({
                country: this.defaultCountry,
                callingCode: this.defaultCallingCode
            }), this.formattedOutput = "", this
        }
    }, {
        key: "isInternational",
        value: function() {
            return this.state.international
        }
    }, {
        key: "getCallingCode",
        value: function() {
            if (this.isInternational()) return this.state.callingCode
        }
    }, {
        key: "getCountryCallingCode",
        value: function() {
            return this.getCallingCode()
        }
    }, {
        key: "getCountry",
        value: function() {
            var r = this.state.digits;
            if (r) return this._getCountry()
        }
    }, {
        key: "_getCountry",
        value: function() {
            var r = this.state.country;
            return r
        }
    }, {
        key: "determineTheCountryIfNeeded",
        value: function() {
            (!this.state.country || this.isCountryCallingCodeAmbiguous()) && this.determineTheCountry()
        }
    }, {
        key: "getFullNumber",
        value: function(r) {
            var n = this;
            if (this.isInternational()) {
                var i = function(o) {
                        return n.formatter.getInternationalPrefixBeforeCountryCallingCode(n.state, {
                            spacing: !!o
                        }) + o
                    },
                    s = this.state.callingCode;
                return i(s ? r ? "".concat(s, " ").concat(r) : s : "".concat(this.state.getDigitsWithoutInternationalPrefix()))
            }
            return r
        }
    }, {
        key: "getNonFormattedNationalNumberWithPrefix",
        value: function() {
            var r = this.state,
                n = r.nationalSignificantNumber,
                i = r.complexPrefixBeforeNationalSignificantNumber,
                s = r.nationalPrefix,
                a = n,
                o = i || s;
            return o && (a = o + a), a
        }
    }, {
        key: "getNonFormattedNumber",
        value: function() {
            var r = this.state.nationalSignificantNumberMatchesInput;
            return this.getFullNumber(r ? this.getNonFormattedNationalNumberWithPrefix() : this.state.getNationalDigits())
        }
    }, {
        key: "getNonFormattedTemplate",
        value: function() {
            var r = this.getNonFormattedNumber();
            if (r) return r.replace(/[\+\d]/g, ia)
        }
    }, {
        key: "isCountryCallingCodeAmbiguous",
        value: function() {
            var r = this.state.callingCode,
                n = this.metadata.getCountryCodesForCallingCode(r);
            return n && n.length > 1
        }
    }, {
        key: "determineTheCountry",
        value: function() {
            this.state.setCountry(dP(this.isInternational() ? this.state.callingCode : this.defaultCallingCode, {
                nationalNumber: this.state.nationalSignificantNumber,
                defaultCountry: this.defaultCountry,
                metadata: this.metadata
            }))
        }
    }, {
        key: "getNumberValue",
        value: function() {
            var r = this.state,
                n = r.digits,
                i = r.callingCode,
                s = r.country,
                a = r.nationalSignificantNumber;
            if (n) {
                if (this.isInternational()) return i ? "+" + i + a : "+" + n;
                if (s || i) {
                    var o = s ? this.metadata.countryCallingCode() : i;
                    return "+" + o + a
                }
            }
        }
    }, {
        key: "getNumber",
        value: function() {
            var r = this.state,
                n = r.nationalSignificantNumber,
                i = r.carrierCode,
                s = r.callingCode,
                a = this._getCountry();
            if (n && !(!a && !s)) {
                if (a && a === this.defaultCountry) {
                    var o = new wn(this.metadata.metadata);
                    o.selectNumberingPlan(a);
                    var c = o.numberingPlan.callingCode(),
                        l = this.metadata.getCountryCodesForCallingCode(c);
                    if (l.length > 1) {
                        var u = lP(n, {
                            countries: l,
                            defaultCountry: this.defaultCountry,
                            metadata: this.metadata.metadata
                        });
                        u && (a = u)
                    }
                }
                var h = new u6(a || s, n, this.metadata.metadata);
                return i && (h.carrierCode = i), h
            }
        }
    }, {
        key: "isPossible",
        value: function() {
            var r = this.getNumber();
            return r ? r.isPossible() : !1
        }
    }, {
        key: "isValid",
        value: function() {
            var r = this.getNumber();
            return r ? r.isValid() : !1
        }
    }, {
        key: "getNationalNumber",
        value: function() {
            return this.state.nationalSignificantNumber
        }
    }, {
        key: "getChars",
        value: function() {
            return (this.state.international ? "+" : "") + this.state.digits
        }
    }, {
        key: "getTemplate",
        value: function() {
            return this.formatter.getTemplate(this.state) || this.getNonFormattedTemplate() || ""
        }
    }]), t
}();

function $Z(t) {
    return new wn(t).getCountries()
}

function SZ(t, e, r) {
    if (e[t]) return new u6(t, e[t], r)
}

function M1(t, {
    method: e
}) {
    var n, i;
    const r = {};
    return t.transport.type === "fallback" && ((i = (n = t.transport).onResponse) == null || i.call(n, ({
        method: s,
        response: a,
        status: o,
        transport: c
    }) => {
        o === "success" && e === s && (r[a] = c.request)
    })), s => r[s] || t.request
}
async function pP(t, e) {
    const {
        address: r,
        abi: n,
        args: i,
        eventName: s,
        fromBlock: a,
        strict: o,
        toBlock: c
    } = e, l = M1(t, {
        method: "eth_newFilter"
    }), u = s ? r0({
        abi: n,
        args: i,
        eventName: s
    }) : void 0, h = await t.request({
        method: "eth_newFilter",
        params: [{
            address: r,
            fromBlock: typeof a == "bigint" ? nt(a) : a,
            toBlock: typeof c == "bigint" ? nt(c) : c,
            topics: u
        }]
    });
    return {
        abi: n,
        args: i,
        eventName: s,
        id: h,
        request: l(h),
        strict: !!o,
        type: "event"
    }
}
class TZ extends be {
    constructor() {
        super("`baseFeeMultiplier` must be greater than 1.", {
            name: "BaseFeeScalarError"
        })
    }
}
class h6 extends be {
    constructor() {
        super("Chain does not support EIP-1559 fees.", {
            name: "Eip1559FeesNotSupportedError"
        })
    }
}
class PZ extends be {
    constructor({
        maxPriorityFeePerGas: e
    }) {
        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${Di(e)} gwei).`, {
            name: "MaxFeePerGasTooLowError"
        })
    }
}
class gP extends be {
    constructor({
        blockHash: e,
        blockNumber: r
    }) {
        let n = "Block";
        e && (n = `Block at hash "${e}"`), r && (n = `Block at number "${r}"`), super(`${n} could not be found.`, {
            name: "BlockNotFoundError"
        })
    }
}
async function to(t, {
    blockHash: e,
    blockNumber: r,
    blockTag: n = t.experimental_blockTag ? ? "latest",
    includeTransactions: i
} = {}) {
    var l, u, h;
    const s = i ? ? !1,
        a = r !== void 0 ? nt(r) : void 0;
    let o = null;
    if (e ? o = await t.request({
            method: "eth_getBlockByHash",
            params: [e, s]
        }, {
            dedupe: !0
        }) : o = await t.request({
            method: "eth_getBlockByNumber",
            params: [a || n, s]
        }, {
            dedupe: !!a
        }), !o) throw new gP({
        blockHash: e,
        blockNumber: r
    });
    return (((h = (u = (l = t.chain) == null ? void 0 : l.formatters) == null ? void 0 : u.block) == null ? void 0 : h.format) || qT)(o)
}
async function f6(t) {
    const e = await t.request({
        method: "eth_gasPrice"
    });
    return BigInt(e)
}
async function NZ(t, e) {
    return mP(t, e)
}
async function mP(t, e) {
    var s, a;
    const {
        block: r,
        chain: n = t.chain,
        request: i
    } = e || {};
    try {
        const o = ((s = n == null ? void 0 : n.fees) == null ? void 0 : s.maxPriorityFeePerGas) ? ? ((a = n == null ? void 0 : n.fees) == null ? void 0 : a.defaultPriorityFee);
        if (typeof o == "function") {
            const l = r || await ht(t, to, "getBlock")({}),
                u = await o({
                    block: l,
                    client: t,
                    request: i
                });
            if (u === null) throw new Error;
            return u
        }
        if (typeof o < "u") return o;
        const c = await t.request({
            method: "eth_maxPriorityFeePerGas"
        });
        return ss(c)
    } catch {
        const [o, c] = await Promise.all([r ? Promise.resolve(r) : ht(t, to, "getBlock")({}), ht(t, f6, "getGasPrice")({})]);
        if (typeof o.baseFeePerGas != "bigint") throw new h6;
        const l = c - o.baseFeePerGas;
        return l < 0 n ? 0 n : l
    }
}
async function OZ(t, e) {
    return g3(t, e)
}
async function g3(t, e) {
    var f, p;
    const {
        block: r,
        chain: n = t.chain,
        request: i,
        type: s = "eip1559"
    } = e || {}, a = await (async () => {
        var g, m;
        return typeof((g = n == null ? void 0 : n.fees) == null ? void 0 : g.baseFeeMultiplier) == "function" ? n.fees.baseFeeMultiplier({
            block: r,
            client: t,
            request: i
        }) : ((m = n == null ? void 0 : n.fees) == null ? void 0 : m.baseFeeMultiplier) ? ? 1.2
    })();
    if (a < 1) throw new TZ;
    const c = 10 ** (((f = a.toString().split(".")[1]) == null ? void 0 : f.length) ? ? 0),
        l = g => g * BigInt(Math.ceil(a * c)) / BigInt(c),
        u = r || await ht(t, to, "getBlock")({});
    if (typeof((p = n == null ? void 0 : n.fees) == null ? void 0 : p.estimateFeesPerGas) == "function") {
        const g = await n.fees.estimateFeesPerGas({
            block: r,
            client: t,
            multiply: l,
            request: i,
            type: s
        });
        if (g !== null) return g
    }
    if (s === "eip1559") {
        if (typeof u.baseFeePerGas != "bigint") throw new h6;
        const g = typeof(i == null ? void 0 : i.maxPriorityFeePerGas) == "bigint" ? i.maxPriorityFeePerGas : await mP(t, {
                block: u,
                chain: n,
                request: i
            }),
            m = l(u.baseFeePerGas);
        return {
            maxFeePerGas: (i == null ? void 0 : i.maxFeePerGas) ? ? m + g,
            maxPriorityFeePerGas: g
        }
    }
    return {
        gasPrice: (i == null ? void 0 : i.gasPrice) ? ? l(await ht(t, f6, "getGasPrice")({}))
    }
}
async function gh(t) {
    const e = await t.request({
        method: "eth_chainId"
    }, {
        dedupe: !0
    });
    return va(e)
}
const yP = ["blobVersionedHashes", "chainId", "fees", "gas", "nonce", "type"],
    o7 = new Map;
async function D1(t, e) {
    const {
        account: r = t.account,
        blobs: n,
        chain: i,
        gas: s,
        kzg: a,
        nonce: o,
        nonceManager: c,
        parameters: l = yP,
        type: u
    } = e, h = r && qr(r), f = { ...e,
        ...h ? {
            from: h == null ? void 0 : h.address
        } : {}
    };
    let p;
    async function g() {
        return p || (p = await ht(t, to, "getBlock")({
            blockTag: "latest"
        }), p)
    }
    let m;
    async function y() {
        return m || (i ? i.id : typeof e.chainId < "u" ? e.chainId : (m = await ht(t, gh, "getChainId")({}), m))
    }
    if (l.includes("nonce") && typeof o > "u" && h)
        if (c) {
            const w = await y();
            f.nonce = await c.consume({
                address: h.address,
                chainId: w,
                client: t
            })
        } else f.nonce = await ht(t, o6, "getTransactionCount")({
            address: h.address,
            blockTag: "pending"
        });
    if ((l.includes("blobVersionedHashes") || l.includes("sidecars")) && n && a) {
        const w = LT({
            blobs: n,
            kzg: a
        });
        if (l.includes("blobVersionedHashes")) {
            const x = dV({
                commitments: w,
                to: "hex"
            });
            f.blobVersionedHashes = x
        }
        if (l.includes("sidecars")) {
            const x = UT({
                    blobs: n,
                    commitments: w,
                    kzg: a
                }),
                E = pV({
                    blobs: n,
                    commitments: w,
                    proofs: x,
                    to: "hex"
                });
            f.sidecars = E
        }
    }
    if (l.includes("chainId") && (f.chainId = await y()), (l.includes("fees") || l.includes("type")) && typeof u > "u") try {
        f.type = gV(f)
    } catch {
        let w = o7.get(t.uid);
        if (typeof w > "u") {
            const x = await g();
            w = typeof(x == null ? void 0 : x.baseFeePerGas) == "bigint", o7.set(t.uid, w)
        }
        f.type = w ? "eip1559" : "legacy"
    }
    if (l.includes("fees"))
        if (f.type !== "legacy" && f.type !== "eip2930") {
            if (typeof f.maxFeePerGas > "u" || typeof f.maxPriorityFeePerGas > "u") {
                const w = await g(),
                    {
                        maxFeePerGas: x,
                        maxPriorityFeePerGas: E
                    } = await g3(t, {
                        block: w,
                        chain: i,
                        request: f
                    });
                if (typeof e.maxPriorityFeePerGas > "u" && e.maxFeePerGas && e.maxFeePerGas < E) throw new PZ({
                    maxPriorityFeePerGas: E
                });
                f.maxPriorityFeePerGas = E, f.maxFeePerGas = x
            }
        } else {
            if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u") throw new h6;
            if (typeof e.gasPrice > "u") {
                const w = await g(),
                    {
                        gasPrice: x
                    } = await g3(t, {
                        block: w,
                        chain: i,
                        request: f,
                        type: "legacy"
                    });
                f.gasPrice = x
            }
        }
    return l.includes("gas") && typeof s > "u" && (f.gas = await ht(t, p6, "estimateGas")({ ...f,
        account: h && {
            address: h.address,
            type: "json-rpc"
        }
    })), kd(f), delete f.parameters, f
}
async function wP(t, {
    address: e,
    blockNumber: r,
    blockTag: n = t.experimental_blockTag ? ? "latest"
}) {
    const i = typeof r == "bigint" ? nt(r) : void 0,
        s = await t.request({
            method: "eth_getBalance",
            params: [e, i || n]
        });
    return BigInt(s)
}
async function p6(t, e) {
    var i, s, a;
    const {
        account: r = t.account
    } = e, n = r ? qr(r) : void 0;
    try {
        let D = function(O) {
            const {
                block: M,
                request: U,
                rpcStateOverride: k
            } = O;
            return t.request({
                method: "eth_estimateGas",
                params: k ? [U, M ? ? t.experimental_blockTag ? ? "latest", k] : M ? [U, M] : [U]
            })
        };
        const {
            accessList: o,
            authorizationList: c,
            blobs: l,
            blobVersionedHashes: u,
            blockNumber: h,
            blockTag: f,
            data: p,
            gas: g,
            gasPrice: m,
            maxFeePerBlobGas: y,
            maxFeePerGas: w,
            maxPriorityFeePerGas: x,
            nonce: E,
            value: _,
            stateOverride: b,
            ...A
        } = await D1(t, { ...e,
            parameters: (n == null ? void 0 : n.type) === "local" ? void 0 : ["blobVersionedHashes"]
        }), T = (typeof h == "bigint" ? nt(h) : void 0) || f, C = n6(b), $ = await (async () => {
            if (A.to) return A.to;
            if (c && c.length > 0) return await DT({
                authorization: c[0]
            }).catch(() => {
                throw new be("`to` is required. Could not infer from `authorizationList`")
            })
        })();
        kd(e);
        const P = (a = (s = (i = t.chain) == null ? void 0 : i.formatters) == null ? void 0 : s.transactionRequest) == null ? void 0 : a.format,
            R = (P || ph)({ ...S1(A, {
                    format: P
                }),
                from: n == null ? void 0 : n.address,
                accessList: o,
                authorizationList: c,
                blobs: l,
                blobVersionedHashes: u,
                data: p,
                gas: g,
                gasPrice: m,
                maxFeePerBlobGas: y,
                maxFeePerGas: w,
                maxPriorityFeePerGas: x,
                nonce: E,
                to: $,
                value: _
            });
        let S = BigInt(await D({
            block: T,
            request: R,
            rpcStateOverride: C
        }));
        if (c) {
            const O = await wP(t, {
                    address: R.from
                }),
                M = await Promise.all(c.map(async U => {
                    const {
                        address: k
                    } = U, F = await D({
                        block: T,
                        request: {
                            authorizationList: void 0,
                            data: p,
                            from: n == null ? void 0 : n.address,
                            to: k,
                            value: nt(O)
                        },
                        rpcStateOverride: C
                    }).catch(() => 100000 n);
                    return 2 n * BigInt(F)
                }));
            S += M.reduce((U, k) => U + k, 0 n)
        }
        return S
    } catch (o) {
        throw vV(o, { ...e,
            account: n,
            chain: t.chain
        })
    }
}
async function jZ(t, e) {
    const {
        abi: r,
        address: n,
        args: i,
        functionName: s,
        dataSuffix: a,
        ...o
    } = e, c = hs({
        abi: r,
        args: i,
        functionName: s
    });
    try {
        return await ht(t, p6, "estimateGas")({
            data: `${c}${a?a.replace("0x",""):""}`,
            to: n,
            ...o
        })
    } catch (l) {
        const u = o.account ? qr(o.account) : void 0;
        throw ld(l, {
            abi: r,
            address: n,
            args: i,
            docsPath: "/docs/contract/estimateContractGas",
            functionName: s,
            sender: u == null ? void 0 : u.address
        })
    }
}
async function g6(t, {
    address: e,
    blockHash: r,
    fromBlock: n,
    toBlock: i,
    event: s,
    events: a,
    args: o,
    strict: c
} = {}) {
    const l = c ? ? !1,
        u = a ? ? (s ? [s] : void 0);
    let h = [];
    u && (h = [u.flatMap(m => r0({
        abi: [m],
        eventName: m.name,
        args: a ? void 0 : o
    }))], s && (h = h[0]));
    let f;
    r ? f = await t.request({
        method: "eth_getLogs",
        params: [{
            address: e,
            topics: h,
            blockHash: r
        }]
    }) : f = await t.request({
        method: "eth_getLogs",
        params: [{
            address: e,
            topics: h,
            fromBlock: typeof n == "bigint" ? nt(n) : n,
            toBlock: typeof i == "bigint" ? nt(i) : i
        }]
    });
    const p = f.map(g => Qo(g));
    return u ? s6({
        abi: u,
        args: o,
        logs: p,
        strict: l
    }) : p
}
async function bP(t, e) {
    const {
        abi: r,
        address: n,
        args: i,
        blockHash: s,
        eventName: a,
        fromBlock: o,
        toBlock: c,
        strict: l
    } = e, u = a ? _d({
        abi: r,
        name: a
    }) : void 0, h = u ? void 0 : r.filter(f => f.type === "event");
    return ht(t, g6, "getLogs")({
        address: n,
        args: i,
        blockHash: s,
        event: u,
        events: h,
        fromBlock: o,
        toBlock: c,
        strict: l
    })
}
async function ec(t, e) {
    const {
        abi: r,
        address: n,
        args: i,
        functionName: s,
        ...a
    } = e, o = hs({
        abi: r,
        args: i,
        functionName: s
    });
    try {
        const {
            data: c
        } = await ht(t, e0, "call")({ ...a,
            data: o,
            to: n
        });
        return Ad({
            abi: r,
            args: i,
            functionName: s,
            data: c || "0x"
        })
    } catch (c) {
        throw ld(c, {
            abi: r,
            address: n,
            args: i,
            docsPath: "/docs/contract/readContract",
            functionName: s
        })
    }
}
async function RZ(t, e) {
    const {
        abi: r,
        address: n,
        args: i,
        dataSuffix: s,
        functionName: a,
        ...o
    } = e, c = o.account ? qr(o.account) : t.account, l = hs({
        abi: r,
        args: i,
        functionName: a
    });
    try {
        const {
            data: u
        } = await ht(t, e0, "call")({
            batch: !1,
            data: `${l}${s?s.replace("0x",""):""}`,
            to: n,
            ...o,
            account: c
        }), h = Ad({
            abi: r,
            args: i,
            functionName: a,
            data: u || "0x"
        }), f = r.filter(p => "name" in p && p.name === e.functionName);
        return {
            result: h,
            request: {
                abi: f,
                address: n,
                args: i,
                dataSuffix: s,
                functionName: a,
                ...o,
                account: c
            }
        }
    } catch (u) {
        throw ld(u, {
            abi: r,
            address: n,
            args: i,
            docsPath: "/docs/contract/simulateContract",
            functionName: a,
            sender: c == null ? void 0 : c.address
        })
    }
}
const Ow = new Map,
    c7 = new Map;
let MZ = 0;

function tc(t, e, r) {
    const n = ++MZ,
        i = () => Ow.get(t) || [],
        s = () => {
            const u = i();
            Ow.set(t, u.filter(h => h.id !== n))
        },
        a = () => {
            const u = i();
            if (!u.some(f => f.id === n)) return;
            const h = c7.get(t);
            if (u.length === 1 && h) {
                const f = h();
                f instanceof Promise && f.catch(() => {})
            }
            s()
        },
        o = i();
    if (Ow.set(t, [...o, {
            id: n,
            fns: e
        }]), o && o.length > 0) return a;
    const c = {};
    for (const u in e) c[u] = (...h) => {
        var p, g;
        const f = i();
        if (f.length !== 0)
            for (const m of f)(g = (p = m.fns)[u]) == null || g.call(p, ...h)
    };
    const l = r(c);
    return typeof l == "function" && c7.set(t, l), a
}

function mh(t, {
    emitOnBegin: e,
    initialWaitTime: r,
    interval: n
}) {
    let i = !0;
    const s = () => i = !1;
    return (async () => {
        let o;
        e && (o = await t({
            unpoll: s
        }));
        const c = await (r == null ? void 0 : r(o)) ? ? n;
        await fm(c);
        const l = async () => {
            i && (await t({
                unpoll: s
            }), await fm(n), l())
        };
        l()
    })(), s
}
const DZ = new Map,
    LZ = new Map;

function UZ(t) {
    const e = (i, s) => ({
            clear: () => s.delete(i),
            get: () => s.get(i),
            set: a => s.set(i, a)
        }),
        r = e(t, DZ),
        n = e(t, LZ);
    return {
        clear: () => {
            r.clear(), n.clear()
        },
        promise: r,
        response: n
    }
}
async function FZ(t, {
    cacheKey: e,
    cacheTime: r = Number.POSITIVE_INFINITY
}) {
    const n = UZ(e),
        i = n.response.get();
    if (i && r > 0 && new Date().getTime() - i.created.getTime() < r) return i.data;
    let s = n.promise.get();
    s || (s = t(), n.promise.set(s));
    try {
        const a = await s;
        return n.response.set({
            created: new Date,
            data: a
        }), a
    } finally {
        n.promise.clear()
    }
}
const BZ = t => `blockNumber.${t}`;
async function n0(t, {
    cacheTime: e = t.cacheTime
} = {}) {
    const r = await FZ(() => t.request({
        method: "eth_blockNumber"
    }), {
        cacheKey: BZ(t.uid),
        cacheTime: e
    });
    return BigInt(r)
}
async function L1(t, {
    filter: e
}) {
    const r = "strict" in e && e.strict,
        n = await e.request({
            method: "eth_getFilterChanges",
            params: [e.id]
        });
    if (typeof n[0] == "string") return n;
    const i = n.map(s => Qo(s));
    return !("abi" in e) || !e.abi ? i : s6({
        abi: e.abi,
        logs: i,
        strict: r
    })
}
async function U1(t, {
    filter: e
}) {
    return e.request({
        method: "eth_uninstallFilter",
        params: [e.id]
    })
}

function WZ(t, e) {
    const {
        abi: r,
        address: n,
        args: i,
        batch: s = !0,
        eventName: a,
        fromBlock: o,
        onError: c,
        onLogs: l,
        poll: u,
        pollingInterval: h = t.pollingInterval,
        strict: f
    } = e;
    return (typeof u < "u" ? u : typeof o == "bigint" ? !0 : !(t.transport.type === "webSocket" || t.transport.type === "ipc" || t.transport.type === "fallback" && (t.transport.transports[0].config.type === "webSocket" || t.transport.transports[0].config.type === "ipc"))) ? (() => {
        const y = f ? ? !1,
            w = zr(["watchContractEvent", n, i, s, t.uid, a, h, y, o]);
        return tc(w, {
            onLogs: l,
            onError: c
        }, x => {
            let E;
            o !== void 0 && (E = o - 1 n);
            let _, b = !1;
            const A = mh(async () => {
                var I;
                if (!b) {
                    try {
                        _ = await ht(t, pP, "createContractEventFilter")({
                            abi: r,
                            address: n,
                            args: i,
                            eventName: a,
                            strict: y,
                            fromBlock: o
                        })
                    } catch {}
                    b = !0;
                    return
                }
                try {
                    let T;
                    if (_) T = await ht(t, L1, "getFilterChanges")({
                        filter: _
                    });
                    else {
                        const C = await ht(t, n0, "getBlockNumber")({});
                        E && E < C ? T = await ht(t, bP, "getContractEvents")({
                            abi: r,
                            address: n,
                            args: i,
                            eventName: a,
                            fromBlock: E + 1 n,
                            toBlock: C,
                            strict: y
                        }) : T = [], E = C
                    }
                    if (T.length === 0) return;
                    if (s) x.onLogs(T);
                    else
                        for (const C of T) x.onLogs([C])
                } catch (T) {
                    _ && T instanceof id && (b = !1), (I = x.onError) == null || I.call(x, T)
                }
            }, {
                emitOnBegin: !0,
                interval: h
            });
            return async () => {
                _ && await ht(t, U1, "uninstallFilter")({
                    filter: _
                }), A()
            }
        })
    })() : (() => {
        const y = f ? ? !1,
            w = zr(["watchContractEvent", n, i, s, t.uid, a, h, y]);
        let x = !0,
            E = () => x = !1;
        return tc(w, {
            onLogs: l,
            onError: c
        }, _ => ((async () => {
            try {
                const b = (() => {
                        if (t.transport.type === "fallback") {
                            const T = t.transport.transports.find(C => C.config.type === "webSocket" || C.config.type === "ipc");
                            return T ? T.value : t.transport
                        }
                        return t.transport
                    })(),
                    A = a ? r0({
                        abi: r,
                        eventName: a,
                        args: i
                    }) : [],
                    {
                        unsubscribe: I
                    } = await b.subscribe({
                        params: ["logs", {
                            address: n,
                            topics: A
                        }],
                        onData(T) {
                            var $;
                            if (!x) return;
                            const C = T.result;
                            try {
                                const {
                                    eventName: P,
                                    args: N
                                } = i6({
                                    abi: r,
                                    data: C.data,
                                    topics: C.topics,
                                    strict: f
                                }), R = Qo(C, {
                                    args: N,
                                    eventName: P
                                });
                                _.onLogs([R])
                            } catch (P) {
                                let N, R;
                                if (P instanceof yp || P instanceof C1) {
                                    if (f) return;
                                    N = P.abiItem.name, R = ($ = P.abiItem.inputs) == null ? void 0 : $.some(S => !("name" in S && S.name))
                                }
                                const D = Qo(C, {
                                    args: R ? [] : {},
                                    eventName: N
                                });
                                _.onLogs([D])
                            }
                        },
                        onError(T) {
                            var C;
                            (C = _.onError) == null || C.call(_, T)
                        }
                    });
                E = I, x || E()
            } catch (b) {
                c == null || c(b)
            }
        })(), () => E()))
    })()
}
class Id extends be {
    constructor({
        docsPath: e
    } = {}) {
        super(["Could not find an Account to execute with this Action.", "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`), {
            docsPath: e,
            docsSlug: "account",
            name: "AccountNotFoundError"
        })
    }
}
class Mg extends be {
    constructor({
        docsPath: e,
        metaMessages: r,
        type: n
    }) {
        super(`Account type "${n}" is not supported.`, {
            docsPath: e,
            metaMessages: r,
            name: "AccountTypeNotSupportedError"
        })
    }
}
async function m6(t, {
    serializedTransaction: e
}) {
    return t.request({
        method: "eth_sendRawTransaction",
        params: [e]
    }, {
        retryCount: 0
    })
}
const jw = new Kp(128);
async function F1(t, e) {
    var x, E, _, b;
    const {
        account: r = t.account,
        chain: n = t.chain,
        accessList: i,
        authorizationList: s,
        blobs: a,
        data: o,
        gas: c,
        gasPrice: l,
        maxFeePerBlobGas: u,
        maxFeePerGas: h,
        maxPriorityFeePerGas: f,
        nonce: p,
        type: g,
        value: m,
        ...y
    } = e;
    if (typeof r > "u") throw new Id({
        docsPath: "/docs/actions/wallet/sendTransaction"
    });
    const w = r ? qr(r) : null;
    try {
        kd(e);
        const A = await (async () => {
            if (e.to) return e.to;
            if (e.to !== null && s && s.length > 0) return await DT({
                authorization: s[0]
            }).catch(() => {
                throw new be("`to` is required. Could not infer from `authorizationList`.")
            })
        })();
        if ((w == null ? void 0 : w.type) === "json-rpc" || w === null) {
            let I;
            n !== null && (I = await ht(t, gh, "getChainId")({}), kT({
                currentChainId: I,
                chain: n
            }));
            const T = (_ = (E = (x = t.chain) == null ? void 0 : x.formatters) == null ? void 0 : E.transactionRequest) == null ? void 0 : _.format,
                $ = (T || ph)({ ...S1(y, {
                        format: T
                    }),
                    accessList: i,
                    authorizationList: s,
                    blobs: a,
                    chainId: I,
                    data: o,
                    from: w == null ? void 0 : w.address,
                    gas: c,
                    gasPrice: l,
                    maxFeePerBlobGas: u,
                    maxFeePerGas: h,
                    maxPriorityFeePerGas: f,
                    nonce: p,
                    to: A,
                    type: g,
                    value: m
                }),
                P = jw.get(t.uid),
                N = P ? "wallet_sendTransaction" : "eth_sendTransaction";
            try {
                return await t.request({
                    method: N,
                    params: [$]
                }, {
                    retryCount: 0
                })
            } catch (R) {
                if (P === !1) throw R;
                const D = R;
                if (D.name === "InvalidInputRpcError" || D.name === "InvalidParamsRpcError" || D.name === "MethodNotFoundRpcError" || D.name === "MethodNotSupportedRpcError") return await t.request({
                    method: "wallet_sendTransaction",
                    params: [$]
                }, {
                    retryCount: 0
                }).then(S => (jw.set(t.uid, !0), S)).catch(S => {
                    const O = S;
                    throw O.name === "MethodNotFoundRpcError" || O.name === "MethodNotSupportedRpcError" ? (jw.set(t.uid, !1), D) : O
                });
                throw D
            }
        }
        if ((w == null ? void 0 : w.type) === "local") {
            const I = await ht(t, D1, "prepareTransactionRequest")({
                    account: w,
                    accessList: i,
                    authorizationList: s,
                    blobs: a,
                    chain: n,
                    data: o,
                    gas: c,
                    gasPrice: l,
                    maxFeePerBlobGas: u,
                    maxFeePerGas: h,
                    maxPriorityFeePerGas: f,
                    nonce: p,
                    nonceManager: w.nonceManager,
                    parameters: [...yP, "sidecars"],
                    type: g,
                    value: m,
                    ...y,
                    to: A
                }),
                T = (b = n == null ? void 0 : n.serializers) == null ? void 0 : b.transaction,
                C = await w.signTransaction(I, {
                    serializer: T
                });
            return await ht(t, m6, "sendRawTransaction")({
                serializedTransaction: C
            })
        }
        throw (w == null ? void 0 : w.type) === "smart" ? new Mg({
            metaMessages: ["Consider using the `sendUserOperation` Action instead."],
            docsPath: "/docs/actions/bundler/sendUserOperation",
            type: "smart"
        }) : new Mg({
            docsPath: "/docs/actions/wallet/sendTransaction",
            type: w == null ? void 0 : w.type
        })
    } catch (A) {
        throw A instanceof Mg ? A : VT(A, { ...e,
            account: w,
            chain: e.chain || void 0
        })
    }
}
async function zZ(t, e) {
    const {
        abi: r,
        account: n = t.account,
        address: i,
        args: s,
        dataSuffix: a,
        functionName: o,
        ...c
    } = e;
    if (typeof n > "u") throw new Id({
        docsPath: "/docs/contract/writeContract"
    });
    const l = n ? qr(n) : null,
        u = hs({
            abi: r,
            args: s,
            functionName: o
        });
    try {
        return await ht(t, F1, "sendTransaction")({
            data: `${u}${a?a.replace("0x",""):""}`,
            to: i,
            account: l,
            ...c
        })
    } catch (h) {
        throw ld(h, {
            abi: r,
            address: i,
            args: s,
            docsPath: "/docs/contract/writeContract",
            functionName: o,
            sender: l == null ? void 0 : l.address
        })
    }
}
class qZ extends be {
    constructor(e) {
        super(`Call bundle failed with status: ${e.statusCode}`, {
            name: "BundleFailedError"
        }), Object.defineProperty(this, "result", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.result = e
    }
}
const vP = "0x5792579257925792579257925792579257925792579257925792579257925792",
    xP = nt(0, {
        size: 32
    });
async function HZ(t, e) {
    const {
        account: r = t.account,
        capabilities: n,
        chain: i = t.chain,
        experimental_fallback: s,
        experimental_fallbackDelay: a = 32,
        forceAtomic: o = !1,
        id: c,
        version: l = "2.0.0"
    } = e, u = r ? qr(r) : null, h = e.calls.map(f => {
        const p = f,
            g = p.abi ? hs({
                abi: p.abi,
                functionName: p.functionName,
                args: p.args
            }) : p.data;
        return {
            data: p.dataSuffix && g ? as([g, p.dataSuffix]) : g,
            to: p.to,
            value: p.value ? nt(p.value) : void 0
        }
    });
    try {
        const f = await t.request({
            method: "wallet_sendCalls",
            params: [{
                atomicRequired: o,
                calls: h,
                capabilities: n,
                chainId: nt(i.id),
                from: u == null ? void 0 : u.address,
                id: c,
                version: l
            }]
        }, {
            retryCount: 0
        });
        return typeof f == "string" ? {
            id: f
        } : f
    } catch (f) {
        const p = f;
        if (s && (p.name === "MethodNotFoundRpcError" || p.name === "MethodNotSupportedRpcError" || p.name === "UnknownRpcError" || p.details.toLowerCase().includes("does not exist / is not available") || p.details.toLowerCase().includes("missing or invalid. request()") || p.details.toLowerCase().includes("did not match any variant of untagged enum") || p.details.toLowerCase().includes("account upgraded to unsupported contract") || p.details.toLowerCase().includes("eip-7702 not supported") || p.details.toLowerCase().includes("unsupported wc_ method"))) {
            if (n && Object.values(n).some(x => !x.optional)) {
                const x = "non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";
                throw new Zu(new be(x, {
                    details: x
                }))
            }
            if (o && h.length > 1) {
                const w = "`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";
                throw new Ju(new be(w, {
                    details: w
                }))
            }
            const g = [];
            for (const w of h) {
                const x = F1(t, {
                    account: u,
                    chain: i,
                    data: w.data,
                    to: w.to,
                    value: w.value ? ss(w.value) : void 0
                });
                g.push(x), a > 0 && await new Promise(E => setTimeout(E, a))
            }
            const m = await Promise.allSettled(g);
            if (m.every(w => w.status === "rejected")) throw m[0].reason;
            const y = m.map(w => w.status === "fulfilled" ? w.value : xP);
            return {
                id: as([...y, nt(i.id, {
                    size: 32
                }), vP])
            }
        }
        throw VT(f, { ...e,
            account: u,
            chain: e.chain
        })
    }
}
async function EP(t, e) {
    async function r(u) {
        if (u.endsWith(vP.slice(2))) {
            const f = Ho(mm(u, -64, -32)),
                p = mm(u, 0, -64).slice(2).match(/.{1,64}/g),
                g = await Promise.all(p.map(y => xP.slice(2) !== y ? t.request({
                    method: "eth_getTransactionReceipt",
                    params: [`0x${y}`]
                }, {
                    dedupe: !0
                }) : void 0)),
                m = g.some(y => y === null) ? 100 : g.every(y => (y == null ? void 0 : y.status) === "0x1") ? 200 : g.every(y => (y == null ? void 0 : y.status) === "0x0") ? 500 : 600;
            return {
                atomic: !1,
                chainId: va(f),
                receipts: g.filter(Boolean),
                status: m,
                version: "2.0.0"
            }
        }
        return t.request({
            method: "wallet_getCallsStatus",
            params: [u]
        })
    }
    const {
        atomic: n = !1,
        chainId: i,
        receipts: s,
        version: a = "2.0.0",
        ...o
    } = await r(e.id), [c, l] = (() => {
        const u = o.status;
        return u >= 100 && u < 200 ? ["pending", u] : u >= 200 && u < 300 ? ["success", u] : u >= 300 && u < 700 ? ["failure", u] : u === "CONFIRMED" ? ["success", 200] : u === "PENDING" ? ["pending", 100] : [void 0, u]
    })();
    return { ...o,
        atomic: n,
        chainId: i ? va(i) : void 0,
        receipts: (s == null ? void 0 : s.map(u => ({ ...u,
            blockNumber: ss(u.blockNumber),
            gasUsed: ss(u.gasUsed),
            status: HT[u.status]
        }))) ? ? [],
        statusCode: l,
        status: c,
        version: a
    }
}
async function VZ(t, e) {
    const {
        id: r,
        pollingInterval: n = t.pollingInterval,
        status: i = ({
            statusCode: m
        }) => m === 200 || m >= 300,
        retryCount: s = 4,
        retryDelay: a = ({
            count: m
        }) => ~~(1 << m) * 200,
        timeout: o = 6e4,
        throwOnFailure: c = !1
    } = e, l = zr(["waitForCallsStatus", t.uid, r]), {
        promise: u,
        resolve: h,
        reject: f
    } = r6();
    let p;
    const g = tc(l, {
        resolve: h,
        reject: f
    }, m => {
        const y = mh(async () => {
            const w = x => {
                clearTimeout(p), y(), x(), g()
            };
            try {
                const x = await pm(async () => {
                    const E = await EP(t, {
                        id: r
                    });
                    if (c && E.status === "failure") throw new qZ(E);
                    return E
                }, {
                    retryCount: s,
                    delay: a
                });
                if (!i(x)) return;
                w(() => m.resolve(x))
            } catch (x) {
                w(() => m.reject(x))
            }
        }, {
            interval: n,
            emitOnBegin: !0
        });
        return y
    });
    return p = o ? setTimeout(() => {
        g(), clearTimeout(p), f(new GZ({
            id: r
        }))
    }, o) : void 0, await u
}
class GZ extends be {
    constructor({
        id: e
    }) {
        super(`Timed out while waiting for call bundle with id "${e}" to be confirmed.`, {
            name: "WaitForCallsStatusTimeoutError"
        })
    }
}
const m3 = 256;
let V0 = m3,
    G0;

function _P(t = 11) {
    if (!G0 || V0 + t > m3 * 2) {
        G0 = "", V0 = 0;
        for (let e = 0; e < m3; e++) G0 += (256 + Math.random() * 256 | 0).toString(16).substring(1)
    }
    return G0.substring(V0, V0++ + t)
}

function CP(t) {
    const {
        batch: e,
        chain: r,
        ccipRead: n,
        key: i = "base",
        name: s = "Base Client",
        type: a = "base"
    } = t, o = t.experimental_blockTag ? ? (typeof(r == null ? void 0 : r.experimental_preconfirmationTime) == "number" ? "pending" : void 0), c = (r == null ? void 0 : r.blockTime) ? ? 12e3, l = Math.min(Math.max(Math.floor(c / 2), 500), 4e3), u = t.pollingInterval ? ? l, h = t.cacheTime ? ? u, f = t.account ? qr(t.account) : void 0, {
        config: p,
        request: g,
        value: m
    } = t.transport({
        chain: r,
        pollingInterval: u
    }), y = { ...p,
        ...m
    }, w = {
        account: f,
        batch: e,
        cacheTime: h,
        ccipRead: n,
        chain: r,
        key: i,
        name: s,
        pollingInterval: u,
        request: g,
        transport: y,
        type: a,
        uid: _P(),
        ...o ? {
            experimental_blockTag: o
        } : {}
    };

    function x(E) {
        return _ => {
            const b = _(E);
            for (const I in w) delete b[I];
            const A = { ...E,
                ...b
            };
            return Object.assign(A, {
                extend: x(A)
            })
        }
    }
    return Object.assign(w, {
        extend: x(w)
    })
}

function y6({
    key: t,
    methods: e,
    name: r,
    request: n,
    retryCount: i = 3,
    retryDelay: s = 150,
    timeout: a,
    type: o
}, c) {
    const l = _P();
    return {
        config: {
            key: t,
            methods: e,
            name: r,
            request: n,
            retryCount: i,
            retryDelay: s,
            timeout: a,
            type: o
        },
        request: lz(n, {
            methods: e,
            retryCount: i,
            retryDelay: s,
            uid: l
        }),
        value: c
    }
}

function AP(t, e = {}) {
    const {
        key: r = "custom",
        methods: n,
        name: i = "Custom Provider",
        retryDelay: s
    } = e;
    return ({
        retryCount: a
    }) => y6({
        key: r,
        methods: n,
        name: i,
        request: t.request.bind(t),
        retryCount: e.retryCount ? ? a,
        retryDelay: s,
        type: "custom"
    })
}

function nNe(t, e = {}) {
    const {
        key: r = "fallback",
        name: n = "Fallback",
        rank: i = !1,
        shouldThrow: s = KZ,
        retryCount: a,
        retryDelay: o
    } = e;
    return ({
        chain: c,
        pollingInterval: l = 4e3,
        timeout: u,
        ...h
    }) => {
        let f = t,
            p = () => {};
        const g = y6({
            key: r,
            name: n,
            async request({
                method: m,
                params: y
            }) {
                let w;
                const x = async (E = 0) => {
                    const _ = f[E]({ ...h,
                        chain: c,
                        retryCount: 0,
                        timeout: u
                    });
                    try {
                        const b = await _.request({
                            method: m,
                            params: y
                        });
                        return p({
                            method: m,
                            params: y,
                            response: b,
                            transport: _,
                            status: "success"
                        }), b
                    } catch (b) {
                        if (p({
                                error: b,
                                method: m,
                                params: y,
                                transport: _,
                                status: "error"
                            }), s(b) || E === f.length - 1 || (w ? ? (w = f.slice(E + 1).some(A => {
                                const {
                                    include: I,
                                    exclude: T
                                } = A({
                                    chain: c
                                }).config.methods || {};
                                return I ? I.includes(m) : T ? !T.includes(m) : !0
                            })), !w)) throw b;
                        return x(E + 1)
                    }
                };
                return x()
            },
            retryCount: a,
            retryDelay: o,
            type: "fallback"
        }, {
            onResponse: m => p = m,
            transports: f.map(m => m({
                chain: c,
                retryCount: 0
            }))
        });
        if (i) {
            const m = typeof i == "object" ? i : {};
            YZ({
                chain: c,
                interval: m.interval ? ? l,
                onTransports: y => f = y,
                ping: m.ping,
                sampleCount: m.sampleCount,
                timeout: m.timeout,
                transports: f,
                weights: m.weights
            })
        }
        return g
    }
}

function KZ(t) {
    return !!("code" in t && typeof t.code == "number" && (t.code === Ku.code || t.code === Yl.code || Ll.nodeMessage.test(t.message) || t.code === 5e3))
}

function YZ({
    chain: t,
    interval: e = 4e3,
    onTransports: r,
    ping: n,
    sampleCount: i = 10,
    timeout: s = 1e3,
    transports: a,
    weights: o = {}
}) {
    const {
        stability: c = .7,
        latency: l = .3
    } = o, u = [], h = async () => {
        const f = await Promise.all(a.map(async m => {
            const y = m({
                    chain: t,
                    retryCount: 0,
                    timeout: s
                }),
                w = Date.now();
            let x, E;
            try {
                await (n ? n({
                    transport: y
                }) : y.request({
                    method: "net_listening"
                })), E = 1
            } catch {
                E = 0
            } finally {
                x = Date.now()
            }
            return {
                latency: x - w,
                success: E
            }
        }));
        u.push(f), u.length > i && u.shift();
        const p = Math.max(...u.map(m => Math.max(...m.map(({
                latency: y
            }) => y)))),
            g = a.map((m, y) => {
                const w = u.map(A => A[y].latency),
                    E = 1 - w.reduce((A, I) => A + I, 0) / w.length / p,
                    _ = u.map(A => A[y].success),
                    b = _.reduce((A, I) => A + I, 0) / _.length;
                return b === 0 ? [0, y] : [l * E + c * b, y]
            }).sort((m, y) => y[0] - m[0]);
        r(g.map(([, m]) => a[m])), await fm(e), h()
    };
    h()
}
class ZZ extends be {
    constructor() {
        super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
            docsPath: "/docs/clients/intro",
            name: "UrlRequiredError"
        })
    }
}

function rc(t, e = {}) {
    const {
        batch: r,
        fetchOptions: n,
        key: i = "http",
        methods: s,
        name: a = "HTTP JSON-RPC",
        onFetchRequest: o,
        onFetchResponse: c,
        retryDelay: l,
        raw: u
    } = e;
    return ({
        chain: h,
        retryCount: f,
        timeout: p
    }) => {
        const {
            batchSize: g = 1e3,
            wait: m = 0
        } = typeof r == "object" ? r : {}, y = e.retryCount ? ? f, w = p ? ? e.timeout ? ? 1e4, x = t || (h == null ? void 0 : h.rpcUrls.default.http[0]);
        if (!x) throw new ZZ;
        const E = zH(x, {
            fetchOptions: n,
            onRequest: o,
            onResponse: c,
            timeout: w
        });
        return y6({
            key: i,
            methods: s,
            name: a,
            async request({
                method: _,
                params: b
            }) {
                const A = {
                        method: _,
                        params: b
                    },
                    {
                        schedule: I
                    } = xT({
                        id: x,
                        wait: m,
                        shouldSplitBatch(P) {
                            return P.length > g
                        },
                        fn: P => E.request({
                            body: P
                        }),
                        sort: (P, N) => P.id - N.id
                    }),
                    T = async P => r ? I(P) : [await E.request({
                        body: P
                    })],
                    [{
                        error: C,
                        result: $
                    }] = await T(A);
                if (u) return {
                    error: C,
                    result: $
                };
                if (C) throw new H4({
                    body: A,
                    error: C,
                    url: x
                });
                return $
            },
            retryCount: y,
            retryDelay: l,
            timeout: w,
            type: "http"
        }, {
            fetchOptions: n,
            url: x
        })
    }
}

function w6(t, e) {
    var n, i, s, a, o, c;
    if (!(t instanceof be)) return !1;
    const r = t.walk(l => l instanceof Jv);
    return r instanceof Jv ? !!(((n = r.data) == null ? void 0 : n.errorName) === "ResolverNotFound" || ((i = r.data) == null ? void 0 : i.errorName) === "ResolverWildcardNotSupported" || ((s = r.data) == null ? void 0 : s.errorName) === "ResolverNotContract" || ((a = r.data) == null ? void 0 : a.errorName) === "ResolverError" || ((o = r.data) == null ? void 0 : o.errorName) === "HttpError" || (c = r.reason) != null && c.includes("Wildcard on non-extended resolvers is not supported") || e === "reverse" && r.reason === QS[50]) : !1
}

function kP(t) {
    if (t.length !== 66 || t.indexOf("[") !== 0 || t.indexOf("]") !== 65) return null;
    const e = `0x${t.slice(1,65)}`;
    return Jn(e) ? e : null
}

function Dg(t) {
    let e = new Uint8Array(32).fill(0);
    if (!t) return ln(e);
    const r = t.split(".");
    for (let n = r.length - 1; n >= 0; n -= 1) {
        const i = kP(r[n]),
            s = i ? dh(i) : Pn(Zl(r[n]), "bytes");
        e = Pn(as([e, s]), "bytes")
    }
    return ln(e)
}

function JZ(t) {
    return `[${t.slice(2)}]`
}

function QZ(t) {
    const e = new Uint8Array(32).fill(0);
    return t ? kP(t) || Pn(Zl(t)) : ln(e)
}

function B1(t) {
    const e = t.replace(/^\.|\.$/gm, "");
    if (e.length === 0) return new Uint8Array(1);
    const r = new Uint8Array(Zl(e).byteLength + 2);
    let n = 0;
    const i = e.split(".");
    for (let s = 0; s < i.length; s++) {
        let a = Zl(i[s]);
        a.byteLength > 255 && (a = Zl(JZ(QZ(i[s])))), r[n] = a.length, r.set(a, n + 1), n += a.length + 1
    }
    return r.byteLength !== n + 1 ? r.slice(0, n + 1) : r
}
async function XZ(t, e) {
    const {
        blockNumber: r,
        blockTag: n,
        coinType: i,
        name: s,
        gatewayUrls: a,
        strict: o
    } = e, {
        chain: c
    } = t, l = (() => {
        if (e.universalResolverAddress) return e.universalResolverAddress;
        if (!c) throw new Error("client chain not configured. universalResolverAddress is required.");
        return fh({
            blockNumber: r,
            chain: c,
            contract: "ensUniversalResolver"
        })
    })(), u = c == null ? void 0 : c.ensTlds;
    if (u && !u.some(h => s.endsWith(h))) return null;
    try {
        const h = hs({
                abi: sE,
                functionName: "addr",
                ...i != null ? {
                    args: [Dg(s), BigInt(i)]
                } : {
                    args: [Dg(s)]
                }
            }),
            f = {
                address: l,
                abi: YS,
                functionName: "resolve",
                args: [cn(B1(s)), h, a ? ? [T1]],
                blockNumber: r,
                blockTag: n
            },
            g = await ht(t, ec, "readContract")(f);
        if (g[0] === "0x") return null;
        const m = Ad({
            abi: sE,
            args: i != null ? [Dg(s), BigInt(i)] : void 0,
            functionName: "addr",
            data: g[0]
        });
        return m === "0x" || Ho(m) === "0x00" ? null : m
    } catch (h) {
        if (o) throw h;
        if (w6(h, "resolve")) return null;
        throw h
    }
}
class eJ extends be {
    constructor({
        data: e
    }) {
        super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
            metaMessages: ["- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.", "", `Provided data: ${JSON.stringify(e)}`],
            name: "EnsAvatarInvalidMetadataError"
        })
    }
}
class Bh extends be {
    constructor({
        reason: e
    }) {
        super(`ENS NFT avatar URI is invalid. ${e}`, {
            name: "EnsAvatarInvalidNftUriError"
        })
    }
}
class b6 extends be {
    constructor({
        uri: e
    }) {
        super(`Unable to resolve ENS avatar URI "${e}". The URI may be malformed, invalid, or does not respond with a valid image.`, {
            name: "EnsAvatarUriResolutionError"
        })
    }
}
class tJ extends be {
    constructor({
        namespace: e
    }) {
        super(`ENS NFT avatar namespace "${e}" is not supported. Must be "erc721" or "erc1155".`, {
            name: "EnsAvatarUnsupportedNamespaceError"
        })
    }
}
const rJ = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/,
    nJ = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/,
    iJ = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/,
    sJ = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function aJ(t) {
    try {
        const e = await fetch(t, {
            method: "HEAD"
        });
        if (e.status === 200) {
            const r = e.headers.get("content-type");
            return r == null ? void 0 : r.startsWith("image/")
        }
        return !1
    } catch (e) {
        return typeof e == "object" && typeof e.response < "u" || !globalThis.hasOwnProperty("Image") ? !1 : new Promise(r => {
            const n = new Image;
            n.onload = () => {
                r(!0)
            }, n.onerror = () => {
                r(!1)
            }, n.src = t
        })
    }
}

function l7(t, e) {
    return t ? t.endsWith("/") ? t.slice(0, -1) : t : e
}

function IP({
    uri: t,
    gatewayUrls: e
}) {
    const r = iJ.test(t);
    if (r) return {
        uri: t,
        isOnChain: !0,
        isEncoded: r
    };
    const n = l7(e == null ? void 0 : e.ipfs, "https://ipfs.io"),
        i = l7(e == null ? void 0 : e.arweave, "https://arweave.net"),
        s = t.match(rJ),
        {
            protocol: a,
            subpath: o,
            target: c,
            subtarget: l = ""
        } = (s == null ? void 0 : s.groups) || {},
        u = a === "ipns:/" || o === "ipns/",
        h = a === "ipfs:/" || o === "ipfs/" || nJ.test(t);
    if (t.startsWith("http") && !u && !h) {
        let p = t;
        return e != null && e.arweave && (p = t.replace(/https:\/\/arweave.net/g, e == null ? void 0 : e.arweave)), {
            uri: p,
            isOnChain: !1,
            isEncoded: !1
        }
    }
    if ((u || h) && c) return {
        uri: `${n}/${u?"ipns":"ipfs"}/${c}${l}`,
        isOnChain: !1,
        isEncoded: !1
    };
    if (a === "ar:/" && c) return {
        uri: `${i}/${c}${l||""}`,
        isOnChain: !1,
        isEncoded: !1
    };
    let f = t.replace(sJ, "");
    if (f.startsWith("<svg") && (f = `data:image/svg+xml;base64,${btoa(f)}`), f.startsWith("data:") || f.startsWith("{")) return {
        uri: f,
        isOnChain: !0,
        isEncoded: !1
    };
    throw new b6({
        uri: t
    })
}

function $P(t) {
    if (typeof t != "object" || !("image" in t) && !("image_url" in t) && !("image_data" in t)) throw new eJ({
        data: t
    });
    return t.image || t.image_url || t.image_data
}
async function oJ({
    gatewayUrls: t,
    uri: e
}) {
    try {
        const r = await fetch(e).then(i => i.json());
        return await v6({
            gatewayUrls: t,
            uri: $P(r)
        })
    } catch {
        throw new b6({
            uri: e
        })
    }
}
async function v6({
    gatewayUrls: t,
    uri: e
}) {
    const {
        uri: r,
        isOnChain: n
    } = IP({
        uri: e,
        gatewayUrls: t
    });
    if (n || await aJ(r)) return r;
    throw new b6({
        uri: e
    })
}

function cJ(t) {
    let e = t;
    e.startsWith("did:nft:") && (e = e.replace("did:nft:", "").replace(/_/g, "/"));
    const [r, n, i] = e.split("/"), [s, a] = r.split(":"), [o, c] = n.split(":");
    if (!s || s.toLowerCase() !== "eip155") throw new Bh({
        reason: "Only EIP-155 supported"
    });
    if (!a) throw new Bh({
        reason: "Chain ID not found"
    });
    if (!c) throw new Bh({
        reason: "Contract address not found"
    });
    if (!i) throw new Bh({
        reason: "Token ID not found"
    });
    if (!o) throw new Bh({
        reason: "ERC namespace not found"
    });
    return {
        chainID: Number.parseInt(a),
        namespace: o.toLowerCase(),
        contractAddress: c,
        tokenID: i
    }
}
async function lJ(t, {
    nft: e
}) {
    if (e.namespace === "erc721") return ec(t, {
        address: e.contractAddress,
        abi: [{
            name: "tokenURI",
            type: "function",
            stateMutability: "view",
            inputs: [{
                name: "tokenId",
                type: "uint256"
            }],
            outputs: [{
                name: "",
                type: "string"
            }]
        }],
        functionName: "tokenURI",
        args: [BigInt(e.tokenID)]
    });
    if (e.namespace === "erc1155") return ec(t, {
        address: e.contractAddress,
        abi: [{
            name: "uri",
            type: "function",
            stateMutability: "view",
            inputs: [{
                name: "_id",
                type: "uint256"
            }],
            outputs: [{
                name: "",
                type: "string"
            }]
        }],
        functionName: "uri",
        args: [BigInt(e.tokenID)]
    });
    throw new tJ({
        namespace: e.namespace
    })
}
async function dJ(t, {
    gatewayUrls: e,
    record: r
}) {
    return /eip155:/i.test(r) ? uJ(t, {
        gatewayUrls: e,
        record: r
    }) : v6({
        uri: r,
        gatewayUrls: e
    })
}
async function uJ(t, {
    gatewayUrls: e,
    record: r
}) {
    const n = cJ(r),
        i = await lJ(t, {
            nft: n
        }),
        {
            uri: s,
            isOnChain: a,
            isEncoded: o
        } = IP({
            uri: i,
            gatewayUrls: e
        });
    if (a && (s.includes("data:application/json;base64,") || s.startsWith("{"))) {
        const l = o ? atob(s.replace("data:application/json;base64,", "")) : s,
            u = JSON.parse(l);
        return v6({
            uri: $P(u),
            gatewayUrls: e
        })
    }
    let c = n.tokenID;
    return n.namespace === "erc1155" && (c = c.replace("0x", "").padStart(64, "0")), oJ({
        gatewayUrls: e,
        uri: s.replace(/(?:0x)?{id}/, c)
    })
}
async function SP(t, e) {
    const {
        blockNumber: r,
        blockTag: n,
        key: i,
        name: s,
        gatewayUrls: a,
        strict: o
    } = e, {
        chain: c
    } = t, l = (() => {
        if (e.universalResolverAddress) return e.universalResolverAddress;
        if (!c) throw new Error("client chain not configured. universalResolverAddress is required.");
        return fh({
            blockNumber: r,
            chain: c,
            contract: "ensUniversalResolver"
        })
    })(), u = c == null ? void 0 : c.ensTlds;
    if (u && !u.some(h => s.endsWith(h))) return null;
    try {
        const h = {
                address: l,
                abi: YS,
                functionName: "resolve",
                args: [cn(B1(s)), hs({
                    abi: iE,
                    functionName: "text",
                    args: [Dg(s), i]
                }), a ? ? [T1]],
                blockNumber: r,
                blockTag: n
            },
            p = await ht(t, ec, "readContract")(h);
        if (p[0] === "0x") return null;
        const g = Ad({
            abi: iE,
            functionName: "text",
            data: p[0]
        });
        return g === "" ? null : g
    } catch (h) {
        if (o) throw h;
        if (w6(h, "resolve")) return null;
        throw h
    }
}
async function hJ(t, {
    blockNumber: e,
    blockTag: r,
    assetGatewayUrls: n,
    name: i,
    gatewayUrls: s,
    strict: a,
    universalResolverAddress: o
}) {
    const c = await ht(t, SP, "getEnsText")({
        blockNumber: e,
        blockTag: r,
        key: "avatar",
        name: i,
        universalResolverAddress: o,
        gatewayUrls: s,
        strict: a
    });
    if (!c) return null;
    try {
        return await dJ(t, {
            record: c,
            gatewayUrls: n
        })
    } catch {
        return null
    }
}
async function fJ(t, {
    address: e,
    blockNumber: r,
    blockTag: n,
    gatewayUrls: i,
    strict: s,
    universalResolverAddress: a
}) {
    let o = a;
    if (!o) {
        if (!t.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
        o = fh({
            blockNumber: r,
            chain: t.chain,
            contract: "ensUniversalResolver"
        })
    }
    const c = `${e.toLowerCase().substring(2)}.addr.reverse`;
    try {
        const l = {
                address: o,
                abi: vq,
                functionName: "reverse",
                args: [cn(B1(c))],
                blockNumber: r,
                blockTag: n
            },
            u = ht(t, ec, "readContract"),
            [h, f] = i ? await u({ ...l,
                args: [...l.args, i]
            }) : await u(l);
        return e.toLowerCase() !== f.toLowerCase() ? null : h
    } catch (l) {
        if (s) throw l;
        if (w6(l, "reverse")) return null;
        throw l
    }
}
async function pJ(t, e) {
    const {
        blockNumber: r,
        blockTag: n,
        name: i
    } = e, {
        chain: s
    } = t, a = (() => {
        if (e.universalResolverAddress) return e.universalResolverAddress;
        if (!s) throw new Error("client chain not configured. universalResolverAddress is required.");
        return fh({
            blockNumber: r,
            chain: s,
            contract: "ensUniversalResolver"
        })
    })(), o = s == null ? void 0 : s.ensTlds;
    if (o && !o.some(l => i.endsWith(l))) throw new Error(`${i} is not a valid ENS TLD (${o==null?void 0:o.join(", ")}) for chain "${s.name}" (id: ${s.id}).`);
    const [c] = await ht(t, ec, "readContract")({
        address: a,
        abi: [{
            inputs: [{
                type: "bytes"
            }],
            name: "findResolver",
            outputs: [{
                type: "address"
            }, {
                type: "bytes32"
            }],
            stateMutability: "view",
            type: "function"
        }],
        functionName: "findResolver",
        args: [cn(B1(i))],
        blockNumber: r,
        blockTag: n
    });
    return c
}
async function TP(t, e) {
    var y, w, x;
    const {
        account: r = t.account,
        blockNumber: n,
        blockTag: i = "latest",
        blobs: s,
        data: a,
        gas: o,
        gasPrice: c,
        maxFeePerBlobGas: l,
        maxFeePerGas: u,
        maxPriorityFeePerGas: h,
        to: f,
        value: p,
        ...g
    } = e, m = r ? qr(r) : void 0;
    try {
        kd(e);
        const _ = (typeof n == "bigint" ? nt(n) : void 0) || i,
            b = (x = (w = (y = t.chain) == null ? void 0 : y.formatters) == null ? void 0 : w.transactionRequest) == null ? void 0 : x.format,
            I = (b || ph)({ ...S1(g, {
                    format: b
                }),
                from: m == null ? void 0 : m.address,
                blobs: s,
                data: a,
                gas: o,
                gasPrice: c,
                maxFeePerBlobGas: l,
                maxFeePerGas: u,
                maxPriorityFeePerGas: h,
                to: f,
                value: p
            }),
            T = await t.request({
                method: "eth_createAccessList",
                params: [I, _]
            });
        return {
            accessList: T.accessList,
            gasUsed: BigInt(T.gasUsed)
        }
    } catch (E) {
        throw vT(E, { ...e,
            account: m,
            chain: t.chain
        })
    }
}
async function gJ(t) {
    const e = M1(t, {
            method: "eth_newBlockFilter"
        }),
        r = await t.request({
            method: "eth_newBlockFilter"
        });
    return {
        id: r,
        request: e(r),
        type: "block"
    }
}
async function PP(t, {
    address: e,
    args: r,
    event: n,
    events: i,
    fromBlock: s,
    strict: a,
    toBlock: o
} = {}) {
    const c = i ? ? (n ? [n] : void 0),
        l = M1(t, {
            method: "eth_newFilter"
        });
    let u = [];
    c && (u = [c.flatMap(p => r0({
        abi: [p],
        eventName: p.name,
        args: r
    }))], n && (u = u[0]));
    const h = await t.request({
        method: "eth_newFilter",
        params: [{
            address: e,
            fromBlock: typeof s == "bigint" ? nt(s) : s,
            toBlock: typeof o == "bigint" ? nt(o) : o,
            ...u.length ? {
                topics: u
            } : {}
        }]
    });
    return {
        abi: c,
        args: r,
        eventName: n ? n.name : void 0,
        fromBlock: s,
        id: h,
        request: l(h),
        strict: !!a,
        toBlock: o,
        type: "event"
    }
}
async function NP(t) {
    const e = M1(t, {
            method: "eth_newPendingTransactionFilter"
        }),
        r = await t.request({
            method: "eth_newPendingTransactionFilter"
        });
    return {
        id: r,
        request: e(r),
        type: "transaction"
    }
}
async function mJ(t) {
    const e = await t.request({
        method: "eth_blobBaseFee"
    });
    return BigInt(e)
}
async function yJ(t, {
    blockHash: e,
    blockNumber: r,
    blockTag: n = "latest"
} = {}) {
    const i = r !== void 0 ? nt(r) : void 0;
    let s;
    return e ? s = await t.request({
        method: "eth_getBlockTransactionCountByHash",
        params: [e]
    }, {
        dedupe: !0
    }) : s = await t.request({
        method: "eth_getBlockTransactionCountByNumber",
        params: [i || n]
    }, {
        dedupe: !!i
    }), va(s)
}
async function d7(t, {
    address: e,
    blockNumber: r,
    blockTag: n = "latest"
}) {
    const i = r !== void 0 ? nt(r) : void 0,
        s = await t.request({
            method: "eth_getCode",
            params: [e, i || n]
        }, {
            dedupe: !!i
        });
    if (s !== "0x") return s
}
class wJ extends be {
    constructor({
        address: e
    }) {
        super(`No EIP-712 domain found on contract "${e}".`, {
            metaMessages: ["Ensure that:", `- The contract is deployed at the address "${e}".`, "- `eip712Domain()` function exists on the contract.", "- `eip712Domain()` function matches signature to ERC-5267 specification."],
            name: "Eip712DomainNotFoundError"
        })
    }
}
async function bJ(t, e) {
    const {
        address: r,
        factory: n,
        factoryData: i
    } = e;
    try {
        const [s, a, o, c, l, u, h] = await ht(t, ec, "readContract")({
            abi: vJ,
            address: r,
            functionName: "eip712Domain",
            factory: n,
            factoryData: i
        });
        return {
            domain: {
                name: a,
                version: o,
                chainId: Number(c),
                verifyingContract: l,
                salt: u
            },
            extensions: h,
            fields: s
        }
    } catch (s) {
        const a = s;
        throw a.name === "ContractFunctionExecutionError" && a.cause.name === "ContractFunctionZeroDataError" ? new wJ({
            address: r
        }) : a
    }
}
const vJ = [{
    inputs: [],
    name: "eip712Domain",
    outputs: [{
        name: "fields",
        type: "bytes1"
    }, {
        name: "name",
        type: "string"
    }, {
        name: "version",
        type: "string"
    }, {
        name: "chainId",
        type: "uint256"
    }, {
        name: "verifyingContract",
        type: "address"
    }, {
        name: "salt",
        type: "bytes32"
    }, {
        name: "extensions",
        type: "uint256[]"
    }],
    stateMutability: "view",
    type: "function"
}];

function xJ(t) {
    var e;
    return {
        baseFeePerGas: t.baseFeePerGas.map(r => BigInt(r)),
        gasUsedRatio: t.gasUsedRatio,
        oldestBlock: BigInt(t.oldestBlock),
        reward: (e = t.reward) == null ? void 0 : e.map(r => r.map(n => BigInt(n)))
    }
}
async function EJ(t, {
    blockCount: e,
    blockNumber: r,
    blockTag: n = "latest",
    rewardPercentiles: i
}) {
    const s = typeof r == "bigint" ? nt(r) : void 0,
        a = await t.request({
            method: "eth_feeHistory",
            params: [nt(e), s || n, i]
        }, {
            dedupe: !!s
        });
    return xJ(a)
}
async function _J(t, {
    filter: e
}) {
    const r = e.strict ? ? !1,
        i = (await e.request({
            method: "eth_getFilterLogs",
            params: [e.id]
        })).map(s => Qo(s));
    return e.abi ? s6({
        abi: e.abi,
        logs: i,
        strict: r
    }) : i
}

function CJ(t) {
    return t.map(e => ({ ...e,
        value: BigInt(e.value)
    }))
}

function AJ(t) {
    return { ...t,
        balance: t.balance ? BigInt(t.balance) : void 0,
        nonce: t.nonce ? va(t.nonce) : void 0,
        storageProof: t.storageProof ? CJ(t.storageProof) : void 0
    }
}
async function kJ(t, {
    address: e,
    blockNumber: r,
    blockTag: n,
    storageKeys: i
}) {
    const s = n ? ? "latest",
        a = r !== void 0 ? nt(r) : void 0,
        o = await t.request({
            method: "eth_getProof",
            params: [e, i, a || s]
        });
    return AJ(o)
}
async function IJ(t, {
    address: e,
    blockNumber: r,
    blockTag: n = "latest",
    slot: i
}) {
    const s = r !== void 0 ? nt(r) : void 0;
    return await t.request({
        method: "eth_getStorageAt",
        params: [e, i, s || n]
    })
}
async function x6(t, {
    blockHash: e,
    blockNumber: r,
    blockTag: n,
    hash: i,
    index: s
}) {
    var u, h, f;
    const a = n || "latest",
        o = r !== void 0 ? nt(r) : void 0;
    let c = null;
    if (i ? c = await t.request({
            method: "eth_getTransactionByHash",
            params: [i]
        }, {
            dedupe: !0
        }) : e ? c = await t.request({
            method: "eth_getTransactionByBlockHashAndIndex",
            params: [e, nt(s)]
        }, {
            dedupe: !0
        }) : c = await t.request({
            method: "eth_getTransactionByBlockNumberAndIndex",
            params: [o || a, nt(s)]
        }, {
            dedupe: !!o
        }), !c) throw new yT({
        blockHash: e,
        blockNumber: r,
        blockTag: a,
        hash: i,
        index: s
    });
    return (((f = (h = (u = t.chain) == null ? void 0 : u.formatters) == null ? void 0 : h.transaction) == null ? void 0 : f.format) || zT)(c)
}
async function $J(t, {
    hash: e,
    transactionReceipt: r
}) {
    const [n, i] = await Promise.all([ht(t, n0, "getBlockNumber")({}), e ? ht(t, x6, "getTransaction")({
        hash: e
    }) : void 0]), s = (r == null ? void 0 : r.blockNumber) || (i == null ? void 0 : i.blockNumber);
    return s ? n - s + 1 n : 0 n
}
async function Lg(t, {
    hash: e
}) {
    var i, s, a;
    const r = await t.request({
        method: "eth_getTransactionReceipt",
        params: [e]
    }, {
        dedupe: !0
    });
    if (!r) throw new wT({
        hash: e
    });
    return (((a = (s = (i = t.chain) == null ? void 0 : i.formatters) == null ? void 0 : s.transactionReceipt) == null ? void 0 : a.format) || yV)(r)
}
async function SJ(t, e) {
    var w;
    const {
        account: r,
        allowFailure: n = !0,
        batchSize: i,
        blockNumber: s,
        blockTag: a,
        multicallAddress: o,
        stateOverride: c
    } = e, l = e.contracts, u = i ? ? (typeof((w = t.batch) == null ? void 0 : w.multicall) == "object" && t.batch.multicall.batchSize || 1024);
    let h = o;
    if (!h) {
        if (!t.chain) throw new Error("client chain not configured. multicallAddress is required.");
        h = fh({
            blockNumber: s,
            chain: t.chain,
            contract: "multicall3"
        })
    }
    const f = [
        []
    ];
    let p = 0,
        g = 0;
    for (let x = 0; x < l.length; x++) {
        const {
            abi: E,
            address: _,
            args: b,
            functionName: A
        } = l[x];
        try {
            const I = hs({
                abi: E,
                args: b,
                functionName: A
            });
            g += (I.length - 2) / 2, u > 0 && g > u && f[p].length > 0 && (p++, g = (I.length - 2) / 2, f[p] = []), f[p] = [...f[p], {
                allowFailure: !0,
                callData: I,
                target: _
            }]
        } catch (I) {
            const T = ld(I, {
                abi: E,
                address: _,
                args: b,
                docsPath: "/docs/contract/multicall",
                functionName: A,
                sender: r
            });
            if (!n) throw T;
            f[p] = [...f[p], {
                allowFailure: !0,
                callData: "0x",
                target: _
            }]
        }
    }
    const m = await Promise.allSettled(f.map(x => ht(t, ec, "readContract")({
            abi: Vv,
            account: r,
            address: h,
            args: [x],
            blockNumber: s,
            blockTag: a,
            functionName: "aggregate3",
            stateOverride: c
        }))),
        y = [];
    for (let x = 0; x < m.length; x++) {
        const E = m[x];
        if (E.status === "rejected") {
            if (!n) throw E.reason;
            for (let b = 0; b < f[x].length; b++) y.push({
                status: "failure",
                error: E.reason,
                result: void 0
            });
            continue
        }
        const _ = E.value;
        for (let b = 0; b < _.length; b++) {
            const {
                returnData: A,
                success: I
            } = _[b], {
                callData: T
            } = f[x][b], {
                abi: C,
                address: $,
                functionName: P,
                args: N
            } = l[y.length];
            try {
                if (T === "0x") throw new Yp;
                if (!I) throw new k1({
                    data: A
                });
                const R = Ad({
                    abi: C,
                    args: N,
                    data: A,
                    functionName: P
                });
                y.push(n ? {
                    result: R,
                    status: "success"
                } : R)
            } catch (R) {
                const D = ld(R, {
                    abi: C,
                    address: $,
                    args: N,
                    docsPath: "/docs/contract/multicall",
                    functionName: P
                });
                if (!n) throw D;
                y.push({
                    error: D,
                    result: void 0,
                    status: "failure"
                })
            }
        }
    }
    if (y.length !== l.length) throw new be("multicall results mismatch");
    return y
}
async function y3(t, e) {
    const {
        blockNumber: r,
        blockTag: n = t.experimental_blockTag ? ? "latest",
        blocks: i,
        returnFullTransactions: s,
        traceTransfers: a,
        validation: o
    } = e;
    try {
        const c = [];
        for (const f of i) {
            const p = f.blockOverrides ? GS(f.blockOverrides) : void 0,
                g = f.calls.map(y => {
                    const w = y,
                        x = w.account ? qr(w.account) : void 0,
                        E = w.abi ? hs(w) : w.data,
                        _ = { ...w,
                            data: w.dataSuffix ? as([E || "0x", w.dataSuffix]) : E,
                            from: w.from ? ? (x == null ? void 0 : x.address)
                        };
                    return kd(_), ph(_)
                }),
                m = f.stateOverrides ? n6(f.stateOverrides) : void 0;
            c.push({
                blockOverrides: p,
                calls: g,
                stateOverrides: m
            })
        }
        const u = (typeof r == "bigint" ? nt(r) : void 0) || n;
        return (await t.request({
            method: "eth_simulateV1",
            params: [{
                blockStateCalls: c,
                returnFullTransactions: s,
                traceTransfers: a,
                validation: o
            }, u]
        })).map((f, p) => ({ ...qT(f),
            calls: f.calls.map((g, m) => {
                var $, P;
                const {
                    abi: y,
                    args: w,
                    functionName: x,
                    to: E
                } = i[p].calls[m], _ = (($ = g.error) == null ? void 0 : $.data) ? ? g.returnData, b = BigInt(g.gasUsed), A = (P = g.logs) == null ? void 0 : P.map(N => Qo(N)), I = g.status === "0x1" ? "success" : "failure", T = y && I === "success" && _ !== "0x" ? Ad({
                    abi: y,
                    data: _,
                    functionName: x
                }) : null, C = (() => {
                    var R;
                    if (I === "success") return;
                    let N;
                    if (((R = g.error) == null ? void 0 : R.data) === "0x" ? N = new Yp : g.error && (N = new k1(g.error)), !!N) return ld(N, {
                        abi: y ? ? [],
                        address: E ? ? "0x",
                        args: w,
                        functionName: x ? ? "<unknown>"
                    })
                })();
                return {
                    data: _,
                    gasUsed: b,
                    logs: A,
                    status: I,
                    ...I === "success" ? {
                        result: T
                    } : {
                        error: C
                    }
                }
            })
        }))
    } catch (c) {
        const l = c,
            u = $1(l, {});
        throw u instanceof Xp ? l : u
    }
}

function OP(t, e = {}) {
    const {
        as: r = typeof t == "string" ? "Hex" : "Bytes"
    } = e, n = q4(aq(t));
    return r === "Bytes" ? n : qS(n)
}
let TJ = class extends Map {
    constructor(e) {
        super(), Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.maxSize = e
    }
    get(e) {
        const r = super.get(e);
        return super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r
    }
    set(e, r) {
        if (super.set(e, r), this.maxSize && this.size > this.maxSize) {
            const n = this.keys().next().value;
            n && this.delete(n)
        }
        return this
    }
};
const PJ = {
        checksum: new TJ(8192)
    },
    Rw = PJ.checksum,
    NJ = /^0x[a-fA-F0-9]{40}$/;

function W1(t, e = {}) {
    const {
        strict: r = !0
    } = e;
    if (!NJ.test(t)) throw new u7({
        address: t,
        cause: new jJ
    });
    if (r) {
        if (t.toLowerCase() === t) return;
        if (OJ(t) !== t) throw new u7({
            address: t,
            cause: new RJ
        })
    }
}

function OJ(t) {
    if (Rw.has(t)) return Rw.get(t);
    W1(t, {
        strict: !1
    });
    const e = t.substring(2).toLowerCase(),
        r = OP(lq(e), {
            as: "Bytes"
        }),
        n = e.split("");
    for (let s = 0; s < 40; s += 2) r[s >> 1] >> 4 >= 8 && n[s] && (n[s] = n[s].toUpperCase()), (r[s >> 1] & 15) >= 8 && n[s + 1] && (n[s + 1] = n[s + 1].toUpperCase());
    const i = `0x${n.join("")}`;
    return Rw.set(t, i), i
}

function w3(t, e = {}) {
    const {
        strict: r = !0
    } = e ? ? {};
    try {
        return W1(t, {
            strict: r
        }), !0
    } catch {
        return !1
    }
}
class u7 extends Hr {
    constructor({
        address: e,
        cause: r
    }) {
        super(`Address "${e}" is invalid.`, {
            cause: r
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidAddressError"
        })
    }
}
class jJ extends Hr {
    constructor() {
        super("Address is not a 20 byte (40 hexadecimal character) value."), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidInputError"
        })
    }
}
class RJ extends Hr {
    constructor() {
        super("Address does not match its checksum counterpart."), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Address.InvalidChecksumError"
        })
    }
}

function b3(t) {
    let e = !0,
        r = "",
        n = 0,
        i = "",
        s = !1;
    for (let a = 0; a < t.length; a++) {
        const o = t[a];
        if (["(", ")", ","].includes(o) && (e = !0), o === "(" && n++, o === ")" && n--, !!e) {
            if (n === 0) {
                if (o === " " && ["event", "function", "error", ""].includes(i)) i = "";
                else if (i += o, o === ")") {
                    s = !0;
                    break
                }
                continue
            }
            if (o === " ") {
                t[a - 1] !== "," && r !== "," && r !== ",(" && (r = "", e = !1);
                continue
            }
            i += o, r += o
        }
    }
    if (!s) throw new Hr("Unable to normalize signature.");
    return i
}

function v3(t, e) {
    const r = typeof t,
        n = e.type;
    switch (n) {
        case "address":
            return w3(t, {
                strict: !1
            });
        case "bool":
            return r === "boolean";
        case "function":
            return r === "string";
        case "string":
            return r === "string";
        default:
            return n === "tuple" && "components" in e ? Object.values(e.components).every((i, s) => v3(Object.values(t)[s], i)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(n) ? r === "number" || r === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(n) ? r === "string" || t instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(n) ? Array.isArray(t) && t.every(i => v3(i, { ...e,
                type: n.replace(/(\[[0-9]{0,}\])$/, "")
            })) : !1
    }
}

function jP(t, e, r) {
    for (const n in t) {
        const i = t[n],
            s = e[n];
        if (i.type === "tuple" && s.type === "tuple" && "components" in i && "components" in s) return jP(i.components, s.components, r[n]);
        const a = [i.type, s.type];
        if (a.includes("address") && a.includes("bytes20") ? !0 : a.includes("address") && a.includes("string") ? w3(r[n], {
                strict: !1
            }) : a.includes("address") && a.includes("bytes") ? w3(r[n], {
                strict: !1
            }) : !1) return a
    }
}

function RP(t, e = {}) {
    const {
        prepare: r = !0
    } = e, n = Array.isArray(t) || typeof t == "string" ? X8(t) : t;
    return { ...n,
        ...r ? {
            hash: ku(n)
        } : {}
    }
}

function MJ(t, e, r) {
    const {
        args: n = [],
        prepare: i = !0
    } = r ? ? {}, s = mq(e, {
        strict: !1
    }), a = t.filter(l => s ? l.type === "function" || l.type === "error" ? MP(l) === Z4(e, 0, 4) : l.type === "event" ? ku(l) === e : !1 : "name" in l && l.name === e);
    if (a.length === 0) throw new x3({
        name: e
    });
    if (a.length === 1) return { ...a[0],
        ...i ? {
            hash: ku(a[0])
        } : {}
    };
    let o;
    for (const l of a) {
        if (!("inputs" in l)) continue;
        if (!n || n.length === 0) {
            if (!l.inputs || l.inputs.length === 0) return { ...l,
                ...i ? {
                    hash: ku(l)
                } : {}
            };
            continue
        }
        if (!l.inputs || l.inputs.length === 0 || l.inputs.length !== n.length) continue;
        if (n.every((h, f) => {
                const p = "inputs" in l && l.inputs[f];
                return p ? v3(h, p) : !1
            })) {
            if (o && "inputs" in o && o.inputs) {
                const h = jP(l.inputs, o.inputs, n);
                if (h) throw new LJ({
                    abiItem: l,
                    type: h[0]
                }, {
                    abiItem: o,
                    type: h[1]
                })
            }
            o = l
        }
    }
    const c = (() => {
        if (o) return o;
        const [l, ...u] = a;
        return { ...l,
            overloads: u
        }
    })();
    if (!c) throw new x3({
        name: e
    });
    return { ...c,
        ...i ? {
            hash: ku(c)
        } : {}
    }
}

function MP(t) {
    return Z4(ku(t), 0, 4)
}

function DJ(t) {
    const e = typeof t == "string" ? t : gm(t);
    return b3(e)
}

function ku(t) {
    return typeof t != "string" && "hash" in t && t.hash ? t.hash : OP(Y4(DJ(t)))
}
class LJ extends Hr {
    constructor(e, r) {
        super("Found ambiguous types in overloaded ABI Items.", {
            metaMessages: [`\`${e.type}\` in \`${b3(gm(e.abiItem))}\`, and`, `\`${r.type}\` in \`${b3(gm(r.abiItem))}\``, "", "These types encode differently and cannot be distinguished at runtime.", "Remove one of the ambiguous items in the ABI."]
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiItem.AmbiguityError"
        })
    }
}
class x3 extends Hr {
    constructor({
        name: e,
        data: r,
        type: n = "item"
    }) {
        const i = e ? ` with name "${e}"` : r ? ` with data "${r}"` : "";
        super(`ABI ${n}${i} not found.`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiItem.NotFoundError"
        })
    }
}
const UJ = /^(.*)\[([0-9]*)\]$/,
    FJ = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
    DP = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

function BJ({
    checksumAddress: t,
    parameters: e,
    values: r
}) {
    const n = [];
    for (let i = 0; i < e.length; i++) n.push(E6({
        checksumAddress: t,
        parameter: e[i],
        value: r[i]
    }));
    return n
}

function E6({
    checksumAddress: t = !1,
    parameter: e,
    value: r
}) {
    const n = e,
        i = YJ(n.type);
    if (i) {
        const [s, a] = i;
        return zJ(r, {
            checksumAddress: t,
            length: s,
            parameter: { ...n,
                type: a
            }
        })
    }
    if (n.type === "tuple") return KJ(r, {
        checksumAddress: t,
        parameter: n
    });
    if (n.type === "address") return WJ(r, {
        checksum: t
    });
    if (n.type === "bool") return HJ(r);
    if (n.type.startsWith("uint") || n.type.startsWith("int")) {
        const s = n.type.startsWith("int"),
            [, , a = "256"] = DP.exec(n.type) ? ? [];
        return VJ(r, {
            signed: s,
            size: Number(a)
        })
    }
    if (n.type.startsWith("bytes")) return qJ(r, {
        type: n.type
    });
    if (n.type === "string") return GJ(r);
    throw new BP(n.type)
}

function _6(t) {
    let e = 0;
    for (let s = 0; s < t.length; s++) {
        const {
            dynamic: a,
            encoded: o
        } = t[s];
        a ? e += 32 : e += Os(o)
    }
    const r = [],
        n = [];
    let i = 0;
    for (let s = 0; s < t.length; s++) {
        const {
            dynamic: a,
            encoded: o
        } = t[s];
        a ? (r.push(si(e + i, {
            size: 32
        })), n.push(o), i += Os(o)) : r.push(o)
    }
    return lo(...r, ...n)
}

function WJ(t, e) {
    const {
        checksum: r = !1
    } = e;
    return W1(t, {
        strict: r
    }), {
        dynamic: !1,
        encoded: od(t.toLowerCase())
    }
}

function zJ(t, e) {
    const {
        checksumAddress: r,
        length: n,
        parameter: i
    } = e, s = n === null;
    if (!Array.isArray(t)) throw new JJ(t);
    if (!s && t.length !== n) throw new ZJ({
        expectedLength: n,
        givenLength: t.length,
        type: `${i.type}[${n}]`
    });
    let a = !1;
    const o = [];
    for (let c = 0; c < t.length; c++) {
        const l = E6({
            checksumAddress: r,
            parameter: i,
            value: t[c]
        });
        l.dynamic && (a = !0), o.push(l)
    }
    if (s || a) {
        const c = _6(o);
        if (s) {
            const l = si(o.length, {
                size: 32
            });
            return {
                dynamic: !0,
                encoded: o.length > 0 ? lo(l, c) : l
            }
        }
        if (a) return {
            dynamic: !0,
            encoded: c
        }
    }
    return {
        dynamic: !1,
        encoded: lo(...o.map(({
            encoded: c
        }) => c))
    }
}

function qJ(t, {
    type: e
}) {
    const [, r] = e.split("bytes"), n = Os(t);
    if (!r) {
        let i = t;
        return n % 32 !== 0 && (i = cd(i, Math.ceil((t.length - 2) / 2 / 32) * 32)), {
            dynamic: !0,
            encoded: lo(od(si(n, {
                size: 32
            })), i)
        }
    }
    if (n !== Number.parseInt(r)) throw new UP({
        expectedSize: Number.parseInt(r),
        value: t
    });
    return {
        dynamic: !1,
        encoded: cd(t)
    }
}

function HJ(t) {
    if (typeof t != "boolean") throw new Hr(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);
    return {
        dynamic: !1,
        encoded: od(zS(t))
    }
}

function VJ(t, {
    signed: e,
    size: r
}) {
    if (typeof r == "number") {
        const n = 2 n ** (BigInt(r) - (e ? 1 n : 0 n)) - 1 n,
            i = e ? -n - 1 n : 0 n;
        if (t > n || t < i) throw new HS({
            max: n.toString(),
            min: i.toString(),
            signed: e,
            size: r / 8,
            value: t.toString()
        })
    }
    return {
        dynamic: !1,
        encoded: si(t, {
            size: 32,
            signed: e
        })
    }
}

function GJ(t) {
    const e = Y4(t),
        r = Math.ceil(Os(e) / 32),
        n = [];
    for (let i = 0; i < r; i++) n.push(cd(Z4(e, i * 32, (i + 1) * 32)));
    return {
        dynamic: !0,
        encoded: lo(cd(si(Os(e), {
            size: 32
        })), ...n)
    }
}

function KJ(t, e) {
    const {
        checksumAddress: r,
        parameter: n
    } = e;
    let i = !1;
    const s = [];
    for (let a = 0; a < n.components.length; a++) {
        const o = n.components[a],
            c = Array.isArray(t) ? a : o.name,
            l = E6({
                checksumAddress: r,
                parameter: o,
                value: t[c]
            });
        s.push(l), l.dynamic && (i = !0)
    }
    return {
        dynamic: i,
        encoded: i ? _6(s) : lo(...s.map(({
            encoded: a
        }) => a))
    }
}

function YJ(t) {
    const e = t.match(/^(.*)\[(\d+)?\]$/);
    return e ? [e[2] ? Number(e[2]) : null, e[1]] : void 0
}

function LP(t, e, r) {
    const {
        checksumAddress: n = !1
    } = {};
    if (t.length !== e.length) throw new FP({
        expectedLength: t.length,
        givenLength: e.length
    });
    const i = BJ({
            checksumAddress: n,
            parameters: t,
            values: e
        }),
        s = _6(i);
    return s.length === 0 ? "0x" : s
}

function E3(t, e) {
    if (t.length !== e.length) throw new FP({
        expectedLength: t.length,
        givenLength: e.length
    });
    const r = [];
    for (let n = 0; n < t.length; n++) {
        const i = t[n],
            s = e[n];
        r.push(E3.encode(i, s))
    }
    return lo(...r)
}(function(t) {
    function e(r, n, i = !1) {
        if (r === "address") {
            const c = n;
            return W1(c), od(c.toLowerCase(), i ? 32 : 0)
        }
        if (r === "string") return Y4(n);
        if (r === "bytes") return n;
        if (r === "bool") return od(zS(n), i ? 32 : 1);
        const s = r.match(DP);
        if (s) {
            const [c, l, u = "256"] = s, h = Number.parseInt(u) / 8;
            return si(n, {
                size: i ? 32 : h,
                signed: l === "int"
            })
        }
        const a = r.match(FJ);
        if (a) {
            const [c, l] = a;
            if (Number.parseInt(l) !== (n.length - 2) / 2) throw new UP({
                expectedSize: Number.parseInt(l),
                value: n
            });
            return cd(n, i ? 32 : 0)
        }
        const o = r.match(UJ);
        if (o && Array.isArray(n)) {
            const [c, l] = o, u = [];
            for (let h = 0; h < n.length; h++) u.push(e(l, n[h], !0));
            return u.length === 0 ? "0x" : lo(...u)
        }
        throw new BP(r)
    }
    t.encode = e
})(E3 || (E3 = {}));
class ZJ extends Hr {
    constructor({
        expectedLength: e,
        givenLength: r,
        type: n
    }) {
        super(`Array length mismatch for type \`${n}\`. Expected: \`${e}\`. Given: \`${r}\`.`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.ArrayLengthMismatchError"
        })
    }
}
class UP extends Hr {
    constructor({
        expectedSize: e,
        value: r
    }) {
        super(`Size of bytes "${r}" (bytes${Os(r)}) does not match expected size (bytes${e}).`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.BytesSizeMismatchError"
        })
    }
}
class FP extends Hr {
    constructor({
        expectedLength: e,
        givenLength: r
    }) {
        super(["ABI encoding parameters/values length mismatch.", `Expected length (parameters): ${e}`, `Given length (values): ${r}`].join(`
`)), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.LengthMismatchError"
        })
    }
}
class JJ extends Hr {
    constructor(e) {
        super(`Value \`${e}\` is not a valid array.`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.InvalidArrayError"
        })
    }
}
class BP extends Hr {
    constructor(e) {
        super(`Type \`${e}\` is not a valid ABI Type.`), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiParameters.InvalidTypeError"
        })
    }
}

function QJ(t, e) {
    var i;
    const {
        bytecode: r,
        args: n
    } = e;
    return lo(r, (i = t.inputs) != null && i.length && (n != null && n.length) ? LP(t.inputs, n) : "0x")
}

function XJ(t) {
    return RP(t)
}

function eQ(t, ...e) {
    const {
        overloads: r
    } = t, n = r ? tQ([t, ...r], t.name, {
        args: e[0]
    }) : t, i = rQ(n), s = e.length > 0 ? LP(n.inputs, e[0]) : void 0;
    return s ? lo(i, s) : i
}

function Yd(t, e = {}) {
    return RP(t, e)
}

function tQ(t, e, r) {
    const n = MJ(t, e, r);
    if (n.type !== "function") throw new x3({
        name: e,
        type: "function"
    });
    return n
}

function rQ(t) {
    return MP(t)
}
const nQ = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    Ma = "0x0000000000000000000000000000000000000000",
    iQ = "0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033";
async function sQ(t, e) {
    const {
        blockNumber: r,
        blockTag: n,
        calls: i,
        stateOverrides: s,
        traceAssetChanges: a,
        traceTransfers: o,
        validation: c
    } = e, l = e.account ? qr(e.account) : void 0;
    if (a && !l) throw new be("`account` is required when `traceAssetChanges` is true");
    const u = l ? QJ(XJ("constructor(bytes, bytes)"), {
            bytecode: ZS,
            args: [iQ, eQ(Yd("function getBalance(address)"), [l.address])]
        }) : void 0,
        h = a ? await Promise.all(e.calls.map(async U => {
            if (!U.data && !U.abi) return;
            const {
                accessList: k
            } = await TP(t, {
                account: l.address,
                ...U,
                data: U.abi ? hs(U) : U.data
            });
            return k.map(({
                address: F,
                storageKeys: q
            }) => q.length > 0 ? F : null)
        })).then(U => U.flat().filter(Boolean)) : [],
        f = await y3(t, {
            blockNumber: r,
            blockTag: n,
            blocks: [...a ? [{
                calls: [{
                    data: u
                }],
                stateOverrides: s
            }, {
                calls: h.map((U, k) => ({
                    abi: [Yd("function balanceOf(address) returns (uint256)")],
                    functionName: "balanceOf",
                    args: [l.address],
                    to: U,
                    from: Ma,
                    nonce: k
                })),
                stateOverrides: [{
                    address: Ma,
                    nonce: 0
                }]
            }] : [], {
                calls: [...i, {}].map(U => ({ ...U,
                    from: l == null ? void 0 : l.address
                })),
                stateOverrides: s
            }, ...a ? [{
                calls: [{
                    data: u
                }]
            }, {
                calls: h.map((U, k) => ({
                    abi: [Yd("function balanceOf(address) returns (uint256)")],
                    functionName: "balanceOf",
                    args: [l.address],
                    to: U,
                    from: Ma,
                    nonce: k
                })),
                stateOverrides: [{
                    address: Ma,
                    nonce: 0
                }]
            }, {
                calls: h.map((U, k) => ({
                    to: U,
                    abi: [Yd("function decimals() returns (uint256)")],
                    functionName: "decimals",
                    from: Ma,
                    nonce: k
                })),
                stateOverrides: [{
                    address: Ma,
                    nonce: 0
                }]
            }, {
                calls: h.map((U, k) => ({
                    to: U,
                    abi: [Yd("function tokenURI(uint256) returns (string)")],
                    functionName: "tokenURI",
                    args: [0 n],
                    from: Ma,
                    nonce: k
                })),
                stateOverrides: [{
                    address: Ma,
                    nonce: 0
                }]
            }, {
                calls: h.map((U, k) => ({
                    to: U,
                    abi: [Yd("function symbol() returns (string)")],
                    functionName: "symbol",
                    from: Ma,
                    nonce: k
                })),
                stateOverrides: [{
                    address: Ma,
                    nonce: 0
                }]
            }] : []],
            traceTransfers: o,
            validation: c
        }),
        p = a ? f[2] : f[0],
        [g, m, , y, w, x, E, _] = a ? f : [],
        {
            calls: b,
            ...A
        } = p,
        I = b.slice(0, -1) ? ? [],
        T = (g == null ? void 0 : g.calls) ? ? [],
        C = (m == null ? void 0 : m.calls) ? ? [],
        $ = [...T, ...C].map(U => U.status === "success" ? ss(U.data) : null),
        P = (y == null ? void 0 : y.calls) ? ? [],
        N = (w == null ? void 0 : w.calls) ? ? [],
        R = [...P, ...N].map(U => U.status === "success" ? ss(U.data) : null),
        D = ((x == null ? void 0 : x.calls) ? ? []).map(U => U.status === "success" ? U.result : null),
        S = ((_ == null ? void 0 : _.calls) ? ? []).map(U => U.status === "success" ? U.result : null),
        O = ((E == null ? void 0 : E.calls) ? ? []).map(U => U.status === "success" ? U.result : null),
        M = [];
    for (const [U, k] of R.entries()) {
        const F = $[U];
        if (typeof k != "bigint" || typeof F != "bigint") continue;
        const q = D[U - 1],
            W = S[U - 1],
            K = O[U - 1],
            H = U === 0 ? {
                address: nQ,
                decimals: 18,
                symbol: "ETH"
            } : {
                address: h[U - 1],
                decimals: K || q ? Number(q ? ? 1) : void 0,
                symbol: W ? ? void 0
            };
        M.some(j => j.token.address === H.address) || M.push({
            token: H,
            value: {
                pre: F,
                post: k,
                diff: k - F
            }
        })
    }
    return {
        assetChanges: M,
        block: A,
        results: I
    }
}

function aQ({
    r: t,
    s: e,
    to: r = "hex",
    v: n,
    yParity: i
}) {
    const s = (() => {
            if (i === 0 || i === 1) return i;
            if (n && (n === 27 n || n === 28 n || n >= 35 n)) return n % 2 n === 0 n ? 1 : 0;
            throw new Error("Invalid `v` or `yParity` value")
        })(),
        a = `0x${new vS.Signature(ss(t),ss(e)).toCompactHex()}${s===0?"1b":"1c"}`;
    return r === "hex" ? a : Ns(a)
}
async function C6(t, e) {
    var h, f, p;
    const {
        address: r,
        factory: n,
        factoryData: i,
        hash: s,
        signature: a,
        universalSignatureVerifierAddress: o = (p = (f = (h = t.chain) == null ? void 0 : h.contracts) == null ? void 0 : f.universalSignatureVerifier) == null ? void 0 : p.address,
        ...c
    } = e, l = Jn(a) ? a : typeof a == "object" && "r" in a && "s" in a ? aQ(a) : ln(a), u = await (async () => !n && !i || _V(l) ? l : CV({
        address: n,
        data: i,
        signature: l
    }))();
    try {
        const g = o ? {
                to: o,
                data: hs({
                    abi: aE,
                    functionName: "isValidSig",
                    args: [r, s, u]
                }),
                ...c
            } : {
                data: I1({
                    abi: aE,
                    args: [r, s, u],
                    bytecode: _q
                }),
                ...c
            },
            {
                data: m
            } = await ht(t, e0, "call")(g);
        return iz(m ? ? "0x0")
    } catch (g) {
        try {
            if (t0(Zr(r), await MT({
                    hash: s,
                    signature: a
                }))) return !0
        } catch {}
        if (g instanceof bT) return !1;
        throw g
    }
}
async function oQ(t, {
    address: e,
    message: r,
    factory: n,
    factoryData: i,
    signature: s,
    ...a
}) {
    const o = GT(r);
    return C6(t, {
        address: e,
        factory: n,
        factoryData: i,
        hash: o,
        signature: s,
        ...a
    })
}
async function cQ(t, e) {
    const {
        address: r,
        factory: n,
        factoryData: i,
        signature: s,
        message: a,
        primaryType: o,
        types: c,
        domain: l,
        ...u
    } = e, h = GH({
        message: a,
        primaryType: o,
        types: c,
        domain: l
    });
    return C6(t, {
        address: r,
        factory: n,
        factoryData: i,
        hash: h,
        signature: s,
        ...u
    })
}

function WP(t, {
    emitOnBegin: e = !1,
    emitMissed: r = !1,
    onBlockNumber: n,
    onError: i,
    poll: s,
    pollingInterval: a = t.pollingInterval
}) {
    const o = typeof s < "u" ? s : !(t.transport.type === "webSocket" || t.transport.type === "ipc" || t.transport.type === "fallback" && (t.transport.transports[0].config.type === "webSocket" || t.transport.transports[0].config.type === "ipc"));
    let c;
    return o ? (() => {
        const h = zr(["watchBlockNumber", t.uid, e, r, a]);
        return tc(h, {
            onBlockNumber: n,
            onError: i
        }, f => mh(async () => {
            var p;
            try {
                const g = await ht(t, n0, "getBlockNumber")({
                    cacheTime: 0
                });
                if (c) {
                    if (g === c) return;
                    if (g - c > 1 && r)
                        for (let m = c + 1 n; m < g; m++) f.onBlockNumber(m, c), c = m
                }(!c || g > c) && (f.onBlockNumber(g, c), c = g)
            } catch (g) {
                (p = f.onError) == null || p.call(f, g)
            }
        }, {
            emitOnBegin: e,
            interval: a
        }))
    })() : (() => {
        const h = zr(["watchBlockNumber", t.uid, e, r]);
        return tc(h, {
            onBlockNumber: n,
            onError: i
        }, f => {
            let p = !0,
                g = () => p = !1;
            return (async () => {
                try {
                    const m = (() => {
                            if (t.transport.type === "fallback") {
                                const w = t.transport.transports.find(x => x.config.type === "webSocket" || x.config.type === "ipc");
                                return w ? w.value : t.transport
                            }
                            return t.transport
                        })(),
                        {
                            unsubscribe: y
                        } = await m.subscribe({
                            params: ["newHeads"],
                            onData(w) {
                                var E;
                                if (!p) return;
                                const x = ss((E = w.result) == null ? void 0 : E.number);
                                f.onBlockNumber(x, c), c = x
                            },
                            onError(w) {
                                var x;
                                (x = f.onError) == null || x.call(f, w)
                            }
                        });
                    g = y, p || g()
                } catch (m) {
                    i == null || i(m)
                }
            })(), () => g()
        })
    })()
}
async function lQ(t, e) {
    const {
        checkReplacement: r = !0,
        confirmations: n = 1,
        hash: i,
        onReplaced: s,
        retryCount: a = 6,
        retryDelay: o = ({
            count: b
        }) => ~~(1 << b) * 200,
        timeout: c = 18e4
    } = e, l = zr(["waitForTransactionReceipt", t.uid, i]), u = (() => {
        var b;
        return e.pollingInterval ? e.pollingInterval : (b = t.chain) != null && b.experimental_preconfirmationTime ? t.chain.experimental_preconfirmationTime : t.pollingInterval
    })();
    let h, f, p, g = !1,
        m, y;
    const {
        promise: w,
        resolve: x,
        reject: E
    } = r6(), _ = c ? setTimeout(() => {
        y(), m(), E(new bH({
            hash: i
        }))
    }, c) : void 0;
    return m = tc(l, {
        onReplaced: s,
        resolve: x,
        reject: E
    }, async b => {
        if (p = await ht(t, Lg, "getTransactionReceipt")({
                hash: i
            }).catch(() => {}), p && n <= 1) {
            clearTimeout(_), b.resolve(p), m();
            return
        }
        y = ht(t, WP, "watchBlockNumber")({
            emitMissed: !0,
            emitOnBegin: !0,
            poll: !0,
            pollingInterval: u,
            async onBlockNumber(A) {
                const I = C => {
                    clearTimeout(_), y(), C(), m()
                };
                let T = A;
                if (!g) try {
                    if (p) {
                        if (n > 1 && (!p.blockNumber || T - p.blockNumber + 1 n < n)) return;
                        I(() => b.resolve(p));
                        return
                    }
                    if (r && !h && (g = !0, await pm(async () => {
                            h = await ht(t, x6, "getTransaction")({
                                hash: i
                            }), h.blockNumber && (T = h.blockNumber)
                        }, {
                            delay: o,
                            retryCount: a
                        }), g = !1), p = await ht(t, Lg, "getTransactionReceipt")({
                            hash: i
                        }), n > 1 && (!p.blockNumber || T - p.blockNumber + 1 n < n)) return;
                    I(() => b.resolve(p))
                } catch (C) {
                    if (C instanceof yT || C instanceof wT) {
                        if (!h) {
                            g = !1;
                            return
                        }
                        try {
                            f = h, g = !0;
                            const $ = await pm(() => ht(t, to, "getBlock")({
                                blockNumber: T,
                                includeTransactions: !0
                            }), {
                                delay: o,
                                retryCount: a,
                                shouldRetry: ({
                                    error: R
                                }) => R instanceof gP
                            });
                            g = !1;
                            const P = $.transactions.find(({
                                from: R,
                                nonce: D
                            }) => R === f.from && D === f.nonce);
                            if (!P || (p = await ht(t, Lg, "getTransactionReceipt")({
                                    hash: P.hash
                                }), n > 1 && (!p.blockNumber || T - p.blockNumber + 1 n < n))) return;
                            let N = "replaced";
                            P.to === f.to && P.value === f.value && P.input === f.input ? N = "repriced" : P.from === P.to && P.value === 0 n && (N = "cancelled"), I(() => {
                                var R;
                                (R = b.onReplaced) == null || R.call(b, {
                                    reason: N,
                                    replacedTransaction: f,
                                    transaction: P,
                                    transactionReceipt: p
                                }), b.resolve(p)
                            })
                        } catch ($) {
                            I(() => b.reject($))
                        }
                    } else I(() => b.reject(C))
                }
            }
        })
    }), w
}

function dQ(t, {
    blockTag: e = t.experimental_blockTag ? ? "latest",
    emitMissed: r = !1,
    emitOnBegin: n = !1,
    onBlock: i,
    onError: s,
    includeTransactions: a,
    poll: o,
    pollingInterval: c = t.pollingInterval
}) {
    const l = typeof o < "u" ? o : !(t.transport.type === "webSocket" || t.transport.type === "ipc" || t.transport.type === "fallback" && (t.transport.transports[0].config.type === "webSocket" || t.transport.transports[0].config.type === "ipc")),
        u = a ? ? !1;
    let h;
    return l ? (() => {
        const g = zr(["watchBlocks", t.uid, e, r, n, u, c]);
        return tc(g, {
            onBlock: i,
            onError: s
        }, m => mh(async () => {
            var y;
            try {
                const w = await ht(t, to, "getBlock")({
                    blockTag: e,
                    includeTransactions: u
                });
                if (w.number !== null && (h == null ? void 0 : h.number) != null) {
                    if (w.number === h.number) return;
                    if (w.number - h.number > 1 && r)
                        for (let x = (h == null ? void 0 : h.number) + 1 n; x < w.number; x++) {
                            const E = await ht(t, to, "getBlock")({
                                blockNumber: x,
                                includeTransactions: u
                            });
                            m.onBlock(E, h), h = E
                        }
                }((h == null ? void 0 : h.number) == null || e === "pending" && (w == null ? void 0 : w.number) == null || w.number !== null && w.number > h.number) && (m.onBlock(w, h), h = w)
            } catch (w) {
                (y = m.onError) == null || y.call(m, w)
            }
        }, {
            emitOnBegin: n,
            interval: c
        }))
    })() : (() => {
        let g = !0,
            m = !0,
            y = () => g = !1;
        return (async () => {
            try {
                n && ht(t, to, "getBlock")({
                    blockTag: e,
                    includeTransactions: u
                }).then(E => {
                    g && m && (i(E, void 0), m = !1)
                }).catch(s);
                const w = (() => {
                        if (t.transport.type === "fallback") {
                            const E = t.transport.transports.find(_ => _.config.type === "webSocket" || _.config.type === "ipc");
                            return E ? E.value : t.transport
                        }
                        return t.transport
                    })(),
                    {
                        unsubscribe: x
                    } = await w.subscribe({
                        params: ["newHeads"],
                        async onData(E) {
                            var b;
                            if (!g) return;
                            const _ = await ht(t, to, "getBlock")({
                                blockNumber: (b = E.result) == null ? void 0 : b.number,
                                includeTransactions: u
                            }).catch(() => {});
                            g && (i(_, h), m = !1, h = _)
                        },
                        onError(E) {
                            s == null || s(E)
                        }
                    });
                y = x, g || y()
            } catch (w) {
                s == null || s(w)
            }
        })(), () => y()
    })()
}

function uQ(t, {
    address: e,
    args: r,
    batch: n = !0,
    event: i,
    events: s,
    fromBlock: a,
    onError: o,
    onLogs: c,
    poll: l,
    pollingInterval: u = t.pollingInterval,
    strict: h
}) {
    const f = typeof l < "u" ? l : typeof a == "bigint" ? !0 : !(t.transport.type === "webSocket" || t.transport.type === "ipc" || t.transport.type === "fallback" && (t.transport.transports[0].config.type === "webSocket" || t.transport.transports[0].config.type === "ipc")),
        p = h ? ? !1;
    return f ? (() => {
        const y = zr(["watchEvent", e, r, n, t.uid, i, u, a]);
        return tc(y, {
            onLogs: c,
            onError: o
        }, w => {
            let x;
            a !== void 0 && (x = a - 1 n);
            let E, _ = !1;
            const b = mh(async () => {
                var A;
                if (!_) {
                    try {
                        E = await ht(t, PP, "createEventFilter")({
                            address: e,
                            args: r,
                            event: i,
                            events: s,
                            strict: p,
                            fromBlock: a
                        })
                    } catch {}
                    _ = !0;
                    return
                }
                try {
                    let I;
                    if (E) I = await ht(t, L1, "getFilterChanges")({
                        filter: E
                    });
                    else {
                        const T = await ht(t, n0, "getBlockNumber")({});
                        x && x !== T ? I = await ht(t, g6, "getLogs")({
                            address: e,
                            args: r,
                            event: i,
                            events: s,
                            fromBlock: x + 1 n,
                            toBlock: T
                        }) : I = [], x = T
                    }
                    if (I.length === 0) return;
                    if (n) w.onLogs(I);
                    else
                        for (const T of I) w.onLogs([T])
                } catch (I) {
                    E && I instanceof id && (_ = !1), (A = w.onError) == null || A.call(w, I)
                }
            }, {
                emitOnBegin: !0,
                interval: u
            });
            return async () => {
                E && await ht(t, U1, "uninstallFilter")({
                    filter: E
                }), b()
            }
        })
    })() : (() => {
        let y = !0,
            w = () => y = !1;
        return (async () => {
            try {
                const x = (() => {
                        if (t.transport.type === "fallback") {
                            const A = t.transport.transports.find(I => I.config.type === "webSocket" || I.config.type === "ipc");
                            return A ? A.value : t.transport
                        }
                        return t.transport
                    })(),
                    E = s ? ? (i ? [i] : void 0);
                let _ = [];
                E && (_ = [E.flatMap(I => r0({
                    abi: [I],
                    eventName: I.name,
                    args: r
                }))], i && (_ = _[0]));
                const {
                    unsubscribe: b
                } = await x.subscribe({
                    params: ["logs", {
                        address: e,
                        topics: _
                    }],
                    onData(A) {
                        var T;
                        if (!y) return;
                        const I = A.result;
                        try {
                            const {
                                eventName: C,
                                args: $
                            } = i6({
                                abi: E ? ? [],
                                data: I.data,
                                topics: I.topics,
                                strict: p
                            }), P = Qo(I, {
                                args: $,
                                eventName: C
                            });
                            c([P])
                        } catch (C) {
                            let $, P;
                            if (C instanceof yp || C instanceof C1) {
                                if (h) return;
                                $ = C.abiItem.name, P = (T = C.abiItem.inputs) == null ? void 0 : T.some(R => !("name" in R && R.name))
                            }
                            const N = Qo(I, {
                                args: P ? [] : {},
                                eventName: $
                            });
                            c([N])
                        }
                    },
                    onError(A) {
                        o == null || o(A)
                    }
                });
                w = b, y || w()
            } catch (x) {
                o == null || o(x)
            }
        })(), () => w()
    })()
}

function hQ(t, {
    batch: e = !0,
    onError: r,
    onTransactions: n,
    poll: i,
    pollingInterval: s = t.pollingInterval
}) {
    return (typeof i < "u" ? i : t.transport.type !== "webSocket" && t.transport.type !== "ipc") ? (() => {
        const l = zr(["watchPendingTransactions", t.uid, e, s]);
        return tc(l, {
            onTransactions: n,
            onError: r
        }, u => {
            let h;
            const f = mh(async () => {
                var p;
                try {
                    if (!h) try {
                        h = await ht(t, NP, "createPendingTransactionFilter")({});
                        return
                    } catch (m) {
                        throw f(), m
                    }
                    const g = await ht(t, L1, "getFilterChanges")({
                        filter: h
                    });
                    if (g.length === 0) return;
                    if (e) u.onTransactions(g);
                    else
                        for (const m of g) u.onTransactions([m])
                } catch (g) {
                    (p = u.onError) == null || p.call(u, g)
                }
            }, {
                emitOnBegin: !0,
                interval: s
            });
            return async () => {
                h && await ht(t, U1, "uninstallFilter")({
                    filter: h
                }), f()
            }
        })
    })() : (() => {
        let l = !0,
            u = () => l = !1;
        return (async () => {
            try {
                const {
                    unsubscribe: h
                } = await t.transport.subscribe({
                    params: ["newPendingTransactions"],
                    onData(f) {
                        if (!l) return;
                        const p = f.result;
                        n([p])
                    },
                    onError(f) {
                        r == null || r(f)
                    }
                });
                u = h, l || u()
            } catch (h) {
                r == null || r(h)
            }
        })(), () => u()
    })()
}

function fQ(t) {
    var h, f, p;
    const {
        scheme: e,
        statement: r,
        ...n
    } = ((h = t.match(pQ)) == null ? void 0 : h.groups) ? ? {}, {
        chainId: i,
        expirationTime: s,
        issuedAt: a,
        notBefore: o,
        requestId: c,
        ...l
    } = ((f = t.match(gQ)) == null ? void 0 : f.groups) ? ? {}, u = (p = t.split("Resources:")[1]) == null ? void 0 : p.split(`
- `).slice(1);
    return { ...n,
        ...l,
        ...i ? {
            chainId: Number(i)
        } : {},
        ...s ? {
            expirationTime: new Date(s)
        } : {},
        ...a ? {
            issuedAt: new Date(a)
        } : {},
        ...o ? {
            notBefore: new Date(o)
        } : {},
        ...c ? {
            requestId: c
        } : {},
        ...u ? {
            resources: u
        } : {},
        ...e ? {
            scheme: e
        } : {},
        ...r ? {
            statement: r
        } : {}
    }
}
const pQ = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/,
    gQ = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;

function mQ(t) {
    const {
        address: e,
        domain: r,
        message: n,
        nonce: i,
        scheme: s,
        time: a = new Date
    } = t;
    if (r && n.domain !== r || i && n.nonce !== i || s && n.scheme !== s || n.expirationTime && a >= n.expirationTime || n.notBefore && a < n.notBefore) return !1;
    try {
        if (!n.address || !gi(n.address, {
                strict: !1
            }) || e && !t0(n.address, e)) return !1
    } catch {
        return !1
    }
    return !0
}
async function yQ(t, e) {
    const {
        address: r,
        domain: n,
        message: i,
        nonce: s,
        scheme: a,
        signature: o,
        time: c = new Date,
        ...l
    } = e, u = fQ(i);
    if (!u.address || !mQ({
            address: r,
            domain: n,
            message: u,
            nonce: s,
            scheme: a,
            time: c
        })) return !1;
    const f = GT(i);
    return C6(t, {
        address: u.address,
        hash: f,
        signature: o,
        ...l
    })
}

function A6(t) {
    return {
        call: e => e0(t, e),
        createAccessList: e => TP(t, e),
        createBlockFilter: () => gJ(t),
        createContractEventFilter: e => pP(t, e),
        createEventFilter: e => PP(t, e),
        createPendingTransactionFilter: () => NP(t),
        estimateContractGas: e => jZ(t, e),
        estimateGas: e => p6(t, e),
        getBalance: e => wP(t, e),
        getBlobBaseFee: () => mJ(t),
        getBlock: e => to(t, e),
        getBlockNumber: e => n0(t, e),
        getBlockTransactionCount: e => yJ(t, e),
        getBytecode: e => d7(t, e),
        getChainId: () => gh(t),
        getCode: e => d7(t, e),
        getContractEvents: e => bP(t, e),
        getEip712Domain: e => bJ(t, e),
        getEnsAddress: e => XZ(t, e),
        getEnsAvatar: e => hJ(t, e),
        getEnsName: e => fJ(t, e),
        getEnsResolver: e => pJ(t, e),
        getEnsText: e => SP(t, e),
        getFeeHistory: e => EJ(t, e),
        estimateFeesPerGas: e => OZ(t, e),
        getFilterChanges: e => L1(t, e),
        getFilterLogs: e => _J(t, e),
        getGasPrice: () => f6(t),
        getLogs: e => g6(t, e),
        getProof: e => kJ(t, e),
        estimateMaxPriorityFeePerGas: e => NZ(t, e),
        getStorageAt: e => IJ(t, e),
        getTransaction: e => x6(t, e),
        getTransactionConfirmations: e => $J(t, e),
        getTransactionCount: e => o6(t, e),
        getTransactionReceipt: e => Lg(t, e),
        multicall: e => SJ(t, e),
        prepareTransactionRequest: e => D1(t, e),
        readContract: e => ec(t, e),
        sendRawTransaction: e => m6(t, e),
        simulate: e => y3(t, e),
        simulateBlocks: e => y3(t, e),
        simulateCalls: e => sQ(t, e),
        simulateContract: e => RZ(t, e),
        verifyMessage: e => oQ(t, e),
        verifySiweMessage: e => yQ(t, e),
        verifyTypedData: e => cQ(t, e),
        uninstallFilter: e => U1(t, e),
        waitForTransactionReceipt: e => lQ(t, e),
        watchBlocks: e => dQ(t, e),
        watchBlockNumber: e => WP(t, e),
        watchContractEvent: e => WZ(t, e),
        watchEvent: e => uQ(t, e),
        watchPendingTransactions: e => hQ(t, e)
    }
}

function nc(t) {
    const {
        key: e = "public",
        name: r = "Public Client"
    } = t;
    return CP({ ...t,
        key: e,
        name: r,
        type: "publicClient"
    }).extend(A6)
}
async function wQ(t, {
    chain: e
}) {
    const {
        id: r,
        name: n,
        nativeCurrency: i,
        rpcUrls: s,
        blockExplorers: a
    } = e;
    await t.request({
        method: "wallet_addEthereumChain",
        params: [{
            chainId: nt(r),
            chainName: n,
            nativeCurrency: i,
            rpcUrls: s.default.http,
            blockExplorerUrls: a ? Object.values(a).map(({
                url: o
            }) => o) : void 0
        }]
    }, {
        dedupe: !0,
        retryCount: 0
    })
}

function bQ(t, e) {
    const {
        abi: r,
        args: n,
        bytecode: i,
        ...s
    } = e, a = I1({
        abi: r,
        args: n,
        bytecode: i
    });
    return F1(t, { ...s,
        ...s.authorizationList ? {
            to: null
        } : {},
        data: a
    })
}
async function vQ(t) {
    var r;
    return ((r = t.account) == null ? void 0 : r.type) === "local" ? [t.account.address] : (await t.request({
        method: "eth_accounts"
    }, {
        dedupe: !0
    })).map(n => Jp(n))
}
async function xQ(t, e = {}) {
    const {
        account: r = t.account,
        chainId: n
    } = e, i = r ? qr(r) : void 0, s = n ? [i == null ? void 0 : i.address, [nt(n)]] : [i == null ? void 0 : i.address], a = await t.request({
        method: "wallet_getCapabilities",
        params: s
    }), o = {};
    for (const [c, l] of Object.entries(a)) {
        o[Number(c)] = {};
        for (let [u, h] of Object.entries(l)) u === "addSubAccount" && (u = "unstable_addSubAccount"), o[Number(c)][u] = h
    }
    return typeof n == "number" ? o[n] : o
}
async function EQ(t) {
    return await t.request({
        method: "wallet_getPermissions"
    }, {
        dedupe: !0
    })
}
async function zP(t, e) {
    var c;
    const {
        account: r = t.account,
        chainId: n,
        nonce: i
    } = e;
    if (!r) throw new Id({
        docsPath: "/docs/eip7702/prepareAuthorization"
    });
    const s = qr(r),
        a = (() => {
            if (e.executor) return e.executor === "self" ? e.executor : qr(e.executor)
        })(),
        o = {
            address: e.contractAddress ? ? e.address,
            chainId: n,
            nonce: i
        };
    return typeof o.chainId > "u" && (o.chainId = ((c = t.chain) == null ? void 0 : c.id) ? ? await ht(t, gh, "getChainId")({})), typeof o.nonce > "u" && (o.nonce = await ht(t, o6, "getTransactionCount")({
        address: s.address,
        blockTag: "pending"
    }), (a === "self" || a != null && a.address && t0(a.address, s.address)) && (o.nonce += 1)), o
}
async function _Q(t) {
    return (await t.request({
        method: "eth_requestAccounts"
    }, {
        dedupe: !0,
        retryCount: 0
    })).map(r => Zr(r))
}
async function CQ(t, e) {
    return t.request({
        method: "wallet_requestPermissions",
        params: [e]
    }, {
        retryCount: 0
    })
}
async function AQ(t, e) {
    const {
        id: r
    } = e;
    await t.request({
        method: "wallet_showCallsStatus",
        params: [r]
    })
}
async function kQ(t, e) {
    const {
        account: r = t.account
    } = e;
    if (!r) throw new Id({
        docsPath: "/docs/eip7702/signAuthorization"
    });
    const n = qr(r);
    if (!n.signAuthorization) throw new Mg({
        docsPath: "/docs/eip7702/signAuthorization",
        metaMessages: ["The `signAuthorization` Action does not support JSON-RPC Accounts."],
        type: n.type
    });
    const i = await zP(t, e);
    return n.signAuthorization(i)
}
async function IQ(t, {
    account: e = t.account,
    message: r
}) {
    if (!e) throw new Id({
        docsPath: "/docs/actions/wallet/signMessage"
    });
    const n = qr(e);
    if (n.signMessage) return n.signMessage({
        message: r
    });
    const i = typeof r == "string" ? sd(r) : r.raw instanceof Uint8Array ? cn(r.raw) : r.raw;
    return t.request({
        method: "personal_sign",
        params: [i, n.address]
    }, {
        retryCount: 0
    })
}
async function $Q(t, e) {
    var l, u, h, f;
    const {
        account: r = t.account,
        chain: n = t.chain,
        ...i
    } = e;
    if (!r) throw new Id({
        docsPath: "/docs/actions/wallet/signTransaction"
    });
    const s = qr(r);
    kd({
        account: s,
        ...e
    });
    const a = await ht(t, gh, "getChainId")({});
    n !== null && kT({
        currentChainId: a,
        chain: n
    });
    const o = (n == null ? void 0 : n.formatters) || ((l = t.chain) == null ? void 0 : l.formatters),
        c = ((u = o == null ? void 0 : o.transactionRequest) == null ? void 0 : u.format) || ph;
    return s.signTransaction ? s.signTransaction({ ...i,
        chainId: a
    }, {
        serializer: (f = (h = t.chain) == null ? void 0 : h.serializers) == null ? void 0 : f.transaction
    }) : await t.request({
        method: "eth_signTransaction",
        params: [{ ...c(i),
            chainId: nt(a),
            from: s.address
        }]
    }, {
        retryCount: 0
    })
}
async function SQ(t, e) {
    const {
        account: r = t.account,
        domain: n,
        message: i,
        primaryType: s
    } = e;
    if (!r) throw new Id({
        docsPath: "/docs/actions/wallet/signTypedData"
    });
    const a = qr(r),
        o = {
            EIP712Domain: NT({
                domain: n
            }),
            ...e.types
        };
    if (PT({
            domain: n,
            message: i,
            primaryType: s,
            types: o
        }), a.signTypedData) return a.signTypedData({
        domain: n,
        message: i,
        primaryType: s,
        types: o
    });
    const c = JH({
        domain: n,
        message: i,
        primaryType: s,
        types: o
    });
    return t.request({
        method: "eth_signTypedData_v4",
        params: [a.address, c]
    }, {
        retryCount: 0
    })
}
async function TQ(t, {
    id: e
}) {
    await t.request({
        method: "wallet_switchEthereumChain",
        params: [{
            chainId: nt(e)
        }]
    }, {
        retryCount: 0
    })
}
async function PQ(t, e) {
    return await t.request({
        method: "wallet_watchAsset",
        params: e
    }, {
        retryCount: 0
    })
}

function NQ(t) {
    return {
        addChain: e => wQ(t, e),
        deployContract: e => bQ(t, e),
        getAddresses: () => vQ(t),
        getCallsStatus: e => EP(t, e),
        getCapabilities: e => xQ(t, e),
        getChainId: () => gh(t),
        getPermissions: () => EQ(t),
        prepareAuthorization: e => zP(t, e),
        prepareTransactionRequest: e => D1(t, e),
        requestAddresses: () => _Q(t),
        requestPermissions: e => CQ(t, e),
        sendCalls: e => HZ(t, e),
        sendRawTransaction: e => m6(t, e),
        sendTransaction: e => F1(t, e),
        showCallsStatus: e => AQ(t, e),
        signAuthorization: e => kQ(t, e),
        signMessage: e => IQ(t, e),
        signTransaction: e => $Q(t, e),
        signTypedData: e => SQ(t, e),
        switchChain: e => TQ(t, e),
        waitForCallsStatus: e => VZ(t, e),
        watchAsset: e => PQ(t, e),
        writeContract: e => zZ(t, e)
    }
}

function qP(t) {
    const {
        key: e = "wallet",
        name: r = "Wallet Client",
        transport: n
    } = t;
    return CP({ ...t,
        key: e,
        name: r,
        transport: n,
        type: "walletClient"
    }).extend(NQ)
}

function sNe(t) {
    const {
        r: e,
        s: r
    } = vS.Signature.fromCompact(t.slice(2, 130)), n = +`0x${t.slice(130)}`, [i, s] = (() => {
        if (n === 0 || n === 1) return [void 0, n];
        if (n === 27) return [BigInt(n), 0];
        if (n === 28) return [BigInt(n), 1];
        throw new Error("Invalid yParityOrV value")
    })();
    return typeof i < "u" ? {
        r: nt(e, {
            size: 32
        }),
        s: nt(r, {
            size: 32
        }),
        v: i,
        yParity: s
    } : {
        r: nt(e, {
            size: 32
        }),
        s: nt(r, {
            size: 32
        }),
        yParity: s
    }
}
let OQ = class {
    getConfig() {
        return this._privyInternal.config
    }
    async getSmartWalletConfig() {
        return this._smartWalletConfig || (this._smartWalletConfig = await this._privyInternal.fetch(mG, {
            params: {
                app_id: this.appId
            }
        })), this._smartWalletConfig
    }
    get appId() {
        return this._privyInternal.appId
    }
    constructor(e) {
        this._privyInternal = e
    }
};
const jQ = new TextEncoder,
    HP = new TextDecoder,
    RQ = t => {
        let e = t;
        typeof e == "string" && (e = jQ.encode(e));
        const r = 32768,
            n = [];
        for (let i = 0; i < e.length; i += r) n.push(String.fromCharCode.apply(null, e.subarray(i, i + r)));
        return btoa(n.join(""))
    },
    MQ = t => RQ(t).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_"),
    DQ = t => {
        const e = atob(t),
            r = new Uint8Array(e.length);
        for (let n = 0; n < e.length; n++) r[n] = e.charCodeAt(n);
        return r
    },
    LQ = t => {
        let e = t;
        e instanceof Uint8Array && (e = HP.decode(e)), e = e.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
        try {
            return DQ(e)
        } catch {
            throw new TypeError("The input to be decoded is not correctly encoded.")
        }
    };
class UQ extends Error {
    static get code() {
        return "ERR_JOSE_GENERIC"
    }
    constructor(e) {
        var r;
        super(e), this.code = "ERR_JOSE_GENERIC", this.name = this.constructor.name, (r = Error.captureStackTrace) === null || r === void 0 || r.call(Error, this, this.constructor)
    }
}
class wl extends UQ {
    constructor() {
        super(...arguments), this.code = "ERR_JWT_INVALID"
    }
    static get code() {
        return "ERR_JWT_INVALID"
    }
}

function FQ(t) {
    return typeof t == "object" && t !== null
}

function BQ(t) {
    if (!FQ(t) || Object.prototype.toString.call(t) !== "[object Object]") return !1;
    if (Object.getPrototypeOf(t) === null) return !0;
    let e = t;
    for (; Object.getPrototypeOf(e) !== null;) e = Object.getPrototypeOf(e);
    return Object.getPrototypeOf(t) === e
}
const dd = MQ,
    WQ = LQ;

function _3(t) {
    if (typeof t != "string") throw new wl("JWTs must use Compact JWS serialization, JWT must be a string");
    const {
        1: e,
        length: r
    } = t.split(".");
    if (r === 5) throw new wl("Only JWTs using Compact JWS serialization can be decoded");
    if (r !== 3) throw new wl("Invalid JWT");
    if (!e) throw new wl("JWTs must contain a payload");
    let n;
    try {
        n = WQ(e)
    } catch {
        throw new wl("Failed to base64url decode the payload")
    }
    let i;
    try {
        i = JSON.parse(HP.decode(n))
    } catch {
        throw new wl("Failed to parse the decoded payload as JSON")
    }
    if (!BQ(i)) throw new wl("Invalid JWT Claims Set");
    return i
}
let bf = class VP {
        static parse(e) {
            try {
                return new VP(e)
            } catch {
                return null
            }
        }
        get subject() {
            return this._decoded.sub
        }
        get expiration() {
            return this._decoded.exp
        }
        get issuer() {
            return this._decoded.iss
        }
        get audience() {
            return this._decoded.aud
        }
        isExpired(e = 0) {
            return Date.now() >= 1e3 * (this.expiration - e)
        }
        constructor(e) {
            this.value = e, this._decoded = _3(e)
        }
    },
    GP = class C3 {
        async updateOnCrossAppAuthentication(e, r) {
            let n = r.access_token,
                i = C3.providerAccessTokenStorageKey(e);
            await this._storage.put(i, n)
        }
        async getProviderAccessToken(e) {
            let r = C3.providerAccessTokenStorageKey(e),
                n = await this._storage.get(r);
            if (typeof n != "string") return null;
            try {
                if (new bf(n).isExpired()) throw Error("JWT is expired");
                return n
            } catch {
                return await this._storage.del(r), null
            }
        }
        async getCrossAppConnections() {
            return await this._privyInternal.fetch(PV, {
                params: {
                    app_id: this._privyInternal.appId
                }
            })
        }
        constructor(e, r) {
            this._privyInternal = e, this._storage = r
        }
    };
GP.providerAccessTokenStorageKey = t => `privy:cross-app:${t}`;
let zQ = class {
    async revoke() {
        await this._privyInternal.fetch($G, {})
    }
    constructor(e) {
        this._privyInternal = e
    }
};

function qQ(t, e) {
    return { ...t,
        rpcUrls: { ...t.rpcUrls,
            privy: {
                http: [e]
            }
        }
    }
}
const ja = {
        id: 42161,
        name: "Arbitrum One",
        network: "arbitrum",
        nativeCurrency: {
            name: "Ether",
            symbol: "ETH",
            decimals: 18
        },
        rpcUrls: {
            privy: {
                http: ["https://arbitrum-mainnet.rpc.privy.systems"]
            },
            alchemy: {
                http: ["https://arb-mainnet.g.alchemy.com/v2"],
                webSocket: ["wss://arb-mainnet.g.alchemy.com/v2"]
            },
            infura: {
                http: ["https://arbitrum-mainnet.infura.io/v3"],
                webSocket: ["wss://arbitrum-mainnet.infura.io/ws/v3"]
            },
            default: {
                http: ["https://arb1.arbitrum.io/rpc"]
            },
            public: {
                http: ["https://arb1.arbitrum.io/rpc"]
            }
        },
        blockExplorers: {
            etherscan: {
                name: "Arbiscan",
                url: "https://arbiscan.io"
            },
            default: {
                name: "Arbiscan",
                url: "https://arbiscan.io"
            }
        }
    },
    z1 = {
        id: 421614,
        name: "Arbitrum Sepolia",
        network: "arbitrum-sepolia",
        nativeCurrency: {
            name: "Arbitrum Sepolia Ether",
            symbol: "ETH",
            decimals: 18
        },
        rpcUrls: {
            privy: {
                http: ["https://arbitrum-sepolia.rpc.privy.systems"]
            },
            default: {
                http: ["https://sepolia-rollup.arbitrum.io/rpc"]
            },
            public: {
                http: ["https://sepolia-rollup.arbitrum.io/rpc"]
            }
        },
        blockExplorers: {
            default: {
                name: "Blockscout",
                url: "https://sepolia-explorer.arbitrum.io"
            }
        },
        testnet: !0
    },
    yh = {
        id: 43114,
        name: "Avalanche",
        network: "avalanche",
        nativeCurrency: {
            decimals: 18,
            name: "Avalanche",
            symbol: "AVAX"
        },
        rpcUrls: {
            default: {
                http: ["https://api.avax.network/ext/bc/C/rpc"]
            },
            public: {
                http: ["https://api.avax.network/ext/bc/C/rpc"]
            }
        },
        blockExplorers: {
            etherscan: {
                name: "SnowTrace",
                url: "https://snowtrace.io"
            },
            default: {
                name: "SnowTrace",
                url: "https://snowtrace.io"
            }
        }
    },
    k6 = {
        id: 43113,
        name: "Avalanche Fuji",
        network: "avalanche-fuji",
        nativeCurrency: {
            decimals: 18,
            name: "Avalanche Fuji",
            symbol: "AVAX"
        },
        rpcUrls: {
            default: {
                http: ["https://api.avax-test.network/ext/bc/C/rpc"]
            },
            public: {
                http: ["https://api.avax-test.network/ext/bc/C/rpc"]
            }
        },
        blockExplorers: {
            etherscan: {
                name: "SnowTrace",
                url: "https://testnet.snowtrace.io"
            },
            default: {
                name: "SnowTrace",
                url: "https://testnet.snowtrace.io"
            }
        },
        testnet: !0
    },
    Fs = {
        id: 8453,
        network: "base",
        name: "Base",
        nativeCurrency: {
            name: "Ether",
            symbol: "ETH",
            decimals: 18
        },
        rpcUrls: {
            privy: {
                http: ["https://base-mainnet.rpc.privy.systems"]
            },
            blast: {
                http: ["https://base-mainnet.blastapi.io"],
                webSocket: ["wss://base-mainnet.blastapi.io"]
            },
            default: {
                http: ["https://mainnet.base.org"]
            },
            public: {
                http: ["https://mainnet.base.org"]
            }
        },
        blockExplorers: {
            etherscan: {
                name: "Basescan",
                url: "https://basescan.org"
            },
            default: {
                name: "Basescan",
                url: "https://basescan.org"
            }
        }
    },
    q1 = {
        id: 84532,
        network: "base-sepolia",
        name: "Base Sepolia",
        nativeCurrency: {
            name: "Sepolia Ether",
            symbol: "ETH",
            decimals: 18
        },
        rpcUrls: {
            privy: {
                http: ["https://base-sepolia.rpc.privy.systems"]
            },
            default: {
                http: ["https://sepolia.base.org"]
            },
            public: {
                http: ["https://sepolia.base.org"]
            }
        },
        blockExplorers: {
            default: {
                name: "Blockscout",
                url: "https://base-sepolia.blockscout.com"
            }
        },
        testnet: !0
    },
    HQ = {
        id: 80085,
        network: "berachain-artio",
        name: "Berachain Artio",
        nativeCurrency: {
            name: "BERA",
            symbol: "BERA",
            decimals: 18
        },
        rpcUrls: {
            default: {
                http: ["https://berachain-artio.rpc.privy.systems"]
            },
            public: {
                http: ["https://berachain-artio.rpc.privy.systems"]
            }
        },
        blockExplorers: {
            default: {
                name: "Beratrail",
                url: "https://artio.beratrail.io"
            }
        },
        testnet: !0
    },
    H1 = {
        id: 42220,
        name: "Celo Mainnet",
        network: "celo",
        nativeCurrency: {
            decimals: 18,
            name: "CELO",
            symbol: "CELO"
        },
        rpcUrls: {
            default: {
                http: ["https://forno.celo.org"]
            },
            infura: {
                http: ["https://celo-mainnet.infura.io/v3"]
            },
            public: {
                http: ["https://forno.celo.org"]
            }
        },
        blockExplorers: {
            default: {
                name: "Celo Explorer",
                url: "https://explorer.celo.org/mainnet"
            },
            etherscan: {
                name: "CeloScan",
                url: "https://celoscan.io"
            }
        },
        testnet: !1
    },
    VQ = {
        id: 44787,
        name: "Celo Alfajores Testnet",
        network: "celo-alfajores",
        nativeCurrency: {
            decimals: 18,
            name: "CELO",
            symbol: "CELO"
        },
        rpcUrls: {
            default: {
                http: ["https://alfajores-forno.celo-testnet.org"]
            },
            infura: {
                http: ["https://celo-alfajores.infura.io/v3"]
            },
            public: {
                http: ["https://alfajores-forno.celo-testnet.org"]
            }
        },
        blockExplorers: {
            default: {
                name: "Celo Explorer",
                url: "https://explorer.celo.org/alfajores"
            },
            etherscan: {
                name: "CeloScan",
                url: "https://alfajores.celoscan.io/"
            }
        },
        testnet: !0
    },
    GQ = {
        id: 314,
        name: "Filecoin - Mainnet",
        network: "filecoin-mainnet",
        nativeCurrency: {
            decimals: 18,
            name: "filecoin",
            symbol: "FIL"
        },
        rpcUrls: {
            default: {
                http: ["https://api.node.glif.io/rpc/v1"]
            },
            public: {
                http: ["https://api.node.glif.io/rpc/v1"]
            }
        },
        blockExplorers: {
            default: {
                name: "Filfox",
                url: "https://filfox.info/en"
            },
            filscan: {
                name: "Filscan",
                url: "https://filscan.io"
            },
            filscout: {
                name: "Filscout",
                url: "https://filscout.io/en"
            },
            glif: {
                name: "Glif",
                url: "https://explorer.glif.io"
            }
        }
    },
    KQ = {
        id: 314159,
        name: "Filecoin - Calibration testnet",
        network: "filecoin-calibration",
        nativeCurrency: {
            decimals: 18,
            name: "testnet filecoin",
            symbol: "tFIL"
        },
        rpcUrls: {
            default: {
                http: ["https://api.calibration.node.glif.io/rpc/v1"]
            },
            public: {
                http: ["https://api.calibration.node.glif.io/rpc/v1"]
            }
        },
        blockExplorers: {
            default: {
                name: "Filscan",
                url: "https://calibration.filscan.io"
            }
        }
    },
    YQ = {
        id: 17069,
        name: "Garnet Holesky",
        network: "garnet-holesky",
        nativeCurrency: {
            name: "ETH",
            symbol: "ETH",
            decimals: 18
        },
        rpcUrls: {
            default: {
                http: ["https://rpc.garnetchain.com"]
            },
            public: {
                http: ["https://rpc.garnetchain.com"]
            }
        },
        blockExplorers: {
            default: {
                name: "Blockscout",
                url: "https://explorer.garnetchain.com"
            }
        }
    },
    ZQ = {
        id: 17e3,
        name: "Holesky",
        network: "holesky",
        nativeCurrency: {
            name: "ETH",
            symbol: "ETH",
            decimals: 18
        },
        rpcUrls: {
            default: {
                http: ["https://ethereum-holesky.publicnode.com"]
            },
            public: {
                http: ["https://ethereum-holesky.publicnode.com"]
            }
        },
        blockExplorers: {
            etherscan: {
                name: "EtherScan",
                url: "https://holesky.etherscan.io"
            },
            default: {
                name: "EtherScan",
                url: "https://holesky.etherscan.io"
            }
        }
    },
    KP = {
        id: 59144,
        network: "linea-mainnet",
        name: "Linea Mainnet",
        nativeCurrency: {
            name: "Linea Ether",
            symbol: "ETH",
            decimals: 18
        },
        rpcUrls: {
            default: {
                http: ["https://rpc.linea.build"],
                webSocket: ["wss://rpc.linea.build"]
            },
            public: {
                http: ["https://rpc.linea.build"],
                webSocket: ["wss://rpc.linea.build"]
            }
        },
        blockExplorers: {
            default: {
                name: "Etherscan",
                url: "https://lineascan.build"
            },
            etherscan: {
                name: "Etherscan",
                url: "https://lineascan.build"
            }
        },
        testnet: !1
    },
    JQ = {
        id: 59140,
        network: "linea-testnet",
        name: "Linea Goerli Testnet",
        nativeCurrency: {
            name: "Linea Ether",
            symbol: "ETH",
            decimals: 18
        },
        rpcUrls: {
            infura: {
                http: ["https://linea-goerli.infura.io/v3"],
                webSocket: ["wss://linea-goerli.infura.io/ws/v3"]
            },
            default: {
                http: ["https://rpc.goerli.linea.build"],
                webSocket: ["wss://rpc.goerli.linea.build"]
            },
            public: {
                http: ["https://rpc.goerli.linea.build"],
                webSocket: ["wss://rpc.goerli.linea.build"]
            }
        },
        blockExplorers: {
            default: {
                name: "Etherscan",
                url: "https://goerli.lineascan.build"
            },
            etherscan: {
                name: "Etherscan",
                url: "https://goerli.lineascan.build"
            }
        },
        testnet: !0
    },
    QQ = {
        id: 42,
        network: "lukso",
        name: "LUKSO",
        nativeCurrency: {
            name: "LUKSO",
            symbol: "LYX",
            decimals: 18
        },
        rpcUrls: {
            default: {
                http: ["https://rpc.mainnet.lukso.network"],
                webSocket: ["wss://ws-rpc.mainnet.lukso.network"]
            }
        },
        blockExplorers: {
            default: {
                name: "LUKSO Mainnet Explorer",
                url: "https://explorer.execution.mainnet.lukso.network"
            }
        }
    },
    Bs = {
        id: 1,
        network: "homestead",
        name: "Ethereum",
        nativeCurrency: {
            name: "Ether",
            symbol: "ETH",
            decimals: 18
        },
        rpcUrls: {
            privy: {
                http: ["https://mainnet.rpc.privy.systems"]
            },
            alchemy: {
                http: ["https://eth-mainnet.g.alchemy.com/v2"],
                webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
            },
            infura: {
                http: ["https://mainnet.infura.io/v3"],
                webSocket: ["wss://mainnet.infura.io/ws/v3"]
            },
            default: {
                http: ["https://cloudflare-eth.com"]
            },
            public: {
                http: ["https://cloudflare-eth.com"]
            }
        },
        blockExplorers: {
            etherscan: {
                name: "Etherscan",
                url: "https://etherscan.io"
            },
            default: {
                name: "Etherscan",
                url: "https://etherscan.io"
            }
        }
    },
    go = {
        id: 10,
        name: "OP Mainnet",
        network: "optimism",
        nativeCurrency: {
            name: "Ether",
            symbol: "ETH",
            decimals: 18
        },
        rpcUrls: {
            privy: {
                http: ["https://optimism-mainnet.rpc.privy.systems"]
            },
            alchemy: {
                http: ["https://opt-mainnet.g.alchemy.com/v2"],
                webSocket: ["wss://opt-mainnet.g.alchemy.com/v2"]
            },
            infura: {
                http: ["https://optimism-mainnet.infura.io/v3"],
                webSocket: ["wss://optimism-mainnet.infura.io/ws/v3"]
            },
            default: {
                http: ["https://mainnet.optimism.io"]
            },
            public: {
                http: ["https://mainnet.optimism.io"]
            }
        },
        blockExplorers: {
            etherscan: {
                name: "Etherscan",
                url: "https://optimistic.etherscan.io"
            },
            default: {
                name: "Optimism Explorer",
                url: "https://explorer.optimism.io"
            }
        }
    },
    V1 = {
        id: 11155420,
        name: "Optimism Sepolia",
        network: "optimism-sepolia",
        nativeCurrency: {
            name: "Sepolia Ether",
            symbol: "ETH",
            decimals: 18
        },
        rpcUrls: {
            privy: {
                http: ["https://optimism-sepolia.rpc.privy.systems"]
            },
            default: {
                http: ["https://sepolia.optimism.io"]
            },
            public: {
                http: ["https://sepolia.optimism.io"]
            },
            infura: {
                http: ["https://optimism-sepolia.infura.io/v3"]
            }
        },
        blockExplorers: {
            default: {
                name: "Blockscout",
                url: "https://optimism-sepolia.blockscout.com"
            }
        },
        testnet: !0
    },
    fs = {
        id: 137,
        name: "Polygon Mainnet",
        network: "polygon",
        nativeCurrency: {
            name: "POL",
            symbol: "POL",
            decimals: 18
        },
        rpcUrls: {
            privy: {
                http: ["https://polygon-mainnet.rpc.privy.systems"]
            },
            alchemy: {
                http: ["https://polygon-mainnet.g.alchemy.com/v2"],
                webSocket: ["wss://polygon-mainnet.g.alchemy.com/v2"]
            },
            infura: {
                http: ["https://polygon-mainnet.infura.io/v3"],
                webSocket: ["wss://polygon-mainnet.infura.io/ws/v3"]
            },
            default: {
                http: ["https://polygon-rpc.com"]
            },
            public: {
                http: ["https://polygon-rpc.com"]
            }
        },
        blockExplorers: {
            etherscan: {
                name: "PolygonScan",
                url: "https://polygonscan.com"
            },
            default: {
                name: "PolygonScan",
                url: "https://polygonscan.com"
            }
        }
    },
    i0 = {
        id: 80002,
        name: "Polygon Amoy",
        network: "polygon-amoy",
        nativeCurrency: {
            name: "POL",
            symbol: "POL",
            decimals: 18
        },
        rpcUrls: {
            privy: {
                http: ["https://polygon-amoy.rpc.privy.systems"]
            },
            infura: {
                http: ["https://polygon-amoy.infura.io/v3"],
                webSocket: ["wss://polygon-amoy.infura.io/ws/v3"]
            },
            default: {
                http: ["https://rpc-amoy.polygon.technology"]
            }
        },
        blockExplorers: {
            default: {
                name: "OK LINK",
                url: "https://www.oklink.com/amoy"
            }
        },
        testnet: !0
    },
    XQ = {
        id: 690,
        name: "Redstone",
        network: "redstone",
        nativeCurrency: {
            name: "ETH",
            symbol: "ETH",
            decimals: 18
        },
        rpcUrls: {
            default: {
                http: ["https://rpc.redstonechain.com"]
            },
            public: {
                http: ["https://rpc.redstonechain.com"]
            }
        },
        blockExplorers: {
            default: {
                name: "Blockscout",
                url: "https://explorer.redstone.xyz/"
            }
        }
    },
    I6 = {
        id: 11155111,
        network: "sepolia",
        name: "Sepolia",
        nativeCurrency: {
            name: "Sepolia Ether",
            symbol: "SEP",
            decimals: 18
        },
        rpcUrls: {
            privy: {
                http: ["https://sepolia.rpc.privy.systems"]
            },
            alchemy: {
                http: ["https://eth-sepolia.g.alchemy.com/v2"],
                webSocket: ["wss://eth-sepolia.g.alchemy.com/v2"]
            },
            infura: {
                http: ["https://sepolia.infura.io/v3"],
                webSocket: ["wss://sepolia.infura.io/ws/v3"]
            },
            default: {
                http: ["https://rpc.sepolia.org"]
            },
            public: {
                http: ["https://rpc.sepolia.org"]
            }
        },
        blockExplorers: {
            etherscan: {
                name: "Etherscan",
                url: "https://sepolia.etherscan.io"
            },
            default: {
                name: "Etherscan",
                url: "https://sepolia.etherscan.io"
            }
        },
        testnet: !0
    },
    $6 = {
        id: 7777777,
        name: "Zora",
        network: "zora",
        nativeCurrency: {
            decimals: 18,
            name: "Ether",
            symbol: "ETH"
        },
        rpcUrls: {
            default: {
                http: ["https://rpc.zora.energy"],
                webSocket: ["wss://rpc.zora.energy"]
            },
            public: {
                http: ["https://rpc.zora.energy"],
                webSocket: ["wss://rpc.zora.energy"]
            }
        },
        blockExplorers: {
            default: {
                name: "Explorer",
                url: "https://explorer.zora.energy"
            }
        }
    },
    YP = {
        id: 999999999,
        name: "Zora Sepolia",
        network: "zora-sepolia",
        nativeCurrency: {
            decimals: 18,
            name: "Zora Sepolia",
            symbol: "ETH"
        },
        rpcUrls: {
            default: {
                http: ["https://sepolia.rpc.zora.energy"],
                webSocket: ["wss://sepolia.rpc.zora.energy"]
            },
            public: {
                http: ["https://sepolia.rpc.zora.energy"],
                webSocket: ["wss://sepolia.rpc.zora.energy"]
            }
        },
        blockExplorers: {
            default: {
                name: "Zora Sepolia Explorer",
                url: "https://sepolia.explorer.zora.energy/"
            }
        },
        testnet: !0
    },
    ZP = {
        id: 999,
        name: "Zora Goerli Testnet",
        network: "zora-testnet",
        nativeCurrency: {
            decimals: 18,
            name: "Zora Goerli",
            symbol: "ETH"
        },
        rpcUrls: {
            default: {
                http: ["https://testnet.rpc.zora.energy"],
                webSocket: ["wss://testnet.rpc.zora.energy"]
            },
            public: {
                http: ["https://testnet.rpc.zora.energy"],
                webSocket: ["wss://testnet.rpc.zora.energy"]
            }
        },
        blockExplorers: {
            default: {
                name: "Explorer",
                url: "https://testnet.explorer.zora.energy"
            }
        },
        testnet: !0
    },
    s0 = [Bs, I6, ZQ, ja, z1, go, V1, fs, i0, H1, VQ, GQ, KQ, Fs, q1, HQ, QQ, KP, JQ, yh, k6, $6, ZP, YP, XQ, YQ],
    JP = new Set(s0.map(t => t.id));

function S6(t) {
    let e = t.filter(r => !JP.has(r.id));
    return s0.concat(e)
}
const QP = t => t.map(e => {
    var i;
    if (e.rpcUrls.privyWalletOverride) return e;
    let r = s0.find(s => s.id === e.id),
        n = (i = r == null ? void 0 : r.rpcUrls.privy) == null ? void 0 : i.http[0];
    return n ? qQ(e, n) : e
});
let Mw = class extends Error {
        constructor({
            error: e,
            code: r
        }) {
            super(e), this.error = e, this.code = r
        }
    },
    Qt = class extends Error {
        constructor({
            error: e,
            code: r
        }) {
            super(e), this.code = r, this.error = e
        }
    },
    eX = class extends Error {
        constructor({
            error: e,
            code: r,
            response: n
        }) {
            super(e), this.code = r, this.error = e, this.response = n
        }
    };
const Uc = t => !!t.id && t.recovery_method === "privy-v2";
let tX = class {
    async sign({
        message: e
    }) {
        return await this.request({
            method: "sign",
            params: {
                message: new TextDecoder("utf8").decode(e)
            }
        })
    }
    async signTransaction({
        psbt: e
    }) {
        return await this.request({
            method: "signTransaction",
            params: {
                psbt: e
            }
        })
    }
    async request(e) {
        if (Uc(this._account)) throw new Qt({
            code: "unsupported_wallet_type",
            error: "Bitcoin wallet providers are only supported for on-device execution and this app uses TEE execution. Use the useSignRawHash hook from @privy-io/expo/extended-chains to sign over a hash with this wallet. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide"
        });
        if (!await this._privyInternal.getAccessToken()) throw new Qt({
            error: "Missing access token",
            code: "attempted_rpc_call_before_logged_in"
        });
        return this.handleIFrameRpc(e)
    }
    async handleIFrameRpc(e) {
        try {
            let r = await this._privyInternal.getAccessToken();
            if (!r) throw Error("Missing access token. User must be authenticated.");
            return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started", {
                method: e.method,
                address: this._account.address
            }), (await this._proxy.rpcWallet({
                accessToken: r,
                request: e,
                entropyId: this._entropyId,
                entropyIdVerifier: this._entropyIdVerifier,
                hdWalletIndex: this._account.wallet_index,
                chainType: this._account.chain_type
            })).response.data
        } catch (r) {
            console.error(r);
            let n = r instanceof Error ? r.message : "Unable to make wallet request";
            throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed", {
                method: e.method,
                address: this._account.address,
                error: n
            }), new Qt({
                code: "embedded_wallet_request_error",
                error: n
            })
        }
    }
    toJSON() {
        return `PrivyEmbeddedBitcoinProvider { address: '${this._account.address}', request: [Function] }`
    }
    constructor({
        proxy: e,
        privyInternal: r,
        account: n,
        entropyId: i,
        entropyIdVerifier: s
    }) {
        this._proxy = e, this._privyInternal = r, this._account = n, this._entropyId = i, this._entropyIdVerifier = s
    }
};
const rX = ["error", "invalid_request_arguments", "wallet_not_on_device", "invalid_recovery_pin", "insufficient_funds", "mfa_timeout", "missing_or_invalid_mfa", "mfa_verification_max_attempts_reached"];
var xi;
(xi = {}).MISSING_OR_INVALID_PRIVY_APP_ID = "missing_or_invalid_privy_app_id", xi.MISSING_OR_INVALID_PRIVY_ACCOUNT_ID = "missing_or_invalid_privy_account_id", xi.INVALID_DATA = "invalid_data", xi.LINKED_TO_ANOTHER_USER = "linked_to_another_user", xi.ALLOWLIST_REJECTED = "allowlist_rejected", xi.OAUTH_USER_DENIED = "oauth_user_denied", xi.UNKNOWN_AUTH_ERROR = "unknown_auth_error", xi.USER_EXITED_AUTH_FLOW = "exited_auth_flow", xi.MUST_BE_AUTHENTICATED = "must_be_authenticated", xi.UNKNOWN_CONNECT_WALLET_ERROR = "unknown_connect_wallet_error", xi.GENERIC_CONNECT_WALLET_ERROR = "generic_connect_wallet_error", xi.CLIENT_REQUEST_TIMEOUT = "client_request_timeout", xi.INVALID_CREDENTIALS = "invalid_credentials";
let nX = class extends Error {
        toString() {
            return `${this.type}${this.privyErrorCode?`-${this.privyErrorCode}`:""}: ${this.message}${this.cause?` [cause: ${this.cause}]`:""}`
        }
        constructor(e, r, n) {
            super(e), r instanceof Error && (this.cause = r), this.privyErrorCode = n
        }
    },
    Ug = class extends Error {
        constructor(e, r) {
            super(r), this.type = e
        }
    },
    XP = class extends nX {
        constructor(e, r, n) {
            super(e, r, n), this.type = "connector_error"
        }
    },
    h7 = class extends Error {
        constructor(e, r, n) {
            super(e), this.code = r, this.data = n
        }
    };
const da = {
    UNKNOWN_ERROR: {
        eipCode: 0,
        message: "Unknown error",
        detail: "Unknown error",
        retryable: !0
    },
    E4001_DEFAULT_USER_REJECTED_REQUEST: {
        eipCode: 4001,
        message: "User Rejected Request",
        detail: "The user rejected the request.",
        default: !0,
        retryable: !0
    },
    E4100_DEFAULT_UNAUTHORIZED: {
        eipCode: 4100,
        message: "Unauthorized",
        detail: "The requested method and/or account has not been authorized by the user.",
        default: !0,
        retryable: !1
    },
    E4200_DEFAULT_UNSUPPORTED_METHOD: {
        eipCode: 4200,
        message: "Unsupported Method",
        detail: "The Provider does not support the requested method.",
        default: !0,
        retryable: !1
    },
    E4900_DEFAULT_DISCONNECTED: {
        eipCode: 4900,
        message: "Disconnected",
        detail: "The Provider is disconnected from all chains.",
        default: !0,
        retryable: !0
    },
    E4901_DEFAULT_CHAIN_DISCONNECTED: {
        eipCode: 4901,
        message: "Chain Disconnected",
        detail: "The Provider is not connected to the requested chain.",
        default: !0,
        retryable: !0
    },
    E32700_DEFAULT_PARSE_ERROR: {
        eipCode: -32700,
        message: "Parse error",
        detail: "Invalid JSON",
        default: !0,
        retryable: !1
    },
    E32600_DEFAULT_INVALID_REQUEST: {
        eipCode: -32600,
        message: "Invalid request",
        detail: "JSON is not a valid request object",
        default: !0,
        retryable: !1
    },
    E32601_DEFAULT_METHOD_NOT_FOUND: {
        eipCode: -32601,
        message: "Method not found",
        detail: "Method does not exist",
        default: !0,
        retryable: !1
    },
    E32602_DEFAULT_INVALID_PARAMS: {
        eipCode: -32602,
        message: "Invalid params",
        detail: "Invalid method parameters",
        default: !0,
        retryable: !1
    },
    E32603_DEFAULT_INTERNAL_ERROR: {
        eipCode: -32603,
        message: "Internal error",
        detail: "Internal JSON-RPC error",
        default: !0,
        retryable: !0
    },
    E32000_DEFAULT_INVALID_INPUT: {
        eipCode: -32e3,
        message: "Invalid input",
        detail: "Missing or invalid parameters",
        default: !0,
        retryable: !1
    },
    E32001_DEFAULT_RESOURCE_NOT_FOUND: {
        eipCode: -32001,
        message: "Resource not found",
        detail: "Requested resource not found",
        default: !0,
        retryable: !1
    },
    E32002_DEFAULT_RESOURCE_UNAVAILABLE: {
        eipCode: -32002,
        message: "Resource unavailable",
        detail: "Requested resource not available",
        default: !0,
        retryable: !0
    },
    E32003_DEFAULT_TRANSACTION_REJECTED: {
        eipCode: -32003,
        message: "Transaction rejected",
        detail: "Transaction creation failed",
        default: !0,
        retryable: !0
    },
    E32004_DEFAULT_METHOD_NOT_SUPPORTED: {
        eipCode: -32004,
        message: "Method not supported",
        detail: "Method is not implemented",
        default: !0,
        retryable: !1
    },
    E32005_DEFAULT_LIMIT_EXCEEDED: {
        eipCode: -32005,
        message: "Limit exceeded",
        detail: "Request exceeds defined limit",
        default: !0,
        retryable: !1
    },
    E32006_DEFAULT_JSON_RPC_VERSION_NOT_SUPPORTED: {
        eipCode: -32006,
        message: "JSON-RPC version not supported",
        detail: "Version of JSON-RPC protocol is not supported",
        default: !0,
        retryable: !1
    },
    E32002_CONNECTION_ALREADY_PENDING: {
        eipCode: -32002,
        message: "Connection request already pending",
        detail: "Don’t see your wallet? Check your other browser windows.",
        retryable: !1
    },
    E32002_REQUEST_ALREADY_PENDING: {
        eipCode: -32002,
        message: "Resource request already pending",
        detail: "Don’t see your wallet? Check your other browser windows.",
        retryable: !1
    },
    E32002_WALLET_LOCKED: {
        eipCode: -32002,
        message: "Wallet might be locked",
        detail: "Don’t see your wallet? Check your other browser windows.",
        retryable: !1
    },
    E4001_USER_REJECTED_REQUEST: {
        eipCode: 4001,
        message: "Signature rejected",
        detail: "Please try signing again.",
        retryable: !0
    }
};

function iX(t) {
    let e = t.type;
    return typeof e == "string" && rX.includes(e)
}

function T6(t) {
    return iX(t) && t.type === "wallet_not_on_device"
}
async function A3(t, {
    request: e
}) {
    return await t.fetchPrivyRoute(IG, {
        body: e
    })
}
async function Dw({
    context: t,
    chainType: e
}) {
    return {
        wallet: await A3(t, {
            request: {
                chain_type: e,
                owner_id: void 0
            }
        })
    }
}
const sX = "logger/5.8.0";
let f7 = !1,
    p7 = !1;
const Fg = {
    debug: 1,
    default: 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let g7 = Fg.default,
    Lw = null;

function aX() {
    try {
        const t = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                try {
                    if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                } catch {
                    t.push(e)
                }
            }), t.length) throw new Error("missing " + t.join(", "));
        if ("é".normalize("NFD") !== "é") throw new Error("broken implementation")
    } catch (t) {
        return t.message
    }
    return null
}
const m7 = aX();
var k3;
(function(t) {
    t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF"
})(k3 || (k3 = {}));
var aa;
(function(t) {
    t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED"
})(aa || (aa = {}));
const y7 = "0123456789abcdef";
class pe {
    constructor(e) {
        Object.defineProperty(this, "version", {
            enumerable: !0,
            value: e,
            writable: !1
        })
    }
    _log(e, r) {
        const n = e.toLowerCase();
        Fg[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(g7 > Fg[n]) && console.log.apply(console, r)
    }
    debug(...e) {
        this._log(pe.levels.DEBUG, e)
    }
    info(...e) {
        this._log(pe.levels.INFO, e)
    }
    warn(...e) {
        this._log(pe.levels.WARNING, e)
    }
    makeError(e, r, n) {
        if (p7) return this.makeError("censored error", r, {});
        r || (r = pe.errors.UNKNOWN_ERROR), n || (n = {});
        const i = [];
        Object.keys(n).forEach(c => {
            const l = n[c];
            try {
                if (l instanceof Uint8Array) {
                    let u = "";
                    for (let h = 0; h < l.length; h++) u += y7[l[h] >> 4], u += y7[l[h] & 15];
                    i.push(c + "=Uint8Array(0x" + u + ")")
                } else i.push(c + "=" + JSON.stringify(l))
            } catch {
                i.push(c + "=" + JSON.stringify(n[c].toString()))
            }
        }), i.push(`code=${r}`), i.push(`version=${this.version}`);
        const s = e;
        let a = "";
        switch (r) {
            case aa.NUMERIC_FAULT:
                {
                    a = "NUMERIC_FAULT";
                    const c = e;
                    switch (c) {
                        case "overflow":
                        case "underflow":
                        case "division-by-zero":
                            a += "-" + c;
                            break;
                        case "negative-power":
                        case "negative-width":
                            a += "-unsupported";
                            break;
                        case "unbound-bitwise-result":
                            a += "-unbound-result";
                            break
                    }
                    break
                }
            case aa.CALL_EXCEPTION:
            case aa.INSUFFICIENT_FUNDS:
            case aa.MISSING_NEW:
            case aa.NONCE_EXPIRED:
            case aa.REPLACEMENT_UNDERPRICED:
            case aa.TRANSACTION_REPLACED:
            case aa.UNPREDICTABLE_GAS_LIMIT:
                a = r;
                break
        }
        a && (e += " [ See: https://links.ethers.org/v5-errors-" + a + " ]"), i.length && (e += " (" + i.join(", ") + ")");
        const o = new Error(e);
        return o.reason = s, o.code = r, Object.keys(n).forEach(function(c) {
            o[c] = n[c]
        }), o
    }
    throwError(e, r, n) {
        throw this.makeError(e, r, n)
    }
    throwArgumentError(e, r, n) {
        return this.throwError(e, pe.errors.INVALID_ARGUMENT, {
            argument: r,
            value: n
        })
    }
    assert(e, r, n, i) {
        e || this.throwError(r, n, i)
    }
    assertArgument(e, r, n, i) {
        e || this.throwArgumentError(r, n, i)
    }
    checkNormalize(e) {
        m7 && this.throwError("platform missing String.prototype.normalize", pe.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: m7
        })
    }
    checkSafeUint53(e, r) {
        typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, pe.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: e
        }), e % 1 && this.throwError(r, pe.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: e
        }))
    }
    checkArgumentCount(e, r, n) {
        n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, pe.errors.MISSING_ARGUMENT, {
            count: e,
            expectedCount: r
        }), e > r && this.throwError("too many arguments" + n, pe.errors.UNEXPECTED_ARGUMENT, {
            count: e,
            expectedCount: r
        })
    }
    checkNew(e, r) {
        (e === Object || e == null) && this.throwError("missing new", pe.errors.MISSING_NEW, {
            name: r.name
        })
    }
    checkAbstract(e, r) {
        e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", pe.errors.UNSUPPORTED_OPERATION, {
            name: e.name,
            operation: "new"
        }) : (e === Object || e == null) && this.throwError("missing new", pe.errors.MISSING_NEW, {
            name: r.name
        })
    }
    static globalLogger() {
        return Lw || (Lw = new pe(sX)), Lw
    }
    static setCensorship(e, r) {
        if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", pe.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            }), f7) {
            if (!e) return;
            this.globalLogger().throwError("error censorship permanent", pe.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            })
        }
        p7 = !!e, f7 = !!r
    }
    static setLogLevel(e) {
        const r = Fg[e.toLowerCase()];
        if (r == null) {
            pe.globalLogger().warn("invalid log level - " + e);
            return
        }
        g7 = r
    }
    static from(e) {
        return new pe(e)
    }
}
pe.errors = aa;
pe.levels = k3;
const oX = "properties/5.8.0";
var cX = function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(a) {
            a(s)
        })
    }
    return new(r || (r = Promise))(function(s, a) {
        function o(u) {
            try {
                l(n.next(u))
            } catch (h) {
                a(h)
            }
        }

        function c(u) {
            try {
                l(n.throw(u))
            } catch (h) {
                a(h)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(o, c)
        }
        l((n = n.apply(t, e || [])).next())
    })
};
const xm = new pe(oX);

function zt(t, e, r) {
    Object.defineProperty(t, e, {
        enumerable: !0,
        value: r,
        writable: !1
    })
}

function vf(t, e) {
    for (let r = 0; r < 32; r++) {
        if (t[e]) return t[e];
        if (!t.prototype || typeof t.prototype != "object") break;
        t = Object.getPrototypeOf(t.prototype).constructor
    }
    return null
}

function An(t) {
    return cX(this, void 0, void 0, function*() {
        const e = Object.keys(t).map(n => {
            const i = t[n];
            return Promise.resolve(i).then(s => ({
                key: n,
                value: s
            }))
        });
        return (yield Promise.all(e)).reduce((n, i) => (n[i.key] = i.value, n), {})
    })
}

function lX(t, e) {
    (!t || typeof t != "object") && xm.throwArgumentError("invalid object", "object", t), Object.keys(t).forEach(r => {
        e[r] || xm.throwArgumentError("invalid object key - " + r, "transaction:" + r, t)
    })
}

function ji(t) {
    const e = {};
    for (const r in t) e[r] = t[r];
    return e
}
const dX = {
    bigint: !0,
    boolean: !0,
    function: !0,
    number: !0,
    string: !0
};

function eN(t) {
    if (t == null || dX[typeof t]) return !0;
    if (Array.isArray(t) || typeof t == "object") {
        if (!Object.isFrozen(t)) return !1;
        const e = Object.keys(t);
        for (let r = 0; r < e.length; r++) {
            let n = null;
            try {
                n = t[e[r]]
            } catch {
                continue
            }
            if (!eN(n)) return !1
        }
        return !0
    }
    return xm.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}

function uX(t) {
    if (eN(t)) return t;
    if (Array.isArray(t)) return Object.freeze(t.map(e => xp(e)));
    if (typeof t == "object") {
        const e = {};
        for (const r in t) {
            const n = t[r];
            n !== void 0 && zt(e, r, xp(n))
        }
        return e
    }
    return xm.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}

function xp(t) {
    return uX(t)
}
class hX {
    constructor(e) {
        for (const r in e) this[r] = xp(e[r])
    }
}
const fX = "abstract-signer/5.8.0";
var Ks = function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(a) {
            a(s)
        })
    }
    return new(r || (r = Promise))(function(s, a) {
        function o(u) {
            try {
                l(n.next(u))
            } catch (h) {
                a(h)
            }
        }

        function c(u) {
            try {
                l(n.throw(u))
            } catch (h) {
                a(h)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(o, c)
        }
        l((n = n.apply(t, e || [])).next())
    })
};
const Cs = new pe(fX),
    pX = ["accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"],
    gX = [pe.errors.INSUFFICIENT_FUNDS, pe.errors.NONCE_EXPIRED, pe.errors.REPLACEMENT_UNDERPRICED];
class G1 {
    constructor() {
        Cs.checkAbstract(new.target, G1), zt(this, "_isSigner", !0)
    }
    getBalance(e) {
        return Ks(this, void 0, void 0, function*() {
            return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), e)
        })
    }
    getTransactionCount(e) {
        return Ks(this, void 0, void 0, function*() {
            return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), e)
        })
    }
    estimateGas(e) {
        return Ks(this, void 0, void 0, function*() {
            this._checkProvider("estimateGas");
            const r = yield An(this.checkTransaction(e));
            return yield this.provider.estimateGas(r)
        })
    }
    call(e, r) {
        return Ks(this, void 0, void 0, function*() {
            this._checkProvider("call");
            const n = yield An(this.checkTransaction(e));
            return yield this.provider.call(n, r)
        })
    }
    sendTransaction(e) {
        return Ks(this, void 0, void 0, function*() {
            this._checkProvider("sendTransaction");
            const r = yield this.populateTransaction(e), n = yield this.signTransaction(r);
            return yield this.provider.sendTransaction(n)
        })
    }
    getChainId() {
        return Ks(this, void 0, void 0, function*() {
            return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId
        })
    }
    getGasPrice() {
        return Ks(this, void 0, void 0, function*() {
            return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
        })
    }
    getFeeData() {
        return Ks(this, void 0, void 0, function*() {
            return this._checkProvider("getFeeData"), yield this.provider.getFeeData()
        })
    }
    resolveName(e) {
        return Ks(this, void 0, void 0, function*() {
            return this._checkProvider("resolveName"), yield this.provider.resolveName(e)
        })
    }
    checkTransaction(e) {
        for (const n in e) pX.indexOf(n) === -1 && Cs.throwArgumentError("invalid transaction key: " + n, "transaction", e);
        const r = ji(e);
        return r.from == null ? r.from = this.getAddress() : r.from = Promise.all([Promise.resolve(r.from), this.getAddress()]).then(n => (n[0].toLowerCase() !== n[1].toLowerCase() && Cs.throwArgumentError("from address mismatch", "transaction", e), n[0])), r
    }
    populateTransaction(e) {
        return Ks(this, void 0, void 0, function*() {
            const r = yield An(this.checkTransaction(e));
            r.to != null && (r.to = Promise.resolve(r.to).then(i => Ks(this, void 0, void 0, function*() {
                if (i == null) return null;
                const s = yield this.resolveName(i);
                return s == null && Cs.throwArgumentError("provided ENS name resolves to null", "tx.to", i), s
            })), r.to.catch(i => {}));
            const n = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
            if (r.gasPrice != null && (r.type === 2 || n) ? Cs.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", e) : (r.type === 0 || r.type === 1) && n && Cs.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", e), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null) r.type = 2;
            else if (r.type === 0 || r.type === 1) r.gasPrice == null && (r.gasPrice = this.getGasPrice());
            else {
                const i = yield this.getFeeData();
                if (r.type == null)
                    if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
                        if (r.type = 2, r.gasPrice != null) {
                            const s = r.gasPrice;
                            delete r.gasPrice, r.maxFeePerGas = s, r.maxPriorityFeePerGas = s
                        } else r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
                else i.gasPrice != null ? (n && Cs.throwError("network does not support EIP-1559", pe.errors.UNSUPPORTED_OPERATION, {
                    operation: "populateTransaction"
                }), r.gasPrice == null && (r.gasPrice = i.gasPrice), r.type = 0) : Cs.throwError("failed to get consistent fee data", pe.errors.UNSUPPORTED_OPERATION, {
                    operation: "signer.getFeeData"
                });
                else r.type === 2 && (r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas))
            }
            return r.nonce == null && (r.nonce = this.getTransactionCount("pending")), r.gasLimit == null && (r.gasLimit = this.estimateGas(r).catch(i => {
                if (gX.indexOf(i.code) >= 0) throw i;
                return Cs.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", pe.errors.UNPREDICTABLE_GAS_LIMIT, {
                    error: i,
                    tx: r
                })
            })), r.chainId == null ? r.chainId = this.getChainId() : r.chainId = Promise.all([Promise.resolve(r.chainId), this.getChainId()]).then(i => (i[1] !== 0 && i[0] !== i[1] && Cs.throwArgumentError("chainId address mismatch", "transaction", e), i[0])), yield An(r)
        })
    }
    _checkProvider(e) {
        this.provider || Cs.throwError("missing provider", pe.errors.UNSUPPORTED_OPERATION, {
            operation: e || "_checkProvider"
        })
    }
    static isSigner(e) {
        return !!(e && e._isSigner)
    }
}
class P6 extends G1 {
    constructor(e, r) {
        super(), zt(this, "address", e), zt(this, "provider", r || null)
    }
    getAddress() {
        return Promise.resolve(this.address)
    }
    _fail(e, r) {
        return Promise.resolve().then(() => {
            Cs.throwError(e, pe.errors.UNSUPPORTED_OPERATION, {
                operation: r
            })
        })
    }
    signMessage(e) {
        return this._fail("VoidSigner cannot sign messages", "signMessage")
    }
    signTransaction(e) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction")
    }
    _signTypedData(e, r, n) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData")
    }
    connect(e) {
        return new P6(this.address, e)
    }
}
const mX = "bytes/5.8.0",
    jr = new pe(mX);

function tN(t) {
    return !!t.toHexString
}

function Mu(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return Mu(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function N6(t) {
    return pr(t) && !(t.length % 2) || wh(t)
}

function w7(t) {
    return typeof t == "number" && t == t && t % 1 === 0
}

function wh(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !w7(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!w7(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function Pt(t, e) {
    if (e || (e = {}), typeof t == "number") {
        jr.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), Mu(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), tN(t) && (t = t.toHexString()), pr(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0" + r : e.hexPad === "right" ? r += "0" : jr.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return Mu(new Uint8Array(n))
    }
    return wh(t) ? Mu(new Uint8Array(t)) : jr.throwArgumentError("invalid arrayify value", "value", t)
}

function Ul(t) {
    const e = t.map(i => Pt(i)),
        r = e.reduce((i, s) => i + s.length, 0),
        n = new Uint8Array(r);
    return e.reduce((i, s) => (n.set(s, i), i + s.length), 0), Mu(n)
}

function eh(t) {
    let e = Pt(t);
    if (e.length === 0) return e;
    let r = 0;
    for (; r < e.length && e[r] === 0;) r++;
    return r && (e = e.slice(r)), e
}

function yX(t, e) {
    t = Pt(t), t.length > e && jr.throwArgumentError("value out of range", "value", arguments[0]);
    const r = new Uint8Array(e);
    return r.set(t, e - t.length), Mu(r)
}

function pr(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const Uw = "0123456789abcdef";

function Tt(t, e) {
    if (e || (e = {}), typeof t == "number") {
        jr.checkSafeUint53(t, "invalid hexlify value");
        let r = "";
        for (; t;) r = Uw[t & 15] + r, t = Math.floor(t / 16);
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00"
    }
    if (typeof t == "bigint") return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), tN(t)) return t.toHexString();
    if (pr(t)) return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : jr.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
    if (wh(t)) {
        let r = "0x";
        for (let n = 0; n < t.length; n++) {
            let i = t[n];
            r += Uw[(i & 240) >> 4] + Uw[i & 15]
        }
        return r
    }
    return jr.throwArgumentError("invalid hexlify value", "value", t)
}

function ud(t) {
    if (typeof t != "string") t = Tt(t);
    else if (!pr(t) || t.length % 2) return null;
    return (t.length - 2) / 2
}

function ii(t, e, r) {
    return typeof t != "string" ? t = Tt(t) : (!pr(t) || t.length % 2) && jr.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, r != null ? "0x" + t.substring(e, 2 + 2 * r) : "0x" + t.substring(e)
}

function rs(t) {
    let e = "0x";
    return t.forEach(r => {
        e += Tt(r).substring(2)
    }), e
}

function O6(t) {
    const e = wX(Tt(t, {
        hexPad: "left"
    }));
    return e === "0x" ? "0x0" : e
}

function wX(t) {
    typeof t != "string" && (t = Tt(t)), pr(t) || jr.throwArgumentError("invalid hex string", "value", t), t = t.substring(2);
    let e = 0;
    for (; e < t.length && t[e] === "0";) e++;
    return "0x" + t.substring(e)
}

function Mr(t, e) {
    for (typeof t != "string" ? t = Tt(t) : pr(t) || jr.throwArgumentError("invalid hex string", "value", t), t.length > 2 * e + 2 && jr.throwArgumentError("value out of range", "value", arguments[1]); t.length < 2 * e + 2;) t = "0x0" + t.substring(2);
    return t
}

function K1(t) {
    const e = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0,
        yParityAndS: "0x",
        compact: "0x"
    };
    if (N6(t)) {
        let r = Pt(t);
        r.length === 64 ? (e.v = 27 + (r[32] >> 7), r[32] &= 127, e.r = Tt(r.slice(0, 32)), e.s = Tt(r.slice(32, 64))) : r.length === 65 ? (e.r = Tt(r.slice(0, 32)), e.s = Tt(r.slice(32, 64)), e.v = r[64]) : jr.throwArgumentError("invalid signature string", "signature", t), e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : jr.throwArgumentError("signature invalid v byte", "signature", t)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (r[32] |= 128), e._vs = Tt(r.slice(32, 64))
    } else {
        if (e.r = t.r, e.s = t.s, e.v = t.v, e.recoveryParam = t.recoveryParam, e._vs = t._vs, e._vs != null) {
            const i = yX(Pt(e._vs), 32);
            e._vs = Tt(i);
            const s = i[0] >= 128 ? 1 : 0;
            e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && jr.throwArgumentError("signature recoveryParam mismatch _vs", "signature", t), i[0] &= 127;
            const a = Tt(i);
            e.s == null ? e.s = a : e.s !== a && jr.throwArgumentError("signature v mismatch _vs", "signature", t)
        }
        if (e.recoveryParam == null) e.v == null ? jr.throwArgumentError("signature missing v and recoveryParam", "signature", t) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
        else if (e.v == null) e.v = 27 + e.recoveryParam;
        else {
            const i = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
            e.recoveryParam !== i && jr.throwArgumentError("signature recoveryParam mismatch v", "signature", t)
        }
        e.r == null || !pr(e.r) ? jr.throwArgumentError("signature missing or invalid r", "signature", t) : e.r = Mr(e.r, 32), e.s == null || !pr(e.s) ? jr.throwArgumentError("signature missing or invalid s", "signature", t) : e.s = Mr(e.s, 32);
        const r = Pt(e.s);
        r[0] >= 128 && jr.throwArgumentError("signature s out of range", "signature", t), e.recoveryParam && (r[0] |= 128);
        const n = Tt(r);
        e._vs && (pr(e._vs) || jr.throwArgumentError("signature invalid _vs", "signature", t), e._vs = Mr(e._vs, 32)), e._vs == null ? e._vs = n : e._vs !== n && jr.throwArgumentError("signature _vs mismatch v and s", "signature", t)
    }
    return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e
}
const rN = "bignumber/5.8.0";
var Em = Et.BN;
const No = new pe(rN),
    Fw = {},
    b7 = 9007199254740991;

function bX(t) {
    return t != null && (Fe.isBigNumber(t) || typeof t == "number" && t % 1 === 0 || typeof t == "string" && !!t.match(/^-?[0-9]+$/) || pr(t) || typeof t == "bigint" || wh(t))
}
let v7 = !1;
class Fe {
    constructor(e, r) {
        e !== Fw && No.throwError("cannot call constructor directly; use BigNumber.from", pe.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
        }), this._hex = r, this._isBigNumber = !0, Object.freeze(this)
    }
    fromTwos(e) {
        return Ei(Bt(this).fromTwos(e))
    }
    toTwos(e) {
        return Ei(Bt(this).toTwos(e))
    }
    abs() {
        return this._hex[0] === "-" ? Fe.from(this._hex.substring(1)) : this
    }
    add(e) {
        return Ei(Bt(this).add(Bt(e)))
    }
    sub(e) {
        return Ei(Bt(this).sub(Bt(e)))
    }
    div(e) {
        return Fe.from(e).isZero() && ms("division-by-zero", "div"), Ei(Bt(this).div(Bt(e)))
    }
    mul(e) {
        return Ei(Bt(this).mul(Bt(e)))
    }
    mod(e) {
        const r = Bt(e);
        return r.isNeg() && ms("division-by-zero", "mod"), Ei(Bt(this).umod(r))
    }
    pow(e) {
        const r = Bt(e);
        return r.isNeg() && ms("negative-power", "pow"), Ei(Bt(this).pow(r))
    }
    and(e) {
        const r = Bt(e);
        return (this.isNegative() || r.isNeg()) && ms("unbound-bitwise-result", "and"), Ei(Bt(this).and(r))
    }
    or(e) {
        const r = Bt(e);
        return (this.isNegative() || r.isNeg()) && ms("unbound-bitwise-result", "or"), Ei(Bt(this).or(r))
    }
    xor(e) {
        const r = Bt(e);
        return (this.isNegative() || r.isNeg()) && ms("unbound-bitwise-result", "xor"), Ei(Bt(this).xor(r))
    }
    mask(e) {
        return (this.isNegative() || e < 0) && ms("negative-width", "mask"), Ei(Bt(this).maskn(e))
    }
    shl(e) {
        return (this.isNegative() || e < 0) && ms("negative-width", "shl"), Ei(Bt(this).shln(e))
    }
    shr(e) {
        return (this.isNegative() || e < 0) && ms("negative-width", "shr"), Ei(Bt(this).shrn(e))
    }
    eq(e) {
        return Bt(this).eq(Bt(e))
    }
    lt(e) {
        return Bt(this).lt(Bt(e))
    }
    lte(e) {
        return Bt(this).lte(Bt(e))
    }
    gt(e) {
        return Bt(this).gt(Bt(e))
    }
    gte(e) {
        return Bt(this).gte(Bt(e))
    }
    isNegative() {
        return this._hex[0] === "-"
    }
    isZero() {
        return Bt(this).isZero()
    }
    toNumber() {
        try {
            return Bt(this).toNumber()
        } catch {
            ms("overflow", "toNumber", this.toString())
        }
        return null
    }
    toBigInt() {
        try {
            return BigInt(this.toString())
        } catch {}
        return No.throwError("this platform does not support BigInt", pe.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        })
    }
    toString() {
        return arguments.length > 0 && (arguments[0] === 10 ? v7 || (v7 = !0, No.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? No.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", pe.errors.UNEXPECTED_ARGUMENT, {}) : No.throwError("BigNumber.toString does not accept parameters", pe.errors.UNEXPECTED_ARGUMENT, {})), Bt(this).toString(10)
    }
    toHexString() {
        return this._hex
    }
    toJSON(e) {
        return {
            type: "BigNumber",
            hex: this.toHexString()
        }
    }
    static from(e) {
        if (e instanceof Fe) return e;
        if (typeof e == "string") return e.match(/^-?0x[0-9a-f]+$/i) ? new Fe(Fw, Ep(e)) : e.match(/^-?[0-9]+$/) ? new Fe(Fw, Ep(new Em(e))) : No.throwArgumentError("invalid BigNumber string", "value", e);
        if (typeof e == "number") return e % 1 && ms("underflow", "BigNumber.from", e), (e >= b7 || e <= -b7) && ms("overflow", "BigNumber.from", e), Fe.from(String(e));
        const r = e;
        if (typeof r == "bigint") return Fe.from(r.toString());
        if (wh(r)) return Fe.from(Tt(r));
        if (r)
            if (r.toHexString) {
                const n = r.toHexString();
                if (typeof n == "string") return Fe.from(n)
            } else {
                let n = r._hex;
                if (n == null && r.type === "BigNumber" && (n = r.hex), typeof n == "string" && (pr(n) || n[0] === "-" && pr(n.substring(1)))) return Fe.from(n)
            }
        return No.throwArgumentError("invalid BigNumber value", "value", e)
    }
    static isBigNumber(e) {
        return !!(e && e._isBigNumber)
    }
}

function Ep(t) {
    if (typeof t != "string") return Ep(t.toString(16));
    if (t[0] === "-") return t = t.substring(1), t[0] === "-" && No.throwArgumentError("invalid hex", "value", t), t = Ep(t), t === "0x00" ? t : "-" + t;
    if (t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x") return "0x00";
    for (t.length % 2 && (t = "0x0" + t.substring(2)); t.length > 4 && t.substring(0, 4) === "0x00";) t = "0x" + t.substring(4);
    return t
}

function Ei(t) {
    return Fe.from(Ep(t))
}

function Bt(t) {
    const e = Fe.from(t).toHexString();
    return e[0] === "-" ? new Em("-" + e.substring(3), 16) : new Em(e.substring(2), 16)
}

function ms(t, e, r) {
    const n = {
        fault: t,
        operation: e
    };
    return r != null && (n.value = r), No.throwError(t, pe.errors.NUMERIC_FAULT, n)
}

function vX(t) {
    return new Em(t, 36).toString(16)
}
const oi = new pe(rN),
    Of = {},
    nN = Fe.from(0),
    iN = Fe.from(-1);

function sN(t, e, r, n) {
    const i = {
        fault: e,
        operation: r
    };
    return n !== void 0 && (i.value = n), oi.throwError(t, pe.errors.NUMERIC_FAULT, i)
}
let jf = "0";
for (; jf.length < 256;) jf += jf;

function j6(t) {
    if (typeof t != "number") try {
        t = Fe.from(t).toNumber()
    } catch {}
    return typeof t == "number" && t >= 0 && t <= 256 && !(t % 1) ? "1" + jf.substring(0, t) : oi.throwArgumentError("invalid decimal size", "decimals", t)
}

function Bw(t, e) {
    e == null && (e = 0);
    const r = j6(e);
    t = Fe.from(t);
    const n = t.lt(nN);
    n && (t = t.mul(iN));
    let i = t.mod(r).toString();
    for (; i.length < r.length - 1;) i = "0" + i;
    i = i.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    const s = t.div(r).toString();
    return r.length === 1 ? t = s : t = s + "." + i, n && (t = "-" + t), t
}

function Va(t, e) {
    e == null && (e = 0);
    const r = j6(e);
    (typeof t != "string" || !t.match(/^-?[0-9.]+$/)) && oi.throwArgumentError("invalid decimal value", "value", t);
    const n = t.substring(0, 1) === "-";
    n && (t = t.substring(1)), t === "." && oi.throwArgumentError("missing value", "value", t);
    const i = t.split(".");
    i.length > 2 && oi.throwArgumentError("too many decimal points", "value", t);
    let s = i[0],
        a = i[1];
    for (s || (s = "0"), a || (a = "0"); a[a.length - 1] === "0";) a = a.substring(0, a.length - 1);
    for (a.length > r.length - 1 && sN("fractional component exceeds decimals", "underflow", "parseFixed"), a === "" && (a = "0"); a.length < r.length - 1;) a += "0";
    const o = Fe.from(s),
        c = Fe.from(a);
    let l = o.mul(r).add(c);
    return n && (l = l.mul(iN)), l
}
class Du {
    constructor(e, r, n, i) {
        e !== Of && oi.throwError("cannot use FixedFormat constructor; use FixedFormat.from", pe.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
        }), this.signed = r, this.width = n, this.decimals = i, this.name = (r ? "" : "u") + "fixed" + String(n) + "x" + String(i), this._multiplier = j6(i), Object.freeze(this)
    }
    static from(e) {
        if (e instanceof Du) return e;
        typeof e == "number" && (e = `fixed128x${e}`);
        let r = !0,
            n = 128,
            i = 18;
        if (typeof e == "string") {
            if (e !== "fixed")
                if (e === "ufixed") r = !1;
                else {
                    const s = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                    s || oi.throwArgumentError("invalid fixed format", "format", e), r = s[1] !== "u", n = parseInt(s[2]), i = parseInt(s[3])
                }
        } else if (e) {
            const s = (a, o, c) => e[a] == null ? c : (typeof e[a] !== o && oi.throwArgumentError("invalid fixed format (" + a + " not " + o + ")", "format." + a, e[a]), e[a]);
            r = s("signed", "boolean", r), n = s("width", "number", n), i = s("decimals", "number", i)
        }
        return n % 8 && oi.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", n), i > 80 && oi.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", i), new Du(Of, r, n, i)
    }
}
class Cn {
    constructor(e, r, n, i) {
        e !== Of && oi.throwError("cannot use FixedNumber constructor; use FixedNumber.from", pe.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
        }), this.format = i, this._hex = r, this._value = n, this._isFixedNumber = !0, Object.freeze(this)
    }
    _checkFormat(e) {
        this.format.name !== e.format.name && oi.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", e)
    }
    addUnsafe(e) {
        this._checkFormat(e);
        const r = Va(this._value, this.format.decimals),
            n = Va(e._value, e.format.decimals);
        return Cn.fromValue(r.add(n), this.format.decimals, this.format)
    }
    subUnsafe(e) {
        this._checkFormat(e);
        const r = Va(this._value, this.format.decimals),
            n = Va(e._value, e.format.decimals);
        return Cn.fromValue(r.sub(n), this.format.decimals, this.format)
    }
    mulUnsafe(e) {
        this._checkFormat(e);
        const r = Va(this._value, this.format.decimals),
            n = Va(e._value, e.format.decimals);
        return Cn.fromValue(r.mul(n).div(this.format._multiplier), this.format.decimals, this.format)
    }
    divUnsafe(e) {
        this._checkFormat(e);
        const r = Va(this._value, this.format.decimals),
            n = Va(e._value, e.format.decimals);
        return Cn.fromValue(r.mul(this.format._multiplier).div(n), this.format.decimals, this.format)
    }
    floor() {
        const e = this.toString().split(".");
        e.length === 1 && e.push("0");
        let r = Cn.from(e[0], this.format);
        const n = !e[1].match(/^(0*)$/);
        return this.isNegative() && n && (r = r.subUnsafe(x7.toFormat(r.format))), r
    }
    ceiling() {
        const e = this.toString().split(".");
        e.length === 1 && e.push("0");
        let r = Cn.from(e[0], this.format);
        const n = !e[1].match(/^(0*)$/);
        return !this.isNegative() && n && (r = r.addUnsafe(x7.toFormat(r.format))), r
    }
    round(e) {
        e == null && (e = 0);
        const r = this.toString().split(".");
        if (r.length === 1 && r.push("0"), (e < 0 || e > 80 || e % 1) && oi.throwArgumentError("invalid decimal count", "decimals", e), r[1].length <= e) return this;
        const n = Cn.from("1" + jf.substring(0, e), this.format),
            i = xX.toFormat(this.format);
        return this.mulUnsafe(n).addUnsafe(i).floor().divUnsafe(n)
    }
    isZero() {
        return this._value === "0.0" || this._value === "0"
    }
    isNegative() {
        return this._value[0] === "-"
    }
    toString() {
        return this._value
    }
    toHexString(e) {
        if (e == null) return this._hex;
        e % 8 && oi.throwArgumentError("invalid byte width", "width", e);
        const r = Fe.from(this._hex).fromTwos(this.format.width).toTwos(e).toHexString();
        return Mr(r, e / 8)
    }
    toUnsafeFloat() {
        return parseFloat(this.toString())
    }
    toFormat(e) {
        return Cn.fromString(this._value, e)
    }
    static fromValue(e, r, n) {
        return n == null && r != null && !bX(r) && (n = r, r = null), r == null && (r = 0), n == null && (n = "fixed"), Cn.fromString(Bw(e, r), Du.from(n))
    }
    static fromString(e, r) {
        r == null && (r = "fixed");
        const n = Du.from(r),
            i = Va(e, n.decimals);
        !n.signed && i.lt(nN) && sN("unsigned value cannot be negative", "overflow", "value", e);
        let s = null;
        n.signed ? s = i.toTwos(n.width).toHexString() : (s = i.toHexString(), s = Mr(s, n.width / 8));
        const a = Bw(i, n.decimals);
        return new Cn(Of, s, a, n)
    }
    static fromBytes(e, r) {
        r == null && (r = "fixed");
        const n = Du.from(r);
        if (Pt(e).length > n.width / 8) throw new Error("overflow");
        let i = Fe.from(e);
        n.signed && (i = i.fromTwos(n.width));
        const s = i.toTwos((n.signed ? 0 : 1) + n.width).toHexString(),
            a = Bw(i, n.decimals);
        return new Cn(Of, s, a, n)
    }
    static from(e, r) {
        if (typeof e == "string") return Cn.fromString(e, r);
        if (wh(e)) return Cn.fromBytes(e, r);
        try {
            return Cn.fromValue(e, 0, r)
        } catch (n) {
            if (n.code !== pe.errors.INVALID_ARGUMENT) throw n
        }
        return oi.throwArgumentError("invalid FixedNumber value", "value", e)
    }
    static isFixedNumber(e) {
        return !!(e && e._isFixedNumber)
    }
}
const x7 = Cn.from(1),
    xX = Cn.from("0.5"),
    EX = "abstract-provider/5.8.0";
var _X = function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(a) {
            a(s)
        })
    }
    return new(r || (r = Promise))(function(s, a) {
        function o(u) {
            try {
                l(n.next(u))
            } catch (h) {
                a(h)
            }
        }

        function c(u) {
            try {
                l(n.throw(u))
            } catch (h) {
                a(h)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(o, c)
        }
        l((n = n.apply(t, e || [])).next())
    })
};
const CX = new pe(EX);
class AX extends hX {
    static isForkEvent(e) {
        return !!(e && e._isForkEvent)
    }
}
class R6 {
    constructor() {
        CX.checkAbstract(new.target, R6), zt(this, "_isProvider", !0)
    }
    getFeeData() {
        return _X(this, void 0, void 0, function*() {
            const {
                block: e,
                gasPrice: r
            } = yield An({
                block: this.getBlock("latest"),
                gasPrice: this.getGasPrice().catch(a => null)
            });
            let n = null,
                i = null,
                s = null;
            return e && e.baseFeePerGas && (n = e.baseFeePerGas, s = Fe.from("1500000000"), i = e.baseFeePerGas.mul(2).add(s)), {
                lastBaseFeePerGas: n,
                maxFeePerGas: i,
                maxPriorityFeePerGas: s,
                gasPrice: r
            }
        })
    }
    addListener(e, r) {
        return this.on(e, r)
    }
    removeListener(e, r) {
        return this.off(e, r)
    }
    static isProvider(e) {
        return !!(e && e._isProvider)
    }
}
const kX = "networks/5.8.0",
    E7 = new pe(kX);

function IX(t) {
    return t && typeof t.renetwork == "function"
}

function oa(t) {
    const e = function(r, n) {
        n == null && (n = {});
        const i = [];
        if (r.InfuraProvider && n.infura !== "-") try {
            i.push(new r.InfuraProvider(t, n.infura))
        } catch {}
        if (r.EtherscanProvider && n.etherscan !== "-") try {
            i.push(new r.EtherscanProvider(t, n.etherscan))
        } catch {}
        if (r.AlchemyProvider && n.alchemy !== "-") try {
            i.push(new r.AlchemyProvider(t, n.alchemy))
        } catch {}
        if (r.PocketProvider && n.pocket !== "-") {
            const s = ["goerli", "ropsten", "rinkeby", "sepolia"];
            try {
                const a = new r.PocketProvider(t, n.pocket);
                a.network && s.indexOf(a.network.name) === -1 && i.push(a)
            } catch {}
        }
        if (r.CloudflareProvider && n.cloudflare !== "-") try {
            i.push(new r.CloudflareProvider(t))
        } catch {}
        if (r.AnkrProvider && n.ankr !== "-") try {
            const s = ["ropsten"],
                a = new r.AnkrProvider(t, n.ankr);
            a.network && s.indexOf(a.network.name) === -1 && i.push(a)
        } catch {}
        if (r.QuickNodeProvider && n.quicknode !== "-") try {
            i.push(new r.QuickNodeProvider(t, n.quicknode))
        } catch {}
        if (i.length === 0) return null;
        if (r.FallbackProvider) {
            let s = 1;
            return n.quorum != null ? s = n.quorum : t === "homestead" && (s = 2), new r.FallbackProvider(i, s)
        }
        return i[0]
    };
    return e.renetwork = function(r) {
        return oa(r)
    }, e
}

function _m(t, e) {
    const r = function(n, i) {
        return n.JsonRpcProvider ? new n.JsonRpcProvider(t, e) : null
    };
    return r.renetwork = function(n) {
        return _m(t, n)
    }, r
}
const _7 = {
        chainId: 1,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "homestead",
        _defaultProvider: oa("homestead")
    },
    C7 = {
        chainId: 3,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "ropsten",
        _defaultProvider: oa("ropsten")
    },
    A7 = {
        chainId: 63,
        name: "classicMordor",
        _defaultProvider: _m("https://www.ethercluster.com/mordor", "classicMordor")
    },
    K0 = {
        unspecified: {
            chainId: 0,
            name: "unspecified"
        },
        homestead: _7,
        mainnet: _7,
        morden: {
            chainId: 2,
            name: "morden"
        },
        ropsten: C7,
        testnet: C7,
        rinkeby: {
            chainId: 4,
            ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
            name: "rinkeby",
            _defaultProvider: oa("rinkeby")
        },
        kovan: {
            chainId: 42,
            name: "kovan",
            _defaultProvider: oa("kovan")
        },
        goerli: {
            chainId: 5,
            ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
            name: "goerli",
            _defaultProvider: oa("goerli")
        },
        kintsugi: {
            chainId: 1337702,
            name: "kintsugi"
        },
        sepolia: {
            chainId: 11155111,
            ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
            name: "sepolia",
            _defaultProvider: oa("sepolia")
        },
        holesky: {
            chainId: 17e3,
            name: "holesky",
            _defaultProvider: oa("holesky")
        },
        classic: {
            chainId: 61,
            name: "classic",
            _defaultProvider: _m("https://www.ethercluster.com/etc", "classic")
        },
        classicMorden: {
            chainId: 62,
            name: "classicMorden"
        },
        classicMordor: A7,
        classicTestnet: A7,
        classicKotti: {
            chainId: 6,
            name: "classicKotti",
            _defaultProvider: _m("https://www.ethercluster.com/kotti", "classicKotti")
        },
        xdai: {
            chainId: 100,
            name: "xdai"
        },
        matic: {
            chainId: 137,
            name: "matic",
            _defaultProvider: oa("matic")
        },
        maticmum: {
            chainId: 80001,
            name: "maticmum",
            _defaultProvider: oa("maticmum")
        },
        optimism: {
            chainId: 10,
            name: "optimism",
            _defaultProvider: oa("optimism")
        },
        "optimism-kovan": {
            chainId: 69,
            name: "optimism-kovan"
        },
        "optimism-goerli": {
            chainId: 420,
            name: "optimism-goerli"
        },
        "optimism-sepolia": {
            chainId: 11155420,
            name: "optimism-sepolia"
        },
        arbitrum: {
            chainId: 42161,
            name: "arbitrum"
        },
        "arbitrum-rinkeby": {
            chainId: 421611,
            name: "arbitrum-rinkeby"
        },
        "arbitrum-goerli": {
            chainId: 421613,
            name: "arbitrum-goerli"
        },
        "arbitrum-sepolia": {
            chainId: 421614,
            name: "arbitrum-sepolia"
        },
        bnb: {
            chainId: 56,
            name: "bnb"
        },
        bnbt: {
            chainId: 97,
            name: "bnbt"
        }
    };

function $X(t) {
    if (t == null) return null;
    if (typeof t == "number") {
        for (const n in K0) {
            const i = K0[n];
            if (i.chainId === t) return {
                name: i.name,
                chainId: i.chainId,
                ensAddress: i.ensAddress || null,
                _defaultProvider: i._defaultProvider || null
            }
        }
        return {
            chainId: t,
            name: "unknown"
        }
    }
    if (typeof t == "string") {
        const n = K0[t];
        return n == null ? null : {
            name: n.name,
            chainId: n.chainId,
            ensAddress: n.ensAddress,
            _defaultProvider: n._defaultProvider || null
        }
    }
    const e = K0[t.name];
    if (!e) return typeof t.chainId != "number" && E7.throwArgumentError("invalid network chainId", "network", t), t;
    t.chainId !== 0 && t.chainId !== e.chainId && E7.throwArgumentError("network chainId mismatch", "network", t);
    let r = t._defaultProvider || null;
    return r == null && e._defaultProvider && (IX(e._defaultProvider) ? r = e._defaultProvider.renetwork(t) : r = e._defaultProvider), {
        name: t.name,
        chainId: e.chainId,
        ensAddress: t.ensAddress || e.ensAddress || null,
        _defaultProvider: r
    }
}

function aN(t) {
    t = atob(t);
    const e = [];
    for (let r = 0; r < t.length; r++) e.push(t.charCodeAt(r));
    return Pt(e)
}

function oN(t) {
    t = Pt(t);
    let e = "";
    for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
    return btoa(e)
}
class cN {
    constructor(e) {
        zt(this, "alphabet", e), zt(this, "base", e.length), zt(this, "_alphabetMap", {}), zt(this, "_leader", e.charAt(0));
        for (let r = 0; r < e.length; r++) this._alphabetMap[e.charAt(r)] = r
    }
    encode(e) {
        let r = Pt(e);
        if (r.length === 0) return "";
        let n = [0];
        for (let s = 0; s < r.length; ++s) {
            let a = r[s];
            for (let o = 0; o < n.length; ++o) a += n[o] << 8, n[o] = a % this.base, a = a / this.base | 0;
            for (; a > 0;) n.push(a % this.base), a = a / this.base | 0
        }
        let i = "";
        for (let s = 0; r[s] === 0 && s < r.length - 1; ++s) i += this._leader;
        for (let s = n.length - 1; s >= 0; --s) i += this.alphabet[n[s]];
        return i
    }
    decode(e) {
        if (typeof e != "string") throw new TypeError("Expected String");
        let r = [];
        if (e.length === 0) return new Uint8Array(r);
        r.push(0);
        for (let n = 0; n < e.length; n++) {
            let i = this._alphabetMap[e[n]];
            if (i === void 0) throw new Error("Non-base" + this.base + " character");
            let s = i;
            for (let a = 0; a < r.length; ++a) s += r[a] * this.base, r[a] = s & 255, s >>= 8;
            for (; s > 0;) r.push(s & 255), s >>= 8
        }
        for (let n = 0; e[n] === this._leader && n < e.length - 1; ++n) r.push(0);
        return Pt(new Uint8Array(r.reverse()))
    }
}
new cN("abcdefghijklmnopqrstuvwxyz234567");
const I3 = new cN("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),
    SX = "0x0000000000000000000000000000000000000000",
    TX = Fe.from(0),
    PX = "0x0000000000000000000000000000000000000000000000000000000000000000";
var Ww = {
        exports: {}
    },
    k7;

function NX() {
    return k7 || (k7 = 1, function(t) {
        (function() {
            var e = "input is invalid type",
                r = "finalize already called",
                n = typeof window == "object",
                i = n ? window : {};
            i.JS_SHA3_NO_WINDOW && (n = !1);
            var s = !n && typeof self == "object",
                a = !i.JS_SHA3_NO_NODE_JS && typeof jn == "object" && jn.versions && jn.versions.node;
            a ? i = globalThis : s && (i = self);
            var o = !i.JS_SHA3_NO_COMMON_JS && !0 && t.exports,
                c = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u",
                l = "0123456789abcdef".split(""),
                u = [31, 7936, 2031616, 520093696],
                h = [4, 1024, 262144, 67108864],
                f = [1, 256, 65536, 16777216],
                p = [6, 1536, 393216, 100663296],
                g = [0, 8, 16, 24],
                m = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648],
                y = [224, 256, 384, 512],
                w = [128, 256],
                x = ["hex", "buffer", "arrayBuffer", "array", "digest"],
                E = {
                    128: 168,
                    256: 136
                };
            (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(j) {
                return Object.prototype.toString.call(j) === "[object Array]"
            }), c && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(j) {
                return typeof j == "object" && j.buffer && j.buffer.constructor === ArrayBuffer
            });
            for (var _ = function(j, V, Y) {
                    return function(X) {
                        return new W(j, V, j).update(X)[Y]()
                    }
                }, b = function(j, V, Y) {
                    return function(X, ne) {
                        return new W(j, V, ne).update(X)[Y]()
                    }
                }, A = function(j, V, Y) {
                    return function(X, ne, ae, ue) {
                        return D["cshake" + j].update(X, ne, ae, ue)[Y]()
                    }
                }, I = function(j, V, Y) {
                    return function(X, ne, ae, ue) {
                        return D["kmac" + j].update(X, ne, ae, ue)[Y]()
                    }
                }, T = function(j, V, Y, X) {
                    for (var ne = 0; ne < x.length; ++ne) {
                        var ae = x[ne];
                        j[ae] = V(Y, X, ae)
                    }
                    return j
                }, C = function(j, V) {
                    var Y = _(j, V, "hex");
                    return Y.create = function() {
                        return new W(j, V, j)
                    }, Y.update = function(X) {
                        return Y.create().update(X)
                    }, T(Y, _, j, V)
                }, $ = function(j, V) {
                    var Y = b(j, V, "hex");
                    return Y.create = function(X) {
                        return new W(j, V, X)
                    }, Y.update = function(X, ne) {
                        return Y.create(ne).update(X)
                    }, T(Y, b, j, V)
                }, P = function(j, V) {
                    var Y = E[j],
                        X = A(j, V, "hex");
                    return X.create = function(ne, ae, ue) {
                        return !ae && !ue ? D["shake" + j].create(ne) : new W(j, V, ne).bytepad([ae, ue], Y)
                    }, X.update = function(ne, ae, ue, he) {
                        return X.create(ae, ue, he).update(ne)
                    }, T(X, A, j, V)
                }, N = function(j, V) {
                    var Y = E[j],
                        X = I(j, V, "hex");
                    return X.create = function(ne, ae, ue) {
                        return new K(j, V, ae).bytepad(["KMAC", ue], Y).bytepad([ne], Y)
                    }, X.update = function(ne, ae, ue, he) {
                        return X.create(ne, ue, he).update(ae)
                    }, T(X, I, j, V)
                }, R = [{
                    name: "keccak",
                    padding: f,
                    bits: y,
                    createMethod: C
                }, {
                    name: "sha3",
                    padding: p,
                    bits: y,
                    createMethod: C
                }, {
                    name: "shake",
                    padding: u,
                    bits: w,
                    createMethod: $
                }, {
                    name: "cshake",
                    padding: h,
                    bits: w,
                    createMethod: P
                }, {
                    name: "kmac",
                    padding: h,
                    bits: w,
                    createMethod: N
                }], D = {}, S = [], O = 0; O < R.length; ++O)
                for (var M = R[O], U = M.bits, k = 0; k < U.length; ++k) {
                    var F = M.name + "_" + U[k];
                    if (S.push(F), D[F] = M.createMethod(U[k], M.padding), M.name !== "sha3") {
                        var q = M.name + U[k];
                        S.push(q), D[q] = D[F]
                    }
                }

            function W(j, V, Y) {
                this.blocks = [], this.s = [], this.padding = V, this.outputBits = Y, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (j << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = Y >> 5, this.extraBytes = (Y & 31) >> 3;
                for (var X = 0; X < 50; ++X) this.s[X] = 0
            }
            W.prototype.update = function(j) {
                if (this.finalized) throw new Error(r);
                var V, Y = typeof j;
                if (Y !== "string") {
                    if (Y === "object") {
                        if (j === null) throw new Error(e);
                        if (c && j.constructor === ArrayBuffer) j = new Uint8Array(j);
                        else if (!Array.isArray(j) && (!c || !ArrayBuffer.isView(j))) throw new Error(e)
                    } else throw new Error(e);
                    V = !0
                }
                for (var X = this.blocks, ne = this.byteCount, ae = j.length, ue = this.blockCount, he = 0, fe = this.s, de, ye; he < ae;) {
                    if (this.reset)
                        for (this.reset = !1, X[0] = this.block, de = 1; de < ue + 1; ++de) X[de] = 0;
                    if (V)
                        for (de = this.start; he < ae && de < ne; ++he) X[de >> 2] |= j[he] << g[de++ & 3];
                    else
                        for (de = this.start; he < ae && de < ne; ++he) ye = j.charCodeAt(he), ye < 128 ? X[de >> 2] |= ye << g[de++ & 3] : ye < 2048 ? (X[de >> 2] |= (192 | ye >> 6) << g[de++ & 3], X[de >> 2] |= (128 | ye & 63) << g[de++ & 3]) : ye < 55296 || ye >= 57344 ? (X[de >> 2] |= (224 | ye >> 12) << g[de++ & 3], X[de >> 2] |= (128 | ye >> 6 & 63) << g[de++ & 3], X[de >> 2] |= (128 | ye & 63) << g[de++ & 3]) : (ye = 65536 + ((ye & 1023) << 10 | j.charCodeAt(++he) & 1023), X[de >> 2] |= (240 | ye >> 18) << g[de++ & 3], X[de >> 2] |= (128 | ye >> 12 & 63) << g[de++ & 3], X[de >> 2] |= (128 | ye >> 6 & 63) << g[de++ & 3], X[de >> 2] |= (128 | ye & 63) << g[de++ & 3]);
                    if (this.lastByteIndex = de, de >= ne) {
                        for (this.start = de - ne, this.block = X[ue], de = 0; de < ue; ++de) fe[de] ^= X[de];
                        H(fe), this.reset = !0
                    } else this.start = de
                }
                return this
            }, W.prototype.encode = function(j, V) {
                var Y = j & 255,
                    X = 1,
                    ne = [Y];
                for (j = j >> 8, Y = j & 255; Y > 0;) ne.unshift(Y), j = j >> 8, Y = j & 255, ++X;
                return V ? ne.push(X) : ne.unshift(X), this.update(ne), ne.length
            }, W.prototype.encodeString = function(j) {
                var V, Y = typeof j;
                if (Y !== "string") {
                    if (Y === "object") {
                        if (j === null) throw new Error(e);
                        if (c && j.constructor === ArrayBuffer) j = new Uint8Array(j);
                        else if (!Array.isArray(j) && (!c || !ArrayBuffer.isView(j))) throw new Error(e)
                    } else throw new Error(e);
                    V = !0
                }
                var X = 0,
                    ne = j.length;
                if (V) X = ne;
                else
                    for (var ae = 0; ae < j.length; ++ae) {
                        var ue = j.charCodeAt(ae);
                        ue < 128 ? X += 1 : ue < 2048 ? X += 2 : ue < 55296 || ue >= 57344 ? X += 3 : (ue = 65536 + ((ue & 1023) << 10 | j.charCodeAt(++ae) & 1023), X += 4)
                    }
                return X += this.encode(X * 8), this.update(j), X
            }, W.prototype.bytepad = function(j, V) {
                for (var Y = this.encode(V), X = 0; X < j.length; ++X) Y += this.encodeString(j[X]);
                var ne = V - Y % V,
                    ae = [];
                return ae.length = ne, this.update(ae), this
            }, W.prototype.finalize = function() {
                if (!this.finalized) {
                    this.finalized = !0;
                    var j = this.blocks,
                        V = this.lastByteIndex,
                        Y = this.blockCount,
                        X = this.s;
                    if (j[V >> 2] |= this.padding[V & 3], this.lastByteIndex === this.byteCount)
                        for (j[0] = j[Y], V = 1; V < Y + 1; ++V) j[V] = 0;
                    for (j[Y - 1] |= 2147483648, V = 0; V < Y; ++V) X[V] ^= j[V];
                    H(X)
                }
            }, W.prototype.toString = W.prototype.hex = function() {
                this.finalize();
                for (var j = this.blockCount, V = this.s, Y = this.outputBlocks, X = this.extraBytes, ne = 0, ae = 0, ue = "", he; ae < Y;) {
                    for (ne = 0; ne < j && ae < Y; ++ne, ++ae) he = V[ne], ue += l[he >> 4 & 15] + l[he & 15] + l[he >> 12 & 15] + l[he >> 8 & 15] + l[he >> 20 & 15] + l[he >> 16 & 15] + l[he >> 28 & 15] + l[he >> 24 & 15];
                    ae % j === 0 && (H(V), ne = 0)
                }
                return X && (he = V[ne], ue += l[he >> 4 & 15] + l[he & 15], X > 1 && (ue += l[he >> 12 & 15] + l[he >> 8 & 15]), X > 2 && (ue += l[he >> 20 & 15] + l[he >> 16 & 15])), ue
            }, W.prototype.arrayBuffer = function() {
                this.finalize();
                var j = this.blockCount,
                    V = this.s,
                    Y = this.outputBlocks,
                    X = this.extraBytes,
                    ne = 0,
                    ae = 0,
                    ue = this.outputBits >> 3,
                    he;
                X ? he = new ArrayBuffer(Y + 1 << 2) : he = new ArrayBuffer(ue);
                for (var fe = new Uint32Array(he); ae < Y;) {
                    for (ne = 0; ne < j && ae < Y; ++ne, ++ae) fe[ae] = V[ne];
                    ae % j === 0 && H(V)
                }
                return X && (fe[ne] = V[ne], he = he.slice(0, ue)), he
            }, W.prototype.buffer = W.prototype.arrayBuffer, W.prototype.digest = W.prototype.array = function() {
                this.finalize();
                for (var j = this.blockCount, V = this.s, Y = this.outputBlocks, X = this.extraBytes, ne = 0, ae = 0, ue = [], he, fe; ae < Y;) {
                    for (ne = 0; ne < j && ae < Y; ++ne, ++ae) he = ae << 2, fe = V[ne], ue[he] = fe & 255, ue[he + 1] = fe >> 8 & 255, ue[he + 2] = fe >> 16 & 255, ue[he + 3] = fe >> 24 & 255;
                    ae % j === 0 && H(V)
                }
                return X && (he = ae << 2, fe = V[ne], ue[he] = fe & 255, X > 1 && (ue[he + 1] = fe >> 8 & 255), X > 2 && (ue[he + 2] = fe >> 16 & 255)), ue
            };

            function K(j, V, Y) {
                W.call(this, j, V, Y)
            }
            K.prototype = new W, K.prototype.finalize = function() {
                return this.encode(this.outputBits, !0), W.prototype.finalize.call(this)
            };
            var H = function(j) {
                var V, Y, X, ne, ae, ue, he, fe, de, ye, Be, ce, Ie, xe, ie, Ee, ft, Ae, Le, Te, Ue, De, We, dt, He, ut, Ye, we, vt, Lt, _t, tr, dr, Yt, Ot, mt, ur, Vr, pt, Un, ei, ti, Fn, L, B, Q, G, re, se, me, ve, Ze, kt, Re, ct, it, lt, Se, yt, It, Mt, jt, sr;
                for (X = 0; X < 48; X += 2) ne = j[0] ^ j[10] ^ j[20] ^ j[30] ^ j[40], ae = j[1] ^ j[11] ^ j[21] ^ j[31] ^ j[41], ue = j[2] ^ j[12] ^ j[22] ^ j[32] ^ j[42], he = j[3] ^ j[13] ^ j[23] ^ j[33] ^ j[43], fe = j[4] ^ j[14] ^ j[24] ^ j[34] ^ j[44], de = j[5] ^ j[15] ^ j[25] ^ j[35] ^ j[45], ye = j[6] ^ j[16] ^ j[26] ^ j[36] ^ j[46], Be = j[7] ^ j[17] ^ j[27] ^ j[37] ^ j[47], ce = j[8] ^ j[18] ^ j[28] ^ j[38] ^ j[48], Ie = j[9] ^ j[19] ^ j[29] ^ j[39] ^ j[49], V = ce ^ (ue << 1 | he >>> 31), Y = Ie ^ (he << 1 | ue >>> 31), j[0] ^= V, j[1] ^= Y, j[10] ^= V, j[11] ^= Y, j[20] ^= V, j[21] ^= Y, j[30] ^= V, j[31] ^= Y, j[40] ^= V, j[41] ^= Y, V = ne ^ (fe << 1 | de >>> 31), Y = ae ^ (de << 1 | fe >>> 31), j[2] ^= V, j[3] ^= Y, j[12] ^= V, j[13] ^= Y, j[22] ^= V, j[23] ^= Y, j[32] ^= V, j[33] ^= Y, j[42] ^= V, j[43] ^= Y, V = ue ^ (ye << 1 | Be >>> 31), Y = he ^ (Be << 1 | ye >>> 31), j[4] ^= V, j[5] ^= Y, j[14] ^= V, j[15] ^= Y, j[24] ^= V, j[25] ^= Y, j[34] ^= V, j[35] ^= Y, j[44] ^= V, j[45] ^= Y, V = fe ^ (ce << 1 | Ie >>> 31), Y = de ^ (Ie << 1 | ce >>> 31), j[6] ^= V, j[7] ^= Y, j[16] ^= V, j[17] ^= Y, j[26] ^= V, j[27] ^= Y, j[36] ^= V, j[37] ^= Y, j[46] ^= V, j[47] ^= Y, V = ye ^ (ne << 1 | ae >>> 31), Y = Be ^ (ae << 1 | ne >>> 31), j[8] ^= V, j[9] ^= Y, j[18] ^= V, j[19] ^= Y, j[28] ^= V, j[29] ^= Y, j[38] ^= V, j[39] ^= Y, j[48] ^= V, j[49] ^= Y, xe = j[0], ie = j[1], Q = j[11] << 4 | j[10] >>> 28, G = j[10] << 4 | j[11] >>> 28, we = j[20] << 3 | j[21] >>> 29, vt = j[21] << 3 | j[20] >>> 29, It = j[31] << 9 | j[30] >>> 23, Mt = j[30] << 9 | j[31] >>> 23, ti = j[40] << 18 | j[41] >>> 14, Fn = j[41] << 18 | j[40] >>> 14, Yt = j[2] << 1 | j[3] >>> 31, Ot = j[3] << 1 | j[2] >>> 31, Ee = j[13] << 12 | j[12] >>> 20, ft = j[12] << 12 | j[13] >>> 20, re = j[22] << 10 | j[23] >>> 22, se = j[23] << 10 | j[22] >>> 22, Lt = j[33] << 13 | j[32] >>> 19, _t = j[32] << 13 | j[33] >>> 19, jt = j[42] << 2 | j[43] >>> 30, sr = j[43] << 2 | j[42] >>> 30, Re = j[5] << 30 | j[4] >>> 2, ct = j[4] << 30 | j[5] >>> 2, mt = j[14] << 6 | j[15] >>> 26, ur = j[15] << 6 | j[14] >>> 26, Ae = j[25] << 11 | j[24] >>> 21, Le = j[24] << 11 | j[25] >>> 21, me = j[34] << 15 | j[35] >>> 17, ve = j[35] << 15 | j[34] >>> 17, tr = j[45] << 29 | j[44] >>> 3, dr = j[44] << 29 | j[45] >>> 3, dt = j[6] << 28 | j[7] >>> 4, He = j[7] << 28 | j[6] >>> 4, it = j[17] << 23 | j[16] >>> 9, lt = j[16] << 23 | j[17] >>> 9, Vr = j[26] << 25 | j[27] >>> 7, pt = j[27] << 25 | j[26] >>> 7, Te = j[36] << 21 | j[37] >>> 11, Ue = j[37] << 21 | j[36] >>> 11, Ze = j[47] << 24 | j[46] >>> 8, kt = j[46] << 24 | j[47] >>> 8, L = j[8] << 27 | j[9] >>> 5, B = j[9] << 27 | j[8] >>> 5, ut = j[18] << 20 | j[19] >>> 12, Ye = j[19] << 20 | j[18] >>> 12, Se = j[29] << 7 | j[28] >>> 25, yt = j[28] << 7 | j[29] >>> 25, Un = j[38] << 8 | j[39] >>> 24, ei = j[39] << 8 | j[38] >>> 24, De = j[48] << 14 | j[49] >>> 18, We = j[49] << 14 | j[48] >>> 18, j[0] = xe ^ ~Ee & Ae, j[1] = ie ^ ~ft & Le, j[10] = dt ^ ~ut & we, j[11] = He ^ ~Ye & vt, j[20] = Yt ^ ~mt & Vr, j[21] = Ot ^ ~ur & pt, j[30] = L ^ ~Q & re, j[31] = B ^ ~G & se, j[40] = Re ^ ~it & Se, j[41] = ct ^ ~lt & yt, j[2] = Ee ^ ~Ae & Te, j[3] = ft ^ ~Le & Ue, j[12] = ut ^ ~we & Lt, j[13] = Ye ^ ~vt & _t, j[22] = mt ^ ~Vr & Un, j[23] = ur ^ ~pt & ei, j[32] = Q ^ ~re & me, j[33] = G ^ ~se & ve, j[42] = it ^ ~Se & It, j[43] = lt ^ ~yt & Mt, j[4] = Ae ^ ~Te & De, j[5] = Le ^ ~Ue & We, j[14] = we ^ ~Lt & tr, j[15] = vt ^ ~_t & dr, j[24] = Vr ^ ~Un & ti, j[25] = pt ^ ~ei & Fn, j[34] = re ^ ~me & Ze, j[35] = se ^ ~ve & kt, j[44] = Se ^ ~It & jt, j[45] = yt ^ ~Mt & sr, j[6] = Te ^ ~De & xe, j[7] = Ue ^ ~We & ie, j[16] = Lt ^ ~tr & dt, j[17] = _t ^ ~dr & He, j[26] = Un ^ ~ti & Yt, j[27] = ei ^ ~Fn & Ot, j[36] = me ^ ~Ze & L, j[37] = ve ^ ~kt & B, j[46] = It ^ ~jt & Re, j[47] = Mt ^ ~sr & ct, j[8] = De ^ ~xe & Ee, j[9] = We ^ ~ie & ft, j[18] = tr ^ ~dt & ut, j[19] = dr ^ ~He & Ye, j[28] = ti ^ ~Yt & mt, j[29] = Fn ^ ~Ot & ur, j[38] = Ze ^ ~L & Q, j[39] = kt ^ ~B & G, j[48] = jt ^ ~Re & it, j[49] = sr ^ ~ct & lt, j[0] ^= m[X], j[1] ^= m[X + 1]
            };
            if (o) t.exports = D;
            else
                for (O = 0; O < S.length; ++O) i[S[O]] = D[S[O]]
        })()
    }(Ww)), Ww.exports
}
var OX = NX();
const jX = Oa(OX);

function Tn(t) {
    return "0x" + jX.keccak_256(Pt(t))
}
const RX = "strings/5.8.0",
    lN = new pe(RX);
var _p;
(function(t) {
    t.current = "", t.NFC = "NFC", t.NFD = "NFD", t.NFKC = "NFKC", t.NFKD = "NFKD"
})(_p || (_p = {}));
var Qi;
(function(t) {
    t.UNEXPECTED_CONTINUE = "unexpected continuation byte", t.BAD_PREFIX = "bad codepoint prefix", t.OVERRUN = "string overrun", t.MISSING_CONTINUE = "missing continuation byte", t.OUT_OF_RANGE = "out of UTF-8 range", t.UTF16_SURROGATE = "UTF-16 surrogate", t.OVERLONG = "overlong representation"
})(Qi || (Qi = {}));

function MX(t, e, r, n, i) {
    return lN.throwArgumentError(`invalid codepoint at offset ${e}; ${t}`, "bytes", r)
}

function dN(t, e, r, n, i) {
    if (t === Qi.BAD_PREFIX || t === Qi.UNEXPECTED_CONTINUE) {
        let s = 0;
        for (let a = e + 1; a < r.length && r[a] >> 6 === 2; a++) s++;
        return s
    }
    return t === Qi.OVERRUN ? r.length - e - 1 : 0
}

function DX(t, e, r, n, i) {
    return t === Qi.OVERLONG ? (n.push(i), 0) : (n.push(65533), dN(t, e, r))
}
const LX = Object.freeze({
    error: MX,
    ignore: dN,
    replace: DX
});

function uN(t, e) {
    e == null && (e = LX.error), t = Pt(t);
    const r = [];
    let n = 0;
    for (; n < t.length;) {
        const i = t[n++];
        if (i >> 7 === 0) {
            r.push(i);
            continue
        }
        let s = null,
            a = null;
        if ((i & 224) === 192) s = 1, a = 127;
        else if ((i & 240) === 224) s = 2, a = 2047;
        else if ((i & 248) === 240) s = 3, a = 65535;
        else {
            (i & 192) === 128 ? n += e(Qi.UNEXPECTED_CONTINUE, n - 1, t, r) : n += e(Qi.BAD_PREFIX, n - 1, t, r);
            continue
        }
        if (n - 1 + s >= t.length) {
            n += e(Qi.OVERRUN, n - 1, t, r);
            continue
        }
        let o = i & (1 << 8 - s - 1) - 1;
        for (let c = 0; c < s; c++) {
            let l = t[n];
            if ((l & 192) != 128) {
                n += e(Qi.MISSING_CONTINUE, n, t, r), o = null;
                break
            }
            o = o << 6 | l & 63, n++
        }
        if (o !== null) {
            if (o > 1114111) {
                n += e(Qi.OUT_OF_RANGE, n - 1 - s, t, r, o);
                continue
            }
            if (o >= 55296 && o <= 57343) {
                n += e(Qi.UTF16_SURROGATE, n - 1 - s, t, r, o);
                continue
            }
            if (o <= a) {
                n += e(Qi.OVERLONG, n - 1 - s, t, r, o);
                continue
            }
            r.push(o)
        }
    }
    return r
}

function ic(t, e = _p.current) {
    e != _p.current && (lN.checkNormalize(), t = t.normalize(e));
    let r = [];
    for (let n = 0; n < t.length; n++) {
        const i = t.charCodeAt(n);
        if (i < 128) r.push(i);
        else if (i < 2048) r.push(i >> 6 | 192), r.push(i & 63 | 128);
        else if ((i & 64512) == 55296) {
            n++;
            const s = t.charCodeAt(n);
            if (n >= t.length || (s & 64512) !== 56320) throw new Error("invalid utf-8 string");
            const a = 65536 + ((i & 1023) << 10) + (s & 1023);
            r.push(a >> 18 | 240), r.push(a >> 12 & 63 | 128), r.push(a >> 6 & 63 | 128), r.push(a & 63 | 128)
        } else r.push(i >> 12 | 224), r.push(i >> 6 & 63 | 128), r.push(i & 63 | 128)
    }
    return Pt(r)
}

function UX(t) {
    return t.map(e => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("")
}

function Y1(t, e) {
    return UX(uN(t, e))
}

function FX(t, e = _p.current) {
    return uN(ic(t, e))
}

function hN(t) {
    return Tn(ic(t))
}
const fN = "hash/5.8.0";

function pN(t, e) {
    e == null && (e = 1);
    const r = [],
        n = r.forEach,
        i = function(s, a) {
            n.call(s, function(o) {
                a > 0 && Array.isArray(o) ? i(o, a - 1) : r.push(o)
            })
        };
    return i(t, e), r
}

function BX(t) {
    const e = {};
    for (let r = 0; r < t.length; r++) {
        const n = t[r];
        e[n[0]] = n[1]
    }
    return e
}

function WX(t) {
    let e = 0;

    function r() {
        return t[e++] << 8 | t[e++]
    }
    let n = r(),
        i = 1,
        s = [0, 1];
    for (let b = 1; b < n; b++) s.push(i += r());
    let a = r(),
        o = e;
    e += a;
    let c = 0,
        l = 0;

    function u() {
        return c == 0 && (l = l << 8 | t[e++], c = 8), l >> --c & 1
    }
    const h = 31,
        f = Math.pow(2, h),
        p = f >>> 1,
        g = p >> 1,
        m = f - 1;
    let y = 0;
    for (let b = 0; b < h; b++) y = y << 1 | u();
    let w = [],
        x = 0,
        E = f;
    for (;;) {
        let b = Math.floor(((y - x + 1) * i - 1) / E),
            A = 0,
            I = n;
        for (; I - A > 1;) {
            let $ = A + I >>> 1;
            b < s[$] ? I = $ : A = $
        }
        if (A == 0) break;
        w.push(A);
        let T = x + Math.floor(E * s[A] / i),
            C = x + Math.floor(E * s[A + 1] / i) - 1;
        for (;
            ((T ^ C) & p) == 0;) y = y << 1 & m | u(), T = T << 1 & m, C = C << 1 & m | 1;
        for (; T & ~C & g;) y = y & p | y << 1 & m >>> 1 | u(), T = T << 1 ^ p, C = (C ^ p) << 1 | p | 1;
        x = T, E = 1 + C - T
    }
    let _ = n - 4;
    return w.map(b => {
        switch (b - _) {
            case 3:
                return _ + 65792 + (t[o++] << 16 | t[o++] << 8 | t[o++]);
            case 2:
                return _ + 256 + (t[o++] << 8 | t[o++]);
            case 1:
                return _ + t[o++];
            default:
                return b - 1
        }
    })
}

function zX(t) {
    let e = 0;
    return () => t[e++]
}

function qX(t) {
    return zX(WX(t))
}

function HX(t) {
    return t & 1 ? ~t >> 1 : t >> 1
}

function VX(t, e) {
    let r = Array(t);
    for (let n = 0; n < t; n++) r[n] = 1 + e();
    return r
}

function I7(t, e) {
    let r = Array(t);
    for (let n = 0, i = -1; n < t; n++) r[n] = i += 1 + e();
    return r
}

function GX(t, e) {
    let r = Array(t);
    for (let n = 0, i = 0; n < t; n++) r[n] = i += HX(e());
    return r
}

function Cm(t, e) {
    let r = I7(t(), t),
        n = t(),
        i = I7(n, t),
        s = VX(n, t);
    for (let a = 0; a < n; a++)
        for (let o = 0; o < s[a]; o++) r.push(i[a] + o);
    return e ? r.map(a => e[a]) : r
}

function KX(t) {
    let e = [];
    for (;;) {
        let r = t();
        if (r == 0) break;
        e.push(ZX(r, t))
    }
    for (;;) {
        let r = t() - 1;
        if (r < 0) break;
        e.push(JX(r, t))
    }
    return BX(pN(e))
}

function YX(t) {
    let e = [];
    for (;;) {
        let r = t();
        if (r == 0) break;
        e.push(r)
    }
    return e
}

function gN(t, e, r) {
    let n = Array(t).fill(void 0).map(() => []);
    for (let i = 0; i < e; i++) GX(t, r).forEach((s, a) => n[a].push(s));
    return n
}

function ZX(t, e) {
    let r = 1 + e(),
        n = e(),
        i = YX(e),
        s = gN(i.length, 1 + t, e);
    return pN(s.map((a, o) => {
        const c = a[0],
            l = a.slice(1);
        return Array(i[o]).fill(void 0).map((u, h) => {
            let f = h * n;
            return [c + h * r, l.map(p => p + f)]
        })
    }))
}

function JX(t, e) {
    let r = 1 + e();
    return gN(r, 1 + t, e).map(i => [i[0], i.slice(1)])
}

function QX(t) {
    let e = Cm(t).sort((n, i) => n - i);
    return r();

    function r() {
        let n = [];
        for (;;) {
            let l = Cm(t, e);
            if (l.length == 0) break;
            n.push({
                set: new Set(l),
                node: r()
            })
        }
        n.sort((l, u) => u.set.size - l.set.size);
        let i = t(),
            s = i % 3;
        i = i / 3 | 0;
        let a = !!(i & 1);
        i >>= 1;
        let o = i == 1,
            c = i == 2;
        return {
            branches: n,
            valid: s,
            fe0f: a,
            save: o,
            check: c
        }
    }
}

function XX() {
    return qX(aN("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="))
}
const Z1 = XX(),
    eee = new Set(Cm(Z1)),
    tee = new Set(Cm(Z1)),
    ree = KX(Z1),
    nee = QX(Z1),
    $7 = 45,
    S7 = 95;

function mN(t) {
    return FX(t)
}

function iee(t) {
    return t.filter(e => e != 65039)
}

function yN(t) {
    for (let e of t.split(".")) {
        let r = mN(e);
        try {
            for (let n = r.lastIndexOf(S7) - 1; n >= 0; n--)
                if (r[n] !== S7) throw new Error("underscore only allowed at start");
            if (r.length >= 4 && r.every(n => n < 128) && r[2] === $7 && r[3] === $7) throw new Error("invalid label extension")
        } catch (n) {
            throw new Error(`Invalid label "${e}": ${n.message}`)
        }
    }
    return t
}

function see(t) {
    return yN(aee(t, iee))
}

function aee(t, e) {
    let r = mN(t).reverse(),
        n = [];
    for (; r.length;) {
        let i = cee(r);
        if (i) {
            n.push(...e(i));
            continue
        }
        let s = r.pop();
        if (eee.has(s)) {
            n.push(s);
            continue
        }
        if (tee.has(s)) continue;
        let a = ree[s];
        if (a) {
            n.push(...a);
            continue
        }
        throw new Error(`Disallowed codepoint: 0x${s.toString(16).toUpperCase()}`)
    }
    return yN(oee(String.fromCodePoint(...n)))
}

function oee(t) {
    return t.normalize("NFC")
}

function cee(t, e) {
    var r;
    let n = nee,
        i, s, a = [],
        o = t.length;
    for (; o;) {
        let c = t[--o];
        if (n = (r = n.branches.find(l => l.set.has(c))) === null || r === void 0 ? void 0 : r.node, !n) break;
        if (n.save) s = c;
        else if (n.check && c === s) break;
        a.push(c), n.fe0f && (a.push(65039), o > 0 && t[o - 1] == 65039 && o--), n.valid && (i = a.slice(), n.valid == 2 && i.splice(1, 1), t.length = o)
    }
    return i
}
const lee = new pe(fN),
    wN = new Uint8Array(32);
wN.fill(0);

function T7(t) {
    if (t.length === 0) throw new Error("invalid ENS name; empty component");
    return t
}

function bN(t) {
    const e = ic(see(t)),
        r = [];
    if (t.length === 0) return r;
    let n = 0;
    for (let i = 0; i < e.length; i++) e[i] === 46 && (r.push(T7(e.slice(n, i))), n = i + 1);
    if (n >= e.length) throw new Error("invalid ENS name; empty component");
    return r.push(T7(e.slice(n))), r
}

function Bg(t) {
    typeof t != "string" && lee.throwArgumentError("invalid ENS name; not a string", "name", t);
    let e = wN;
    const r = bN(t);
    for (; r.length;) e = Tn(Ul([e, Tn(r.pop())]));
    return Tt(e)
}

function dee(t) {
    return Tt(Ul(bN(t).map(e => {
        if (e.length > 63) throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
        const r = new Uint8Array(e.length + 1);
        return r.set(e, 1), r[0] = r.length - 1, r
    }))) + "00"
}
const uee = "rlp/5.8.0",
    Qa = new pe(uee);

function P7(t) {
    const e = [];
    for (; t;) e.unshift(t & 255), t >>= 8;
    return e
}

function N7(t, e, r) {
    let n = 0;
    for (let i = 0; i < r; i++) n = n * 256 + t[e + i];
    return n
}

function vN(t) {
    if (Array.isArray(t)) {
        let n = [];
        if (t.forEach(function(s) {
                n = n.concat(vN(s))
            }), n.length <= 55) return n.unshift(192 + n.length), n;
        const i = P7(n.length);
        return i.unshift(247 + i.length), i.concat(n)
    }
    N6(t) || Qa.throwArgumentError("RLP object must be BytesLike", "object", t);
    const e = Array.prototype.slice.call(Pt(t));
    if (e.length === 1 && e[0] <= 127) return e;
    if (e.length <= 55) return e.unshift(128 + e.length), e;
    const r = P7(e.length);
    return r.unshift(183 + r.length), r.concat(e)
}

function J1(t) {
    return Tt(vN(t))
}

function O7(t, e, r, n) {
    const i = [];
    for (; r < e + 1 + n;) {
        const s = xN(t, r);
        i.push(s.result), r += s.consumed, r > e + 1 + n && Qa.throwError("child data too short", pe.errors.BUFFER_OVERRUN, {})
    }
    return {
        consumed: 1 + n,
        result: i
    }
}

function xN(t, e) {
    if (t.length === 0 && Qa.throwError("data too short", pe.errors.BUFFER_OVERRUN, {}), t[e] >= 248) {
        const r = t[e] - 247;
        e + 1 + r > t.length && Qa.throwError("data short segment too short", pe.errors.BUFFER_OVERRUN, {});
        const n = N7(t, e + 1, r);
        return e + 1 + r + n > t.length && Qa.throwError("data long segment too short", pe.errors.BUFFER_OVERRUN, {}), O7(t, e, e + 1 + r, r + n)
    } else if (t[e] >= 192) {
        const r = t[e] - 192;
        return e + 1 + r > t.length && Qa.throwError("data array too short", pe.errors.BUFFER_OVERRUN, {}), O7(t, e, e + 1, r)
    } else if (t[e] >= 184) {
        const r = t[e] - 183;
        e + 1 + r > t.length && Qa.throwError("data array too short", pe.errors.BUFFER_OVERRUN, {});
        const n = N7(t, e + 1, r);
        e + 1 + r + n > t.length && Qa.throwError("data array too short", pe.errors.BUFFER_OVERRUN, {});
        const i = Tt(t.slice(e + 1 + r, e + 1 + r + n));
        return {
            consumed: 1 + r + n,
            result: i
        }
    } else if (t[e] >= 128) {
        const r = t[e] - 128;
        e + 1 + r > t.length && Qa.throwError("data too short", pe.errors.BUFFER_OVERRUN, {});
        const n = Tt(t.slice(e + 1, e + 1 + r));
        return {
            consumed: 1 + r,
            result: n
        }
    }
    return {
        consumed: 1,
        result: Tt(t[e])
    }
}

function M6(t) {
    const e = Pt(t),
        r = xN(e, 0);
    return r.consumed !== e.length && Qa.throwArgumentError("invalid rlp data", "data", t), r.result
}
const hee = "address/5.8.0",
    Iu = new pe(hee);

function j7(t) {
    pr(t, 20) || Iu.throwArgumentError("invalid address", "address", t), t = t.toLowerCase();
    const e = t.substring(2).split(""),
        r = new Uint8Array(40);
    for (let i = 0; i < 40; i++) r[i] = e[i].charCodeAt(0);
    const n = Pt(Tn(r));
    for (let i = 0; i < 40; i += 2) n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return "0x" + e.join("")
}
const fee = 9007199254740991;

function pee(t) {
    return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10
}
const D6 = {};
for (let t = 0; t < 10; t++) D6[String(t)] = String(t);
for (let t = 0; t < 26; t++) D6[String.fromCharCode(65 + t)] = String(10 + t);
const R7 = Math.floor(pee(fee));

function gee(t) {
    t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
    let e = t.split("").map(n => D6[n]).join("");
    for (; e.length >= R7;) {
        let n = e.substring(0, R7);
        e = parseInt(n, 10) % 97 + e.substring(n.length)
    }
    let r = String(98 - parseInt(e, 10) % 97);
    for (; r.length < 2;) r = "0" + r;
    return r
}

function Ea(t) {
    let e = null;
    if (typeof t != "string" && Iu.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) t.substring(0, 2) !== "0x" && (t = "0x" + t), e = j7(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && Iu.throwArgumentError("bad address checksum", "address", t);
    else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        for (t.substring(2, 4) !== gee(t) && Iu.throwArgumentError("bad icap checksum", "address", t), e = vX(t.substring(4)); e.length < 40;) e = "0" + e;
        e = j7("0x" + e)
    } else Iu.throwArgumentError("invalid address", "address", t);
    return e
}

function mee(t) {
    let e = null;
    try {
        e = Ea(t.from)
    } catch {
        Iu.throwArgumentError("missing from address", "transaction", t)
    }
    const r = eh(Pt(Fe.from(t.nonce).toHexString()));
    return Ea(ii(Tn(J1([e, r])), 12))
}
var yee = function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(a) {
            a(s)
        })
    }
    return new(r || (r = Promise))(function(s, a) {
        function o(u) {
            try {
                l(n.next(u))
            } catch (h) {
                a(h)
            }
        }

        function c(u) {
            try {
                l(n.throw(u))
            } catch (h) {
                a(h)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(o, c)
        }
        l((n = n.apply(t, e || [])).next())
    })
};
const Or = new pe(fN),
    EN = new Uint8Array(32);
EN.fill(0);
const wee = Fe.from(-1),
    _N = Fe.from(0),
    CN = Fe.from(1),
    bee = Fe.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

function vee(t) {
    const e = Pt(t),
        r = e.length % 32;
    return r ? rs([e, EN.slice(r)]) : Tt(e)
}
const xee = Mr(CN.toHexString(), 32),
    Eee = Mr(_N.toHexString(), 32),
    M7 = {
        name: "string",
        version: "string",
        chainId: "uint256",
        verifyingContract: "address",
        salt: "bytes32"
    },
    zw = ["name", "version", "chainId", "verifyingContract", "salt"];

function D7(t) {
    return function(e) {
        return typeof e != "string" && Or.throwArgumentError(`invalid domain value for ${JSON.stringify(t)}`, `domain.${t}`, e), e
    }
}
const _ee = {
    name: D7("name"),
    version: D7("version"),
    chainId: function(t) {
        try {
            return Fe.from(t).toString()
        } catch {}
        return Or.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", t)
    },
    verifyingContract: function(t) {
        try {
            return Ea(t).toLowerCase()
        } catch {}
        return Or.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", t)
    },
    salt: function(t) {
        try {
            const e = Pt(t);
            if (e.length !== 32) throw new Error("bad length");
            return Tt(e)
        } catch {}
        return Or.throwArgumentError('invalid domain value "salt"', "domain.salt", t)
    }
};

function qw(t) {
    {
        const e = t.match(/^(u?)int(\d*)$/);
        if (e) {
            const r = e[1] === "",
                n = parseInt(e[2] || "256");
            (n % 8 !== 0 || n > 256 || e[2] && e[2] !== String(n)) && Or.throwArgumentError("invalid numeric width", "type", t);
            const i = bee.mask(r ? n - 1 : n),
                s = r ? i.add(CN).mul(wee) : _N;
            return function(a) {
                const o = Fe.from(a);
                return (o.lt(s) || o.gt(i)) && Or.throwArgumentError(`value out-of-bounds for ${t}`, "value", a), Mr(o.toTwos(256).toHexString(), 32)
            }
        }
    } {
        const e = t.match(/^bytes(\d+)$/);
        if (e) {
            const r = parseInt(e[1]);
            return (r === 0 || r > 32 || e[1] !== String(r)) && Or.throwArgumentError("invalid bytes width", "type", t),
                function(n) {
                    return Pt(n).length !== r && Or.throwArgumentError(`invalid length for ${t}`, "value", n), vee(n)
                }
        }
    }
    switch (t) {
        case "address":
            return function(e) {
                return Mr(Ea(e), 32)
            };
        case "bool":
            return function(e) {
                return e ? xee : Eee
            };
        case "bytes":
            return function(e) {
                return Tn(e)
            };
        case "string":
            return function(e) {
                return hN(e)
            }
    }
    return null
}

function L7(t, e) {
    return `${t}(${e.map(({name:r,type:n})=>n+" "+r).join(",")})`
}
class Zi {
    constructor(e) {
        zt(this, "types", Object.freeze(xp(e))), zt(this, "_encoderCache", {}), zt(this, "_types", {});
        const r = {},
            n = {},
            i = {};
        Object.keys(e).forEach(o => {
            r[o] = {}, n[o] = [], i[o] = {}
        });
        for (const o in e) {
            const c = {};
            e[o].forEach(l => {
                c[l.name] && Or.throwArgumentError(`duplicate variable name ${JSON.stringify(l.name)} in ${JSON.stringify(o)}`, "types", e), c[l.name] = !0;
                const u = l.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                u === o && Or.throwArgumentError(`circular type reference to ${JSON.stringify(u)}`, "types", e), !qw(u) && (n[u] || Or.throwArgumentError(`unknown type ${JSON.stringify(u)}`, "types", e), n[u].push(o), r[o][u] = !0)
            })
        }
        const s = Object.keys(n).filter(o => n[o].length === 0);
        s.length === 0 ? Or.throwArgumentError("missing primary type", "types", e) : s.length > 1 && Or.throwArgumentError(`ambiguous primary types or unused types: ${s.map(o=>JSON.stringify(o)).join(", ")}`, "types", e), zt(this, "primaryType", s[0]);

        function a(o, c) {
            c[o] && Or.throwArgumentError(`circular type reference to ${JSON.stringify(o)}`, "types", e), c[o] = !0, Object.keys(r[o]).forEach(l => {
                n[l] && (a(l, c), Object.keys(c).forEach(u => {
                    i[u][l] = !0
                }))
            }), delete c[o]
        }
        a(this.primaryType, {});
        for (const o in i) {
            const c = Object.keys(i[o]);
            c.sort(), this._types[o] = L7(o, e[o]) + c.map(l => L7(l, e[l])).join("")
        }
    }
    getEncoder(e) {
        let r = this._encoderCache[e];
        return r || (r = this._encoderCache[e] = this._getEncoder(e)), r
    }
    _getEncoder(e) {
        {
            const i = qw(e);
            if (i) return i
        }
        const r = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (r) {
            const i = r[1],
                s = this.getEncoder(i),
                a = parseInt(r[3]);
            return o => {
                a >= 0 && o.length !== a && Or.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", o);
                let c = o.map(s);
                return this._types[i] && (c = c.map(Tn)), Tn(rs(c))
            }
        }
        const n = this.types[e];
        if (n) {
            const i = hN(this._types[e]);
            return s => {
                const a = n.map(({
                    name: o,
                    type: c
                }) => {
                    const l = this.getEncoder(c)(s[o]);
                    return this._types[c] ? Tn(l) : l
                });
                return a.unshift(i), rs(a)
            }
        }
        return Or.throwArgumentError(`unknown type: ${e}`, "type", e)
    }
    encodeType(e) {
        const r = this._types[e];
        return r || Or.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e), r
    }
    encodeData(e, r) {
        return this.getEncoder(e)(r)
    }
    hashStruct(e, r) {
        return Tn(this.encodeData(e, r))
    }
    encode(e) {
        return this.encodeData(this.primaryType, e)
    }
    hash(e) {
        return this.hashStruct(this.primaryType, e)
    }
    _visit(e, r, n) {
        if (qw(e)) return n(e, r);
        const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (i) {
            const a = i[1],
                o = parseInt(i[3]);
            return o >= 0 && r.length !== o && Or.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", r), r.map(c => this._visit(a, c, n))
        }
        const s = this.types[e];
        return s ? s.reduce((a, {
            name: o,
            type: c
        }) => (a[o] = this._visit(c, r[o], n), a), {}) : Or.throwArgumentError(`unknown type: ${e}`, "type", e)
    }
    visit(e, r) {
        return this._visit(this.primaryType, e, r)
    }
    static from(e) {
        return new Zi(e)
    }
    static getPrimaryType(e) {
        return Zi.from(e).primaryType
    }
    static hashStruct(e, r, n) {
        return Zi.from(r).hashStruct(e, n)
    }
    static hashDomain(e) {
        const r = [];
        for (const n in e) {
            const i = M7[n];
            i || Or.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(n)}`, "domain", e), r.push({
                name: n,
                type: i
            })
        }
        return r.sort((n, i) => zw.indexOf(n.name) - zw.indexOf(i.name)), Zi.hashStruct("EIP712Domain", {
            EIP712Domain: r
        }, e)
    }
    static encode(e, r, n) {
        return rs(["0x1901", Zi.hashDomain(e), Zi.from(r).hash(n)])
    }
    static hash(e, r, n) {
        return Tn(Zi.encode(e, r, n))
    }
    static resolveNames(e, r, n, i) {
        return yee(this, void 0, void 0, function*() {
            e = ji(e);
            const s = {};
            e.verifyingContract && !pr(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x");
            const a = Zi.from(r);
            a.visit(n, (o, c) => (o === "address" && !pr(c, 20) && (s[c] = "0x"), c));
            for (const o in s) s[o] = yield i(o);
            return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), n = a.visit(n, (o, c) => o === "address" && s[c] ? s[c] : c), {
                domain: e,
                value: n
            }
        })
    }
    static getPayload(e, r, n) {
        Zi.hashDomain(e);
        const i = {},
            s = [];
        zw.forEach(c => {
            const l = e[c];
            l != null && (i[c] = _ee[c](l), s.push({
                name: c,
                type: M7[c]
            }))
        });
        const a = Zi.from(r),
            o = ji(r);
        return o.EIP712Domain ? Or.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", r) : o.EIP712Domain = s, a.encode(n), {
            types: o,
            domain: i,
            primaryType: a.primaryType,
            message: a.visit(n, (c, l) => {
                if (c.match(/^bytes(\d*)/)) return Tt(Pt(l));
                if (c.match(/^u?int/)) return Fe.from(l).toString();
                switch (c) {
                    case "address":
                        return l.toLowerCase();
                    case "bool":
                        return !!l;
                    case "string":
                        return typeof l != "string" && Or.throwArgumentError("invalid string", "value", l), l
                }
                return Or.throwArgumentError("unsupported type", "type", c)
            })
        }
    }
}
var Hw = {},
    ar = {},
    Vw, U7;

function a0() {
    if (U7) return Vw;
    U7 = 1, Vw = t;

    function t(e, r) {
        if (!e) throw new Error(r || "Assertion failed")
    }
    return t.equal = function(r, n, i) {
        if (r != n) throw new Error(i || "Assertion failed: " + r + " != " + n)
    }, Vw
}
var Y0 = {
        exports: {}
    },
    F7;

function Cee() {
    return F7 || (F7 = 1, typeof Object.create == "function" ? Y0.exports = function(e, r) {
        r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }))
    } : Y0.exports = function(e, r) {
        if (r) {
            e.super_ = r;
            var n = function() {};
            n.prototype = r.prototype, e.prototype = new n, e.prototype.constructor = e
        }
    }), Y0.exports
}
var B7;

function mo() {
    if (B7) return ar;
    B7 = 1;
    var t = a0(),
        e = Cee();
    ar.inherits = e;

    function r(N, R) {
        return (N.charCodeAt(R) & 64512) !== 55296 || R < 0 || R + 1 >= N.length ? !1 : (N.charCodeAt(R + 1) & 64512) === 56320
    }

    function n(N, R) {
        if (Array.isArray(N)) return N.slice();
        if (!N) return [];
        var D = [];
        if (typeof N == "string")
            if (R) {
                if (R === "hex")
                    for (N = N.replace(/[^a-z0-9]+/ig, ""), N.length % 2 !== 0 && (N = "0" + N), O = 0; O < N.length; O += 2) D.push(parseInt(N[O] + N[O + 1], 16))
            } else
                for (var S = 0, O = 0; O < N.length; O++) {
                    var M = N.charCodeAt(O);
                    M < 128 ? D[S++] = M : M < 2048 ? (D[S++] = M >> 6 | 192, D[S++] = M & 63 | 128) : r(N, O) ? (M = 65536 + ((M & 1023) << 10) + (N.charCodeAt(++O) & 1023), D[S++] = M >> 18 | 240, D[S++] = M >> 12 & 63 | 128, D[S++] = M >> 6 & 63 | 128, D[S++] = M & 63 | 128) : (D[S++] = M >> 12 | 224, D[S++] = M >> 6 & 63 | 128, D[S++] = M & 63 | 128)
                } else
                    for (O = 0; O < N.length; O++) D[O] = N[O] | 0;
        return D
    }
    ar.toArray = n;

    function i(N) {
        for (var R = "", D = 0; D < N.length; D++) R += o(N[D].toString(16));
        return R
    }
    ar.toHex = i;

    function s(N) {
        var R = N >>> 24 | N >>> 8 & 65280 | N << 8 & 16711680 | (N & 255) << 24;
        return R >>> 0
    }
    ar.htonl = s;

    function a(N, R) {
        for (var D = "", S = 0; S < N.length; S++) {
            var O = N[S];
            R === "little" && (O = s(O)), D += c(O.toString(16))
        }
        return D
    }
    ar.toHex32 = a;

    function o(N) {
        return N.length === 1 ? "0" + N : N
    }
    ar.zero2 = o;

    function c(N) {
        return N.length === 7 ? "0" + N : N.length === 6 ? "00" + N : N.length === 5 ? "000" + N : N.length === 4 ? "0000" + N : N.length === 3 ? "00000" + N : N.length === 2 ? "000000" + N : N.length === 1 ? "0000000" + N : N
    }
    ar.zero8 = c;

    function l(N, R, D, S) {
        var O = D - R;
        t(O % 4 === 0);
        for (var M = new Array(O / 4), U = 0, k = R; U < M.length; U++, k += 4) {
            var F;
            S === "big" ? F = N[k] << 24 | N[k + 1] << 16 | N[k + 2] << 8 | N[k + 3] : F = N[k + 3] << 24 | N[k + 2] << 16 | N[k + 1] << 8 | N[k], M[U] = F >>> 0
        }
        return M
    }
    ar.join32 = l;

    function u(N, R) {
        for (var D = new Array(N.length * 4), S = 0, O = 0; S < N.length; S++, O += 4) {
            var M = N[S];
            R === "big" ? (D[O] = M >>> 24, D[O + 1] = M >>> 16 & 255, D[O + 2] = M >>> 8 & 255, D[O + 3] = M & 255) : (D[O + 3] = M >>> 24, D[O + 2] = M >>> 16 & 255, D[O + 1] = M >>> 8 & 255, D[O] = M & 255)
        }
        return D
    }
    ar.split32 = u;

    function h(N, R) {
        return N >>> R | N << 32 - R
    }
    ar.rotr32 = h;

    function f(N, R) {
        return N << R | N >>> 32 - R
    }
    ar.rotl32 = f;

    function p(N, R) {
        return N + R >>> 0
    }
    ar.sum32 = p;

    function g(N, R, D) {
        return N + R + D >>> 0
    }
    ar.sum32_3 = g;

    function m(N, R, D, S) {
        return N + R + D + S >>> 0
    }
    ar.sum32_4 = m;

    function y(N, R, D, S, O) {
        return N + R + D + S + O >>> 0
    }
    ar.sum32_5 = y;

    function w(N, R, D, S) {
        var O = N[R],
            M = N[R + 1],
            U = S + M >>> 0,
            k = (U < S ? 1 : 0) + D + O;
        N[R] = k >>> 0, N[R + 1] = U
    }
    ar.sum64 = w;

    function x(N, R, D, S) {
        var O = R + S >>> 0,
            M = (O < R ? 1 : 0) + N + D;
        return M >>> 0
    }
    ar.sum64_hi = x;

    function E(N, R, D, S) {
        var O = R + S;
        return O >>> 0
    }
    ar.sum64_lo = E;

    function _(N, R, D, S, O, M, U, k) {
        var F = 0,
            q = R;
        q = q + S >>> 0, F += q < R ? 1 : 0, q = q + M >>> 0, F += q < M ? 1 : 0, q = q + k >>> 0, F += q < k ? 1 : 0;
        var W = N + D + O + U + F;
        return W >>> 0
    }
    ar.sum64_4_hi = _;

    function b(N, R, D, S, O, M, U, k) {
        var F = R + S + M + k;
        return F >>> 0
    }
    ar.sum64_4_lo = b;

    function A(N, R, D, S, O, M, U, k, F, q) {
        var W = 0,
            K = R;
        K = K + S >>> 0, W += K < R ? 1 : 0, K = K + M >>> 0, W += K < M ? 1 : 0, K = K + k >>> 0, W += K < k ? 1 : 0, K = K + q >>> 0, W += K < q ? 1 : 0;
        var H = N + D + O + U + F + W;
        return H >>> 0
    }
    ar.sum64_5_hi = A;

    function I(N, R, D, S, O, M, U, k, F, q) {
        var W = R + S + M + k + q;
        return W >>> 0
    }
    ar.sum64_5_lo = I;

    function T(N, R, D) {
        var S = R << 32 - D | N >>> D;
        return S >>> 0
    }
    ar.rotr64_hi = T;

    function C(N, R, D) {
        var S = N << 32 - D | R >>> D;
        return S >>> 0
    }
    ar.rotr64_lo = C;

    function $(N, R, D) {
        return N >>> D
    }
    ar.shr64_hi = $;

    function P(N, R, D) {
        var S = N << 32 - D | R >>> D;
        return S >>> 0
    }
    return ar.shr64_lo = P, ar
}
var Gw = {},
    W7;

function o0() {
    if (W7) return Gw;
    W7 = 1;
    var t = mo(),
        e = a0();

    function r() {
        this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
    }
    return Gw.BlockHash = r, r.prototype.update = function(i, s) {
        if (i = t.toArray(i, s), this.pending ? this.pending = this.pending.concat(i) : this.pending = i, this.pendingTotal += i.length, this.pending.length >= this._delta8) {
            i = this.pending;
            var a = i.length % this._delta8;
            this.pending = i.slice(i.length - a, i.length), this.pending.length === 0 && (this.pending = null), i = t.join32(i, 0, i.length - a, this.endian);
            for (var o = 0; o < i.length; o += this._delta32) this._update(i, o, o + this._delta32)
        }
        return this
    }, r.prototype.digest = function(i) {
        return this.update(this._pad()), e(this.pending === null), this._digest(i)
    }, r.prototype._pad = function() {
        var i = this.pendingTotal,
            s = this._delta8,
            a = s - (i + this.padLength) % s,
            o = new Array(a + this.padLength);
        o[0] = 128;
        for (var c = 1; c < a; c++) o[c] = 0;
        if (i <<= 3, this.endian === "big") {
            for (var l = 8; l < this.padLength; l++) o[c++] = 0;
            o[c++] = 0, o[c++] = 0, o[c++] = 0, o[c++] = 0, o[c++] = i >>> 24 & 255, o[c++] = i >>> 16 & 255, o[c++] = i >>> 8 & 255, o[c++] = i & 255
        } else
            for (o[c++] = i & 255, o[c++] = i >>> 8 & 255, o[c++] = i >>> 16 & 255, o[c++] = i >>> 24 & 255, o[c++] = 0, o[c++] = 0, o[c++] = 0, o[c++] = 0, l = 8; l < this.padLength; l++) o[c++] = 0;
        return o
    }, Gw
}
var bl = {},
    Da = {},
    z7;

function AN() {
    if (z7) return Da;
    z7 = 1;
    var t = mo(),
        e = t.rotr32;

    function r(u, h, f, p) {
        if (u === 0) return n(h, f, p);
        if (u === 1 || u === 3) return s(h, f, p);
        if (u === 2) return i(h, f, p)
    }
    Da.ft_1 = r;

    function n(u, h, f) {
        return u & h ^ ~u & f
    }
    Da.ch32 = n;

    function i(u, h, f) {
        return u & h ^ u & f ^ h & f
    }
    Da.maj32 = i;

    function s(u, h, f) {
        return u ^ h ^ f
    }
    Da.p32 = s;

    function a(u) {
        return e(u, 2) ^ e(u, 13) ^ e(u, 22)
    }
    Da.s0_256 = a;

    function o(u) {
        return e(u, 6) ^ e(u, 11) ^ e(u, 25)
    }
    Da.s1_256 = o;

    function c(u) {
        return e(u, 7) ^ e(u, 18) ^ u >>> 3
    }
    Da.g0_256 = c;

    function l(u) {
        return e(u, 17) ^ e(u, 19) ^ u >>> 10
    }
    return Da.g1_256 = l, Da
}
var Kw, q7;

function Aee() {
    if (q7) return Kw;
    q7 = 1;
    var t = mo(),
        e = o0(),
        r = AN(),
        n = t.rotl32,
        i = t.sum32,
        s = t.sum32_5,
        a = r.ft_1,
        o = e.BlockHash,
        c = [1518500249, 1859775393, 2400959708, 3395469782];

    function l() {
        if (!(this instanceof l)) return new l;
        o.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
    }
    return t.inherits(l, o), Kw = l, l.blockSize = 512, l.outSize = 160, l.hmacStrength = 80, l.padLength = 64, l.prototype._update = function(h, f) {
        for (var p = this.W, g = 0; g < 16; g++) p[g] = h[f + g];
        for (; g < p.length; g++) p[g] = n(p[g - 3] ^ p[g - 8] ^ p[g - 14] ^ p[g - 16], 1);
        var m = this.h[0],
            y = this.h[1],
            w = this.h[2],
            x = this.h[3],
            E = this.h[4];
        for (g = 0; g < p.length; g++) {
            var _ = ~~(g / 20),
                b = s(n(m, 5), a(_, y, w, x), E, p[g], c[_]);
            E = x, x = w, w = n(y, 30), y = m, m = b
        }
        this.h[0] = i(this.h[0], m), this.h[1] = i(this.h[1], y), this.h[2] = i(this.h[2], w), this.h[3] = i(this.h[3], x), this.h[4] = i(this.h[4], E)
    }, l.prototype._digest = function(h) {
        return h === "hex" ? t.toHex32(this.h, "big") : t.split32(this.h, "big")
    }, Kw
}
var Yw, H7;

function kN() {
    if (H7) return Yw;
    H7 = 1;
    var t = mo(),
        e = o0(),
        r = AN(),
        n = a0(),
        i = t.sum32,
        s = t.sum32_4,
        a = t.sum32_5,
        o = r.ch32,
        c = r.maj32,
        l = r.s0_256,
        u = r.s1_256,
        h = r.g0_256,
        f = r.g1_256,
        p = e.BlockHash,
        g = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

    function m() {
        if (!(this instanceof m)) return new m;
        p.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = g, this.W = new Array(64)
    }
    return t.inherits(m, p), Yw = m, m.blockSize = 512, m.outSize = 256, m.hmacStrength = 192, m.padLength = 64, m.prototype._update = function(w, x) {
        for (var E = this.W, _ = 0; _ < 16; _++) E[_] = w[x + _];
        for (; _ < E.length; _++) E[_] = s(f(E[_ - 2]), E[_ - 7], h(E[_ - 15]), E[_ - 16]);
        var b = this.h[0],
            A = this.h[1],
            I = this.h[2],
            T = this.h[3],
            C = this.h[4],
            $ = this.h[5],
            P = this.h[6],
            N = this.h[7];
        for (n(this.k.length === E.length), _ = 0; _ < E.length; _++) {
            var R = a(N, u(C), o(C, $, P), this.k[_], E[_]),
                D = i(l(b), c(b, A, I));
            N = P, P = $, $ = C, C = i(T, R), T = I, I = A, A = b, b = i(R, D)
        }
        this.h[0] = i(this.h[0], b), this.h[1] = i(this.h[1], A), this.h[2] = i(this.h[2], I), this.h[3] = i(this.h[3], T), this.h[4] = i(this.h[4], C), this.h[5] = i(this.h[5], $), this.h[6] = i(this.h[6], P), this.h[7] = i(this.h[7], N)
    }, m.prototype._digest = function(w) {
        return w === "hex" ? t.toHex32(this.h, "big") : t.split32(this.h, "big")
    }, Yw
}
var Zw, V7;

function kee() {
    if (V7) return Zw;
    V7 = 1;
    var t = mo(),
        e = kN();

    function r() {
        if (!(this instanceof r)) return new r;
        e.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
    }
    return t.inherits(r, e), Zw = r, r.blockSize = 512, r.outSize = 224, r.hmacStrength = 192, r.padLength = 64, r.prototype._digest = function(i) {
        return i === "hex" ? t.toHex32(this.h.slice(0, 7), "big") : t.split32(this.h.slice(0, 7), "big")
    }, Zw
}
var Jw, G7;

function IN() {
    if (G7) return Jw;
    G7 = 1;
    var t = mo(),
        e = o0(),
        r = a0(),
        n = t.rotr64_hi,
        i = t.rotr64_lo,
        s = t.shr64_hi,
        a = t.shr64_lo,
        o = t.sum64,
        c = t.sum64_hi,
        l = t.sum64_lo,
        u = t.sum64_4_hi,
        h = t.sum64_4_lo,
        f = t.sum64_5_hi,
        p = t.sum64_5_lo,
        g = e.BlockHash,
        m = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

    function y() {
        if (!(this instanceof y)) return new y;
        g.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = m, this.W = new Array(160)
    }
    t.inherits(y, g), Jw = y, y.blockSize = 1024, y.outSize = 512, y.hmacStrength = 192, y.padLength = 128, y.prototype._prepareBlock = function(D, S) {
        for (var O = this.W, M = 0; M < 32; M++) O[M] = D[S + M];
        for (; M < O.length; M += 2) {
            var U = P(O[M - 4], O[M - 3]),
                k = N(O[M - 4], O[M - 3]),
                F = O[M - 14],
                q = O[M - 13],
                W = C(O[M - 30], O[M - 29]),
                K = $(O[M - 30], O[M - 29]),
                H = O[M - 32],
                j = O[M - 31];
            O[M] = u(U, k, F, q, W, K, H, j), O[M + 1] = h(U, k, F, q, W, K, H, j)
        }
    }, y.prototype._update = function(D, S) {
        this._prepareBlock(D, S);
        var O = this.W,
            M = this.h[0],
            U = this.h[1],
            k = this.h[2],
            F = this.h[3],
            q = this.h[4],
            W = this.h[5],
            K = this.h[6],
            H = this.h[7],
            j = this.h[8],
            V = this.h[9],
            Y = this.h[10],
            X = this.h[11],
            ne = this.h[12],
            ae = this.h[13],
            ue = this.h[14],
            he = this.h[15];
        r(this.k.length === O.length);
        for (var fe = 0; fe < O.length; fe += 2) {
            var de = ue,
                ye = he,
                Be = I(j, V),
                ce = T(j, V),
                Ie = w(j, V, Y, X, ne),
                xe = x(j, V, Y, X, ne, ae),
                ie = this.k[fe],
                Ee = this.k[fe + 1],
                ft = O[fe],
                Ae = O[fe + 1],
                Le = f(de, ye, Be, ce, Ie, xe, ie, Ee, ft, Ae),
                Te = p(de, ye, Be, ce, Ie, xe, ie, Ee, ft, Ae);
            de = b(M, U), ye = A(M, U), Be = E(M, U, k, F, q), ce = _(M, U, k, F, q, W);
            var Ue = c(de, ye, Be, ce),
                De = l(de, ye, Be, ce);
            ue = ne, he = ae, ne = Y, ae = X, Y = j, X = V, j = c(K, H, Le, Te), V = l(H, H, Le, Te), K = q, H = W, q = k, W = F, k = M, F = U, M = c(Le, Te, Ue, De), U = l(Le, Te, Ue, De)
        }
        o(this.h, 0, M, U), o(this.h, 2, k, F), o(this.h, 4, q, W), o(this.h, 6, K, H), o(this.h, 8, j, V), o(this.h, 10, Y, X), o(this.h, 12, ne, ae), o(this.h, 14, ue, he)
    }, y.prototype._digest = function(D) {
        return D === "hex" ? t.toHex32(this.h, "big") : t.split32(this.h, "big")
    };

    function w(R, D, S, O, M) {
        var U = R & S ^ ~R & M;
        return U < 0 && (U += 4294967296), U
    }

    function x(R, D, S, O, M, U) {
        var k = D & O ^ ~D & U;
        return k < 0 && (k += 4294967296), k
    }

    function E(R, D, S, O, M) {
        var U = R & S ^ R & M ^ S & M;
        return U < 0 && (U += 4294967296), U
    }

    function _(R, D, S, O, M, U) {
        var k = D & O ^ D & U ^ O & U;
        return k < 0 && (k += 4294967296), k
    }

    function b(R, D) {
        var S = n(R, D, 28),
            O = n(D, R, 2),
            M = n(D, R, 7),
            U = S ^ O ^ M;
        return U < 0 && (U += 4294967296), U
    }

    function A(R, D) {
        var S = i(R, D, 28),
            O = i(D, R, 2),
            M = i(D, R, 7),
            U = S ^ O ^ M;
        return U < 0 && (U += 4294967296), U
    }

    function I(R, D) {
        var S = n(R, D, 14),
            O = n(R, D, 18),
            M = n(D, R, 9),
            U = S ^ O ^ M;
        return U < 0 && (U += 4294967296), U
    }

    function T(R, D) {
        var S = i(R, D, 14),
            O = i(R, D, 18),
            M = i(D, R, 9),
            U = S ^ O ^ M;
        return U < 0 && (U += 4294967296), U
    }

    function C(R, D) {
        var S = n(R, D, 1),
            O = n(R, D, 8),
            M = s(R, D, 7),
            U = S ^ O ^ M;
        return U < 0 && (U += 4294967296), U
    }

    function $(R, D) {
        var S = i(R, D, 1),
            O = i(R, D, 8),
            M = a(R, D, 7),
            U = S ^ O ^ M;
        return U < 0 && (U += 4294967296), U
    }

    function P(R, D) {
        var S = n(R, D, 19),
            O = n(D, R, 29),
            M = s(R, D, 6),
            U = S ^ O ^ M;
        return U < 0 && (U += 4294967296), U
    }

    function N(R, D) {
        var S = i(R, D, 19),
            O = i(D, R, 29),
            M = a(R, D, 6),
            U = S ^ O ^ M;
        return U < 0 && (U += 4294967296), U
    }
    return Jw
}
var Qw, K7;

function Iee() {
    if (K7) return Qw;
    K7 = 1;
    var t = mo(),
        e = IN();

    function r() {
        if (!(this instanceof r)) return new r;
        e.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
    }
    return t.inherits(r, e), Qw = r, r.blockSize = 1024, r.outSize = 384, r.hmacStrength = 192, r.padLength = 128, r.prototype._digest = function(i) {
        return i === "hex" ? t.toHex32(this.h.slice(0, 12), "big") : t.split32(this.h.slice(0, 12), "big")
    }, Qw
}
var Y7;

function $ee() {
    return Y7 || (Y7 = 1, bl.sha1 = Aee(), bl.sha224 = kee(), bl.sha256 = kN(), bl.sha384 = Iee(), bl.sha512 = IN()), bl
}
var Xw = {},
    Z7;

function See() {
    if (Z7) return Xw;
    Z7 = 1;
    var t = mo(),
        e = o0(),
        r = t.rotl32,
        n = t.sum32,
        i = t.sum32_3,
        s = t.sum32_4,
        a = e.BlockHash;

    function o() {
        if (!(this instanceof o)) return new o;
        a.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
    }
    t.inherits(o, a), Xw.ripemd160 = o, o.blockSize = 512, o.outSize = 160, o.hmacStrength = 192, o.padLength = 64, o.prototype._update = function(y, w) {
        for (var x = this.h[0], E = this.h[1], _ = this.h[2], b = this.h[3], A = this.h[4], I = x, T = E, C = _, $ = b, P = A, N = 0; N < 80; N++) {
            var R = n(r(s(x, c(N, E, _, b), y[h[N] + w], l(N)), p[N]), A);
            x = A, A = b, b = r(_, 10), _ = E, E = R, R = n(r(s(I, c(79 - N, T, C, $), y[f[N] + w], u(N)), g[N]), P), I = P, P = $, $ = r(C, 10), C = T, T = R
        }
        R = i(this.h[1], _, $), this.h[1] = i(this.h[2], b, P), this.h[2] = i(this.h[3], A, I), this.h[3] = i(this.h[4], x, T), this.h[4] = i(this.h[0], E, C), this.h[0] = R
    }, o.prototype._digest = function(y) {
        return y === "hex" ? t.toHex32(this.h, "little") : t.split32(this.h, "little")
    };

    function c(m, y, w, x) {
        return m <= 15 ? y ^ w ^ x : m <= 31 ? y & w | ~y & x : m <= 47 ? (y | ~w) ^ x : m <= 63 ? y & x | w & ~x : y ^ (w | ~x)
    }

    function l(m) {
        return m <= 15 ? 0 : m <= 31 ? 1518500249 : m <= 47 ? 1859775393 : m <= 63 ? 2400959708 : 2840853838
    }

    function u(m) {
        return m <= 15 ? 1352829926 : m <= 31 ? 1548603684 : m <= 47 ? 1836072691 : m <= 63 ? 2053994217 : 0
    }
    var h = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
        f = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
        p = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
        g = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    return Xw
}
var e2, J7;

function Tee() {
    if (J7) return e2;
    J7 = 1;
    var t = mo(),
        e = a0();

    function r(n, i, s) {
        if (!(this instanceof r)) return new r(n, i, s);
        this.Hash = n, this.blockSize = n.blockSize / 8, this.outSize = n.outSize / 8, this.inner = null, this.outer = null, this._init(t.toArray(i, s))
    }
    return e2 = r, r.prototype._init = function(i) {
        i.length > this.blockSize && (i = new this.Hash().update(i).digest()), e(i.length <= this.blockSize);
        for (var s = i.length; s < this.blockSize; s++) i.push(0);
        for (s = 0; s < i.length; s++) i[s] ^= 54;
        for (this.inner = new this.Hash().update(i), s = 0; s < i.length; s++) i[s] ^= 106;
        this.outer = new this.Hash().update(i)
    }, r.prototype.update = function(i, s) {
        return this.inner.update(i, s), this
    }, r.prototype.digest = function(i) {
        return this.outer.update(this.inner.digest()), this.outer.digest(i)
    }, e2
}
var Q7;

function Pee() {
    return Q7 || (Q7 = 1, function(t) {
        var e = t;
        e.utils = mo(), e.common = o0(), e.sha = $ee(), e.ripemd = See(), e.hmac = Tee(), e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160
    }(Hw)), Hw
}
var Nee = Pee();
const Ya = Oa(Nee);

function X7(t) {
    return "0x" + Ya.sha256().update(Pt(t)).digest("hex")
}
const Oee = "web/5.8.0";
var jee = function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(a) {
            a(s)
        })
    }
    return new(r || (r = Promise))(function(s, a) {
        function o(u) {
            try {
                l(n.next(u))
            } catch (h) {
                a(h)
            }
        }

        function c(u) {
            try {
                l(n.throw(u))
            } catch (h) {
                a(h)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(o, c)
        }
        l((n = n.apply(t, e || [])).next())
    })
};

function Ree(t, e) {
    return jee(this, void 0, void 0, function*() {
        e == null && (e = {});
        const r = {
            method: e.method || "GET",
            headers: e.headers || {},
            body: e.body || void 0
        };
        if (e.skipFetchSetup !== !0 && (r.mode = "cors", r.cache = "no-cache", r.credentials = "same-origin", r.redirect = "follow", r.referrer = "client"), e.fetchOptions != null) {
            const a = e.fetchOptions;
            a.mode && (r.mode = a.mode), a.cache && (r.cache = a.cache), a.credentials && (r.credentials = a.credentials), a.redirect && (r.redirect = a.redirect), a.referrer && (r.referrer = a.referrer)
        }
        const n = yield fetch(t, r), i = yield n.arrayBuffer(), s = {};
        return n.headers.forEach ? n.headers.forEach((a, o) => {
            s[o.toLowerCase()] = a
        }) : n.headers.keys().forEach(a => {
            s[a.toLowerCase()] = n.headers.get(a)
        }), {
            headers: s,
            statusCode: n.status,
            statusMessage: n.statusText,
            body: Pt(new Uint8Array(i))
        }
    })
}
var Mee = function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(a) {
            a(s)
        })
    }
    return new(r || (r = Promise))(function(s, a) {
        function o(u) {
            try {
                l(n.next(u))
            } catch (h) {
                a(h)
            }
        }

        function c(u) {
            try {
                l(n.throw(u))
            } catch (h) {
                a(h)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(o, c)
        }
        l((n = n.apply(t, e || [])).next())
    })
};
const ta = new pe(Oee);

function e_(t) {
    return new Promise(e => {
        setTimeout(e, t)
    })
}

function vc(t, e) {
    if (t == null) return null;
    if (typeof t == "string") return t;
    if (N6(t)) {
        if (e && (e.split("/")[0] === "text" || e.split(";")[0].trim() === "application/json")) try {
            return Y1(t)
        } catch {}
        return Tt(t)
    }
    return t
}

function Dee(t) {
    return ic(t.replace(/%([0-9a-f][0-9a-f])/gi, (e, r) => String.fromCharCode(parseInt(r, 16))))
}

function Lee(t, e, r) {
    const n = typeof t == "object" && t.throttleLimit != null ? t.throttleLimit : 12;
    ta.assertArgument(n > 0 && n % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", n);
    const i = typeof t == "object" ? t.throttleCallback : null,
        s = typeof t == "object" && typeof t.throttleSlotInterval == "number" ? t.throttleSlotInterval : 100;
    ta.assertArgument(s > 0 && s % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", s);
    const a = typeof t == "object" ? !!t.errorPassThrough : !1,
        o = {};
    let c = null;
    const l = {
        method: "GET"
    };
    let u = !1,
        h = 2 * 60 * 1e3;
    if (typeof t == "string") c = t;
    else if (typeof t == "object") {
        if ((t == null || t.url == null) && ta.throwArgumentError("missing URL", "connection.url", t), c = t.url, typeof t.timeout == "number" && t.timeout > 0 && (h = t.timeout), t.headers)
            for (const w in t.headers) o[w.toLowerCase()] = {
                key: w,
                value: String(t.headers[w])
            }, ["if-none-match", "if-modified-since"].indexOf(w.toLowerCase()) >= 0 && (u = !0);
        if (l.allowGzip = !!t.allowGzip, t.user != null && t.password != null) {
            c.substring(0, 6) !== "https:" && t.allowInsecureAuthentication !== !0 && ta.throwError("basic authentication requires a secure https url", pe.errors.INVALID_ARGUMENT, {
                argument: "url",
                url: c,
                user: t.user,
                password: "[REDACTED]"
            });
            const w = t.user + ":" + t.password;
            o.authorization = {
                key: "Authorization",
                value: "Basic " + oN(ic(w))
            }
        }
        t.skipFetchSetup != null && (l.skipFetchSetup = !!t.skipFetchSetup), t.fetchOptions != null && (l.fetchOptions = ji(t.fetchOptions))
    }
    const f = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
        p = c ? c.match(f) : null;
    if (p) try {
        const w = {
            statusCode: 200,
            statusMessage: "OK",
            headers: {
                "content-type": p[1] || "text/plain"
            },
            body: p[2] ? aN(p[3]) : Dee(p[3])
        };
        let x = w.body;
        return r && (x = r(w.body, w)), Promise.resolve(x)
    } catch (w) {
        ta.throwError("processing response error", pe.errors.SERVER_ERROR, {
            body: vc(p[1], p[2]),
            error: w,
            requestBody: null,
            requestMethod: "GET",
            url: c
        })
    }
    e && (l.method = "POST", l.body = e, o["content-type"] == null && (o["content-type"] = {
        key: "Content-Type",
        value: "application/octet-stream"
    }), o["content-length"] == null && (o["content-length"] = {
        key: "Content-Length",
        value: String(e.length)
    }));
    const g = {};
    Object.keys(o).forEach(w => {
        const x = o[w];
        g[x.key] = x.value
    }), l.headers = g;
    const m = function() {
            let w = null;
            return {
                promise: new Promise(function(_, b) {
                    h && (w = setTimeout(() => {
                        w != null && (w = null, b(ta.makeError("timeout", pe.errors.TIMEOUT, {
                            requestBody: vc(l.body, g["content-type"]),
                            requestMethod: l.method,
                            timeout: h,
                            url: c
                        })))
                    }, h))
                }),
                cancel: function() {
                    w != null && (clearTimeout(w), w = null)
                }
            }
        }(),
        y = function() {
            return Mee(this, void 0, void 0, function*() {
                for (let w = 0; w < n; w++) {
                    let x = null;
                    try {
                        if (x = yield Ree(c, l), w < n) {
                            if (x.statusCode === 301 || x.statusCode === 302) {
                                const _ = x.headers.location || "";
                                if (l.method === "GET" && _.match(/^https:/)) {
                                    c = x.headers.location;
                                    continue
                                }
                            } else if (x.statusCode === 429) {
                                let _ = !0;
                                if (i && (_ = yield i(w, c)), _) {
                                    let b = 0;
                                    const A = x.headers["retry-after"];
                                    typeof A == "string" && A.match(/^[1-9][0-9]*$/) ? b = parseInt(A) * 1e3 : b = s * parseInt(String(Math.random() * Math.pow(2, w))), yield e_(b);
                                    continue
                                }
                            }
                        }
                    } catch (_) {
                        x = _.response, x == null && (m.cancel(), ta.throwError("missing response", pe.errors.SERVER_ERROR, {
                            requestBody: vc(l.body, g["content-type"]),
                            requestMethod: l.method,
                            serverError: _,
                            url: c
                        }))
                    }
                    let E = x.body;
                    if (u && x.statusCode === 304 ? E = null : !a && (x.statusCode < 200 || x.statusCode >= 300) && (m.cancel(), ta.throwError("bad response", pe.errors.SERVER_ERROR, {
                            status: x.statusCode,
                            headers: x.headers,
                            body: vc(E, x.headers ? x.headers["content-type"] : null),
                            requestBody: vc(l.body, g["content-type"]),
                            requestMethod: l.method,
                            url: c
                        })), r) try {
                        const _ = yield r(E, x);
                        return m.cancel(), _
                    } catch (_) {
                        if (_.throttleRetry && w < n) {
                            let b = !0;
                            if (i && (b = yield i(w, c)), b) {
                                const A = s * parseInt(String(Math.random() * Math.pow(2, w)));
                                yield e_(A);
                                continue
                            }
                        }
                        m.cancel(), ta.throwError("processing response error", pe.errors.SERVER_ERROR, {
                            body: vc(E, x.headers ? x.headers["content-type"] : null),
                            error: _,
                            requestBody: vc(l.body, g["content-type"]),
                            requestMethod: l.method,
                            url: c
                        })
                    }
                    return m.cancel(), E
                }
                return ta.throwError("failed response", pe.errors.SERVER_ERROR, {
                    requestBody: vc(l.body, g["content-type"]),
                    requestMethod: l.method,
                    url: c
                })
            })
        }();
    return Promise.race([m.promise, y])
}

function L6(t, e, r) {
    let n = (s, a) => {
            let o = null;
            if (s != null) try {
                o = JSON.parse(Y1(s))
            } catch (c) {
                ta.throwError("invalid JSON", pe.errors.SERVER_ERROR, {
                    body: s,
                    error: c
                })
            }
            return r && (o = r(o, a)), o
        },
        i = null;
    if (e != null) {
        i = ic(e);
        const s = typeof t == "string" ? {
            url: t
        } : ji(t);
        s.headers ? Object.keys(s.headers).filter(o => o.toLowerCase() === "content-type").length !== 0 || (s.headers = ji(s.headers), s.headers["content-type"] = "application/json") : s.headers = {
            "content-type": "application/json"
        }, t = s
    }
    return Lee(t, i, n)
}

function xf(t, e) {
    return e || (e = {}), e = ji(e), e.floor == null && (e.floor = 0), e.ceiling == null && (e.ceiling = 1e4), e.interval == null && (e.interval = 250), new Promise(function(r, n) {
        let i = null,
            s = !1;
        const a = () => s ? !1 : (s = !0, i && clearTimeout(i), !0);
        e.timeout && (i = setTimeout(() => {
            a() && n(new Error("timeout"))
        }, e.timeout));
        const o = e.retryLimit;
        let c = 0;

        function l() {
            return t().then(function(u) {
                if (u !== void 0) a() && r(u);
                else if (e.oncePoll) e.oncePoll.once("poll", l);
                else if (e.onceBlock) e.onceBlock.once("block", l);
                else if (!s) {
                    if (c++, c > o) {
                        a() && n(new Error("retry limit reached"));
                        return
                    }
                    let h = e.interval * parseInt(String(Math.random() * Math.pow(2, c)));
                    h < e.floor && (h = e.floor), h > e.ceiling && (h = e.ceiling), setTimeout(l, h)
                }
                return null
            }, function(u) {
                a() && n(u)
            })
        }
        l()
    })
}
var t2, t_;

function Uee() {
    if (t_) return t2;
    t_ = 1;
    for (var t = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", e = {}, r = 0; r < t.length; r++) {
        var n = t.charAt(r);
        if (e[n] !== void 0) throw new TypeError(n + " is ambiguous");
        e[n] = r
    }

    function i(m) {
        var y = m >> 25;
        return (m & 33554431) << 5 ^ -(y >> 0 & 1) & 996825010 ^ -(y >> 1 & 1) & 642813549 ^ -(y >> 2 & 1) & 513874426 ^ -(y >> 3 & 1) & 1027748829 ^ -(y >> 4 & 1) & 705979059
    }

    function s(m) {
        for (var y = 1, w = 0; w < m.length; ++w) {
            var x = m.charCodeAt(w);
            if (x < 33 || x > 126) return "Invalid prefix (" + m + ")";
            y = i(y) ^ x >> 5
        }
        for (y = i(y), w = 0; w < m.length; ++w) {
            var E = m.charCodeAt(w);
            y = i(y) ^ E & 31
        }
        return y
    }

    function a(m, y, w) {
        if (w = w || 90, m.length + 7 + y.length > w) throw new TypeError("Exceeds length limit");
        m = m.toLowerCase();
        var x = s(m);
        if (typeof x == "string") throw new Error(x);
        for (var E = m + "1", _ = 0; _ < y.length; ++_) {
            var b = y[_];
            if (b >> 5 !== 0) throw new Error("Non 5-bit word");
            x = i(x) ^ b, E += t.charAt(b)
        }
        for (_ = 0; _ < 6; ++_) x = i(x);
        for (x ^= 1, _ = 0; _ < 6; ++_) {
            var A = x >> (5 - _) * 5 & 31;
            E += t.charAt(A)
        }
        return E
    }

    function o(m, y) {
        if (y = y || 90, m.length < 8) return m + " too short";
        if (m.length > y) return "Exceeds length limit";
        var w = m.toLowerCase(),
            x = m.toUpperCase();
        if (m !== w && m !== x) return "Mixed-case string " + m;
        m = w;
        var E = m.lastIndexOf("1");
        if (E === -1) return "No separator character for " + m;
        if (E === 0) return "Missing prefix for " + m;
        var _ = m.slice(0, E),
            b = m.slice(E + 1);
        if (b.length < 6) return "Data too short";
        var A = s(_);
        if (typeof A == "string") return A;
        for (var I = [], T = 0; T < b.length; ++T) {
            var C = b.charAt(T),
                $ = e[C];
            if ($ === void 0) return "Unknown character " + C;
            A = i(A) ^ $, !(T + 6 >= b.length) && I.push($)
        }
        return A !== 1 ? "Invalid checksum for " + m : {
            prefix: _,
            words: I
        }
    }

    function c() {
        var m = o.apply(null, arguments);
        if (typeof m == "object") return m
    }

    function l(m) {
        var y = o.apply(null, arguments);
        if (typeof y == "object") return y;
        throw new Error(y)
    }

    function u(m, y, w, x) {
        for (var E = 0, _ = 0, b = (1 << w) - 1, A = [], I = 0; I < m.length; ++I)
            for (E = E << y | m[I], _ += y; _ >= w;) _ -= w, A.push(E >> _ & b);
        if (x) _ > 0 && A.push(E << w - _ & b);
        else {
            if (_ >= y) return "Excess padding";
            if (E << w - _ & b) return "Non-zero padding"
        }
        return A
    }

    function h(m) {
        var y = u(m, 8, 5, !0);
        if (Array.isArray(y)) return y
    }

    function f(m) {
        var y = u(m, 8, 5, !0);
        if (Array.isArray(y)) return y;
        throw new Error(y)
    }

    function p(m) {
        var y = u(m, 5, 8, !1);
        if (Array.isArray(y)) return y
    }

    function g(m) {
        var y = u(m, 5, 8, !1);
        if (Array.isArray(y)) return y;
        throw new Error(y)
    }
    return t2 = {
        decodeUnsafe: c,
        decode: l,
        encode: a,
        toWordsUnsafe: h,
        toWords: f,
        fromWordsUnsafe: p,
        fromWords: g
    }, t2
}
var Fee = Uee();
const r_ = Oa(Fee),
    Q1 = "providers/5.8.0";

function bh(t, e, r) {
    return r = {
        path: e,
        exports: {},
        require: function(n, i) {
            return Bee(n, i ? ? r.path)
        }
    }, t(r, r.exports), r.exports
}

function Bee() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
}
var U6 = $N;

function $N(t, e) {
    if (!t) throw new Error(e || "Assertion failed")
}
$N.equal = function(e, r, n) {
    if (e != r) throw new Error(n || "Assertion failed: " + e + " != " + r)
};
var ha = bh(function(t, e) {
        var r = e;

        function n(a, o) {
            if (Array.isArray(a)) return a.slice();
            if (!a) return [];
            var c = [];
            if (typeof a != "string") {
                for (var l = 0; l < a.length; l++) c[l] = a[l] | 0;
                return c
            }
            if (o === "hex") {
                a = a.replace(/[^a-z0-9]+/ig, ""), a.length % 2 !== 0 && (a = "0" + a);
                for (var l = 0; l < a.length; l += 2) c.push(parseInt(a[l] + a[l + 1], 16))
            } else
                for (var l = 0; l < a.length; l++) {
                    var u = a.charCodeAt(l),
                        h = u >> 8,
                        f = u & 255;
                    h ? c.push(h, f) : c.push(f)
                }
            return c
        }
        r.toArray = n;

        function i(a) {
            return a.length === 1 ? "0" + a : a
        }
        r.zero2 = i;

        function s(a) {
            for (var o = "", c = 0; c < a.length; c++) o += i(a[c].toString(16));
            return o
        }
        r.toHex = s, r.encode = function(o, c) {
            return c === "hex" ? s(o) : o
        }
    }),
    ps = bh(function(t, e) {
        var r = e;
        r.assert = U6, r.toArray = ha.toArray, r.zero2 = ha.zero2, r.toHex = ha.toHex, r.encode = ha.encode;

        function n(c, l, u) {
            var h = new Array(Math.max(c.bitLength(), u) + 1),
                f;
            for (f = 0; f < h.length; f += 1) h[f] = 0;
            var p = 1 << l + 1,
                g = c.clone();
            for (f = 0; f < h.length; f++) {
                var m, y = g.andln(p - 1);
                g.isOdd() ? (y > (p >> 1) - 1 ? m = (p >> 1) - y : m = y, g.isubn(m)) : m = 0, h[f] = m, g.iushrn(1)
            }
            return h
        }
        r.getNAF = n;

        function i(c, l) {
            var u = [
                [],
                []
            ];
            c = c.clone(), l = l.clone();
            for (var h = 0, f = 0, p; c.cmpn(-h) > 0 || l.cmpn(-f) > 0;) {
                var g = c.andln(3) + h & 3,
                    m = l.andln(3) + f & 3;
                g === 3 && (g = -1), m === 3 && (m = -1);
                var y;
                (g & 1) === 0 ? y = 0 : (p = c.andln(7) + h & 7, (p === 3 || p === 5) && m === 2 ? y = -g : y = g), u[0].push(y);
                var w;
                (m & 1) === 0 ? w = 0 : (p = l.andln(7) + f & 7, (p === 3 || p === 5) && g === 2 ? w = -m : w = m), u[1].push(w), 2 * h === y + 1 && (h = 1 - h), 2 * f === w + 1 && (f = 1 - f), c.iushrn(1), l.iushrn(1)
            }
            return u
        }
        r.getJSF = i;

        function s(c, l, u) {
            var h = "_" + l;
            c.prototype[l] = function() {
                return this[h] !== void 0 ? this[h] : this[h] = u.call(this)
            }
        }
        r.cachedProperty = s;

        function a(c) {
            return typeof c == "string" ? r.toArray(c, "hex") : c
        }
        r.parseBytes = a;

        function o(c) {
            return new Et(c, "hex", "le")
        }
        r.intFromLE = o
    }),
    Am = ps.getNAF,
    Wee = ps.getJSF,
    km = ps.assert;

function ll(t, e) {
    this.type = t, this.p = new Et(e.p, 16), this.red = e.prime ? Et.red(e.prime) : Et.mont(this.p), this.zero = new Et(0).toRed(this.red), this.one = new Et(1).toRed(this.red), this.two = new Et(2).toRed(this.red), this.n = e.n && new Et(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var r = this.n && this.p.div(this.n);
    !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
}
var $d = ll;
ll.prototype.point = function() {
    throw new Error("Not implemented")
};
ll.prototype.validate = function() {
    throw new Error("Not implemented")
};
ll.prototype._fixedNafMul = function(e, r) {
    km(e.precomputed);
    var n = e._getDoubles(),
        i = Am(r, 1, this._bitLength),
        s = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
    s /= 3;
    var a = [],
        o, c;
    for (o = 0; o < i.length; o += n.step) {
        c = 0;
        for (var l = o + n.step - 1; l >= o; l--) c = (c << 1) + i[l];
        a.push(c)
    }
    for (var u = this.jpoint(null, null, null), h = this.jpoint(null, null, null), f = s; f > 0; f--) {
        for (o = 0; o < a.length; o++) c = a[o], c === f ? h = h.mixedAdd(n.points[o]) : c === -f && (h = h.mixedAdd(n.points[o].neg()));
        u = u.add(h)
    }
    return u.toP()
};
ll.prototype._wnafMul = function(e, r) {
    var n = 4,
        i = e._getNAFPoints(n);
    n = i.wnd;
    for (var s = i.points, a = Am(r, n, this._bitLength), o = this.jpoint(null, null, null), c = a.length - 1; c >= 0; c--) {
        for (var l = 0; c >= 0 && a[c] === 0; c--) l++;
        if (c >= 0 && l++, o = o.dblp(l), c < 0) break;
        var u = a[c];
        km(u !== 0), e.type === "affine" ? u > 0 ? o = o.mixedAdd(s[u - 1 >> 1]) : o = o.mixedAdd(s[-u - 1 >> 1].neg()) : u > 0 ? o = o.add(s[u - 1 >> 1]) : o = o.add(s[-u - 1 >> 1].neg())
    }
    return e.type === "affine" ? o.toP() : o
};
ll.prototype._wnafMulAdd = function(e, r, n, i, s) {
    var a = this._wnafT1,
        o = this._wnafT2,
        c = this._wnafT3,
        l = 0,
        u, h, f;
    for (u = 0; u < i; u++) {
        f = r[u];
        var p = f._getNAFPoints(e);
        a[u] = p.wnd, o[u] = p.points
    }
    for (u = i - 1; u >= 1; u -= 2) {
        var g = u - 1,
            m = u;
        if (a[g] !== 1 || a[m] !== 1) {
            c[g] = Am(n[g], a[g], this._bitLength), c[m] = Am(n[m], a[m], this._bitLength), l = Math.max(c[g].length, l), l = Math.max(c[m].length, l);
            continue
        }
        var y = [r[g], null, null, r[m]];
        r[g].y.cmp(r[m].y) === 0 ? (y[1] = r[g].add(r[m]), y[2] = r[g].toJ().mixedAdd(r[m].neg())) : r[g].y.cmp(r[m].y.redNeg()) === 0 ? (y[1] = r[g].toJ().mixedAdd(r[m]), y[2] = r[g].add(r[m].neg())) : (y[1] = r[g].toJ().mixedAdd(r[m]), y[2] = r[g].toJ().mixedAdd(r[m].neg()));
        var w = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
            x = Wee(n[g], n[m]);
        for (l = Math.max(x[0].length, l), c[g] = new Array(l), c[m] = new Array(l), h = 0; h < l; h++) {
            var E = x[0][h] | 0,
                _ = x[1][h] | 0;
            c[g][h] = w[(E + 1) * 3 + (_ + 1)], c[m][h] = 0, o[g] = y
        }
    }
    var b = this.jpoint(null, null, null),
        A = this._wnafT4;
    for (u = l; u >= 0; u--) {
        for (var I = 0; u >= 0;) {
            var T = !0;
            for (h = 0; h < i; h++) A[h] = c[h][u] | 0, A[h] !== 0 && (T = !1);
            if (!T) break;
            I++, u--
        }
        if (u >= 0 && I++, b = b.dblp(I), u < 0) break;
        for (h = 0; h < i; h++) {
            var C = A[h];
            C !== 0 && (C > 0 ? f = o[h][C - 1 >> 1] : C < 0 && (f = o[h][-C - 1 >> 1].neg()), f.type === "affine" ? b = b.mixedAdd(f) : b = b.add(f))
        }
    }
    for (u = 0; u < i; u++) o[u] = null;
    return s ? b : b.toP()
};

function Ws(t, e) {
    this.curve = t, this.type = e, this.precomputed = null
}
ll.BasePoint = Ws;
Ws.prototype.eq = function() {
    throw new Error("Not implemented")
};
Ws.prototype.validate = function() {
    return this.curve.validate(this)
};
ll.prototype.decodePoint = function(e, r) {
    e = ps.toArray(e, r);
    var n = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
        e[0] === 6 ? km(e[e.length - 1] % 2 === 0) : e[0] === 7 && km(e[e.length - 1] % 2 === 1);
        var i = this.point(e.slice(1, 1 + n), e.slice(1 + n, 1 + 2 * n));
        return i
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n) return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
    throw new Error("Unknown point format")
};
Ws.prototype.encodeCompressed = function(e) {
    return this.encode(e, !0)
};
Ws.prototype._encode = function(e) {
    var r = this.curve.p.byteLength(),
        n = this.getX().toArray("be", r);
    return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r))
};
Ws.prototype.encode = function(e, r) {
    return ps.encode(this._encode(r), e)
};
Ws.prototype.precompute = function(e) {
    if (this.precomputed) return this;
    var r = {
        doubles: null,
        naf: null,
        beta: null
    };
    return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this
};
Ws.prototype._hasDoubles = function(e) {
    if (!this.precomputed) return !1;
    var r = this.precomputed.doubles;
    return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1
};
Ws.prototype._getDoubles = function(e, r) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    for (var n = [this], i = this, s = 0; s < r; s += e) {
        for (var a = 0; a < e; a++) i = i.dbl();
        n.push(i)
    }
    return {
        step: e,
        points: n
    }
};
Ws.prototype._getNAFPoints = function(e) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++) r[s] = r[s - 1].add(i);
    return {
        wnd: e,
        points: r
    }
};
Ws.prototype._getBeta = function() {
    return null
};
Ws.prototype.dblp = function(e) {
    for (var r = this, n = 0; n < e; n++) r = r.dbl();
    return r
};
var F6 = bh(function(t) {
        typeof Object.create == "function" ? t.exports = function(r, n) {
            n && (r.super_ = n, r.prototype = Object.create(n.prototype, {
                constructor: {
                    value: r,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }))
        } : t.exports = function(r, n) {
            if (n) {
                r.super_ = n;
                var i = function() {};
                i.prototype = n.prototype, r.prototype = new i, r.prototype.constructor = r
            }
        }
    }),
    zee = ps.assert;

function zs(t) {
    $d.call(this, "short", t), this.a = new Et(t.a, 16).toRed(this.red), this.b = new Et(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
}
F6(zs, $d);
var qee = zs;
zs.prototype._getEndomorphism = function(e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, n;
        if (e.beta) r = new Et(e.beta, 16).toRed(this.red);
        else {
            var i = this._getEndoRoots(this.p);
            r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red)
        }
        if (e.lambda) n = new Et(e.lambda, 16);
        else {
            var s = this._getEndoRoots(this.n);
            this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = s[0] : (n = s[1], zee(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0))
        }
        var a;
        return e.basis ? a = e.basis.map(function(o) {
            return {
                a: new Et(o.a, 16),
                b: new Et(o.b, 16)
            }
        }) : a = this._getEndoBasis(n), {
            beta: r,
            lambda: n,
            basis: a
        }
    }
};
zs.prototype._getEndoRoots = function(e) {
    var r = e === this.p ? this.red : Et.mont(e),
        n = new Et(2).toRed(r).redInvm(),
        i = n.redNeg(),
        s = new Et(3).toRed(r).redNeg().redSqrt().redMul(n),
        a = i.redAdd(s).fromRed(),
        o = i.redSub(s).fromRed();
    return [a, o]
};
zs.prototype._getEndoBasis = function(e) {
    for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), s = new Et(1), a = new Et(0), o = new Et(0), c = new Et(1), l, u, h, f, p, g, m, y = 0, w, x; n.cmpn(0) !== 0;) {
        var E = i.div(n);
        w = i.sub(E.mul(n)), x = o.sub(E.mul(s));
        var _ = c.sub(E.mul(a));
        if (!h && w.cmp(r) < 0) l = m.neg(), u = s, h = w.neg(), f = x;
        else if (h && ++y === 2) break;
        m = w, i = n, n = w, o = s, s = x, c = a, a = _
    }
    p = w.neg(), g = x;
    var b = h.sqr().add(f.sqr()),
        A = p.sqr().add(g.sqr());
    return A.cmp(b) >= 0 && (p = l, g = u), h.negative && (h = h.neg(), f = f.neg()), p.negative && (p = p.neg(), g = g.neg()), [{
        a: h,
        b: f
    }, {
        a: p,
        b: g
    }]
};
zs.prototype._endoSplit = function(e) {
    var r = this.endo.basis,
        n = r[0],
        i = r[1],
        s = i.b.mul(e).divRound(this.n),
        a = n.b.neg().mul(e).divRound(this.n),
        o = s.mul(n.a),
        c = a.mul(i.a),
        l = s.mul(n.b),
        u = a.mul(i.b),
        h = e.sub(o).sub(c),
        f = l.add(u).neg();
    return {
        k1: h,
        k2: f
    }
};
zs.prototype.pointFromX = function(e, r) {
    e = new Et(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
        i = n.redSqrt();
    if (i.redSqr().redSub(n).cmp(this.zero) !== 0) throw new Error("invalid point");
    var s = i.fromRed().isOdd();
    return (r && !s || !r && s) && (i = i.redNeg()), this.point(e, i)
};
zs.prototype.validate = function(e) {
    if (e.inf) return !0;
    var r = e.x,
        n = e.y,
        i = this.a.redMul(r),
        s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
    return n.redSqr().redISub(s).cmpn(0) === 0
};
zs.prototype._endoWnafMulAdd = function(e, r, n) {
    for (var i = this._endoWnafT1, s = this._endoWnafT2, a = 0; a < e.length; a++) {
        var o = this._endoSplit(r[a]),
            c = e[a],
            l = c._getBeta();
        o.k1.negative && (o.k1.ineg(), c = c.neg(!0)), o.k2.negative && (o.k2.ineg(), l = l.neg(!0)), i[a * 2] = c, i[a * 2 + 1] = l, s[a * 2] = o.k1, s[a * 2 + 1] = o.k2
    }
    for (var u = this._wnafMulAdd(1, i, s, a * 2, n), h = 0; h < a * 2; h++) i[h] = null, s[h] = null;
    return u
};

function bn(t, e, r, n) {
    $d.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new Et(e, 16), this.y = new Et(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
}
F6(bn, $d.BasePoint);
zs.prototype.point = function(e, r, n) {
    return new bn(this, e, r, n)
};
zs.prototype.pointFromJSON = function(e, r) {
    return bn.fromJSON(this, e, r)
};
bn.prototype._getBeta = function() {
    if (this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta) return e.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
            var n = this.curve,
                i = function(s) {
                    return n.point(s.x.redMul(n.endo.beta), s.y)
                };
            e.beta = r, r.precomputed = {
                beta: null,
                naf: e.naf && {
                    wnd: e.naf.wnd,
                    points: e.naf.points.map(i)
                },
                doubles: e.doubles && {
                    step: e.doubles.step,
                    points: e.doubles.points.map(i)
                }
            }
        }
        return r
    }
};
bn.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
        }
    }] : [this.x, this.y]
};
bn.fromJSON = function(e, r, n) {
    typeof r == "string" && (r = JSON.parse(r));
    var i = e.point(r[0], r[1], n);
    if (!r[2]) return i;

    function s(o) {
        return e.point(o[0], o[1], n)
    }
    var a = r[2];
    return i.precomputed = {
        beta: null,
        doubles: a.doubles && {
            step: a.doubles.step,
            points: [i].concat(a.doubles.points.map(s))
        },
        naf: a.naf && {
            wnd: a.naf.wnd,
            points: [i].concat(a.naf.points.map(s))
        }
    }, i
};
bn.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
};
bn.prototype.isInfinity = function() {
    return this.inf
};
bn.prototype.add = function(e) {
    if (this.inf) return e;
    if (e.inf) return this;
    if (this.eq(e)) return this.dbl();
    if (this.neg().eq(e)) return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
    var r = this.y.redSub(e.y);
    r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
    var n = r.redSqr().redISub(this.x).redISub(e.x),
        i = r.redMul(this.x.redSub(n)).redISub(this.y);
    return this.curve.point(n, i)
};
bn.prototype.dbl = function() {
    if (this.inf) return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0) return this.curve.point(null, null);
    var r = this.curve.a,
        n = this.x.redSqr(),
        i = e.redInvm(),
        s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i),
        a = s.redSqr().redISub(this.x.redAdd(this.x)),
        o = s.redMul(this.x.redSub(a)).redISub(this.y);
    return this.curve.point(a, o)
};
bn.prototype.getX = function() {
    return this.x.fromRed()
};
bn.prototype.getY = function() {
    return this.y.fromRed()
};
bn.prototype.mul = function(e) {
    return e = new Et(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e)
};
bn.prototype.mulAdd = function(e, r, n) {
    var i = [this, r],
        s = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2)
};
bn.prototype.jmulAdd = function(e, r, n) {
    var i = [this, r],
        s = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0)
};
bn.prototype.eq = function(e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)
};
bn.prototype.neg = function(e) {
    if (this.inf) return this;
    var r = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
        var n = this.precomputed,
            i = function(s) {
                return s.neg()
            };
        r.precomputed = {
            naf: n.naf && {
                wnd: n.naf.wnd,
                points: n.naf.points.map(i)
            },
            doubles: n.doubles && {
                step: n.doubles.step,
                points: n.doubles.points.map(i)
            }
        }
    }
    return r
};
bn.prototype.toJ = function() {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e
};

function Rn(t, e, r, n) {
    $d.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Et(0)) : (this.x = new Et(e, 16), this.y = new Et(r, 16), this.z = new Et(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
}
F6(Rn, $d.BasePoint);
zs.prototype.jpoint = function(e, r, n) {
    return new Rn(this, e, r, n)
};
Rn.prototype.toP = function() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var e = this.z.redInvm(),
        r = e.redSqr(),
        n = this.x.redMul(r),
        i = this.y.redMul(r).redMul(e);
    return this.curve.point(n, i)
};
Rn.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
};
Rn.prototype.add = function(e) {
    if (this.isInfinity()) return e;
    if (e.isInfinity()) return this;
    var r = e.z.redSqr(),
        n = this.z.redSqr(),
        i = this.x.redMul(r),
        s = e.x.redMul(n),
        a = this.y.redMul(r.redMul(e.z)),
        o = e.y.redMul(n.redMul(this.z)),
        c = i.redSub(s),
        l = a.redSub(o);
    if (c.cmpn(0) === 0) return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var u = c.redSqr(),
        h = u.redMul(c),
        f = i.redMul(u),
        p = l.redSqr().redIAdd(h).redISub(f).redISub(f),
        g = l.redMul(f.redISub(p)).redISub(a.redMul(h)),
        m = this.z.redMul(e.z).redMul(c);
    return this.curve.jpoint(p, g, m)
};
Rn.prototype.mixedAdd = function(e) {
    if (this.isInfinity()) return e.toJ();
    if (e.isInfinity()) return this;
    var r = this.z.redSqr(),
        n = this.x,
        i = e.x.redMul(r),
        s = this.y,
        a = e.y.redMul(r).redMul(this.z),
        o = n.redSub(i),
        c = s.redSub(a);
    if (o.cmpn(0) === 0) return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var l = o.redSqr(),
        u = l.redMul(o),
        h = n.redMul(l),
        f = c.redSqr().redIAdd(u).redISub(h).redISub(h),
        p = c.redMul(h.redISub(f)).redISub(s.redMul(u)),
        g = this.z.redMul(o);
    return this.curve.jpoint(f, p, g)
};
Rn.prototype.dblp = function(e) {
    if (e === 0) return this;
    if (this.isInfinity()) return this;
    if (!e) return this.dbl();
    var r;
    if (this.curve.zeroA || this.curve.threeA) {
        var n = this;
        for (r = 0; r < e; r++) n = n.dbl();
        return n
    }
    var i = this.curve.a,
        s = this.curve.tinv,
        a = this.x,
        o = this.y,
        c = this.z,
        l = c.redSqr().redSqr(),
        u = o.redAdd(o);
    for (r = 0; r < e; r++) {
        var h = a.redSqr(),
            f = u.redSqr(),
            p = f.redSqr(),
            g = h.redAdd(h).redIAdd(h).redIAdd(i.redMul(l)),
            m = a.redMul(f),
            y = g.redSqr().redISub(m.redAdd(m)),
            w = m.redISub(y),
            x = g.redMul(w);
        x = x.redIAdd(x).redISub(p);
        var E = u.redMul(c);
        r + 1 < e && (l = l.redMul(p)), a = y, c = E, u = x
    }
    return this.curve.jpoint(a, u.redMul(s), c)
};
Rn.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
};
Rn.prototype._zeroDbl = function() {
    var e, r, n;
    if (this.zOne) {
        var i = this.x.redSqr(),
            s = this.y.redSqr(),
            a = s.redSqr(),
            o = this.x.redAdd(s).redSqr().redISub(i).redISub(a);
        o = o.redIAdd(o);
        var c = i.redAdd(i).redIAdd(i),
            l = c.redSqr().redISub(o).redISub(o),
            u = a.redIAdd(a);
        u = u.redIAdd(u), u = u.redIAdd(u), e = l, r = c.redMul(o.redISub(l)).redISub(u), n = this.y.redAdd(this.y)
    } else {
        var h = this.x.redSqr(),
            f = this.y.redSqr(),
            p = f.redSqr(),
            g = this.x.redAdd(f).redSqr().redISub(h).redISub(p);
        g = g.redIAdd(g);
        var m = h.redAdd(h).redIAdd(h),
            y = m.redSqr(),
            w = p.redIAdd(p);
        w = w.redIAdd(w), w = w.redIAdd(w), e = y.redISub(g).redISub(g), r = m.redMul(g.redISub(e)).redISub(w), n = this.y.redMul(this.z), n = n.redIAdd(n)
    }
    return this.curve.jpoint(e, r, n)
};
Rn.prototype._threeDbl = function() {
    var e, r, n;
    if (this.zOne) {
        var i = this.x.redSqr(),
            s = this.y.redSqr(),
            a = s.redSqr(),
            o = this.x.redAdd(s).redSqr().redISub(i).redISub(a);
        o = o.redIAdd(o);
        var c = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),
            l = c.redSqr().redISub(o).redISub(o);
        e = l;
        var u = a.redIAdd(a);
        u = u.redIAdd(u), u = u.redIAdd(u), r = c.redMul(o.redISub(l)).redISub(u), n = this.y.redAdd(this.y)
    } else {
        var h = this.z.redSqr(),
            f = this.y.redSqr(),
            p = this.x.redMul(f),
            g = this.x.redSub(h).redMul(this.x.redAdd(h));
        g = g.redAdd(g).redIAdd(g);
        var m = p.redIAdd(p);
        m = m.redIAdd(m);
        var y = m.redAdd(m);
        e = g.redSqr().redISub(y), n = this.y.redAdd(this.z).redSqr().redISub(f).redISub(h);
        var w = f.redSqr();
        w = w.redIAdd(w), w = w.redIAdd(w), w = w.redIAdd(w), r = g.redMul(m.redISub(e)).redISub(w)
    }
    return this.curve.jpoint(e, r, n)
};
Rn.prototype._dbl = function() {
    var e = this.curve.a,
        r = this.x,
        n = this.y,
        i = this.z,
        s = i.redSqr().redSqr(),
        a = r.redSqr(),
        o = n.redSqr(),
        c = a.redAdd(a).redIAdd(a).redIAdd(e.redMul(s)),
        l = r.redAdd(r);
    l = l.redIAdd(l);
    var u = l.redMul(o),
        h = c.redSqr().redISub(u.redAdd(u)),
        f = u.redISub(h),
        p = o.redSqr();
    p = p.redIAdd(p), p = p.redIAdd(p), p = p.redIAdd(p);
    var g = c.redMul(f).redISub(p),
        m = n.redAdd(n).redMul(i);
    return this.curve.jpoint(h, g, m)
};
Rn.prototype.trpl = function() {
    if (!this.curve.zeroA) return this.dbl().add(this);
    var e = this.x.redSqr(),
        r = this.y.redSqr(),
        n = this.z.redSqr(),
        i = r.redSqr(),
        s = e.redAdd(e).redIAdd(e),
        a = s.redSqr(),
        o = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
    o = o.redIAdd(o), o = o.redAdd(o).redIAdd(o), o = o.redISub(a);
    var c = o.redSqr(),
        l = i.redIAdd(i);
    l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
    var u = s.redIAdd(o).redSqr().redISub(a).redISub(c).redISub(l),
        h = r.redMul(u);
    h = h.redIAdd(h), h = h.redIAdd(h);
    var f = this.x.redMul(c).redISub(h);
    f = f.redIAdd(f), f = f.redIAdd(f);
    var p = this.y.redMul(u.redMul(l.redISub(u)).redISub(o.redMul(c)));
    p = p.redIAdd(p), p = p.redIAdd(p), p = p.redIAdd(p);
    var g = this.z.redAdd(o).redSqr().redISub(n).redISub(c);
    return this.curve.jpoint(f, p, g)
};
Rn.prototype.mul = function(e, r) {
    return e = new Et(e, r), this.curve._wnafMul(this, e)
};
Rn.prototype.eq = function(e) {
    if (e.type === "affine") return this.eq(e.toJ());
    if (this === e) return !0;
    var r = this.z.redSqr(),
        n = e.z.redSqr();
    if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0) return !1;
    var i = r.redMul(this.z),
        s = n.redMul(e.z);
    return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0
};
Rn.prototype.eqXToP = function(e) {
    var r = this.z.redSqr(),
        n = e.toRed(this.curve.red).redMul(r);
    if (this.x.cmp(n) === 0) return !0;
    for (var i = e.clone(), s = this.curve.redN.redMul(r);;) {
        if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0) return !1;
        if (n.redIAdd(s), this.x.cmp(n) === 0) return !0
    }
};
Rn.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
};
Rn.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0
};
var Wg = bh(function(t, e) {
        var r = e;
        r.base = $d, r.short = qee, r.mont = null, r.edwards = null
    }),
    zg = bh(function(t, e) {
        var r = e,
            n = ps.assert;

        function i(o) {
            o.type === "short" ? this.curve = new Wg.short(o) : o.type === "edwards" ? this.curve = new Wg.edwards(o) : this.curve = new Wg.mont(o), this.g = this.curve.g, this.n = this.curve.n, this.hash = o.hash, n(this.g.validate(), "Invalid curve"), n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
        }
        r.PresetCurve = i;

        function s(o, c) {
            Object.defineProperty(r, o, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    var l = new i(c);
                    return Object.defineProperty(r, o, {
                        configurable: !0,
                        enumerable: !0,
                        value: l
                    }), l
                }
            })
        }
        s("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: Ya.sha256,
            gRed: !1,
            g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
        }), s("p224", {
            type: "short",
            prime: "p224",
            p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
            b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
            n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
            hash: Ya.sha256,
            gRed: !1,
            g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
        }), s("p256", {
            type: "short",
            prime: null,
            p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
            a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
            b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
            n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
            hash: Ya.sha256,
            gRed: !1,
            g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
        }), s("p384", {
            type: "short",
            prime: null,
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
            a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
            b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
            n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
            hash: Ya.sha384,
            gRed: !1,
            g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
        }), s("p521", {
            type: "short",
            prime: null,
            p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
            a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
            b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
            n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
            hash: Ya.sha512,
            gRed: !1,
            g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
        }), s("curve25519", {
            type: "mont",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "76d06",
            b: "1",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: Ya.sha256,
            gRed: !1,
            g: ["9"]
        }), s("ed25519", {
            type: "edwards",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "-1",
            c: "1",
            d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: Ya.sha256,
            gRed: !1,
            g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
        });
        var a;
        try {
            a = null.crash()
        } catch {
            a = void 0
        }
        s("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: Ya.sha256,
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [{
                a: "3086d221a7d46bcde86c90e49284eb15",
                b: "-e4437ed6010e88286f547fa90abfe4c3"
            }, {
                a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                b: "3086d221a7d46bcde86c90e49284eb15"
            }],
            gRed: !1,
            g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", a]
        })
    });

function rl(t) {
    if (!(this instanceof rl)) return new rl(t);
    this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e = ha.toArray(t.entropy, t.entropyEnc || "hex"),
        r = ha.toArray(t.nonce, t.nonceEnc || "hex"),
        n = ha.toArray(t.pers, t.persEnc || "hex");
    U6(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, n)
}
var SN = rl;
rl.prototype._init = function(e, r, n) {
    var i = e.concat(r).concat(n);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var s = 0; s < this.V.length; s++) this.K[s] = 0, this.V[s] = 1;
    this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656
};
rl.prototype._hmac = function() {
    return new Ya.hmac(this.hash, this.K)
};
rl.prototype._update = function(e) {
    var r = this._hmac().update(this.V).update([0]);
    e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest())
};
rl.prototype.reseed = function(e, r, n, i) {
    typeof r != "string" && (i = n, n = r, r = null), e = ha.toArray(e, r), n = ha.toArray(n, i), U6(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(n || [])), this._reseed = 1
};
rl.prototype.generate = function(e, r, n, i) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
    typeof r != "string" && (i = n, n = r, r = null), n && (n = ha.toArray(n, i || "hex"), this._update(n));
    for (var s = []; s.length < e;) this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
    var a = s.slice(0, e);
    return this._update(n), this._reseed++, ha.encode(a, r)
};
var $3 = ps.assert;

function Zn(t, e) {
    this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc)
}
var B6 = Zn;
Zn.fromPublic = function(e, r, n) {
    return r instanceof Zn ? r : new Zn(e, {
        pub: r,
        pubEnc: n
    })
};
Zn.fromPrivate = function(e, r, n) {
    return r instanceof Zn ? r : new Zn(e, {
        priv: r,
        privEnc: n
    })
};
Zn.prototype.validate = function() {
    var e = this.getPublic();
    return e.isInfinity() ? {
        result: !1,
        reason: "Invalid public key"
    } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
        result: !0,
        reason: null
    } : {
        result: !1,
        reason: "Public key * N != O"
    } : {
        result: !1,
        reason: "Public key is not a point"
    }
};
Zn.prototype.getPublic = function(e, r) {
    return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub
};
Zn.prototype.getPrivate = function(e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv
};
Zn.prototype._importPrivate = function(e, r) {
    this.priv = new Et(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n)
};
Zn.prototype._importPublic = function(e, r) {
    if (e.x || e.y) {
        this.ec.curve.type === "mont" ? $3(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && $3(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
        return
    }
    this.pub = this.ec.curve.decodePoint(e, r)
};
Zn.prototype.derive = function(e) {
    return e.validate() || $3(e.validate(), "public point not validated"), e.mul(this.priv).getX()
};
Zn.prototype.sign = function(e, r, n) {
    return this.ec.sign(e, this, r, n)
};
Zn.prototype.verify = function(e, r, n) {
    return this.ec.verify(e, r, this, void 0, n)
};
Zn.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
};
var Hee = ps.assert;

function X1(t, e) {
    if (t instanceof X1) return t;
    this._importDER(t, e) || (Hee(t.r && t.s, "Signature without r or s"), this.r = new Et(t.r, 16), this.s = new Et(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam)
}
var ey = X1;

function Vee() {
    this.place = 0
}

function r2(t, e) {
    var r = t[e.place++];
    if (!(r & 128)) return r;
    var n = r & 15;
    if (n === 0 || n > 4 || t[e.place] === 0) return !1;
    for (var i = 0, s = 0, a = e.place; s < n; s++, a++) i <<= 8, i |= t[a], i >>>= 0;
    return i <= 127 ? !1 : (e.place = a, i)
}

function n_(t) {
    for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r;) e++;
    return e === 0 ? t : t.slice(e)
}
X1.prototype._importDER = function(e, r) {
    e = ps.toArray(e, r);
    var n = new Vee;
    if (e[n.place++] !== 48) return !1;
    var i = r2(e, n);
    if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2) return !1;
    var s = r2(e, n);
    if (s === !1 || (e[n.place] & 128) !== 0) return !1;
    var a = e.slice(n.place, s + n.place);
    if (n.place += s, e[n.place++] !== 2) return !1;
    var o = r2(e, n);
    if (o === !1 || e.length !== o + n.place || (e[n.place] & 128) !== 0) return !1;
    var c = e.slice(n.place, o + n.place);
    if (a[0] === 0)
        if (a[1] & 128) a = a.slice(1);
        else return !1;
    if (c[0] === 0)
        if (c[1] & 128) c = c.slice(1);
        else return !1;
    return this.r = new Et(a), this.s = new Et(c), this.recoveryParam = null, !0
};

function n2(t, e) {
    if (e < 128) {
        t.push(e);
        return
    }
    var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (t.push(r | 128); --r;) t.push(e >>> (r << 3) & 255);
    t.push(e)
}
X1.prototype.toDER = function(e) {
    var r = this.r.toArray(),
        n = this.s.toArray();
    for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = n_(r), n = n_(n); !n[0] && !(n[1] & 128);) n = n.slice(1);
    var i = [2];
    n2(i, r.length), i = i.concat(r), i.push(2), n2(i, n.length);
    var s = i.concat(n),
        a = [48];
    return n2(a, s.length), a = a.concat(s), ps.encode(a, e)
};
var Gee = function() {
        throw new Error("unsupported")
    },
    Tl = ps.assert;

function js(t) {
    if (!(this instanceof js)) return new js(t);
    typeof t == "string" && (Tl(Object.prototype.hasOwnProperty.call(zg, t), "Unknown curve " + t), t = zg[t]), t instanceof zg.PresetCurve && (t = {
        curve: t
    }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash
}
var Kee = js;
js.prototype.keyPair = function(e) {
    return new B6(this, e)
};
js.prototype.keyFromPrivate = function(e, r) {
    return B6.fromPrivate(this, e, r)
};
js.prototype.keyFromPublic = function(e, r) {
    return B6.fromPublic(this, e, r)
};
js.prototype.genKeyPair = function(e) {
    e || (e = {});
    for (var r = new SN({
            hash: this.hash,
            pers: e.pers,
            persEnc: e.persEnc || "utf8",
            entropy: e.entropy || Gee(this.hash.hmacStrength),
            entropyEnc: e.entropy && e.entropyEnc || "utf8",
            nonce: this.n.toArray()
        }), n = this.n.byteLength(), i = this.n.sub(new Et(2));;) {
        var s = new Et(r.generate(n));
        if (!(s.cmp(i) > 0)) return s.iaddn(1), this.keyFromPrivate(s)
    }
};
js.prototype._truncateToN = function(e, r, n) {
    var i;
    if (Et.isBN(e) || typeof e == "number") e = new Et(e, 16), i = e.byteLength();
    else if (typeof e == "object") i = e.length, e = new Et(e, 16);
    else {
        var s = e.toString();
        i = s.length + 1 >>> 1, e = new Et(s, 16)
    }
    typeof n != "number" && (n = i * 8);
    var a = n - this.n.bitLength();
    return a > 0 && (e = e.ushrn(a)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
};
js.prototype.sign = function(e, r, n, i) {
    if (typeof n == "object" && (i = n, n = null), i || (i = {}), typeof e != "string" && typeof e != "number" && !Et.isBN(e)) {
        Tl(typeof e == "object" && e && typeof e.length == "number", "Expected message to be an array-like, a hex string, or a BN instance"), Tl(e.length >>> 0 === e.length);
        for (var s = 0; s < e.length; s++) Tl((e[s] & 255) === e[s])
    }
    r = this.keyFromPrivate(r, n), e = this._truncateToN(e, !1, i.msgBitLength), Tl(!e.isNeg(), "Can not sign a negative message");
    var a = this.n.byteLength(),
        o = r.getPrivate().toArray("be", a),
        c = e.toArray("be", a);
    Tl(new Et(c).eq(e), "Can not sign message");
    for (var l = new SN({
            hash: this.hash,
            entropy: o,
            nonce: c,
            pers: i.pers,
            persEnc: i.persEnc || "utf8"
        }), u = this.n.sub(new Et(1)), h = 0;; h++) {
        var f = i.k ? i.k(h) : new Et(l.generate(this.n.byteLength()));
        if (f = this._truncateToN(f, !0), !(f.cmpn(1) <= 0 || f.cmp(u) >= 0)) {
            var p = this.g.mul(f);
            if (!p.isInfinity()) {
                var g = p.getX(),
                    m = g.umod(this.n);
                if (m.cmpn(0) !== 0) {
                    var y = f.invm(this.n).mul(m.mul(r.getPrivate()).iadd(e));
                    if (y = y.umod(this.n), y.cmpn(0) !== 0) {
                        var w = (p.getY().isOdd() ? 1 : 0) | (g.cmp(m) !== 0 ? 2 : 0);
                        return i.canonical && y.cmp(this.nh) > 0 && (y = this.n.sub(y), w ^= 1), new ey({
                            r: m,
                            s: y,
                            recoveryParam: w
                        })
                    }
                }
            }
        }
    }
};
js.prototype.verify = function(e, r, n, i, s) {
    s || (s = {}), e = this._truncateToN(e, !1, s.msgBitLength), n = this.keyFromPublic(n, i), r = new ey(r, "hex");
    var a = r.r,
        o = r.s;
    if (a.cmpn(1) < 0 || a.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1;
    var c = o.invm(this.n),
        l = c.mul(e).umod(this.n),
        u = c.mul(a).umod(this.n),
        h;
    return this.curve._maxwellTrick ? (h = this.g.jmulAdd(l, n.getPublic(), u), h.isInfinity() ? !1 : h.eqXToP(a)) : (h = this.g.mulAdd(l, n.getPublic(), u), h.isInfinity() ? !1 : h.getX().umod(this.n).cmp(a) === 0)
};
js.prototype.recoverPubKey = function(t, e, r, n) {
    Tl((3 & r) === r, "The recovery param is more than two bits"), e = new ey(e, n);
    var i = this.n,
        s = new Et(t),
        a = e.r,
        o = e.s,
        c = r & 1,
        l = r >> 1;
    if (a.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l) throw new Error("Unable to find sencond key candinate");
    l ? a = this.curve.pointFromX(a.add(this.curve.n), c) : a = this.curve.pointFromX(a, c);
    var u = e.r.invm(i),
        h = i.sub(s).mul(u).umod(i),
        f = o.mul(u).umod(i);
    return this.g.mulAdd(h, a, f)
};
js.prototype.getKeyRecoveryParam = function(t, e, r, n) {
    if (e = new ey(e, n), e.recoveryParam !== null) return e.recoveryParam;
    for (var i = 0; i < 4; i++) {
        var s;
        try {
            s = this.recoverPubKey(t, e, i)
        } catch {
            continue
        }
        if (s.eq(r)) return i
    }
    throw new Error("Unable to find valid recovery factor")
};
var Yee = bh(function(t, e) {
        var r = e;
        r.version = "6.6.1", r.utils = ps, r.rand = function() {
            throw new Error("unsupported")
        }, r.curve = Wg, r.curves = zg, r.ec = Kee, r.eddsa = null
    }),
    Zee = Yee.ec;
const Jee = "signing-key/5.8.0",
    S3 = new pe(Jee);
let i2 = null;

function Oc() {
    return i2 || (i2 = new Zee("secp256k1")), i2
}
class Qee {
    constructor(e) {
        zt(this, "curve", "secp256k1"), zt(this, "privateKey", Tt(e)), ud(this.privateKey) !== 32 && S3.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        const r = Oc().keyFromPrivate(Pt(this.privateKey));
        zt(this, "publicKey", "0x" + r.getPublic(!1, "hex")), zt(this, "compressedPublicKey", "0x" + r.getPublic(!0, "hex")), zt(this, "_isSigningKey", !0)
    }
    _addPoint(e) {
        const r = Oc().keyFromPublic(Pt(this.publicKey)),
            n = Oc().keyFromPublic(Pt(e));
        return "0x" + r.pub.add(n.pub).encodeCompressed("hex")
    }
    signDigest(e) {
        const r = Oc().keyFromPrivate(Pt(this.privateKey)),
            n = Pt(e);
        n.length !== 32 && S3.throwArgumentError("bad digest length", "digest", e);
        const i = r.sign(n, {
            canonical: !0
        });
        return K1({
            recoveryParam: i.recoveryParam,
            r: Mr("0x" + i.r.toString(16), 32),
            s: Mr("0x" + i.s.toString(16), 32)
        })
    }
    computeSharedSecret(e) {
        const r = Oc().keyFromPrivate(Pt(this.privateKey)),
            n = Oc().keyFromPublic(Pt(TN(e)));
        return Mr("0x" + r.derive(n.getPublic()).toString(16), 32)
    }
    static isSigningKey(e) {
        return !!(e && e._isSigningKey)
    }
}

function Xee(t, e) {
    const r = K1(e),
        n = {
            r: Pt(r.r),
            s: Pt(r.s)
        };
    return "0x" + Oc().recoverPubKey(Pt(t), n, r.recoveryParam).encode("hex", !1)
}

function TN(t, e) {
    const r = Pt(t);
    return r.length === 32 ? new Qee(r).publicKey : r.length === 33 ? "0x" + Oc().keyFromPublic(r).getPublic(!1, "hex") : r.length === 65 ? Tt(r) : S3.throwArgumentError("invalid public or private key", "key", "[REDACTED]")
}
const ete = "transactions/5.8.0",
    pc = new pe(ete);
var i_;
(function(t) {
    t[t.legacy = 0] = "legacy", t[t.eip2930 = 1] = "eip2930", t[t.eip1559 = 2] = "eip1559"
})(i_ || (i_ = {}));

function W6(t) {
    return t === "0x" ? null : Ea(t)
}

function Gn(t) {
    return t === "0x" ? TX : Fe.from(t)
}

function tte(t) {
    const e = TN(t);
    return Ea(ii(Tn(ii(e, 1)), 12))
}

function PN(t, e) {
    return tte(Xee(Pt(t), e))
}

function Xi(t, e) {
    const r = eh(Fe.from(t).toHexString());
    return r.length > 32 && pc.throwArgumentError("invalid length for " + e, "transaction:" + e, t), r
}

function s2(t, e) {
    return {
        address: Ea(t),
        storageKeys: (e || []).map((r, n) => (ud(r) !== 32 && pc.throwArgumentError("invalid access list storageKey", `accessList[${t}:${n}]`, r), r.toLowerCase()))
    }
}

function c0(t) {
    if (Array.isArray(t)) return t.map((r, n) => Array.isArray(r) ? (r.length > 2 && pc.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${n}]`, r), s2(r[0], r[1])) : s2(r.address, r.storageKeys));
    const e = Object.keys(t).map(r => {
        const n = t[r].reduce((i, s) => (i[s] = !0, i), {});
        return s2(r, Object.keys(n).sort())
    });
    return e.sort((r, n) => r.address.localeCompare(n.address)), e
}

function NN(t) {
    return c0(t).map(e => [e.address, e.storageKeys])
}

function rte(t, e) {
    if (t.gasPrice != null) {
        const n = Fe.from(t.gasPrice),
            i = Fe.from(t.maxFeePerGas || 0);
        n.eq(i) || pc.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
            gasPrice: n,
            maxFeePerGas: i
        })
    }
    const r = [Xi(t.chainId || 0, "chainId"), Xi(t.nonce || 0, "nonce"), Xi(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), Xi(t.maxFeePerGas || 0, "maxFeePerGas"), Xi(t.gasLimit || 0, "gasLimit"), t.to != null ? Ea(t.to) : "0x", Xi(t.value || 0, "value"), t.data || "0x", NN(t.accessList || [])];
    if (e) {
        const n = K1(e);
        r.push(Xi(n.recoveryParam, "recoveryParam")), r.push(eh(n.r)), r.push(eh(n.s))
    }
    return rs(["0x02", J1(r)])
}

function nte(t, e) {
    const r = [Xi(t.chainId || 0, "chainId"), Xi(t.nonce || 0, "nonce"), Xi(t.gasPrice || 0, "gasPrice"), Xi(t.gasLimit || 0, "gasLimit"), t.to != null ? Ea(t.to) : "0x", Xi(t.value || 0, "value"), t.data || "0x", NN(t.accessList || [])];
    if (e) {
        const n = K1(e);
        r.push(Xi(n.recoveryParam, "recoveryParam")), r.push(eh(n.r)), r.push(eh(n.s))
    }
    return rs(["0x01", J1(r)])
}

function ON(t, e, r) {
    try {
        const n = Gn(e[0]).toNumber();
        if (n !== 0 && n !== 1) throw new Error("bad recid");
        t.v = n
    } catch {
        pc.throwArgumentError("invalid v for transaction type: 1", "v", e[0])
    }
    t.r = Mr(e[1], 32), t.s = Mr(e[2], 32);
    try {
        const n = Tn(r(t));
        t.from = PN(n, {
            r: t.r,
            s: t.s,
            recoveryParam: t.v
        })
    } catch {}
}

function ite(t) {
    const e = M6(t.slice(1));
    e.length !== 9 && e.length !== 12 && pc.throwArgumentError("invalid component count for transaction type: 2", "payload", Tt(t));
    const r = Gn(e[2]),
        n = Gn(e[3]),
        i = {
            type: 2,
            chainId: Gn(e[0]).toNumber(),
            nonce: Gn(e[1]).toNumber(),
            maxPriorityFeePerGas: r,
            maxFeePerGas: n,
            gasPrice: null,
            gasLimit: Gn(e[4]),
            to: W6(e[5]),
            value: Gn(e[6]),
            data: e[7],
            accessList: c0(e[8])
        };
    return e.length === 9 || (i.hash = Tn(t), ON(i, e.slice(9), rte)), i
}

function ste(t) {
    const e = M6(t.slice(1));
    e.length !== 8 && e.length !== 11 && pc.throwArgumentError("invalid component count for transaction type: 1", "payload", Tt(t));
    const r = {
        type: 1,
        chainId: Gn(e[0]).toNumber(),
        nonce: Gn(e[1]).toNumber(),
        gasPrice: Gn(e[2]),
        gasLimit: Gn(e[3]),
        to: W6(e[4]),
        value: Gn(e[5]),
        data: e[6],
        accessList: c0(e[7])
    };
    return e.length === 8 || (r.hash = Tn(t), ON(r, e.slice(8), nte)), r
}

function ate(t) {
    const e = M6(t);
    e.length !== 9 && e.length !== 6 && pc.throwArgumentError("invalid raw transaction", "rawTransaction", t);
    const r = {
        nonce: Gn(e[0]).toNumber(),
        gasPrice: Gn(e[1]),
        gasLimit: Gn(e[2]),
        to: W6(e[3]),
        value: Gn(e[4]),
        data: e[5],
        chainId: 0
    };
    if (e.length === 6) return r;
    try {
        r.v = Fe.from(e[6]).toNumber()
    } catch {
        return r
    }
    if (r.r = Mr(e[7], 32), r.s = Mr(e[8], 32), Fe.from(r.r).isZero() && Fe.from(r.s).isZero()) r.chainId = r.v, r.v = 0;
    else {
        r.chainId = Math.floor((r.v - 35) / 2), r.chainId < 0 && (r.chainId = 0);
        let n = r.v - 27;
        const i = e.slice(0, 6);
        r.chainId !== 0 && (i.push(Tt(r.chainId)), i.push("0x"), i.push("0x"), n -= r.chainId * 2 + 8);
        const s = Tn(J1(i));
        try {
            r.from = PN(s, {
                r: Tt(r.r),
                s: Tt(r.s),
                recoveryParam: n
            })
        } catch {}
        r.hash = Tn(t)
    }
    return r.type = null, r
}

function ote(t) {
    const e = Pt(t);
    if (e[0] > 127) return ate(e);
    switch (e[0]) {
        case 1:
            return ste(e);
        case 2:
            return ite(e)
    }
    return pc.throwError(`unsupported transaction type: ${e[0]}`, pe.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: e[0]
    })
}
const Wh = new pe(Q1);
class et {
    constructor() {
        this.formats = this.getDefaultFormats()
    }
    getDefaultFormats() {
        const e = {},
            r = this.address.bind(this),
            n = this.bigNumber.bind(this),
            i = this.blockTag.bind(this),
            s = this.data.bind(this),
            a = this.hash.bind(this),
            o = this.hex.bind(this),
            c = this.number.bind(this),
            l = this.type.bind(this),
            u = h => this.data(h, !0);
        return e.transaction = {
            hash: a,
            type: l,
            accessList: et.allowNull(this.accessList.bind(this), null),
            blockHash: et.allowNull(a, null),
            blockNumber: et.allowNull(c, null),
            transactionIndex: et.allowNull(c, null),
            confirmations: et.allowNull(c, null),
            from: r,
            gasPrice: et.allowNull(n),
            maxPriorityFeePerGas: et.allowNull(n),
            maxFeePerGas: et.allowNull(n),
            gasLimit: n,
            to: et.allowNull(r, null),
            value: n,
            nonce: c,
            data: s,
            r: et.allowNull(this.uint256),
            s: et.allowNull(this.uint256),
            v: et.allowNull(c),
            creates: et.allowNull(r, null),
            raw: et.allowNull(s)
        }, e.transactionRequest = {
            from: et.allowNull(r),
            nonce: et.allowNull(c),
            gasLimit: et.allowNull(n),
            gasPrice: et.allowNull(n),
            maxPriorityFeePerGas: et.allowNull(n),
            maxFeePerGas: et.allowNull(n),
            to: et.allowNull(r),
            value: et.allowNull(n),
            data: et.allowNull(u),
            type: et.allowNull(c),
            accessList: et.allowNull(this.accessList.bind(this), null)
        }, e.receiptLog = {
            transactionIndex: c,
            blockNumber: c,
            transactionHash: a,
            address: r,
            topics: et.arrayOf(a),
            data: s,
            logIndex: c,
            blockHash: a
        }, e.receipt = {
            to: et.allowNull(this.address, null),
            from: et.allowNull(this.address, null),
            contractAddress: et.allowNull(r, null),
            transactionIndex: c,
            root: et.allowNull(o),
            gasUsed: n,
            logsBloom: et.allowNull(s),
            blockHash: a,
            transactionHash: a,
            logs: et.arrayOf(this.receiptLog.bind(this)),
            blockNumber: c,
            confirmations: et.allowNull(c, null),
            cumulativeGasUsed: n,
            effectiveGasPrice: et.allowNull(n),
            status: et.allowNull(c),
            type: l
        }, e.block = {
            hash: et.allowNull(a),
            parentHash: a,
            number: c,
            timestamp: c,
            nonce: et.allowNull(o),
            difficulty: this.difficulty.bind(this),
            gasLimit: n,
            gasUsed: n,
            miner: et.allowNull(r),
            extraData: s,
            transactions: et.allowNull(et.arrayOf(a)),
            baseFeePerGas: et.allowNull(n)
        }, e.blockWithTransactions = ji(e.block), e.blockWithTransactions.transactions = et.allowNull(et.arrayOf(this.transactionResponse.bind(this))), e.filter = {
            fromBlock: et.allowNull(i, void 0),
            toBlock: et.allowNull(i, void 0),
            blockHash: et.allowNull(a, void 0),
            address: et.allowNull(r, void 0),
            topics: et.allowNull(this.topics.bind(this), void 0)
        }, e.filterLog = {
            blockNumber: et.allowNull(c),
            blockHash: et.allowNull(a),
            transactionIndex: c,
            removed: et.allowNull(this.boolean.bind(this)),
            address: r,
            data: et.allowFalsish(s, "0x"),
            topics: et.arrayOf(a),
            transactionHash: a,
            logIndex: c
        }, e
    }
    accessList(e) {
        return c0(e || [])
    }
    number(e) {
        return e === "0x" ? 0 : Fe.from(e).toNumber()
    }
    type(e) {
        return e === "0x" || e == null ? 0 : Fe.from(e).toNumber()
    }
    bigNumber(e) {
        return Fe.from(e)
    }
    boolean(e) {
        if (typeof e == "boolean") return e;
        if (typeof e == "string") {
            if (e = e.toLowerCase(), e === "true") return !0;
            if (e === "false") return !1
        }
        throw new Error("invalid boolean - " + e)
    }
    hex(e, r) {
        return typeof e == "string" && (!r && e.substring(0, 2) !== "0x" && (e = "0x" + e), pr(e)) ? e.toLowerCase() : Wh.throwArgumentError("invalid hash", "value", e)
    }
    data(e, r) {
        const n = this.hex(e, r);
        if (n.length % 2 !== 0) throw new Error("invalid data; odd-length - " + e);
        return n
    }
    address(e) {
        return Ea(e)
    }
    callAddress(e) {
        if (!pr(e, 32)) return null;
        const r = Ea(ii(e, 12));
        return r === SX ? null : r
    }
    contractAddress(e) {
        return mee(e)
    }
    blockTag(e) {
        if (e == null) return "latest";
        if (e === "earliest") return "0x0";
        switch (e) {
            case "earliest":
                return "0x0";
            case "latest":
            case "pending":
            case "safe":
            case "finalized":
                return e
        }
        if (typeof e == "number" || pr(e)) return O6(e);
        throw new Error("invalid blockTag")
    }
    hash(e, r) {
        const n = this.hex(e, r);
        return ud(n) !== 32 ? Wh.throwArgumentError("invalid hash", "value", e) : n
    }
    difficulty(e) {
        if (e == null) return null;
        const r = Fe.from(e);
        try {
            return r.toNumber()
        } catch {}
        return null
    }
    uint256(e) {
        if (!pr(e)) throw new Error("invalid uint256");
        return Mr(e, 32)
    }
    _block(e, r) {
        e.author != null && e.miner == null && (e.miner = e.author);
        const n = e._difficulty != null ? e._difficulty : e.difficulty,
            i = et.check(r, e);
        return i._difficulty = n == null ? null : Fe.from(n), i
    }
    block(e) {
        return this._block(e, this.formats.block)
    }
    blockWithTransactions(e) {
        return this._block(e, this.formats.blockWithTransactions)
    }
    transactionRequest(e) {
        return et.check(this.formats.transactionRequest, e)
    }
    transactionResponse(e) {
        e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas), e.to && Fe.from(e.to).isZero() && (e.to = "0x0000000000000000000000000000000000000000"), e.input != null && e.data == null && (e.data = e.input), e.to == null && e.creates == null && (e.creates = this.contractAddress(e)), (e.type === 1 || e.type === 2) && e.accessList == null && (e.accessList = []);
        const r = et.check(this.formats.transaction, e);
        if (e.chainId != null) {
            let n = e.chainId;
            pr(n) && (n = Fe.from(n).toNumber()), r.chainId = n
        } else {
            let n = e.networkId;
            n == null && r.v == null && (n = e.chainId), pr(n) && (n = Fe.from(n).toNumber()), typeof n != "number" && r.v != null && (n = (r.v - 35) / 2, n < 0 && (n = 0), n = parseInt(n)), typeof n != "number" && (n = 0), r.chainId = n
        }
        return r.blockHash && r.blockHash.replace(/0/g, "") === "x" && (r.blockHash = null), r
    }
    transaction(e) {
        return ote(e)
    }
    receiptLog(e) {
        return et.check(this.formats.receiptLog, e)
    }
    receipt(e) {
        const r = et.check(this.formats.receipt, e);
        if (r.root != null)
            if (r.root.length <= 4) {
                const n = Fe.from(r.root).toNumber();
                n === 0 || n === 1 ? (r.status != null && r.status !== n && Wh.throwArgumentError("alt-root-status/status mismatch", "value", {
                    root: r.root,
                    status: r.status
                }), r.status = n, delete r.root) : Wh.throwArgumentError("invalid alt-root-status", "value.root", r.root)
            } else r.root.length !== 66 && Wh.throwArgumentError("invalid root hash", "value.root", r.root);
        return r.status != null && (r.byzantium = !0), r
    }
    topics(e) {
        return Array.isArray(e) ? e.map(r => this.topics(r)) : e != null ? this.hash(e, !0) : null
    }
    filter(e) {
        return et.check(this.formats.filter, e)
    }
    filterLog(e) {
        return et.check(this.formats.filterLog, e)
    }
    static check(e, r) {
        const n = {};
        for (const i in e) try {
            const s = e[i](r[i]);
            s !== void 0 && (n[i] = s)
        } catch (s) {
            throw s.checkKey = i, s.checkValue = r[i], s
        }
        return n
    }
    static allowNull(e, r) {
        return function(n) {
            return n == null ? r : e(n)
        }
    }
    static allowFalsish(e, r) {
        return function(n) {
            return n ? e(n) : r
        }
    }
    static arrayOf(e) {
        return function(r) {
            if (!Array.isArray(r)) throw new Error("not an array");
            const n = [];
            return r.forEach(function(i) {
                n.push(e(i))
            }), n
        }
    }
}
var At = function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(a) {
            a(s)
        })
    }
    return new(r || (r = Promise))(function(s, a) {
        function o(u) {
            try {
                l(n.next(u))
            } catch (h) {
                a(h)
            }
        }

        function c(u) {
            try {
                l(n.throw(u))
            } catch (h) {
                a(h)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(o, c)
        }
        l((n = n.apply(t, e || [])).next())
    })
};
const Dt = new pe(Q1),
    cte = 10;

function s_(t) {
    return t == null ? "null" : (ud(t) !== 32 && Dt.throwArgumentError("invalid topic", "topic", t), t.toLowerCase())
}

function a_(t) {
    for (t = t.slice(); t.length > 0 && t[t.length - 1] == null;) t.pop();
    return t.map(e => {
        if (Array.isArray(e)) {
            const r = {};
            e.forEach(i => {
                r[s_(i)] = !0
            });
            const n = Object.keys(r);
            return n.sort(), n.join("|")
        } else return s_(e)
    }).join("&")
}

function lte(t) {
    return t === "" ? [] : t.split(/&/g).map(e => {
        if (e === "") return [];
        const r = e.split("|").map(n => n === "null" ? null : n);
        return r.length === 1 ? r[0] : r
    })
}

function Zd(t) {
    if (typeof t == "string") {
        if (t = t.toLowerCase(), ud(t) === 32) return "tx:" + t;
        if (t.indexOf(":") === -1) return t
    } else {
        if (Array.isArray(t)) return "filter:*:" + a_(t);
        if (AX.isForkEvent(t)) throw Dt.warn("not implemented"), new Error("not implemented");
        if (t && typeof t == "object") return "filter:" + (t.address || "*") + ":" + a_(t.topics || [])
    }
    throw new Error("invalid event - " + t)
}

function zh() {
    return new Date().getTime()
}

function o_(t) {
    return new Promise(e => {
        setTimeout(e, t)
    })
}
const dte = ["block", "network", "pending", "poll"];
let ute = class {
    constructor(e, r, n) {
        zt(this, "tag", e), zt(this, "listener", r), zt(this, "once", n), this._lastBlockNumber = -2, this._inflight = !1
    }
    get event() {
        switch (this.type) {
            case "tx":
                return this.hash;
            case "filter":
                return this.filter
        }
        return this.tag
    }
    get type() {
        return this.tag.split(":")[0]
    }
    get hash() {
        const e = this.tag.split(":");
        return e[0] !== "tx" ? null : e[1]
    }
    get filter() {
        const e = this.tag.split(":");
        if (e[0] !== "filter") return null;
        const r = e[1],
            n = lte(e[2]),
            i = {};
        return n.length > 0 && (i.topics = n), r && r !== "*" && (i.address = r), i
    }
    pollable() {
        return this.tag.indexOf(":") >= 0 || dte.indexOf(this.tag) >= 0
    }
};
const hte = {
    0: {
        symbol: "btc",
        p2pkh: 0,
        p2sh: 5,
        prefix: "bc"
    },
    2: {
        symbol: "ltc",
        p2pkh: 48,
        p2sh: 50,
        prefix: "ltc"
    },
    3: {
        symbol: "doge",
        p2pkh: 30,
        p2sh: 22
    },
    60: {
        symbol: "eth",
        ilk: "eth"
    },
    61: {
        symbol: "etc",
        ilk: "eth"
    },
    700: {
        symbol: "xdai",
        ilk: "eth"
    }
};

function a2(t) {
    return Mr(Fe.from(t).toHexString(), 32)
}

function c_(t) {
    return I3.encode(Ul([t, ii(X7(X7(t)), 0, 4)]))
}
const jN = new RegExp("^(ipfs)://(.*)$", "i"),
    l_ = [new RegExp("^(https)://(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), jN, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];

function qg(t, e) {
    try {
        return Y1(Cp(t, e))
    } catch {}
    return null
}

function Cp(t, e) {
    if (t === "0x") return null;
    const r = Fe.from(ii(t, e, e + 32)).toNumber(),
        n = Fe.from(ii(t, r, r + 32)).toNumber();
    return ii(t, r + 32, r + 32 + n)
}

function o2(t) {
    return t.match(/^ipfs:\/\/ipfs\//i) ? t = t.substring(12) : t.match(/^ipfs:\/\//i) ? t = t.substring(7) : Dt.throwArgumentError("unsupported IPFS format", "link", t), `https://gateway.ipfs.io/ipfs/${t}`
}

function d_(t) {
    const e = Pt(t);
    if (e.length > 32) throw new Error("internal; should not happen");
    const r = new Uint8Array(32);
    return r.set(e, 32 - e.length), r
}

function fte(t) {
    if (t.length % 32 === 0) return t;
    const e = new Uint8Array(Math.ceil(t.length / 32) * 32);
    return e.set(t), e
}

function RN(t) {
    const e = [];
    let r = 0;
    for (let n = 0; n < t.length; n++) e.push(null), r += 32;
    for (let n = 0; n < t.length; n++) {
        const i = Pt(t[n]);
        e[n] = d_(r), e.push(d_(i.length)), e.push(fte(i)), r += 32 + Math.ceil(i.length / 32) * 32
    }
    return rs(e)
}
class u_ {
    constructor(e, r, n, i) {
        zt(this, "provider", e), zt(this, "name", n), zt(this, "address", e.formatter.address(r)), zt(this, "_resolvedAddress", i)
    }
    supportsWildcard() {
        return this._supportsEip2544 || (this._supportsEip2544 = this.provider.call({
            to: this.address,
            data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
        }).then(e => Fe.from(e).eq(1)).catch(e => {
            if (e.code === pe.errors.CALL_EXCEPTION) return !1;
            throw this._supportsEip2544 = null, e
        })), this._supportsEip2544
    }
    _fetch(e, r) {
        return At(this, void 0, void 0, function*() {
            const n = {
                to: this.address,
                ccipReadEnabled: !0,
                data: rs([e, Bg(this.name), r || "0x"])
            };
            let i = !1;
            (yield this.supportsWildcard()) && (i = !0, n.data = rs(["0x9061b923", RN([dee(this.name), n.data])]));
            try {
                let s = yield this.provider.call(n);
                return Pt(s).length % 32 === 4 && Dt.throwError("resolver threw error", pe.errors.CALL_EXCEPTION, {
                    transaction: n,
                    data: s
                }), i && (s = Cp(s, 0)), s
            } catch (s) {
                if (s.code === pe.errors.CALL_EXCEPTION) return null;
                throw s
            }
        })
    }
    _fetchBytes(e, r) {
        return At(this, void 0, void 0, function*() {
            const n = yield this._fetch(e, r);
            return n != null ? Cp(n, 0) : null
        })
    }
    _getAddress(e, r) {
        const n = hte[String(e)];
        if (n == null && Dt.throwError(`unsupported coin type: ${e}`, pe.errors.UNSUPPORTED_OPERATION, {
                operation: `getAddress(${e})`
            }), n.ilk === "eth") return this.provider.formatter.address(r);
        const i = Pt(r);
        if (n.p2pkh != null) {
            const s = r.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
            if (s) {
                const a = parseInt(s[1], 16);
                if (s[2].length === a * 2 && a >= 1 && a <= 75) return c_(Ul([
                    [n.p2pkh], "0x" + s[2]
                ]))
            }
        }
        if (n.p2sh != null) {
            const s = r.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
            if (s) {
                const a = parseInt(s[1], 16);
                if (s[2].length === a * 2 && a >= 1 && a <= 75) return c_(Ul([
                    [n.p2sh], "0x" + s[2]
                ]))
            }
        }
        if (n.prefix != null) {
            const s = i[1];
            let a = i[0];
            if (a === 0 ? s !== 20 && s !== 32 && (a = -1) : a = -1, a >= 0 && i.length === 2 + s && s >= 1 && s <= 75) {
                const o = r_.toWords(i.slice(2));
                return o.unshift(a), r_.encode(n.prefix, o)
            }
        }
        return null
    }
    getAddress(e) {
        return At(this, void 0, void 0, function*() {
            if (e == null && (e = 60), e === 60) try {
                const i = yield this._fetch("0x3b3b57de");
                return i === "0x" || i === PX ? null : this.provider.formatter.callAddress(i)
            } catch (i) {
                if (i.code === pe.errors.CALL_EXCEPTION) return null;
                throw i
            }
            const r = yield this._fetchBytes("0xf1cb7e06", a2(e));
            if (r == null || r === "0x") return null;
            const n = this._getAddress(e, r);
            return n == null && Dt.throwError("invalid or unsupported coin data", pe.errors.UNSUPPORTED_OPERATION, {
                operation: `getAddress(${e})`,
                coinType: e,
                data: r
            }), n
        })
    }
    getAvatar() {
        return At(this, void 0, void 0, function*() {
            const e = [{
                type: "name",
                content: this.name
            }];
            try {
                const r = yield this.getText("avatar");
                if (r == null) return null;
                for (let n = 0; n < l_.length; n++) {
                    const i = r.match(l_[n]);
                    if (i == null) continue;
                    const s = i[1].toLowerCase();
                    switch (s) {
                        case "https":
                            return e.push({
                                type: "url",
                                content: r
                            }), {
                                linkage: e,
                                url: r
                            };
                        case "data":
                            return e.push({
                                type: "data",
                                content: r
                            }), {
                                linkage: e,
                                url: r
                            };
                        case "ipfs":
                            return e.push({
                                type: "ipfs",
                                content: r
                            }), {
                                linkage: e,
                                url: o2(r)
                            };
                        case "erc721":
                        case "erc1155":
                            {
                                const a = s === "erc721" ? "0xc87b56dd" : "0x0e89341c";e.push({
                                    type: s,
                                    content: r
                                });
                                const o = this._resolvedAddress || (yield this.getAddress()),
                                    c = (i[2] || "").split("/");
                                if (c.length !== 2) return null;
                                const l = yield this.provider.formatter.address(c[0]), u = Mr(Fe.from(c[1]).toHexString(), 32);
                                if (s === "erc721") {
                                    const m = this.provider.formatter.callAddress(yield this.provider.call({
                                        to: l,
                                        data: rs(["0x6352211e", u])
                                    }));
                                    if (o !== m) return null;
                                    e.push({
                                        type: "owner",
                                        content: m
                                    })
                                } else if (s === "erc1155") {
                                    const m = Fe.from(yield this.provider.call({
                                        to: l,
                                        data: rs(["0x00fdd58e", Mr(o, 32), u])
                                    }));
                                    if (m.isZero()) return null;
                                    e.push({
                                        type: "balance",
                                        content: m.toString()
                                    })
                                }
                                const h = {
                                    to: this.provider.formatter.address(c[0]),
                                    data: rs([a, u])
                                };
                                let f = qg(yield this.provider.call(h), 0);
                                if (f == null) return null;e.push({
                                    type: "metadata-url-base",
                                    content: f
                                }),
                                s === "erc1155" && (f = f.replace("{id}", u.substring(2)), e.push({
                                    type: "metadata-url-expanded",
                                    content: f
                                })),
                                f.match(/^ipfs:/i) && (f = o2(f)),
                                e.push({
                                    type: "metadata-url",
                                    content: f
                                });
                                const p = yield L6(f);
                                if (!p) return null;e.push({
                                    type: "metadata",
                                    content: JSON.stringify(p)
                                });
                                let g = p.image;
                                if (typeof g != "string") return null;
                                if (!g.match(/^(https:\/\/|data:)/i)) {
                                    if (g.match(jN) == null) return null;
                                    e.push({
                                        type: "url-ipfs",
                                        content: g
                                    }), g = o2(g)
                                }
                                return e.push({
                                    type: "url",
                                    content: g
                                }),
                                {
                                    linkage: e,
                                    url: g
                                }
                            }
                    }
                }
            } catch {}
            return null
        })
    }
    getContentHash() {
        return At(this, void 0, void 0, function*() {
            const e = yield this._fetchBytes("0xbc1c58d1");
            if (e == null || e === "0x") return null;
            const r = e.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (r) {
                const a = parseInt(r[3], 16);
                if (r[4].length === a * 2) return "ipfs://" + I3.encode("0x" + r[1])
            }
            const n = e.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (n) {
                const a = parseInt(n[3], 16);
                if (n[4].length === a * 2) return "ipns://" + I3.encode("0x" + n[1])
            }
            const i = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (i && i[1].length === 32 * 2) return "bzz://" + i[1];
            const s = e.match(/^0x90b2c605([0-9a-f]*)$/);
            if (s && s[1].length === 34 * 2) {
                const a = {
                    "=": "",
                    "+": "-",
                    "/": "_"
                };
                return "sia://" + oN("0x" + s[1]).replace(/[=+\/]/g, c => a[c])
            }
            return Dt.throwError("invalid or unsupported content hash data", pe.errors.UNSUPPORTED_OPERATION, {
                operation: "getContentHash()",
                data: e
            })
        })
    }
    getText(e) {
        return At(this, void 0, void 0, function*() {
            let r = ic(e);
            r = Ul([a2(64), a2(r.length), r]), r.length % 32 !== 0 && (r = Ul([r, Mr("0x", 32 - e.length % 32)]));
            const n = yield this._fetchBytes("0x59d1d43c", Tt(r));
            return n == null || n === "0x" ? null : Y1(n)
        })
    }
}
let c2 = null,
    pte = 1;
class gte extends R6 {
    constructor(e) {
        if (super(), this._events = [], this._emitted = {
                block: -2
            }, this.disableCcipRead = !1, this.formatter = new.target.getFormatter(), zt(this, "anyNetwork", e === "any"), this.anyNetwork && (e = this.detectNetwork()), e instanceof Promise) this._networkPromise = e, e.catch(r => {}), this._ready().catch(r => {});
        else {
            const r = vf(new.target, "getNetwork")(e);
            r ? (zt(this, "_network", r), this.emit("network", r, null)) : Dt.throwArgumentError("invalid network", "network", e)
        }
        this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._maxFilterBlockRange = 10, this._pollingInterval = 4e3, this._fastQueryDate = 0
    }
    _ready() {
        return At(this, void 0, void 0, function*() {
            if (this._network == null) {
                let e = null;
                if (this._networkPromise) try {
                    e = yield this._networkPromise
                } catch {}
                e == null && (e = yield this.detectNetwork()), e || Dt.throwError("no network detected", pe.errors.UNKNOWN_ERROR, {}), this._network == null && (this.anyNetwork ? this._network = e : zt(this, "_network", e), this.emit("network", e, null))
            }
            return this._network
        })
    }
    get ready() {
        return xf(() => this._ready().then(e => e, e => {
            if (!(e.code === pe.errors.NETWORK_ERROR && e.event === "noNetwork")) throw e
        }))
    }
    static getFormatter() {
        return c2 == null && (c2 = new et), c2
    }
    static getNetwork(e) {
        return $X(e ? ? "homestead")
    }
    ccipReadFetch(e, r, n) {
        return At(this, void 0, void 0, function*() {
            if (this.disableCcipRead || n.length === 0) return null;
            const i = e.to.toLowerCase(),
                s = r.toLowerCase(),
                a = [];
            for (let o = 0; o < n.length; o++) {
                const c = n[o],
                    l = c.replace("{sender}", i).replace("{data}", s),
                    u = c.indexOf("{data}") >= 0 ? null : JSON.stringify({
                        data: s,
                        sender: i
                    }),
                    h = yield L6({
                        url: l,
                        errorPassThrough: !0
                    }, u, (p, g) => (p.status = g.statusCode, p));
                if (h.data) return h.data;
                const f = h.message || "unknown error";
                if (h.status >= 400 && h.status < 500) return Dt.throwError(`response not found during CCIP fetch: ${f}`, pe.errors.SERVER_ERROR, {
                    url: c,
                    errorMessage: f
                });
                a.push(f)
            }
            return Dt.throwError(`error encountered during CCIP fetch: ${a.map(o=>JSON.stringify(o)).join(", ")}`, pe.errors.SERVER_ERROR, {
                urls: n,
                errorMessages: a
            })
        })
    }
    _getInternalBlockNumber(e) {
        return At(this, void 0, void 0, function*() {
            if (yield this._ready(), e > 0)
                for (; this._internalBlockNumber;) {
                    const i = this._internalBlockNumber;
                    try {
                        const s = yield i;
                        if (zh() - s.respTime <= e) return s.blockNumber;
                        break
                    } catch {
                        if (this._internalBlockNumber === i) break
                    }
                }
            const r = zh(),
                n = An({
                    blockNumber: this.perform("getBlockNumber", {}),
                    networkError: this.getNetwork().then(i => null, i => i)
                }).then(({
                    blockNumber: i,
                    networkError: s
                }) => {
                    if (s) throw this._internalBlockNumber === n && (this._internalBlockNumber = null), s;
                    const a = zh();
                    return i = Fe.from(i).toNumber(), i < this._maxInternalBlockNumber && (i = this._maxInternalBlockNumber), this._maxInternalBlockNumber = i, this._setFastBlockNumber(i), {
                        blockNumber: i,
                        reqTime: r,
                        respTime: a
                    }
                });
            return this._internalBlockNumber = n, n.catch(i => {
                this._internalBlockNumber === n && (this._internalBlockNumber = null)
            }), (yield n).blockNumber
        })
    }
    poll() {
        return At(this, void 0, void 0, function*() {
            const e = pte++,
                r = [];
            let n = null;
            try {
                n = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2)
            } catch (i) {
                this.emit("error", i);
                return
            }
            if (this._setFastBlockNumber(n), this.emit("poll", e, n), n === this._lastBlockNumber) {
                this.emit("didPoll", e);
                return
            }
            if (this._emitted.block === -2 && (this._emitted.block = n - 1), Math.abs(this._emitted.block - n) > 1e3) Dt.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${n})`), this.emit("error", Dt.makeError("network block skew detected", pe.errors.NETWORK_ERROR, {
                blockNumber: n,
                event: "blockSkew",
                previousBlockNumber: this._emitted.block
            })), this.emit("block", n);
            else
                for (let i = this._emitted.block + 1; i <= n; i++) this.emit("block", i);
            this._emitted.block !== n && (this._emitted.block = n, Object.keys(this._emitted).forEach(i => {
                if (i === "block") return;
                const s = this._emitted[i];
                s !== "pending" && n - s > 12 && delete this._emitted[i]
            })), this._lastBlockNumber === -2 && (this._lastBlockNumber = n - 1), this._events.forEach(i => {
                switch (i.type) {
                    case "tx":
                        {
                            const s = i.hash;
                            let a = this.getTransactionReceipt(s).then(o => (!o || o.blockNumber == null || (this._emitted["t:" + s] = o.blockNumber, this.emit(s, o)), null)).catch(o => {
                                this.emit("error", o)
                            });r.push(a);
                            break
                        }
                    case "filter":
                        {
                            if (!i._inflight) {
                                i._inflight = !0, i._lastBlockNumber === -2 && (i._lastBlockNumber = n - 1);
                                const s = i.filter;
                                s.fromBlock = i._lastBlockNumber + 1, s.toBlock = n;
                                const a = s.toBlock - this._maxFilterBlockRange;
                                a > s.fromBlock && (s.fromBlock = a), s.fromBlock < 0 && (s.fromBlock = 0);
                                const o = this.getLogs(s).then(c => {
                                    i._inflight = !1, c.length !== 0 && c.forEach(l => {
                                        l.blockNumber > i._lastBlockNumber && (i._lastBlockNumber = l.blockNumber), this._emitted["b:" + l.blockHash] = l.blockNumber, this._emitted["t:" + l.transactionHash] = l.blockNumber, this.emit(s, l)
                                    })
                                }).catch(c => {
                                    this.emit("error", c), i._inflight = !1
                                });
                                r.push(o)
                            }
                            break
                        }
                }
            }), this._lastBlockNumber = n, Promise.all(r).then(() => {
                this.emit("didPoll", e)
            }).catch(i => {
                this.emit("error", i)
            })
        })
    }
    resetEventsBlock(e) {
        this._lastBlockNumber = e - 1, this.polling && this.poll()
    }
    get network() {
        return this._network
    }
    detectNetwork() {
        return At(this, void 0, void 0, function*() {
            return Dt.throwError("provider does not support network detection", pe.errors.UNSUPPORTED_OPERATION, {
                operation: "provider.detectNetwork"
            })
        })
    }
    getNetwork() {
        return At(this, void 0, void 0, function*() {
            const e = yield this._ready(), r = yield this.detectNetwork();
            if (e.chainId !== r.chainId) {
                if (this.anyNetwork) return this._network = r, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", r, e), yield o_(0), this._network;
                const n = Dt.makeError("underlying network changed", pe.errors.NETWORK_ERROR, {
                    event: "changed",
                    network: e,
                    detectedNetwork: r
                });
                throw this.emit("error", n), n
            }
            return e
        })
    }
    get blockNumber() {
        return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(e => {
            this._setFastBlockNumber(e)
        }, e => {}), this._fastBlockNumber != null ? this._fastBlockNumber : -1
    }
    get polling() {
        return this._poller != null
    }
    set polling(e) {
        e && !this._poller ? (this._poller = setInterval(() => {
            this.poll()
        }, this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout(() => {
            this.poll(), this._bootstrapPoll = setTimeout(() => {
                this._poller || this.poll(), this._bootstrapPoll = null
            }, this.pollingInterval)
        }, 0))) : !e && this._poller && (clearInterval(this._poller), this._poller = null)
    }
    get pollingInterval() {
        return this._pollingInterval
    }
    set pollingInterval(e) {
        if (typeof e != "number" || e <= 0 || parseInt(String(e)) != e) throw new Error("invalid polling interval");
        this._pollingInterval = e, this._poller && (clearInterval(this._poller), this._poller = setInterval(() => {
            this.poll()
        }, this._pollingInterval))
    }
    _getFastBlockNumber() {
        const e = zh();
        return e - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = e, this._fastBlockNumberPromise = this.getBlockNumber().then(r => ((this._fastBlockNumber == null || r > this._fastBlockNumber) && (this._fastBlockNumber = r), this._fastBlockNumber))), this._fastBlockNumberPromise
    }
    _setFastBlockNumber(e) {
        this._fastBlockNumber != null && e < this._fastBlockNumber || (this._fastQueryDate = zh(), (this._fastBlockNumber == null || e > this._fastBlockNumber) && (this._fastBlockNumber = e, this._fastBlockNumberPromise = Promise.resolve(e)))
    }
    waitForTransaction(e, r, n) {
        return At(this, void 0, void 0, function*() {
            return this._waitForTransaction(e, r ? ? 1, n || 0, null)
        })
    }
    _waitForTransaction(e, r, n, i) {
        return At(this, void 0, void 0, function*() {
            const s = yield this.getTransactionReceipt(e);
            return (s ? s.confirmations : 0) >= r ? s : new Promise((a, o) => {
                const c = [];
                let l = !1;
                const u = function() {
                        return l ? !0 : (l = !0, c.forEach(f => {
                            f()
                        }), !1)
                    },
                    h = f => {
                        f.confirmations < r || u() || a(f)
                    };
                if (this.on(e, h), c.push(() => {
                        this.removeListener(e, h)
                    }), i) {
                    let f = i.startBlock,
                        p = null;
                    const g = m => At(this, void 0, void 0, function*() {
                        l || (yield o_(1e3), this.getTransactionCount(i.from).then(y => At(this, void 0, void 0, function*() {
                            if (!l) {
                                if (y <= i.nonce) f = m;
                                else {
                                    {
                                        const w = yield this.getTransaction(e);
                                        if (w && w.blockNumber != null) return
                                    }
                                    for (p == null && (p = f - 3, p < i.startBlock && (p = i.startBlock)); p <= m;) {
                                        if (l) return;
                                        const w = yield this.getBlockWithTransactions(p);
                                        for (let x = 0; x < w.transactions.length; x++) {
                                            const E = w.transactions[x];
                                            if (E.hash === e) return;
                                            if (E.from === i.from && E.nonce === i.nonce) {
                                                if (l) return;
                                                const _ = yield this.waitForTransaction(E.hash, r);
                                                if (u()) return;
                                                let b = "replaced";
                                                E.data === i.data && E.to === i.to && E.value.eq(i.value) ? b = "repriced" : E.data === "0x" && E.from === E.to && E.value.isZero() && (b = "cancelled"), o(Dt.makeError("transaction was replaced", pe.errors.TRANSACTION_REPLACED, {
                                                    cancelled: b === "replaced" || b === "cancelled",
                                                    reason: b,
                                                    replacement: this._wrapTransaction(E),
                                                    hash: e,
                                                    receipt: _
                                                }));
                                                return
                                            }
                                        }
                                        p++
                                    }
                                }
                                l || this.once("block", g)
                            }
                        }), y => {
                            l || this.once("block", g)
                        }))
                    });
                    if (l) return;
                    this.once("block", g), c.push(() => {
                        this.removeListener("block", g)
                    })
                }
                if (typeof n == "number" && n > 0) {
                    const f = setTimeout(() => {
                        u() || o(Dt.makeError("timeout exceeded", pe.errors.TIMEOUT, {
                            timeout: n
                        }))
                    }, n);
                    f.unref && f.unref(), c.push(() => {
                        clearTimeout(f)
                    })
                }
            })
        })
    }
    getBlockNumber() {
        return At(this, void 0, void 0, function*() {
            return this._getInternalBlockNumber(0)
        })
    }
    getGasPrice() {
        return At(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const e = yield this.perform("getGasPrice", {});
            try {
                return Fe.from(e)
            } catch (r) {
                return Dt.throwError("bad result from backend", pe.errors.SERVER_ERROR, {
                    method: "getGasPrice",
                    result: e,
                    error: r
                })
            }
        })
    }
    getBalance(e, r) {
        return At(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const n = yield An({
                address: this._getAddress(e),
                blockTag: this._getBlockTag(r)
            }), i = yield this.perform("getBalance", n);
            try {
                return Fe.from(i)
            } catch (s) {
                return Dt.throwError("bad result from backend", pe.errors.SERVER_ERROR, {
                    method: "getBalance",
                    params: n,
                    result: i,
                    error: s
                })
            }
        })
    }
    getTransactionCount(e, r) {
        return At(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const n = yield An({
                address: this._getAddress(e),
                blockTag: this._getBlockTag(r)
            }), i = yield this.perform("getTransactionCount", n);
            try {
                return Fe.from(i).toNumber()
            } catch (s) {
                return Dt.throwError("bad result from backend", pe.errors.SERVER_ERROR, {
                    method: "getTransactionCount",
                    params: n,
                    result: i,
                    error: s
                })
            }
        })
    }
    getCode(e, r) {
        return At(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const n = yield An({
                address: this._getAddress(e),
                blockTag: this._getBlockTag(r)
            }), i = yield this.perform("getCode", n);
            try {
                return Tt(i)
            } catch (s) {
                return Dt.throwError("bad result from backend", pe.errors.SERVER_ERROR, {
                    method: "getCode",
                    params: n,
                    result: i,
                    error: s
                })
            }
        })
    }
    getStorageAt(e, r, n) {
        return At(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const i = yield An({
                address: this._getAddress(e),
                blockTag: this._getBlockTag(n),
                position: Promise.resolve(r).then(a => O6(a))
            }), s = yield this.perform("getStorageAt", i);
            try {
                return Tt(s)
            } catch (a) {
                return Dt.throwError("bad result from backend", pe.errors.SERVER_ERROR, {
                    method: "getStorageAt",
                    params: i,
                    result: s,
                    error: a
                })
            }
        })
    }
    _wrapTransaction(e, r, n) {
        if (r != null && ud(r) !== 32) throw new Error("invalid response - sendTransaction");
        const i = e;
        return r != null && e.hash !== r && Dt.throwError("Transaction hash mismatch from Provider.sendTransaction.", pe.errors.UNKNOWN_ERROR, {
            expectedHash: e.hash,
            returnedHash: r
        }), i.wait = (s, a) => At(this, void 0, void 0, function*() {
            s == null && (s = 1), a == null && (a = 0);
            let o;
            s !== 0 && n != null && (o = {
                data: e.data,
                from: e.from,
                nonce: e.nonce,
                to: e.to,
                value: e.value,
                startBlock: n
            });
            const c = yield this._waitForTransaction(e.hash, s, a, o);
            return c == null && s === 0 ? null : (this._emitted["t:" + e.hash] = c.blockNumber, c.status === 0 && Dt.throwError("transaction failed", pe.errors.CALL_EXCEPTION, {
                transactionHash: e.hash,
                transaction: e,
                receipt: c
            }), c)
        }), i
    }
    sendTransaction(e) {
        return At(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const r = yield Promise.resolve(e).then(s => Tt(s)), n = this.formatter.transaction(e);
            n.confirmations == null && (n.confirmations = 0);
            const i = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            try {
                const s = yield this.perform("sendTransaction", {
                    signedTransaction: r
                });
                return this._wrapTransaction(n, s, i)
            } catch (s) {
                throw s.transaction = n, s.transactionHash = n.hash, s
            }
        })
    }
    _getTransactionRequest(e) {
        return At(this, void 0, void 0, function*() {
            const r = yield e, n = {};
            return ["from", "to"].forEach(i => {
                r[i] != null && (n[i] = Promise.resolve(r[i]).then(s => s ? this._getAddress(s) : null))
            }), ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach(i => {
                r[i] != null && (n[i] = Promise.resolve(r[i]).then(s => s ? Fe.from(s) : null))
            }), ["type"].forEach(i => {
                r[i] != null && (n[i] = Promise.resolve(r[i]).then(s => s ? ? null))
            }), r.accessList && (n.accessList = this.formatter.accessList(r.accessList)), ["data"].forEach(i => {
                r[i] != null && (n[i] = Promise.resolve(r[i]).then(s => s ? Tt(s) : null))
            }), this.formatter.transactionRequest(yield An(n))
        })
    }
    _getFilter(e) {
        return At(this, void 0, void 0, function*() {
            e = yield e;
            const r = {};
            return e.address != null && (r.address = this._getAddress(e.address)), ["blockHash", "topics"].forEach(n => {
                e[n] != null && (r[n] = e[n])
            }), ["fromBlock", "toBlock"].forEach(n => {
                e[n] != null && (r[n] = this._getBlockTag(e[n]))
            }), this.formatter.filter(yield An(r))
        })
    }
    _call(e, r, n) {
        return At(this, void 0, void 0, function*() {
            n >= cte && Dt.throwError("CCIP read exceeded maximum redirections", pe.errors.SERVER_ERROR, {
                redirects: n,
                transaction: e
            });
            const i = e.to,
                s = yield this.perform("call", {
                    transaction: e,
                    blockTag: r
                });
            if (n >= 0 && r === "latest" && i != null && s.substring(0, 10) === "0x556f1830" && ud(s) % 32 === 4) try {
                const a = ii(s, 4),
                    o = ii(a, 0, 32);
                Fe.from(o).eq(i) || Dt.throwError("CCIP Read sender did not match", pe.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction: e,
                    data: s
                });
                const c = [],
                    l = Fe.from(ii(a, 32, 64)).toNumber(),
                    u = Fe.from(ii(a, l, l + 32)).toNumber(),
                    h = ii(a, l + 32);
                for (let w = 0; w < u; w++) {
                    const x = qg(h, w * 32);
                    x == null && Dt.throwError("CCIP Read contained corrupt URL string", pe.errors.CALL_EXCEPTION, {
                        name: "OffchainLookup",
                        signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                        transaction: e,
                        data: s
                    }), c.push(x)
                }
                const f = Cp(a, 64);
                Fe.from(ii(a, 100, 128)).isZero() || Dt.throwError("CCIP Read callback selector included junk", pe.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction: e,
                    data: s
                });
                const p = ii(a, 96, 100),
                    g = Cp(a, 128),
                    m = yield this.ccipReadFetch(e, f, c);
                m == null && Dt.throwError("CCIP Read disabled or provided no URLs", pe.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction: e,
                    data: s
                });
                const y = {
                    to: i,
                    data: rs([p, RN([m, g])])
                };
                return this._call(y, r, n + 1)
            } catch (a) {
                if (a.code === pe.errors.SERVER_ERROR) throw a
            }
            try {
                return Tt(s)
            } catch (a) {
                return Dt.throwError("bad result from backend", pe.errors.SERVER_ERROR, {
                    method: "call",
                    params: {
                        transaction: e,
                        blockTag: r
                    },
                    result: s,
                    error: a
                })
            }
        })
    }
    call(e, r) {
        return At(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const n = yield An({
                transaction: this._getTransactionRequest(e),
                blockTag: this._getBlockTag(r),
                ccipReadEnabled: Promise.resolve(e.ccipReadEnabled)
            });
            return this._call(n.transaction, n.blockTag, n.ccipReadEnabled ? 0 : -1)
        })
    }
    estimateGas(e) {
        return At(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const r = yield An({
                transaction: this._getTransactionRequest(e)
            }), n = yield this.perform("estimateGas", r);
            try {
                return Fe.from(n)
            } catch (i) {
                return Dt.throwError("bad result from backend", pe.errors.SERVER_ERROR, {
                    method: "estimateGas",
                    params: r,
                    result: n,
                    error: i
                })
            }
        })
    }
    _getAddress(e) {
        return At(this, void 0, void 0, function*() {
            e = yield e, typeof e != "string" && Dt.throwArgumentError("invalid address or ENS name", "name", e);
            const r = yield this.resolveName(e);
            return r == null && Dt.throwError("ENS name not configured", pe.errors.UNSUPPORTED_OPERATION, {
                operation: `resolveName(${JSON.stringify(e)})`
            }), r
        })
    }
    _getBlock(e, r) {
        return At(this, void 0, void 0, function*() {
            yield this.getNetwork(), e = yield e;
            let n = -128;
            const i = {
                includeTransactions: !!r
            };
            if (pr(e, 32)) i.blockHash = e;
            else try {
                i.blockTag = yield this._getBlockTag(e), pr(i.blockTag) && (n = parseInt(i.blockTag.substring(2), 16))
            } catch {
                Dt.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", e)
            }
            return xf(() => At(this, void 0, void 0, function*() {
                const s = yield this.perform("getBlock", i);
                if (s == null) return i.blockHash != null && this._emitted["b:" + i.blockHash] == null || i.blockTag != null && n > this._emitted.block ? null : void 0;
                if (r) {
                    let a = null;
                    for (let c = 0; c < s.transactions.length; c++) {
                        const l = s.transactions[c];
                        if (l.blockNumber == null) l.confirmations = 0;
                        else if (l.confirmations == null) {
                            a == null && (a = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
                            let u = a - l.blockNumber + 1;
                            u <= 0 && (u = 1), l.confirmations = u
                        }
                    }
                    const o = this.formatter.blockWithTransactions(s);
                    return o.transactions = o.transactions.map(c => this._wrapTransaction(c)), o
                }
                return this.formatter.block(s)
            }), {
                oncePoll: this
            })
        })
    }
    getBlock(e) {
        return this._getBlock(e, !1)
    }
    getBlockWithTransactions(e) {
        return this._getBlock(e, !0)
    }
    getTransaction(e) {
        return At(this, void 0, void 0, function*() {
            yield this.getNetwork(), e = yield e;
            const r = {
                transactionHash: this.formatter.hash(e, !0)
            };
            return xf(() => At(this, void 0, void 0, function*() {
                const n = yield this.perform("getTransaction", r);
                if (n == null) return this._emitted["t:" + e] == null ? null : void 0;
                const i = this.formatter.transactionResponse(n);
                if (i.blockNumber == null) i.confirmations = 0;
                else if (i.confirmations == null) {
                    let a = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
                    a <= 0 && (a = 1), i.confirmations = a
                }
                return this._wrapTransaction(i)
            }), {
                oncePoll: this
            })
        })
    }
    getTransactionReceipt(e) {
        return At(this, void 0, void 0, function*() {
            yield this.getNetwork(), e = yield e;
            const r = {
                transactionHash: this.formatter.hash(e, !0)
            };
            return xf(() => At(this, void 0, void 0, function*() {
                const n = yield this.perform("getTransactionReceipt", r);
                if (n == null) return this._emitted["t:" + e] == null ? null : void 0;
                if (n.blockHash == null) return;
                const i = this.formatter.receipt(n);
                if (i.blockNumber == null) i.confirmations = 0;
                else if (i.confirmations == null) {
                    let a = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
                    a <= 0 && (a = 1), i.confirmations = a
                }
                return i
            }), {
                oncePoll: this
            })
        })
    }
    getLogs(e) {
        return At(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const r = yield An({
                filter: this._getFilter(e)
            }), n = yield this.perform("getLogs", r);
            return n.forEach(i => {
                i.removed == null && (i.removed = !1)
            }), et.arrayOf(this.formatter.filterLog.bind(this.formatter))(n)
        })
    }
    getEtherPrice() {
        return At(this, void 0, void 0, function*() {
            return yield this.getNetwork(), this.perform("getEtherPrice", {})
        })
    }
    _getBlockTag(e) {
        return At(this, void 0, void 0, function*() {
            if (e = yield e, typeof e == "number" && e < 0) {
                e % 1 && Dt.throwArgumentError("invalid BlockTag", "blockTag", e);
                let r = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                return r += e, r < 0 && (r = 0), this.formatter.blockTag(r)
            }
            return this.formatter.blockTag(e)
        })
    }
    getResolver(e) {
        return At(this, void 0, void 0, function*() {
            let r = e;
            for (;;) {
                if (r === "" || r === "." || e !== "eth" && r === "eth") return null;
                const n = yield this._getResolver(r, "getResolver");
                if (n != null) {
                    const i = new u_(this, n, e);
                    return r !== e && !(yield i.supportsWildcard()) ? null : i
                }
                r = r.split(".").slice(1).join(".")
            }
        })
    }
    _getResolver(e, r) {
        return At(this, void 0, void 0, function*() {
            r == null && (r = "ENS");
            const n = yield this.getNetwork();
            n.ensAddress || Dt.throwError("network does not support ENS", pe.errors.UNSUPPORTED_OPERATION, {
                operation: r,
                network: n.name
            });
            try {
                const i = yield this.call({
                    to: n.ensAddress,
                    data: "0x0178b8bf" + Bg(e).substring(2)
                });
                return this.formatter.callAddress(i)
            } catch {}
            return null
        })
    }
    resolveName(e) {
        return At(this, void 0, void 0, function*() {
            e = yield e;
            try {
                return Promise.resolve(this.formatter.address(e))
            } catch (n) {
                if (pr(e)) throw n
            }
            typeof e != "string" && Dt.throwArgumentError("invalid ENS name", "name", e);
            const r = yield this.getResolver(e);
            return r ? yield r.getAddress(): null
        })
    }
    lookupAddress(e) {
        return At(this, void 0, void 0, function*() {
            e = yield e, e = this.formatter.address(e);
            const r = e.substring(2).toLowerCase() + ".addr.reverse",
                n = yield this._getResolver(r, "lookupAddress");
            if (n == null) return null;
            const i = qg(yield this.call({
                to: n,
                data: "0x691f3431" + Bg(r).substring(2)
            }), 0);
            return (yield this.resolveName(i)) != e ? null : i
        })
    }
    getAvatar(e) {
        return At(this, void 0, void 0, function*() {
            let r = null;
            if (pr(e)) {
                const s = this.formatter.address(e).substring(2).toLowerCase() + ".addr.reverse",
                    a = yield this._getResolver(s, "getAvatar");
                if (!a) return null;
                r = new u_(this, a, s);
                try {
                    const o = yield r.getAvatar();
                    if (o) return o.url
                } catch (o) {
                    if (o.code !== pe.errors.CALL_EXCEPTION) throw o
                }
                try {
                    const o = qg(yield this.call({
                        to: a,
                        data: "0x691f3431" + Bg(s).substring(2)
                    }), 0);
                    r = yield this.getResolver(o)
                } catch (o) {
                    if (o.code !== pe.errors.CALL_EXCEPTION) throw o;
                    return null
                }
            } else if (r = yield this.getResolver(e), !r) return null;
            const n = yield r.getAvatar();
            return n == null ? null : n.url
        })
    }
    perform(e, r) {
        return Dt.throwError(e + " not implemented", pe.errors.NOT_IMPLEMENTED, {
            operation: e
        })
    }
    _startEvent(e) {
        this.polling = this._events.filter(r => r.pollable()).length > 0
    }
    _stopEvent(e) {
        this.polling = this._events.filter(r => r.pollable()).length > 0
    }
    _addEventListener(e, r, n) {
        const i = new ute(Zd(e), r, n);
        return this._events.push(i), this._startEvent(i), this
    }
    on(e, r) {
        return this._addEventListener(e, r, !1)
    }
    once(e, r) {
        return this._addEventListener(e, r, !0)
    }
    emit(e, ...r) {
        let n = !1,
            i = [],
            s = Zd(e);
        return this._events = this._events.filter(a => a.tag !== s ? !0 : (setTimeout(() => {
            a.listener.apply(this, r)
        }, 0), n = !0, a.once ? (i.push(a), !1) : !0)), i.forEach(a => {
            this._stopEvent(a)
        }), n
    }
    listenerCount(e) {
        if (!e) return this._events.length;
        let r = Zd(e);
        return this._events.filter(n => n.tag === r).length
    }
    listeners(e) {
        if (e == null) return this._events.map(n => n.listener);
        let r = Zd(e);
        return this._events.filter(n => n.tag === r).map(n => n.listener)
    }
    off(e, r) {
        if (r == null) return this.removeAllListeners(e);
        const n = [];
        let i = !1,
            s = Zd(e);
        return this._events = this._events.filter(a => a.tag !== s || a.listener != r || i ? !0 : (i = !0, n.push(a), !1)), n.forEach(a => {
            this._stopEvent(a)
        }), this
    }
    removeAllListeners(e) {
        let r = [];
        if (e == null) r = this._events, this._events = [];
        else {
            const n = Zd(e);
            this._events = this._events.filter(i => i.tag !== n ? !0 : (r.push(i), !1))
        }
        return r.forEach(n => {
            this._stopEvent(n)
        }), this
    }
}
var Oo = function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(a) {
            a(s)
        })
    }
    return new(r || (r = Promise))(function(s, a) {
        function o(u) {
            try {
                l(n.next(u))
            } catch (h) {
                a(h)
            }
        }

        function c(u) {
            try {
                l(n.throw(u))
            } catch (h) {
                a(h)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(o, c)
        }
        l((n = n.apply(t, e || [])).next())
    })
};
const Jr = new pe(Q1),
    mte = ["call", "estimateGas"];

function Rf(t, e) {
    if (t == null) return null;
    if (typeof t.message == "string" && t.message.match("reverted")) {
        const r = pr(t.data) ? t.data : null;
        if (!e || r) return {
            message: t.message,
            data: r
        }
    }
    if (typeof t == "object") {
        for (const r in t) {
            const n = Rf(t[r], e);
            if (n) return n
        }
        return null
    }
    if (typeof t == "string") try {
        return Rf(JSON.parse(t), e)
    } catch {}
    return null
}

function MN(t, e, r) {
    const n = r.transaction || r.signedTransaction;
    if (t === "call") {
        const s = Rf(e, !0);
        if (s) return s.data;
        Jr.throwError("missing revert data in call exception; Transaction reverted without a reason string", pe.errors.CALL_EXCEPTION, {
            data: "0x",
            transaction: n,
            error: e
        })
    }
    if (t === "estimateGas") {
        let s = Rf(e.body, !1);
        s == null && (s = Rf(e, !1)), s && Jr.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", pe.errors.UNPREDICTABLE_GAS_LIMIT, {
            reason: s.message,
            method: t,
            transaction: n,
            error: e
        })
    }
    let i = e.message;
    throw e.code === pe.errors.SERVER_ERROR && e.error && typeof e.error.message == "string" ? i = e.error.message : typeof e.body == "string" ? i = e.body : typeof e.responseText == "string" && (i = e.responseText), i = (i || "").toLowerCase(), i.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) && Jr.throwError("insufficient funds for intrinsic transaction cost", pe.errors.INSUFFICIENT_FUNDS, {
        error: e,
        method: t,
        transaction: n
    }), i.match(/nonce (is )?too low/i) && Jr.throwError("nonce has already been used", pe.errors.NONCE_EXPIRED, {
        error: e,
        method: t,
        transaction: n
    }), i.match(/replacement transaction underpriced|transaction gas price.*too low/i) && Jr.throwError("replacement fee too low", pe.errors.REPLACEMENT_UNDERPRICED, {
        error: e,
        method: t,
        transaction: n
    }), i.match(/only replay-protected/i) && Jr.throwError("legacy pre-eip-155 transactions not supported", pe.errors.UNSUPPORTED_OPERATION, {
        error: e,
        method: t,
        transaction: n
    }), mte.indexOf(t) >= 0 && i.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) && Jr.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", pe.errors.UNPREDICTABLE_GAS_LIMIT, {
        error: e,
        method: t,
        transaction: n
    }), e
}

function h_(t) {
    return new Promise(function(e) {
        setTimeout(e, t)
    })
}

function yte(t) {
    if (t.error) {
        const e = new Error(t.error.message);
        throw e.code = t.error.code, e.data = t.error.data, e
    }
    return t.result
}

function qh(t) {
    return t && t.toLowerCase()
}
const T3 = {};
class DN extends G1 {
    constructor(e, r, n) {
        if (super(), e !== T3) throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
        zt(this, "provider", r), n == null && (n = 0), typeof n == "string" ? (zt(this, "_address", this.provider.formatter.address(n)), zt(this, "_index", null)) : typeof n == "number" ? (zt(this, "_index", n), zt(this, "_address", null)) : Jr.throwArgumentError("invalid address or index", "addressOrIndex", n)
    }
    connect(e) {
        return Jr.throwError("cannot alter JSON-RPC Signer connection", pe.errors.UNSUPPORTED_OPERATION, {
            operation: "connect"
        })
    }
    connectUnchecked() {
        return new wte(T3, this.provider, this._address || this._index)
    }
    getAddress() {
        return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then(e => (e.length <= this._index && Jr.throwError("unknown account #" + this._index, pe.errors.UNSUPPORTED_OPERATION, {
            operation: "getAddress"
        }), this.provider.formatter.address(e[this._index])))
    }
    sendUncheckedTransaction(e) {
        e = ji(e);
        const r = this.getAddress().then(n => (n && (n = n.toLowerCase()), n));
        if (e.gasLimit == null) {
            const n = ji(e);
            n.from = r, e.gasLimit = this.provider.estimateGas(n)
        }
        return e.to != null && (e.to = Promise.resolve(e.to).then(n => Oo(this, void 0, void 0, function*() {
            if (n == null) return null;
            const i = yield this.provider.resolveName(n);
            return i == null && Jr.throwArgumentError("provided ENS name resolves to null", "tx.to", n), i
        }))), An({
            tx: An(e),
            sender: r
        }).then(({
            tx: n,
            sender: i
        }) => {
            n.from != null ? n.from.toLowerCase() !== i && Jr.throwArgumentError("from address mismatch", "transaction", e) : n.from = i;
            const s = this.provider.constructor.hexlifyTransaction(n, {
                from: !0
            });
            return this.provider.send("eth_sendTransaction", [s]).then(a => a, a => (typeof a.message == "string" && a.message.match(/user denied/i) && Jr.throwError("user rejected transaction", pe.errors.ACTION_REJECTED, {
                action: "sendTransaction",
                transaction: n
            }), MN("sendTransaction", a, s)))
        })
    }
    signTransaction(e) {
        return Jr.throwError("signing transactions is unsupported", pe.errors.UNSUPPORTED_OPERATION, {
            operation: "signTransaction"
        })
    }
    sendTransaction(e) {
        return Oo(this, void 0, void 0, function*() {
            const r = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval), n = yield this.sendUncheckedTransaction(e);
            try {
                return yield xf(() => Oo(this, void 0, void 0, function*() {
                    const i = yield this.provider.getTransaction(n);
                    if (i !== null) return this.provider._wrapTransaction(i, n, r)
                }), {
                    oncePoll: this.provider
                })
            } catch (i) {
                throw i.transactionHash = n, i
            }
        })
    }
    signMessage(e) {
        return Oo(this, void 0, void 0, function*() {
            const r = typeof e == "string" ? ic(e) : e,
                n = yield this.getAddress();
            try {
                return yield this.provider.send("personal_sign", [Tt(r), n.toLowerCase()])
            } catch (i) {
                throw typeof i.message == "string" && i.message.match(/user denied/i) && Jr.throwError("user rejected signing", pe.errors.ACTION_REJECTED, {
                    action: "signMessage",
                    from: n,
                    messageData: e
                }), i
            }
        })
    }
    _legacySignMessage(e) {
        return Oo(this, void 0, void 0, function*() {
            const r = typeof e == "string" ? ic(e) : e,
                n = yield this.getAddress();
            try {
                return yield this.provider.send("eth_sign", [n.toLowerCase(), Tt(r)])
            } catch (i) {
                throw typeof i.message == "string" && i.message.match(/user denied/i) && Jr.throwError("user rejected signing", pe.errors.ACTION_REJECTED, {
                    action: "_legacySignMessage",
                    from: n,
                    messageData: e
                }), i
            }
        })
    }
    _signTypedData(e, r, n) {
        return Oo(this, void 0, void 0, function*() {
            const i = yield Zi.resolveNames(e, r, n, a => this.provider.resolveName(a)), s = yield this.getAddress();
            try {
                return yield this.provider.send("eth_signTypedData_v4", [s.toLowerCase(), JSON.stringify(Zi.getPayload(i.domain, r, i.value))])
            } catch (a) {
                throw typeof a.message == "string" && a.message.match(/user denied/i) && Jr.throwError("user rejected signing", pe.errors.ACTION_REJECTED, {
                    action: "_signTypedData",
                    from: s,
                    messageData: {
                        domain: i.domain,
                        types: r,
                        value: i.value
                    }
                }), a
            }
        })
    }
    unlock(e) {
        return Oo(this, void 0, void 0, function*() {
            const r = this.provider,
                n = yield this.getAddress();
            return r.send("personal_unlockAccount", [n.toLowerCase(), e, null])
        })
    }
}
class wte extends DN {
    sendTransaction(e) {
        return this.sendUncheckedTransaction(e).then(r => ({
            hash: r,
            nonce: null,
            gasLimit: null,
            gasPrice: null,
            data: null,
            value: null,
            chainId: null,
            confirmations: 0,
            from: null,
            wait: n => this.provider.waitForTransaction(r, n)
        }))
    }
}
const bte = {
    chainId: !0,
    data: !0,
    gasLimit: !0,
    gasPrice: !0,
    nonce: !0,
    to: !0,
    value: !0,
    type: !0,
    accessList: !0,
    maxFeePerGas: !0,
    maxPriorityFeePerGas: !0
};
class vte extends gte {
    constructor(e, r) {
        let n = r;
        n == null && (n = new Promise((i, s) => {
            setTimeout(() => {
                this.detectNetwork().then(a => {
                    i(a)
                }, a => {
                    s(a)
                })
            }, 0)
        })), super(n), e || (e = vf(this.constructor, "defaultUrl")()), typeof e == "string" ? zt(this, "connection", Object.freeze({
            url: e
        })) : zt(this, "connection", Object.freeze(ji(e))), this._nextId = 42
    }
    get _cache() {
        return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache
    }
    static defaultUrl() {
        return "http://localhost:8545"
    }
    detectNetwork() {
        return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout(() => {
            this._cache.detectNetwork = null
        }, 0)), this._cache.detectNetwork
    }
    _uncachedDetectNetwork() {
        return Oo(this, void 0, void 0, function*() {
            yield h_(0);
            let e = null;
            try {
                e = yield this.send("eth_chainId", [])
            } catch {
                try {
                    e = yield this.send("net_version", [])
                } catch {}
            }
            if (e != null) {
                const r = vf(this.constructor, "getNetwork");
                try {
                    return r(Fe.from(e).toNumber())
                } catch (n) {
                    return Jr.throwError("could not detect network", pe.errors.NETWORK_ERROR, {
                        chainId: e,
                        event: "invalidNetwork",
                        serverError: n
                    })
                }
            }
            return Jr.throwError("could not detect network", pe.errors.NETWORK_ERROR, {
                event: "noNetwork"
            })
        })
    }
    getSigner(e) {
        return new DN(T3, this, e)
    }
    getUncheckedSigner(e) {
        return this.getSigner(e).connectUnchecked()
    }
    listAccounts() {
        return this.send("eth_accounts", []).then(e => e.map(r => this.formatter.address(r)))
    }
    send(e, r) {
        const n = {
            method: e,
            params: r,
            id: this._nextId++,
            jsonrpc: "2.0"
        };
        this.emit("debug", {
            action: "request",
            request: xp(n),
            provider: this
        });
        const i = ["eth_chainId", "eth_blockNumber"].indexOf(e) >= 0;
        if (i && this._cache[e]) return this._cache[e];
        const s = L6(this.connection, JSON.stringify(n), yte).then(a => (this.emit("debug", {
            action: "response",
            request: n,
            response: a,
            provider: this
        }), a), a => {
            throw this.emit("debug", {
                action: "response",
                error: a,
                request: n,
                provider: this
            }), a
        });
        return i && (this._cache[e] = s, setTimeout(() => {
            this._cache[e] = null
        }, 0)), s
    }
    prepareRequest(e, r) {
        switch (e) {
            case "getBlockNumber":
                return ["eth_blockNumber", []];
            case "getGasPrice":
                return ["eth_gasPrice", []];
            case "getBalance":
                return ["eth_getBalance", [qh(r.address), r.blockTag]];
            case "getTransactionCount":
                return ["eth_getTransactionCount", [qh(r.address), r.blockTag]];
            case "getCode":
                return ["eth_getCode", [qh(r.address), r.blockTag]];
            case "getStorageAt":
                return ["eth_getStorageAt", [qh(r.address), Mr(r.position, 32), r.blockTag]];
            case "sendTransaction":
                return ["eth_sendRawTransaction", [r.signedTransaction]];
            case "getBlock":
                return r.blockTag ? ["eth_getBlockByNumber", [r.blockTag, !!r.includeTransactions]] : r.blockHash ? ["eth_getBlockByHash", [r.blockHash, !!r.includeTransactions]] : null;
            case "getTransaction":
                return ["eth_getTransactionByHash", [r.transactionHash]];
            case "getTransactionReceipt":
                return ["eth_getTransactionReceipt", [r.transactionHash]];
            case "call":
                return ["eth_call", [vf(this.constructor, "hexlifyTransaction")(r.transaction, {
                    from: !0
                }), r.blockTag]];
            case "estimateGas":
                return ["eth_estimateGas", [vf(this.constructor, "hexlifyTransaction")(r.transaction, {
                    from: !0
                })]];
            case "getLogs":
                return r.filter && r.filter.address != null && (r.filter.address = qh(r.filter.address)), ["eth_getLogs", [r.filter]]
        }
        return null
    }
    perform(e, r) {
        return Oo(this, void 0, void 0, function*() {
            if (e === "call" || e === "estimateGas") {
                const i = r.transaction;
                if (i && i.type != null && Fe.from(i.type).isZero() && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
                    const s = yield this.getFeeData();
                    s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && (r = ji(r), r.transaction = ji(i), delete r.transaction.type)
                }
            }
            const n = this.prepareRequest(e, r);
            n == null && Jr.throwError(e + " not implemented", pe.errors.NOT_IMPLEMENTED, {
                operation: e
            });
            try {
                return yield this.send(n[0], n[1])
            } catch (i) {
                return MN(e, i, r)
            }
        })
    }
    _startEvent(e) {
        e.tag === "pending" && this._startPending(), super._startEvent(e)
    }
    _startPending() {
        if (this._pendingFilter != null) return;
        const e = this,
            r = this.send("eth_newPendingTransactionFilter", []);
        this._pendingFilter = r, r.then(function(n) {
            function i() {
                e.send("eth_getFilterChanges", [n]).then(function(s) {
                    if (e._pendingFilter != r) return null;
                    let a = Promise.resolve();
                    return s.forEach(function(o) {
                        e._emitted["t:" + o.toLowerCase()] = "pending", a = a.then(function() {
                            return e.getTransaction(o).then(function(c) {
                                return e.emit("pending", c), null
                            })
                        })
                    }), a.then(function() {
                        return h_(1e3)
                    })
                }).then(function() {
                    if (e._pendingFilter != r) {
                        e.send("eth_uninstallFilter", [n]);
                        return
                    }
                    return setTimeout(function() {
                        i()
                    }, 0), null
                }).catch(s => {})
            }
            return i(), n
        }).catch(n => {})
    }
    _stopEvent(e) {
        e.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(e)
    }
    static hexlifyTransaction(e, r) {
        const n = ji(bte);
        if (r)
            for (const s in r) r[s] && (n[s] = !0);
        lX(e, n);
        const i = {};
        return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(s) {
            if (e[s] == null) return;
            const a = O6(Fe.from(e[s]));
            s === "gasLimit" && (s = "gas"), i[s] = a
        }), ["from", "to", "data"].forEach(function(s) {
            e[s] != null && (i[s] = Tt(e[s]))
        }), e.accessList && (i.accessList = c0(e.accessList)), i
    }
}
var xte = function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(a) {
            a(s)
        })
    }
    return new(r || (r = Promise))(function(s, a) {
        function o(u) {
            try {
                l(n.next(u))
            } catch (h) {
                a(h)
            }
        }

        function c(u) {
            try {
                l(n.throw(u))
            } catch (h) {
                a(h)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(o, c)
        }
        l((n = n.apply(t, e || [])).next())
    })
};
const Ete = new pe(Q1);
class _te extends vte {
    detectNetwork() {
        const e = Object.create(null, {
            detectNetwork: {
                get: () => super.detectNetwork
            }
        });
        return xte(this, void 0, void 0, function*() {
            let r = this.network;
            return r == null && (r = yield e.detectNetwork.call(this), r || Ete.throwError("no network detected", pe.errors.UNKNOWN_ERROR, {}), this._network == null && (zt(this, "_network", r), this.emit("network", r, null))), r
        })
    }
}

function P3(t) {
    if (typeof t == "number" || typeof t == "bigint" || typeof t == "string") return t;
    if (typeof t.toHexString == "function") return t.toHexString();
    throw Error(`Expected numeric value but received ${t}`)
}
const LN = t => [ja.id, z1.id].includes(t),
    Cte = async (t, e) => {
        if (!LN(t.chainId)) throw Error("Invalid chain ID for Arbitrum gas estimation.");
        if (t.type === void 0 && (t.type = 2), t.maxFeePerGas) return t;
        try {
            let {
                lastBaseFeePerGas: r
            } = await e.getFeeData();
            if (r) {
                let n = r.mul(Fe.from(120)).div(Fe.from(100));
                t.maxFeePerGas = P3(n), t.maxPriorityFeePerGas = P3(Fe.from(0))
            }
        } catch (r) {
            throw Error(`Failed to set gas price for Arbitrum transaction: ${r}.`)
        }
        return t
    },
    UN = t => [56, 97].includes(t),
    Ate = async (t, e) => {
        var r;
        if (!UN(t.chainId)) throw Error("Invalid chain ID for BSC gas estimation.");
        if (t.type === void 0 ? t.type = 0 : (t.type == 1 || t.type == 2) && console.warn("Transaction request type specified is incompatible for chain and will result in undefined behavior.  Please use transaction type 0."), !t.gasPrice) {
            let n = await e.getFeeData();
            t.gasPrice = (r = n.gasPrice) == null ? void 0 : r.toHexString()
        }
        return t
    },
    FN = t => [Fs.id, q1.id, go.id, V1.id, $6.id, ZP.id, YP.id, 81457, 168587773].includes(t),
    kte = async (t, e) => {
        if (!FN(t.chainId)) throw Error("Invalid chain ID for OP Stack gas estimation.");
        if (t.type === void 0 && (t.type = 2), t.gasPrice && (console.warn("`gasPrice` is not supported on this chain and will be ignored. Use `maxPriorityFeePerGas` and/or `maxFeePerGas` instead."), delete t.gasPrice), t.maxPriorityFeePerGas && t.maxFeePerGas) return t;
        try {
            if (!t.maxPriorityFeePerGas) {
                let r = await e.send("eth_maxPriorityFeePerGas", []);
                t.maxPriorityFeePerGas = r
            }
            if (t.maxFeePerGas && (console.warn("maxFeePerGas is specified without maxPriorityFeePerGas - this can result in hung transactions."), t.maxPriorityFeePerGas >= t.maxFeePerGas)) throw Error("Overridden maxFeePerGas is less than or equal to the calculated maxPriorityFeePerGas. Please set both values or maxPriorityFeePerGas alone for correct gas estimation.");
            if (!t.maxFeePerGas) {
                let {
                    lastBaseFeePerGas: r
                } = await e.getFeeData();
                if (!r) throw Error("Unable to fetch baseFee for last block.");
                let n = Fe.from(r).mul(Fe.from(126)).div(Fe.from(100)).add(Fe.from(t.maxPriorityFeePerGas));
                t.maxFeePerGas = P3(n)
            }
        } catch (r) {
            throw Error(`Failed to set gas price for OP stack transaction: ${r}.`)
        }
        return t
    },
    Ite = "units/5.8.0",
    $te = new pe(Ite),
    Ste = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];

function f_(t, e) {
    if (typeof t != "string" && $te.throwArgumentError("value must be a string", "value", t), typeof e == "string") {
        const r = Ste.indexOf(e);
        r !== -1 && (e = 3 * r)
    }
    return Va(t, e ? ? 18)
}
var Hg = {
        exports: {}
    },
    Tte = Hg.exports,
    p_;

function Pte() {
    return p_ || (p_ = 1, function(t, e) {
        (function(r, n) {
            t.exports = n()
        })(Tte, function() {
            var r = function(s, a) {
                if (a = a || {}, typeof s != "function") throw new i("fetch must be a function");
                if (typeof a != "object") throw new i("defaults must be an object");
                if (a.retries !== void 0 && !n(a.retries)) throw new i("retries must be a positive integer");
                if (a.retryDelay !== void 0 && !n(a.retryDelay) && typeof a.retryDelay != "function") throw new i("retryDelay must be a positive integer or a function returning a positive integer");
                if (a.retryOn !== void 0 && !Array.isArray(a.retryOn) && typeof a.retryOn != "function") throw new i("retryOn property expects an array or function");
                var o = {
                    retries: 3,
                    retryDelay: 1e3,
                    retryOn: []
                };
                return a = Object.assign(o, a),
                    function(l, u) {
                        var h = a.retries,
                            f = a.retryDelay,
                            p = a.retryOn;
                        if (u && u.retries !== void 0)
                            if (n(u.retries)) h = u.retries;
                            else throw new i("retries must be a positive integer");
                        if (u && u.retryDelay !== void 0)
                            if (n(u.retryDelay) || typeof u.retryDelay == "function") f = u.retryDelay;
                            else throw new i("retryDelay must be a positive integer or a function returning a positive integer");
                        if (u && u.retryOn)
                            if (Array.isArray(u.retryOn) || typeof u.retryOn == "function") p = u.retryOn;
                            else throw new i("retryOn property expects an array or function");
                        return new Promise(function(g, m) {
                            var y = function(x) {
                                var E = typeof Request < "u" && l instanceof Request ? l.clone() : l;
                                s(E, u).then(function(_) {
                                    if (Array.isArray(p) && p.indexOf(_.status) === -1) g(_);
                                    else if (typeof p == "function") try {
                                        return Promise.resolve(p(x, null, _)).then(function(b) {
                                            b ? w(x, null, _) : g(_)
                                        }).catch(m)
                                    } catch (b) {
                                        m(b)
                                    } else x < h ? w(x, null, _) : g(_)
                                }).catch(function(_) {
                                    if (typeof p == "function") try {
                                        Promise.resolve(p(x, _, null)).then(function(b) {
                                            b ? w(x, _, null) : m(_)
                                        }).catch(function(b) {
                                            m(b)
                                        })
                                    } catch (b) {
                                        m(b)
                                    } else x < h ? w(x, _, null) : m(_)
                                })
                            };

                            function w(x, E, _) {
                                var b = typeof f == "function" ? f(x, E, _) : f;
                                setTimeout(function() {
                                    y(++x)
                                }, b)
                            }
                            y(0)
                        })
                    }
            };

            function n(s) {
                return Number.isInteger(s) && s >= 0
            }

            function i(s) {
                this.name = "ArgumentError", this.message = s
            }
            return r
        })
    }(Hg)), Hg.exports
}
var Nte = Pte();
const z6 = Oa(Nte);
let Ote = z6(fetch, {
    retries: 3,
    retryDelay: 500
});
const BN = t => [fs.id, i0.id].includes(t);
let l2 = t => ({
        maxPriorityFee: f_(t.maxPriorityFee.toFixed(9), "gwei").toHexString(),
        maxFee: f_(t.maxFee.toFixed(9), "gwei").toHexString()
    }),
    jte = t => ({
        safeLow: l2(t.safeLow),
        standard: l2(t.standard),
        fast: l2(t.fast)
    });
const Rte = async t => {
    let e = "";
    switch (t) {
        case fs.id:
            e = "https://gasstation.polygon.technology/v2";
            break;
        case i0.id:
            e = "https://gasstation.polygon.technology/amoy";
            break;
        default:
            throw Error(`chainId ${t} does not support polygon gas stations`)
    }
    let r = await Ote(e),
        n = await r.json();
    if (r.status > 399) throw n;
    return jte(n)
};
async function Mte(t) {
    if (!BN(t.chainId)) throw Error("Invalid chain ID for Polygon gas estimation.");
    if (t.type === void 0 && (t.type = 2), t.maxPriorityFeePerGas && t.maxFeePerGas) return t;
    try {
        let {
            standard: e
        } = await Rte(t.chainId);
        t.maxPriorityFeePerGas || (t.maxPriorityFeePerGas = e.maxPriorityFee), t.maxFeePerGas || (t.maxFeePerGas = e.maxFee), t.gasPrice && (console.warn("`gasPrice` is not supported on this chain and will be ignored. Use `maxPriorityFeePerGas` and/or `maxFeePerGas` instead."), delete t.gasPrice)
    } catch (e) {
        throw Error(`Failed to set gas prices from Polygon gas station with error: ${e}.`)
    }
    return t
}
const Dte = async (t, e) => {
    var r, n, i;
    if (t.type === void 0 && (t.type = 2), t.type === 2) {
        if (!t.maxFeePerGas || !t.maxPriorityFeePerGas) {
            let s = await e.getFeeData();
            t.maxFeePerGas || (t.maxFeePerGas = (r = s.maxFeePerGas) == null ? void 0 : r.toHexString()), t.maxPriorityFeePerGas || (t.maxPriorityFeePerGas = (n = s.maxPriorityFeePerGas) == null ? void 0 : n.toHexString())
        }
    } else if (!t.gasPrice) {
        let s = await e.getFeeData();
        t.gasPrice = (i = s.gasPrice) == null ? void 0 : i.toHexString()
    }
    return t
};
async function Lte(t, e) {
    try {
        return (await e.estimateGas(t)).toHexString()
    } catch (r) {
        let n;
        if ("message" in r && r.message.includes("insufficient funds") && (console.warn(`Gas estimation failed with error: ${r}. Retrying gas estimation by omitting the 'value'`), n = await async function({
                txRequest: i,
                provider: s
            }) {
                try {
                    let a = { ...i,
                        value: void 0
                    };
                    return (await s.estimateGas(a)).toHexString()
                } catch (a) {
                    return console.warn(`Gas estimation failed with error: ${a} when omitting the 'value'`), null
                }
            }({
                txRequest: t,
                provider: e
            })), n || (console.warn(`Gas estimation failed with error: ${r}. Retrying gas estimation by omitting the 'from'`), n = await async function({
                txRequest: i,
                provider: s
            }) {
                try {
                    let a = { ...i,
                        from: void 0
                    };
                    return (await s.estimateGas(a)).toHexString()
                } catch (a) {
                    return console.warn(`Gas estimation failed with error: ${a} when omitting the 'from' address`), null
                }
            }({
                txRequest: t,
                provider: e
            })), !n) throw r;
        return n
    }
}
const g_ = (t, e, r, n) => {
        var a, o, c, l;
        let i = Number(t),
            s = e.find(u => u.id === i);
        if (!s) throw new XP(`Unsupported chainId ${t}`, 4901);
        return new _te(s.rpcUrls.privyWalletOverride && s.rpcUrls.privyWalletOverride.http[0] ? s.rpcUrls.privyWalletOverride.http[0] : r.rpcUrls && r.rpcUrls[i] ? r.rpcUrls[i] : (a = s.rpcUrls.privy) != null && a.http[0] ? {
            url: s.rpcUrls.privy.http[0],
            headers: {
                "privy-app-id": n.appId
            }
        } : (o = s.rpcUrls.public) != null && o.http[0] ? (c = s.rpcUrls.public) == null ? void 0 : c.http[0] : (l = s.rpcUrls.default) == null ? void 0 : l.http[0])
    },
    Ute = (t, e, r) => {
        var a, o, c;
        let n, i = t.id,
            s = Number(t.id);
        if (t.rpcUrls.privyWalletOverride && t.rpcUrls.privyWalletOverride.http[0]) n = t.rpcUrls.privyWalletOverride.http[0];
        else if (e.rpcUrls && e.rpcUrls[s]) n = e.rpcUrls[s];
        else if ((a = t.rpcUrls.privy) != null && a.http[0]) {
            let l = new URL(t.rpcUrls.privy.http[0]);
            l.searchParams.append("privyAppId", r), n = l.toString()
        } else n = (o = t.rpcUrls.public) != null && o.http[0] ? t.rpcUrls.public.http[0] : (c = t.rpcUrls.default) == null ? void 0 : c.http[0];
        if (!n) throw new XP(`No RPC url found for ${i}`);
        return n
    };

function WN(t) {
    return /^-?0x[a-f0-9]+$/i.test(t)
}

function Fte(t) {
    for (let e of ["gasLimit", "gasPrice", "value", "maxPriorityFeePerGas", "maxFeePerGas"]) {
        let r = t[e];
        if (r !== void 0 && ! function(n) {
                let i = typeof n == "number",
                    s = typeof n == "bigint",
                    a = typeof n == "string" && WN(n);
                return i || s || a
            }(r)) throw Error(`Transaction request property '${e}' must be a valid number, bigint, or hex string representing a quantity`)
    }
    if (typeof t.chainId != "number") throw Error("Transaction request property 'chainId' must be a number")
}
async function m_(t, e, r) {
    if (e.chainId = Number(e.chainId), Fte(e), e.from || (e.from = t), !e.nonce) {
        let n = new P6(t, r);
        e.nonce = await n.getTransactionCount("pending")
    }
    return e.gasLimit || (e.gas ? (e.gasLimit = e.gas, delete e.gas) : e.gasLimit = await Lte(e, r)), typeof e.type == "string" && WN(e.type) && (e.type = Number(e.type)), [23294, 23295].includes(e.chainId) && (e.type = 0), (e = BN(e.chainId) ? await Mte(e) : LN(e.chainId) ? await Cte(e, r) : FN(e.chainId) ? await kte(e, r) : UN(e.chainId) ? await Ate(e, r) : await Dte(e, r)).type === 0 && delete e.accessList, e.type !== 2 && (delete e.maxPriorityFeePerGas, delete e.maxFeePerGas), e
}

function Bte({
    currentRecoveryMethod: t,
    upgradeToRecoveryMethod: e
}) {
    switch (t) {
        case "privy":
        case "user-passcode":
        case "recovery-encryption-key":
            return !0;
        case "icloud":
        case "google-drive":
            if (t === e) throw Error("Cannot upgrade to the existing cloud platform");
            return !0;
        default:
            throw Error("Unknown recovery method")
    }
}

function zN(t) {
    return new Promise(e => {
        setTimeout(() => {
            e()
        }, t)
    })
}
let Wte = class {
    enqueue(e, r) {
        this.callbacks[e] = r
    }
    dequeue(e, r) {
        let n = this.callbacks[r];
        if (!n) throw Error(`cannot dequeue ${e} event: no event found for id ${r}`);
        switch (delete this.callbacks[r], e) {
            case "privy:iframe:ready":
            case "privy:wallets:create":
            case "privy:user-signer:sign":
            case "privy:wallets:add":
            case "privy:wallets:set-recovery":
            case "privy:wallets:connect":
            case "privy:wallets:recover":
            case "privy:wallets:rpc":
            case "privy:wallet:create":
            case "privy:wallet:connect":
            case "privy:wallet:recover":
            case "privy:wallet:rpc":
            case "privy:solana-wallet:create":
            case "privy:solana-wallet:create-additional":
            case "privy:solana-wallet:connect":
            case "privy:solana-wallet:recover":
            case "privy:solana-wallet:rpc":
            case "privy:delegated-actions:consent":
            case "privy:mfa:verify":
            case "privy:mfa:init-enrollment":
            case "privy:mfa:submit-enrollment":
            case "privy:mfa:unenroll":
            case "privy:mfa:clear":
                return n;
            default:
                throw Error(`invalid wallet event type ${e}`)
        }
    }
    constructor() {
        this.callbacks = {}
    }
};
async function zte(t, e, r, n, i = !1, s, a) {
    var u, h, f;
    let o = i,
        c = async p => {
            var g;
            if (o) {
                p === (i ? 0 : 1) ? n() : (g = r.current) == null || g.reject(new Ug("missing_or_invalid_mfa", "MFA verification failed, retry."));
                let m = await new Promise((y, w) => {
                    e.current = {
                        resolve: y,
                        reject: w
                    }, setTimeout(() => {
                        var E;
                        let x = new Ug("mfa_timeout", "Timed out waiting for MFA code");
                        (E = r.current) == null || E.reject(x), w(x)
                    }, a)
                });
                return await t(m)
            }
            return await t()
        },
        l = null;
    for (let p = 0; p < s; p++) try {
        l = await c(p), (u = r.current) == null || u.resolve(void 0);
        break
    } catch (g) {
        if (g.type !== "missing_or_invalid_mfa") throw (h = r.current) == null || h.resolve(void 0), g;
        o = !0
    }
    if (l === null) {
        let p = new Ug("mfa_verification_max_attempts_reached", "Max MFA verification attempts reached");
        throw (f = r.current) == null || f.reject(p), p
    }
    return l
}
var y_;
let qte = (y_ = 0, () => "id-" + y_++),
    Hte = (t, e) => typeof e == "bigint" ? e.toString() : e,
    xc = (t, {
        ms: e,
        msg: r
    }) => Promise.race([t, zN(e ? ? 15e3).then(() => Promise.reject(Error(r)))]),
    w_ = new Wte,
    b_ = class {
        invokeWithMfa(e, r) {
            return xc(zte(n => xc(this.waitForReady().then(() => e(n)), {
                msg: r.timeoutMsg,
                ms: r.timeoutMs
            }), this.mfa.rootPromise, this.mfa.submitPromise, () => this.mfa.emit("mfaRequired"), r.mfaAlwaysRequired ? ? !1, 4, 3e5), {
                msg: "Operation reached timeout: MFA verification",
                ms: 126e4
            })
        }
        reload() {
            return this.ready = !1, this._embeddedWalletMessagePoster.reload()
        }
        ping(e = 15e3) {
            return xc(this.invoke("privy:iframe:ready", {}), {
                msg: "Ping reached timeout",
                ms: e
            })
        }
        create(e) {
            return xc(this.waitForReady().then(() => this.invoke("privy:wallet:create", e)), {
                msg: "Operation reached timeout: create"
            })
        }
        rpc(e) {
            return this.invokeWithMfa(r => this.invoke("privy:wallet:rpc", { ...r,
                ...e
            }), {
                timeoutMsg: "Operation reached timeout: rpc"
            })
        }
        createSolana(e) {
            return this.invokeWithMfa(r => this.invoke("privy:solana-wallet:create", { ...r,
                ...e
            }), {
                timeoutMsg: "Operation reached timeout: create",
                timeoutMs: 6e4
            })
        }
        createAdditionalSolana(e) {
            return xc(this.waitForReady().then(() => this.invoke("privy:solana-wallet:create-additional", e)), {
                msg: "Operation reached timeout: create"
            })
        }
        solanaRpc(e) {
            return this.invokeWithMfa(r => this.invoke("privy:solana-wallet:rpc", { ...r,
                ...e
            }), {
                timeoutMsg: "Operation reached timeout: solana-rpc"
            })
        }
        delegateWallets(e) {
            return this.invokeWithMfa(r => this.invoke("privy:delegated-actions:consent", { ...r,
                ...e
            }), {
                timeoutMsg: "Operation reached timeout: delegated-actions:consent"
            })
        }
        verifyMfa(e) {
            return this.invokeWithMfa(r => this.invoke("privy:mfa:verify", { ...r,
                ...e
            }), {
                timeoutMsg: "Operation reached timeout: mfa:verify",
                mfaAlwaysRequired: !0
            })
        }
        initEnrollMfa(e) {
            return this.invokeWithMfa(r => this.invoke("privy:mfa:init-enrollment", { ...r,
                ...e
            }), {
                timeoutMsg: "Operation reached timeout: mfa:init-enrollment"
            })
        }
        submitEnrollMfa(e) {
            return this.invokeWithMfa(r => this.invoke("privy:mfa:submit-enrollment", { ...r,
                ...e
            }), {
                timeoutMsg: "Operation reached timeout: mfa:submit-enrollment"
            })
        }
        unenrollMfa(e) {
            return this.invokeWithMfa(r => this.invoke("privy:mfa:unenroll", { ...r,
                ...e
            }), {
                timeoutMsg: "Operation reached timeout: mfa:unenroll",
                mfaAlwaysRequired: !0
            })
        }
        clearMfa(e) {
            return xc(this.waitForReady().then(() => this.invoke("privy:mfa:clear", e)), {
                msg: "Operation reached timeout: mfa:clear"
            })
        }
        createWallet(e) {
            return this.invokeWithMfa(r => this.invoke("privy:wallets:create", { ...r,
                ...e
            }), {
                timeoutMsg: "Operation reached timeout: create",
                timeoutMs: 6e4
            })
        }
        signWithUserSigner(e) {
            return this.invokeWithMfa(r => this.invoke("privy:user-signer:sign", { ...r,
                ...e
            }), {
                timeoutMsg: "Operation reached timeout: user-signer:sign"
            })
        }
        addWallet(e) {
            return xc(this.waitForReady().then(() => this.invoke("privy:wallets:add", e)), {
                msg: "Operation reached timeout: wallets:add"
            })
        }
        setRecovery(e) {
            return this.invokeWithMfa(r => this.invoke("privy:wallets:set-recovery", { ...r,
                ...e
            }), {
                timeoutMsg: "Operation reached timeout: wallets:set-recovery",
                timeoutMs: 6e4
            })
        }
        connect(e) {
            return xc(this.waitForReady().then(() => this.invoke("privy:wallets:connect", e)), {
                msg: "Operation reached timeout: wallets:connect"
            })
        }
        recover(e) {
            return this.invokeWithMfa(r => this.invoke("privy:wallets:recover", { ...r,
                ...e
            }), {
                timeoutMsg: "Operation reached timeout: wallets:recover",
                timeoutMs: 6e4
            })
        }
        rpcWallet(e) {
            return this.invokeWithMfa(r => this.invoke("privy:wallets:rpc", { ...r,
                ...e
            }), {
                timeoutMsg: "Operation reached timeout: wallets:rpc"
            })
        }
        handleEmbeddedWalletMessages(e) {
            let {
                reject: r,
                resolve: n
            } = w_.dequeue(e.event, e.id);
            return e.error !== void 0 ? r(new Ug(e.error.type, e.error.message)) : n(e.data)
        }
        waitForReady() {
            return this.ready ? Promise.resolve() : new Promise(async (e, r) => {
                for (; !this.ready;) this.invoke("privy:iframe:ready", {}).then(() => {
                    this.ready = !0, e()
                }).catch(r), await zN(150)
            })
        }
        invoke(e, r) {
            let n = ((s, a) => `${s}${JSON.stringify(a,Hte)}`)(e, r);
            if (e === "privy:wallet:create" || e === "privy:solana-wallet:create") {
                let s = this.cache.get(n);
                if (s) return s
            }
            let i = new Promise((s, a) => {
                let o = qte();
                w_.enqueue(o, {
                    resolve: s,
                    reject: a
                }), this._embeddedWalletMessagePoster.postMessage(JSON.stringify({
                    id: o,
                    event: e,
                    data: r
                }), "*")
            }).finally(() => {
                this.cache.delete(n)
            });
            return this.cache.set(n, i), i
        }
        constructor(e, r) {
            this.ready = !1, this.cache = new Map, this._embeddedWalletMessagePoster = e, this.mfa = r
        }
    },
    Vte = ["eth_sign", "eth_signTransaction", "personal_sign", "eth_signTypedData_v4", "csw_signUserOperation", "secp256k1_sign"];
const Gte = t => Vte.includes(t),
    Im = t => /^0x[0-9a-fA-F]*$/.test(t),
    $m = t => Ve.from(t, "utf8"),
    Ap = t => `0x${t.toString("hex")}`;
var d2, v_;

function Kte() {
    return v_ || (v_ = 1, d2 = function t(e) {
        if (typeof e == "number" && isNaN(e)) throw new Error("NaN is not allowed");
        if (typeof e == "number" && !isFinite(e)) throw new Error("Infinity is not allowed");
        return e === null || typeof e != "object" ? JSON.stringify(e) : e.toJSON instanceof Function ? t(e.toJSON()) : Array.isArray(e) ? `[${e.reduce((i,s,a)=>`${i}${a===0?"":","}${t(s===void 0||typeof s=="symbol"?null:s)}`,"")}]` : `{${Object.keys(e).sort().reduce((n,i)=>{if(e[i]===void 0||typeof e[i]=="symbol")return n;const s=n.length===0?"":",";return`${n}${s}${t(i)}:${t(e[i])}`},"")}}`
    }), d2
}
var Yte = Kte();
const Zte = Oa(Yte);
async function Jte(t, e) {
    let r = Zte(e);
    if (r === void 0) throw new Qt({
        error: "Failed to prepare the payload for signing",
        code: "invalid_input"
    });
    let n = Ve.from(r).toString("base64"),
        {
            signature: i
        } = await t({
            message: n
        });
    return {
        signature: i
    }
}
async function Ni(t, e, {
    wallet_id: r,
    ...n
}) {
    let i = {
            version: 1,
            url: t.getCompiledPath($w, {
                params: {
                    wallet_id: r
                }
            }),
            method: $w.method,
            headers: {
                "privy-app-id": t.app.appId
            },
            body: { ...n
            }
        },
        {
            signature: s
        } = await Jte(e, i);
    return await t.fetchPrivyRoute($w, {
        body: n,
        params: {
            wallet_id: r
        },
        headers: {
            "privy-authorization-signature": s
        }
    })
}

function Qte(t) {
    return {
        from: t.from,
        to: t.to,
        nonce: vl(t.nonce),
        chain_id: vl(t.chainId),
        data: function(e) {
            if (e !== void 0) return typeof e == "string" ? Im(e) ? e : Ap($m(e)) : Ap(Ve.from(Uint8Array.from(e)))
        }(t.data),
        value: vl(t.value),
        type: t.type,
        gas_limit: vl(t.gasLimit),
        gas_price: vl(t.gasPrice),
        max_fee_per_gas: vl(t.maxFeePerGas),
        max_priority_fee_per_gas: vl(t.maxPriorityFeePerGas)
    }
}

function vl(t) {
    if (typeof t == "number" || typeof t == "bigint") return `0x${BigInt(t).toString(16)}`;
    if (typeof t == "string") return Im(t) ? t : Ap($m(t))
}

function Xte(t) {
    return typeof t == "string" && (t = JSON.parse(t)), {
        types: t.types,
        primary_type: String(t.primaryType),
        domain: t.domain,
        message: t.message
    }
}
async function qN({
    context: t,
    account: e,
    rpcRequest: r
}) {
    switch (r.chainType) {
        case "ethereum":
            return async function({
                context: n,
                account: i,
                rpcRequest: s
            }) {
                switch (s.method) {
                    case "personal_sign":
                        {
                            let [a] = s.params,
                            o = await Ni(n, n.signRequest, {
                                chain_type: "ethereum",
                                method: "personal_sign",
                                wallet_id: i.id,
                                params: a.startsWith("0x") ? {
                                    message: a.slice(2),
                                    encoding: "hex"
                                } : {
                                    message: a,
                                    encoding: "utf-8"
                                }
                            });
                            if (o.method !== "personal_sign") throw Error("Unable to sign message");
                            return {
                                data: o.data.signature
                            }
                        }
                    case "eth_signTransaction":
                        {
                            let [a] = s.params,
                            o = await Ni(n, n.signRequest, {
                                chain_type: "ethereum",
                                method: "eth_signTransaction",
                                wallet_id: i.id,
                                params: {
                                    transaction: Qte(a)
                                }
                            });
                            if (o.method !== "eth_signTransaction") throw Error("Unable to sign transaction");
                            return {
                                data: o.data.signed_transaction
                            }
                        }
                    case "eth_signTypedData_v4":
                        {
                            let [, a] = s.params,
                            o = await Ni(n, n.signRequest, {
                                chain_type: "ethereum",
                                method: s.method,
                                wallet_id: i.id,
                                params: {
                                    typed_data: Xte(a)
                                }
                            });
                            if (o.method !== "eth_signTypedData_v4") throw Error("Unable to sign typed data");
                            return {
                                data: o.data.signature
                            }
                        }
                    case "eth_sign":
                        {
                            let [, a] = s.params,
                            o = await Ni(n, n.signRequest, {
                                chain_type: "ethereum",
                                method: "secp256k1_sign",
                                wallet_id: i.id,
                                params: {
                                    hash: Im(a) ? a : Ap($m(a))
                                }
                            });
                            if (o.method !== "secp256k1_sign") throw Error("Unable to sign message");
                            return {
                                data: o.data.signature
                            }
                        }
                    case "secp256k1_sign":
                        {
                            let [a] = s.params,
                            o = await Ni(n, n.signRequest, {
                                chain_type: "ethereum",
                                method: "secp256k1_sign",
                                wallet_id: i.id,
                                params: {
                                    hash: Im(a) ? a : Ap($m(a))
                                }
                            });
                            if (o.method !== "secp256k1_sign") throw Error("Unable to sign message");
                            return {
                                data: o.data.signature
                            }
                        }
                    case "csw_signUserOperation":
                    case "eth_sendTransaction":
                    case "eth_populateTransactionRequest":
                        throw Error(`This wallet does not support the method: ${s.method}`)
                }
            }({
                context: t,
                account: e,
                rpcRequest: r.request
            });
        case "solana":
            return async function({
                context: n,
                account: i,
                rpcRequest: s
            }) {
                if (s.method === "signMessage") {
                    let {
                        message: a
                    } = s.params, o = await Ni(n, n.signRequest, {
                        chain_type: "solana",
                        method: "signMessage",
                        wallet_id: i.id,
                        params: {
                            message: a,
                            encoding: "base64"
                        }
                    });
                    if (o.method !== "signMessage") throw Error("Unable to sign message");
                    return {
                        data: o.data.signature
                    }
                }
            }({
                context: t,
                account: e,
                rpcRequest: r.request
            })
    }
}
let u2 = class extends Ed {
    async request(e) {
        var r, n;
        if (Gte(e.method)) return this.handleIFrameRpc(e);
        switch (e.method) {
            case "eth_accounts":
            case "eth_requestAccounts":
                return this._account.address ? [this._account.address] : [];
            case "eth_chainId":
                return `0x${this._chainId.toString(16)}`;
            case "wallet_switchEthereumChain":
                return this.handleSwitchEthereumChain(e);
            case "eth_estimateGas":
                return this.handleEstimateGas(e);
            case "eth_sendTransaction":
                {
                    let i = (r = e.params) == null ? void 0 : r[0];
                    return this.handleSendTransaction(i)
                }
            case "eth_populateTransactionRequest":
                {
                    let i = (n = e.params) == null ? void 0 : n[0];
                    return this.handlePopulateTransaction(i)
                }
            default:
                return this.handleJsonRpc(e)
        }
    }
    ensureChainId(e) {
        let r = {
            chainId: this._chainId,
            ...e
        };
        return this.internalSwitchEthereumChain(r.chainId), r
    }
    internalSwitchEthereumChain(e) {
        e && Number(e) !== this._chainId && (this._chainId = Number(e), this._jsonRpcProvider = g_(this._chainId, this._chains, {
            rpcUrls: []
        }, {
            appId: this._privyInternal.appId
        }), this.emit("chainChanged", e))
    }
    async handlePopulateTransaction(e) {
        let r = this.ensureChainId(e);
        return m_(this._account.address, r, this._jsonRpcProvider)
    }
    async handleSendTransaction(e) {
        let r = this.ensureChainId(e),
            n = await m_(this._account.address, r, this._jsonRpcProvider),
            i = await this.handleIFrameRpc({
                method: "eth_signTransaction",
                params: [n]
            });
        return await this.handleJsonRpc({
            method: "eth_sendRawTransaction",
            params: [i]
        })
    }
    async handleEstimateGas(e) {
        if (!e.params || !Array.isArray(e.params)) throw Error("Invalid params for eth_estimateGas");
        delete e.params[0].gasPrice, delete e.params[0].maxFeePerGas, delete e.params[0].maxPriorityFeePerGas;
        let r = { ...e.params[0],
            chainId: `0x${this._chainId.toString(16)}`
        };
        this.internalSwitchEthereumChain(r.chainId);
        try {
            return await this._jsonRpcProvider.send("eth_estimateGas", [r])
        } catch (n) {
            console.warn(`Gas estimation failed with error: ${n}. Retrying gas estimation by omitting the 'from' address`);
            try {
                return delete r.from, await this._jsonRpcProvider.send("eth_estimateGas", [r])
            } catch (i) {
                throw console.warn(`Gas estimation failed with error: ${i} when omitting the 'from' address`), n
            }
        }
    }
    handleSwitchEthereumChain(e) {
        let r;
        if (!e.params || !Array.isArray(e.params)) throw new h7(`Invalid params for ${e.method}`, 4200);
        if (typeof e.params[0] == "string") r = e.params[0];
        else {
            if (!("chainId" in e.params[0]) || typeof e.params[0].chainId != "string") throw new h7(`Invalid params for ${e.method}`, 4200);
            r = e.params[0].chainId
        }
        this.internalSwitchEthereumChain(r)
    }
    async handleIFrameRpc(e) {
        try {
            let r = await this._privyInternal.getAccessToken();
            if (!r) throw Error("Missing privy token. User must be logged in");
            this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started", {
                method: e.method,
                address: this._account.address
            });
            let n = this._account;
            if (Uc(n)) {
                let {
                    data: i
                } = await qN({
                    context: {
                        app: this._appApi,
                        fetchPrivyRoute: (...s) => this._privyInternal.fetch(...s),
                        getCompiledPath: (...s) => this._privyInternal.getPath(...s),
                        signRequest: ({
                            message: s
                        }) => this._walletProxy.signWithUserSigner({
                            accessToken: r,
                            message: s
                        })
                    },
                    account: n,
                    rpcRequest: {
                        chainType: "ethereum",
                        request: e
                    }
                });
                return i
            }
            try {
                await this._walletProxy.connect({
                    entropyId: this._entropyId,
                    entropyIdVerifier: this._entropyIdVerifier,
                    accessToken: r
                })
            } catch (i) {
                let s = T6(i);
                if (s && this._account.recovery_method === "privy") await this._walletProxy.recover({
                    entropyId: this._entropyId,
                    entropyIdVerifier: this._entropyIdVerifier,
                    accessToken: r
                });
                else {
                    if (!s || !this._onNeedsRecovery) throw i; {
                        let a;
                        await new Promise(async (o, c) => {
                            var l;
                            a = setTimeout(() => c(new Qt({
                                code: "embedded_wallet_recovery_error",
                                error: "User-owned recovery timed out"
                            })), 12e4), await ((l = this._onNeedsRecovery) == null ? void 0 : l.call(this, {
                                recoveryMethod: this._account.recovery_method,
                                onRecovered: () => o(!0)
                            }))
                        }).finally(() => clearTimeout(a))
                    }
                }
            }
            return (await this._walletProxy.rpcWallet({
                accessToken: r,
                request: e,
                entropyId: this._entropyId,
                entropyIdVerifier: this._entropyIdVerifier,
                hdWalletIndex: this._account.wallet_index,
                chainType: "ethereum"
            })).response.data
        } catch (r) {
            console.error(r);
            let n = r instanceof Error ? r.message : "Unable to make wallet request";
            throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed", {
                method: e.method,
                address: this._account.address,
                error: n
            }), new Qt({
                code: "embedded_wallet_request_error",
                error: n
            })
        }
    }
    async handleJsonRpc(e) {
        return this._jsonRpcProvider.send(e.method, e.params ? ? [])
    }
    toJSON() {
        return `PrivyEIP1193Provider { address: '${this._account.address}', chainId: ${this._chainId}, request: [Function] }`
    }
    constructor({
        walletProxy: e,
        privyInternal: r,
        account: n,
        entropyId: i,
        entropyIdVerifier: s,
        chains: a,
        onNeedsRecovery: o,
        chainId: c = a[0].id,
        appApi: l
    }) {
        super(), this._walletProxy = e, this._privyInternal = r, this._account = n, this._entropyId = i, this._entropyIdVerifier = s, this._chainId = c, this._chains = a, this._onNeedsRecovery = o, this._jsonRpcProvider = g_(c, a, {
            rpcUrls: []
        }, {
            appId: l.appId
        }), this._appApi = l
    }
};

function N3(t) {
    return "version" in t
}

function x_(t, e) {
    let r = (N3(t) ? t.message : t.compileMessage()).staticAccountKeys.find(n => n.toBase58() === e);
    if (!r) throw Error(`Transaction does not contain public key ${e}`);
    return r
}
let ere = class {
        async request(e) {
            if (!await this._privyInternal.getAccessToken()) throw new Qt({
                error: "Missing access token",
                code: "attempted_rpc_call_before_logged_in"
            });
            switch (e.method) {
                case "signAndSendTransaction":
                    return await this.handleSignAndSendTransaction(e);
                case "signTransaction":
                    return await this.handleSignTransaction(e);
                default:
                    return await this.handleIFrameRpc(e)
            }
        }
        get _publicKey() {
            return this._account.address
        }
        async connectAndRecover(e) {
            if (this._account.recovery_method !== "privy-v2") try {
                await this._proxy.connect({
                    entropyId: this._entropyId,
                    entropyIdVerifier: this._entropyIdVerifier,
                    accessToken: e
                })
            } catch (r) {
                let n = T6(r);
                if (n && this._account.recovery_method === "privy") await this._proxy.recover({
                    entropyId: this._entropyId,
                    entropyIdVerifier: this._entropyIdVerifier,
                    accessToken: e
                });
                else {
                    if (!n || !this._onNeedsRecovery) throw r; {
                        let i;
                        await new Promise(async (s, a) => {
                            var o;
                            i = setTimeout(() => a(new Qt({
                                code: "embedded_wallet_recovery_error",
                                error: "User-owned recovery timed out"
                            })), 12e4), await ((o = this._onNeedsRecovery) == null ? void 0 : o.call(this, {
                                recoveryMethod: this._account.recovery_method,
                                onRecovered: () => s(!0)
                            }))
                        }).finally(() => clearTimeout(i))
                    }
                }
            }
        }
        async signMessageRpc(e, r) {
            let n = this._account;
            if (!Uc(n)) return (await this._proxy.rpcWallet({
                accessToken: r,
                request: e,
                chainType: "solana",
                hdWalletIndex: this._account.wallet_index,
                entropyId: this._entropyId,
                entropyIdVerifier: this._entropyIdVerifier
            })).response.data; {
                let {
                    data: i
                } = await qN({
                    context: {
                        app: this._app,
                        fetchPrivyRoute: (...s) => this._privyInternal.fetch(...s),
                        getCompiledPath: (...s) => this._privyInternal.getPath(...s),
                        signRequest: ({
                            message: s
                        }) => this._proxy.signWithUserSigner({
                            accessToken: r,
                            message: s
                        })
                    },
                    account: n,
                    rpcRequest: {
                        chainType: "solana",
                        request: e
                    }
                });
                return {
                    signature: i
                }
            }
        }
        async handleIFrameRpc(e) {
            try {
                let r = await this._privyInternal.getAccessToken();
                if (!r) throw Error("Missing privy token. User must be logged in");
                return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started", {
                    method: e.method,
                    address: this._account.address
                }), await this.connectAndRecover(r), await this.signMessageRpc(e, r)
            } catch (r) {
                console.error(r);
                let n = r instanceof Error ? r.message : "Unable to make wallet request";
                throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed", {
                    method: e.method,
                    address: this._account.address,
                    error: n
                }), new Qt({
                    code: "embedded_wallet_request_error",
                    error: n
                })
            }
        }
        async handleSignAndSendTransaction(e) {
            try {
                let r = await this._privyInternal.getAccessToken();
                if (!r) throw Error("Missing privy token. User must be logged in");
                this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started", {
                    method: e.method,
                    address: this._account.address
                }), await this.connectAndRecover(r);
                let {
                    transaction: n,
                    connection: i,
                    options: s
                } = e.params, a = x_(n, this._account.address), o = N3(n) ? Ve.from(n.message.serialize()) : n.serializeMessage(), {
                    signature: c
                } = await this.signMessageRpc({
                    method: "signMessage",
                    params: {
                        message: o.toString("base64")
                    }
                }, r);
                return n.addSignature(a, Ve.from(c, "base64")), {
                    signature: await i.sendRawTransaction(n.serialize(), s)
                }
            } catch (r) {
                console.error(r);
                let n = r instanceof Error ? r.message : "Unable to make wallet request";
                throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed", {
                    method: e.method,
                    address: this._account.address,
                    error: n
                }), new Qt({
                    code: "embedded_wallet_request_error",
                    error: n
                })
            }
        }
        async handleSignTransaction(e) {
            try {
                let r = await this._privyInternal.getAccessToken();
                if (!r) throw Error("Missing privy token. User must be logged in");
                this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started", {
                    method: e.method,
                    address: this._account.address
                }), await this.connectAndRecover(r);
                let {
                    transaction: n
                } = e.params, i = x_(n, this._account.address), s = N3(n) ? Ve.from(n.message.serialize()) : n.serializeMessage(), {
                    signature: a
                } = await this.signMessageRpc({
                    method: "signMessage",
                    params: {
                        message: s.toString("base64")
                    }
                }, r);
                return n.addSignature(i, Ve.from(a, "base64")), {
                    signedTransaction: n
                }
            } catch (r) {
                console.error(r);
                let n = r instanceof Error ? r.message : "Unable to make wallet request";
                throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed", {
                    method: e.method,
                    address: this._account.wallet_index,
                    error: n
                }), new Qt({
                    code: "embedded_wallet_request_error",
                    error: n
                })
            }
        }
        toJSON() {
            return `PrivyEmbeddedSolanaProvider { address: '${this._account.address}', request: [Function] }`
        }
        constructor({
            proxy: e,
            privyInternal: r,
            account: n,
            entropyId: i,
            entropyIdVerifier: s,
            onNeedsRecovery: a,
            app: o
        }) {
            this._proxy = e, this._privyInternal = r, this._account = n, this._entropyId = i, this._entropyIdVerifier = s, this._onNeedsRecovery = a, this._app = o
        }
    },
    tre = class {
        setMessagePoster(e) {
            this._proxy = new b_(e, this._mfaPromises), this._mfa.setProxy(this._proxy)
        }
        async signWithUserSigner(e) {
            if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
            let r = await this._privyInternal.getAccessToken();
            if (!r) throw new Qt({
                error: "User must be logged in to sign a message with the user signer",
                code: "user_signer_sign_error"
            });
            let {
                signature: n
            } = await this._proxy.signWithUserSigner({
                accessToken: r,
                message: e.message
            });
            return {
                signature: n
            }
        }
        async add(e) {
            var n;
            if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
            if (((n = this._privyInternal.config) == null ? void 0 : n.embedded_wallet_config.mode) === "user-controlled-server-wallets-only") await Dw({
                context: {
                    app: this._appApi,
                    fetchPrivyRoute: (...i) => this._privyInternal.fetch(...i),
                    getCompiledPath: (...i) => this._privyInternal.getPath(...i)
                },
                chainType: e.chainType
            });
            else {
                let i = await this._privyInternal.getAccessToken();
                if (!i) throw new Qt({
                    error: "User must be logged in to create an embedded wallet",
                    code: "embedded_wallet_creation_error"
                });
                await this._proxy.addWallet({
                    accessToken: i,
                    ...e
                })
            }
            let {
                user: r
            } = await this._privyInternal.refreshSession();
            return {
                user: r
            }
        }
        async getBitcoinProvider({
            wallet: e,
            entropyId: r,
            entropyIdVerifier: n,
            recoveryPassword: i,
            recoveryAccessToken: s,
            recoverySecretOverride: a
        }) {
            if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
            if (!await this._privyInternal.getAccessToken()) throw Error("User must be logged in to create an embedded wallet");
            return Uc(e) || await this._load({
                entropyId: r,
                entropyIdVerifier: n,
                wallet: e,
                recoveryPassword: i,
                recoveryAccessToken: s,
                recoverySecretOverride: a
            }), new tX({
                account: e,
                privyInternal: this._privyInternal,
                proxy: this._proxy,
                entropyId: r,
                entropyIdVerifier: n
            })
        }
        async create({
            password: e,
            recoveryMethod: r,
            recoveryToken: n,
            recoveryKey: i,
            recoverySecretOverride: s,
            iCloudRecordNameOverride: a,
            solanaAccount: o,
            skipCallbacks: c
        }) {
            var l, u;
            if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
            if (((l = this._privyInternal.config) == null ? void 0 : l.embedded_wallet_config.mode) === "user-controlled-server-wallets-only") {
                if (r && !r.startsWith("privy")) throw new Qt({
                    error: "User-controlled server wallets do not support custom recovery methods",
                    code: "embedded_wallet_creation_error"
                });
                await Dw({
                    context: {
                        app: this._appApi,
                        fetchPrivyRoute: (...h) => this._privyInternal.fetch(...h),
                        getCompiledPath: (...h) => this._privyInternal.getPath(...h)
                    },
                    chainType: "ethereum"
                })
            } else {
                let h;
                if (h = r || (e ? "user-passcode" : "privy"), e && typeof e != "string") throw Error("Invalid recovery password, must be a string");
                if (h === "privy" && ((u = this._privyInternal.config) != null && u.embedded_wallet_config.require_user_password_on_create)) throw Error("Password not provided yet is required by App configuration");
                let f = await this._privyInternal.getAccessToken();
                if (!f) throw Error("User must be logged in to create an embedded wallet");
                let {
                    address: p
                } = await this._proxy.create({
                    accessToken: f,
                    recoveryMethod: h,
                    recoveryKey: i,
                    recoveryPassword: e,
                    recoveryAccessToken: n,
                    recoverySecretOverride: s,
                    iCloudRecordNameOverride: a,
                    solanaAddress: o == null ? void 0 : o.address
                });
                if (!p) throw Error("Failed to create wallet")
            }
            return await this._privyInternal.refreshSession(c)
        }
        async createSolana(e) {
            var r, n;
            if (!this._proxy) throw new Qt({
                error: "Embedded wallet proxy not initialized",
                code: "embedded_wallet_creation_error"
            });
            if (((r = this._privyInternal.config) == null ? void 0 : r.embedded_wallet_config.mode) === "user-controlled-server-wallets-only") await Dw({
                context: {
                    app: this._appApi,
                    fetchPrivyRoute: (...i) => this._privyInternal.fetch(...i),
                    getCompiledPath: (...i) => this._privyInternal.getPath(...i)
                },
                chainType: "solana"
            });
            else {
                let i = await this._privyInternal.getAccessToken();
                if (!i) throw new Qt({
                    error: "User must be logged in to create an embedded wallet",
                    code: "embedded_wallet_creation_error"
                });
                e != null && e.ethereumAccount && await this.getProvider(e.ethereumAccount);
                let {
                    publicKey: s
                } = await this._proxy.createSolana({
                    accessToken: i,
                    ethereumAddress: (n = e == null ? void 0 : e.ethereumAccount) == null ? void 0 : n.address
                });
                if (!s) throw new Qt({
                    error: "Failed to create wallet",
                    code: "embedded_wallet_creation_error"
                })
            }
            return await this._privyInternal.refreshSession()
        }
        async delegateWallets({
            delegatedWallets: e,
            rootWallet: r
        }) {
            if (!this._proxy) throw new Qt({
                error: "Embedded wallet proxy not initialized",
                code: "embedded_wallet_creation_error"
            });
            let n = await this._privyInternal.getAccessToken();
            if (!n) throw new Qt({
                error: "User must be logged in to create an embedded wallet",
                code: "embedded_wallet_creation_error"
            });
            await this._proxy.delegateWallets({
                accessToken: n,
                delegatedWallets: e,
                rootWallet: r
            })
        }
        async getProvider(e, r, n, i, s) {
            if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
            return Uc(e) || await this._load({
                wallet: e,
                entropyId: e.address,
                entropyIdVerifier: "ethereum-address-verifier",
                recoveryPassword: r,
                recoveryKey: s,
                recoveryAccessToken: n,
                recoverySecretOverride: i
            }), new u2({
                account: e,
                entropyId: e.address,
                entropyIdVerifier: "ethereum-address-verifier",
                privyInternal: this._privyInternal,
                chains: this._chains,
                walletProxy: this._proxy,
                appApi: this._appApi
            })
        }
        async getEthereumProvider({
            wallet: e,
            entropyId: r,
            entropyIdVerifier: n,
            recoveryPassword: i,
            recoveryAccessToken: s,
            recoverySecretOverride: a,
            recoveryKey: o,
            onNeedsRecovery: c
        }) {
            if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
            if (!await this._privyInternal.getAccessToken()) throw Error("User must be logged in to create an embedded wallet");
            return Uc(e) || (!c || i || s || a || o) && await this._load({
                entropyId: r,
                entropyIdVerifier: n,
                wallet: e,
                recoveryPassword: i,
                recoveryAccessToken: s,
                recoverySecretOverride: a,
                recoveryKey: o
            }), new u2({
                account: e,
                entropyId: r,
                entropyIdVerifier: "ethereum-address-verifier",
                privyInternal: this._privyInternal,
                chains: this._chains,
                walletProxy: this._proxy,
                onNeedsRecovery: c,
                appApi: this._appApi
            })
        }
        async getSolanaProvider(e, r, n, i, s, a, o) {
            if (!this._proxy) throw new Qt({
                error: "Embedded wallet proxy not initialized",
                code: "embedded_wallet_webview_not_loaded"
            });
            return Uc(e) || (!o || i || s || a) && await this._load({
                wallet: e,
                entropyId: r,
                entropyIdVerifier: n,
                recoveryPassword: i,
                recoveryAccessToken: s,
                recoverySecretOverride: a
            }), new ere({
                account: e,
                privyInternal: this._privyInternal,
                proxy: this._proxy,
                entropyId: r,
                entropyIdVerifier: n,
                onNeedsRecovery: o,
                app: this._appApi
            })
        }
        async setRecovery(e) {
            let {
                wallet: r,
                ...n
            } = e;
            if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
            if (Uc(r)) throw new Qt({
                error: "This wallet does not support setting recovery methods",
                code: "unsupported_recovery_method"
            });
            Bte({
                currentRecoveryMethod: r.recovery_method,
                upgradeToRecoveryMethod: n.recoveryMethod === "icloud-native" ? "icloud" : n.recoveryMethod
            }), await this._load(r.chain_type === "solana" ? {
                wallet: r,
                entropyId: r.address,
                entropyIdVerifier: "solana-address-verifier"
            } : {
                wallet: r,
                entropyId: r.address,
                entropyIdVerifier: "ethereum-address-verifier"
            });
            let i = await this._privyInternal.getAccessToken();
            if (!i) throw Error("User must be logged in to interact with embedded wallets");
            let s = r.recovery_method;
            this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_set_recovery_started", {
                address: r.address,
                target_recovery_method: n.recoveryMethod,
                existing_recovery_method: s
            });
            try {
                let a;
                if (n.recoveryMethod === "user-passcode") a = {
                    recoveryMethod: "user-passcode",
                    recoveryPassword: n.password
                };
                else if (n.recoveryMethod === "google-drive") a = {
                    recoveryMethod: "google-drive",
                    recoveryAccessToken: n.recoveryAccessToken
                };
                else if (n.recoveryMethod === "icloud") a = {
                    recoveryMethod: "icloud",
                    recoveryAccessToken: n.recoveryAccessToken
                };
                else if (n.recoveryMethod === "icloud-native") a = {
                    recoveryMethod: "icloud-native",
                    iCloudRecordNameOverride: n.iCloudRecordNameOverride,
                    recoverySecretOverride: n.recoverySecretOverride
                };
                else if (n.recoveryMethod === "recovery-encryption-key") a = {
                    recoveryMethod: "recovery-encryption-key",
                    recoveryKey: n.recoveryKey
                };
                else {
                    if (n.recoveryMethod !== "privy") throw Error(`Unknown recovery method: ${n.recoveryMethod}`);
                    a = {
                        recoveryMethod: "privy"
                    }
                }
                await this._proxy.setRecovery({
                    accessToken: i,
                    entropyId: r.address,
                    entropyIdVerifier: r.chain_type === "solana" ? "solana-address-verifier" : "ethereum-address-verifier",
                    ...a
                }), this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_set_recovery_completed", {
                    address: r.address,
                    target_recovery_method: n.recoveryMethod,
                    existing_recovery_method: s
                });
                let {
                    user: o
                } = await this._privyInternal.refreshSession();
                return {
                    user: o,
                    provider: r.chain_type !== "ethereum" ? null : new u2({
                        account: r,
                        entropyId: r.address,
                        entropyIdVerifier: "ethereum-address-verifier",
                        privyInternal: this._privyInternal,
                        chains: this._chains,
                        walletProxy: this._proxy,
                        appApi: this._appApi
                    })
                }
            } catch (a) {
                throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_set_recovery_failed", {
                    address: r.address,
                    recovery_method: r.recovery_method,
                    error: a instanceof Error ? a.message : "Unable to recover wallet"
                }), a
            }
        }
        getURL() {
            let e = new URL(`${this._privyInternal.baseUrl}/apps/${this._privyInternal.appId}/embedded-wallets`);
            return this._privyInternal.caid && e.searchParams.append("caid", this._privyInternal.caid), this._privyInternal.appClientId && e.searchParams.append("client_id", this._privyInternal.appClientId), e.href
        }
        get chains() {
            return this._chains
        }
        onMessage(e) {
            if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
            return this._proxy.handleEmbeddedWalletMessages(e)
        }
        reload() {
            this._proxy ? this._proxy.reload() : console.warn("Attempted to reload proxy before initialized")
        }
        async ping(e) {
            try {
                if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
                return await this._proxy.ping(e), !0
            } catch (r) {
                return console.error(r), !1
            }
        }
        async _load({
            entropyId: e,
            entropyIdVerifier: r,
            wallet: n,
            recoveryPassword: i,
            recoveryKey: s,
            recoveryAccessToken: a,
            recoverySecretOverride: o
        }) {
            if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
            let c = await this._privyInternal.getAccessToken();
            if (!c) throw Error("User must be logged in to interact with embedded wallets");
            try {
                return await this._proxy.connect({
                    accessToken: c,
                    entropyId: e,
                    entropyIdVerifier: r
                }), e
            } catch (l) {
                if (T6(l)) try {
                    if (n.recovery_method === "privy") {
                        this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started", {
                            address: n.address,
                            recovery_method: n.recovery_method
                        });
                        let u = await this._proxy.recover({
                            accessToken: c,
                            entropyId: e,
                            entropyIdVerifier: r
                        });
                        return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed", {
                            address: n.address,
                            recovery_method: n.recovery_method
                        }), u.entropyId
                    }
                    if (n.recovery_method === "user-passcode" && i) {
                        this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started", {
                            address: n.address,
                            recovery_method: n.recovery_method
                        });
                        let u = await this._proxy.recover({
                            accessToken: c,
                            recoveryPassword: i,
                            entropyId: e,
                            entropyIdVerifier: r
                        });
                        return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed", {
                            address: n.address,
                            recovery_method: n.recovery_method
                        }), u.entropyId
                    }
                    if (["google-drive", "icloud"].includes(n.recovery_method) && a) {
                        this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started", {
                            address: n.address,
                            recovery_method: n.recovery_method
                        });
                        let u = await this._proxy.recover({
                            accessToken: c,
                            recoveryAccessToken: a,
                            entropyId: e,
                            entropyIdVerifier: r
                        });
                        return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed", {
                            address: n.address,
                            recovery_method: n.recovery_method
                        }), u.entropyId
                    }
                    if (n.recovery_method === "icloud" && o) {
                        this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started", {
                            address: n.address,
                            recovery_method: "icloud-native"
                        });
                        let u = await this._proxy.recover({
                            accessToken: c,
                            recoverySecretOverride: o,
                            entropyId: e,
                            entropyIdVerifier: r
                        });
                        return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed", {
                            address: n.address,
                            recovery_method: "icloud-native"
                        }), u.entropyId
                    }
                    if (n.recovery_method === "recovery-encryption-key" && s) {
                        this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started", {
                            address: n.address,
                            recovery_method: n.recovery_method
                        });
                        let u = await this._proxy.recover({
                            accessToken: c,
                            recoveryKey: s,
                            entropyId: e,
                            entropyIdVerifier: r
                        });
                        return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed", {
                            address: n.address,
                            recovery_method: n.recovery_method
                        }), u.entropyId
                    }
                } catch (u) {
                    throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_failed", {
                        address: n.address,
                        recovery_method: n.recovery_method,
                        error: u instanceof Error ? u.message : `Unable to recover wallet: ${e}`
                    }), u
                }
                throw l
            }
        }
        constructor(e, r, n, i, s, a) {
            if (this._chains = Array.from(s0), this._privyInternal = e, r && (this._proxy = new b_(r, s), i.setProxy(this._proxy)), n) {
                let o = QP(n);
                this._chains = o
            }
            this._mfa = i, this._mfaPromises = s, this._appApi = a
        }
    },
    rre = class extends Ed {
        constructor() {
            super(), this.rootPromise = {
                current: null
            }, this.submitPromise = {
                current: null
            }
        }
    },
    Z0;
const nre = new Uint8Array(16);

function ire() {
    if (!Z0 && (Z0 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Z0)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return Z0(nre)
}
const _n = [];
for (let t = 0; t < 256; ++t) _n.push((t + 256).toString(16).slice(1));

function sre(t, e = 0) {
    return _n[t[e + 0]] + _n[t[e + 1]] + _n[t[e + 2]] + _n[t[e + 3]] + "-" + _n[t[e + 4]] + _n[t[e + 5]] + "-" + _n[t[e + 6]] + _n[t[e + 7]] + "-" + _n[t[e + 8]] + _n[t[e + 9]] + "-" + _n[t[e + 10]] + _n[t[e + 11]] + _n[t[e + 12]] + _n[t[e + 13]] + _n[t[e + 14]] + _n[t[e + 15]]
}
const are = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto),
    E_ = {
        randomUUID: are
    };

function Sm(t, e, r) {
    if (E_.randomUUID && !t) return E_.randomUUID();
    t = t || {};
    const n = t.random || (t.rng || ire)();
    return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, sre(n)
} /*! js-cookie v3.0.5 | MIT */
function J0(t) {
    for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e];
        for (var n in r) t[n] = r[n]
    }
    return t
}
var ore = {
    read: function(t) {
        return t[0] === '"' && (t = t.slice(1, -1)), t.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
    },
    write: function(t) {
        return encodeURIComponent(t).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent)
    }
};

function O3(t, e) {
    function r(i, s, a) {
        if (!(typeof document > "u")) {
            a = J0({}, e, a), typeof a.expires == "number" && (a.expires = new Date(Date.now() + a.expires * 864e5)), a.expires && (a.expires = a.expires.toUTCString()), i = encodeURIComponent(i).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
            var o = "";
            for (var c in a) a[c] && (o += "; " + c, a[c] !== !0 && (o += "=" + a[c].split(";")[0]));
            return document.cookie = i + "=" + t.write(s, i) + o
        }
    }

    function n(i) {
        if (!(typeof document > "u" || arguments.length && !i)) {
            for (var s = document.cookie ? document.cookie.split("; ") : [], a = {}, o = 0; o < s.length; o++) {
                var c = s[o].split("="),
                    l = c.slice(1).join("=");
                try {
                    var u = decodeURIComponent(c[0]);
                    if (a[u] = t.read(l, u), i === u) break
                } catch {}
            }
            return i ? a[i] : a
        }
    }
    return Object.create({
        set: r,
        get: n,
        remove: function(i, s) {
            r(i, "", J0({}, s, {
                expires: -1
            }))
        },
        withAttributes: function(i) {
            return O3(this.converter, J0({}, this.attributes, i))
        },
        withConverter: function(i) {
            return O3(J0({}, this.converter, i), this.attributes)
        }
    }, {
        attributes: {
            value: Object.freeze(e)
        },
        converter: {
            value: Object.freeze(t)
        }
    })
}
var Ur = O3(ore, {
    path: "/"
});
const __ = Promise.allSettled.bind(Promise) ? ? (t => Promise.all(t.map(e => e.then(r => ({
    status: "fulfilled",
    value: r
})).catch(r => ({
    status: "rejected",
    reason: r
})))));
let Jd = "privy:token",
    h2 = "privy-token",
    Q0 = "privy:refresh_token",
    f2 = "privy-refresh-token",
    Qd = "privy:id-token",
    p2 = "privy-id-token",
    X0 = "privy-session",
    HN = class extends Ed {
        set isUsingServerCookies(e) {
            this._isUsingServerCookies = e
        }
        async getToken() {
            let e = await this._storage.get(Jd);
            try {
                return typeof e == "string" ? new bf(e).value : null
            } catch (r) {
                return console.error(r), await this.destroyLocalState({
                    reason: "getToken_error"
                }), null
            }
        }
        async getRefreshToken() {
            let e = await this._storage.get(Q0);
            return typeof e == "string" ? e : null
        }
        async getIdentityToken() {
            let e = await this._storage.get(Qd);
            return typeof e == "string" ? e : null
        }
        get mightHaveServerCookies() {
            try {
                let e = Ur.get(X0);
                return e !== void 0 && e.length > 0
            } catch (e) {
                console.error(e)
            }
            return !1
        }
        hasRefreshCredentials(e, r) {
            return this.mightHaveServerCookies || typeof e == "string" && typeof r == "string"
        }
        tokenIsActive(e) {
            if (!e) return !1;
            let r = bf.parse(e);
            return r !== null && !r.isExpired(30)
        }
        async destroyLocalState(e) {
            await __([this._storage.del(Jd), this._storage.del(Q0), this._storage.del(Qd), this._storage.del(this.GUEST_CREDENTIAL_STORAGE_KEY)]), Ur.remove(h2), Ur.remove(f2), Ur.remove(p2), Ur.remove(X0), e != null && e.reason && this.emit("storage_cleared", {
                reason: e.reason
            })
        }
        async storeToken(e) {
            var r;
            if (typeof e == "string") {
                let n = await this._storage.get(Jd);
                if (await this._storage.put(Jd, e), !this._isUsingServerCookies) {
                    let i = (r = bf.parse(e)) == null ? void 0 : r.expiration;
                    Ur.set(h2, e, {
                        sameSite: "Strict",
                        secure: !0,
                        expires: i ? new Date(1e3 * i) : void 0
                    })
                }
                n !== e && this.emit("token_stored", {
                    cookiesEnabled: this._isUsingServerCookies
                })
            } else {
                let n = await this._storage.get(Jd);
                await this._storage.del(Jd), Ur.remove(h2), n !== null && this.emit("token_cleared", {
                    reason: "set_with_non_string_value"
                })
            }
        }
        async storeRefreshToken(e) {
            typeof e == "string" ? (await this._storage.put(Q0, e), this._isUsingServerCookies || (Ur.set(X0, "t", {
                sameSite: "Strict",
                secure: !0,
                expires: 30
            }), Ur.set(f2, e, {
                sameSite: "Strict",
                secure: !0,
                expires: 30
            })), this.emit("refresh_token_stored", {
                cookiesEnabled: this._isUsingServerCookies
            })) : (await this._storage.del(Q0), Ur.remove(f2), Ur.remove(X0), this.emit("refresh_token_cleared", {
                reason: "set_with_non_string_value"
            }))
        }
        async updateWithTokensResponse(e) {
            let r = (await __([this.storeToken(e.token), this.storeRefreshToken(e.refresh_token), this.storeIdentityToken(e.identity_token), this.processOAuthTokens(e.oauth_tokens)])).filter(n => n.status === "rejected");
            r.length > 0 && this.emit("error_storing_tokens", r.map(n => String(n.reason)).join(", "))
        }
        async processOAuthTokens(e) {
            e && this.emit("oauth_tokens_granted", e)
        }
        async storeIdentityToken(e) {
            var r;
            if (typeof e == "string") {
                let n = await this._storage.get(Qd);
                if (await this._storage.put(Qd, e), !this._isUsingServerCookies) {
                    let i = (r = bf.parse(e)) == null ? void 0 : r.expiration;
                    Ur.set(p2, e, {
                        sameSite: "Strict",
                        secure: !0,
                        expires: i ? new Date(1e3 * i) : void 0
                    })
                }
                n !== e && this.emit("identity_token_stored", {
                    cookiesEnabled: this._isUsingServerCookies
                })
            } else {
                let n = await this._storage.get(Qd);
                await this._storage.del(Qd), Ur.remove(p2), n !== null && this.emit("identity_token_cleared", {
                    reason: "set_with_non_string_value"
                })
            }
        }
        async getOrCreateGuestCredential() {
            let e = this._storage.get(this.GUEST_CREDENTIAL_STORAGE_KEY);
            if (e && typeof e == "string") return e;
            let r = dd(crypto.getRandomValues(new Uint8Array(32)));
            return await this._storage.put(this.GUEST_CREDENTIAL_STORAGE_KEY, r), r
        }
        constructor(e) {
            super(), this._isUsingServerCookies = !1, this._storage = e.storage, this.GUEST_CREDENTIAL_STORAGE_KEY = `privy:guest:${e.appId}`
        }
    };
HN.events = ["storage_cleared", "token_cleared", "refresh_token_cleared", "identity_token_cleared", "token_stored", "refresh_token_stored", "identity_token_stored", "oauth_tokens_granted", "error_storing_tokens"];
var cre = t => {
    let e = new AbortController;
    return setTimeout(() => e.abort(), t), e.signal
};

function lre(t) {
    let e = new URLSearchParams;
    for (let r in t) t[r] != null && e.append(r, String(t[r]));
    return Array.from(e).length ? "?" + e.toString() : ""
}
const eg = () => {};
let Ec = {
    NONE: Number.NEGATIVE_INFINITY,
    ERROR: 1,
    WARN: 2,
    INFO: 3,
    DEBUG: Number.POSITIVE_INFINITY
};
const dre = ({
    level: t
} = {
    level: "ERROR"
}) => ({
    get level() {
        return t
    },
    error: Ec[t] >= Ec.ERROR ? console.error : eg,
    warn: Ec[t] >= Ec.WARN ? console.warn : eg,
    info: Ec[t] >= Ec.INFO ? console.info : eg,
    debug: Ec[t] >= Ec.DEBUG ? console.debug : eg
});
let g2 = "privy:caid",
    ure = class {
        setCallbacks(e) {
            this.callbacks = { ...this.callbacks,
                ...e
            }
        }
        get isReady() {
            return !!this._config
        }
        get config() {
            return this._config
        }
        get caid() {
            return this._analyticsId
        }
        async _initialize() {
            var e, r, n, i, s;
            if (this.isReady)(r = (e = this.callbacks) == null ? void 0 : e.setIsReady) == null || r.call(e, !0);
            else {
                if (!await this.isStorageAccessible()) throw new Qt({
                    code: "storage_error",
                    error: "Unable to access storage"
                });
                this._config = await this.getAppConfig(), (n = this._config) != null && n.custom_api_url && (this.baseUrl = this._config.custom_api_url, this.session.isUsingServerCookies = !0), (s = (i = this.callbacks) == null ? void 0 : i.setIsReady) == null || s.call(i, !0), this._sdkVersion.startsWith("react-auth:") || this.createAnalyticsEvent("sdk_initialize", {})
            }
        }
        getPath(e, {
            params: r,
            query: n
        }) {
            return `${this.baseUrl}${pG(e.path,r)}${lre(n)}`
        }
        async fetch(e, {
            body: r,
            params: n,
            query: i,
            headers: s,
            onRequest: a = this._beforeRequest.bind(this)
        }) {
            let o = new Request(this.getPath(e, {
                    params: n,
                    query: i
                }), {
                    method: e.method,
                    body: JSON.stringify(r),
                    headers: s
                }),
                c = await a(o),
                l = await this._fetch(o, c),
                u = await l.json();
            if (l.status > 299) throw new Mw(u);
            return u
        }
        async _beforeRequestWithoutInitialize(e) {
            let r = await this.session.getToken(),
                n = new Headers(e.headers);
            n.set("privy-app-id", this.appId), this.appClientId && n.set("privy-client-id", this.appClientId), n.set("privy-client", this._sdkVersion), r && n.set("Authorization", `Bearer ${r}`), n.set("Content-Type", "application/json"), n.set("Accept", "application/json");
            let i = await this._getOrGenerateClientAnalyticsId();
            return i && n.set("privy-ca-id", i), this.nativeAppIdentifier && n.set("x-native-app-identifier", this.nativeAppIdentifier), {
                signal: cre(2e4),
                headers: n,
                credentials: "include"
            }
        }
        async beforeRequestWithoutRefresh(e) {
            return await this._initialize(), this._beforeRequestWithoutInitialize(e)
        }
        async _beforeRequest(e) {
            return await this._initialize(), await this.getAccessToken(), this.beforeRequestWithoutRefresh(e)
        }
        async getAppConfig() {
            return await this.fetch($V, {
                params: {
                    app_id: this.appId
                },
                onRequest: this._beforeRequestWithoutInitialize.bind(this)
            })
        }
        async _getOrGenerateClientAnalyticsId() {
            if (this._analyticsId) return this._analyticsId;
            try {
                let e = await this._storage.get(g2);
                if (typeof e == "string" && e.length > 0) return this._analyticsId = e, e
            } catch (e) {
                this.logger.error("Unable to load clientId", e)
            }
            try {
                this._analyticsId = Sm()
            } catch (e) {
                this.logger.error("Unable to generate uuidv4", e)
            }
            if (!this._analyticsId) return null;
            try {
                await this._storage.put(g2, this._analyticsId)
            } catch (e) {
                this.logger.error(`Unable to store clientId: ${this._analyticsId}`, e)
            }
            return this._analyticsId
        }
        async destroyClientAnalyticsId() {
            try {
                return await this._storage.del(g2)
            } catch (e) {
                this.logger.error("Unable to delete clientId", e)
            }
        }
        async createAnalyticsEvent(e, r) {
            try {
                await this.fetch(IV, {
                    body: {
                        event_name: e,
                        client_id: await this._getOrGenerateClientAnalyticsId(),
                        payload: r
                    },
                    onRequest: this.beforeRequestWithoutRefresh.bind(this)
                })
            } catch {}
        }
        async refreshSession(e = !1) {
            if (!await this.isStorageAccessible()) throw new Qt({
                code: "storage_error",
                error: "Unable to access storage"
            });
            let r = await this.session.getRefreshToken() ? ? void 0,
                n = r ? ? "key",
                i = this._cache.get(n);
            if (i) return this.logger.debug("[privy:refresh] found in-flight session refresh request, deduping"), await i;
            let s = this._refreshSession(r, e);
            this._cache.set(n, s);
            try {
                return await s
            } finally {
                this._cache.delete(n)
            }
        }
        async _refreshSession(e, r) {
            var i, s, a, o, c, l;
            let n = await this.session.getToken();
            if (!this.session.hasRefreshCredentials(n, e ? ? null)) throw this.logger.debug("[privy:refresh] missing tokens, skipping request"), await this._initialize(), new Mw({
                code: CE.MISSING_OR_INVALID_TOKEN,
                error: "No tokens found in storage"
            });
            try {
                this.logger.debug(`[privy:refresh] fetching: ${_E.path}`);
                let u = await this.fetch(_E, {
                        body: {
                            refresh_token: e
                        },
                        onRequest: this.beforeRequestWithoutRefresh.bind(this)
                    }),
                    h = u.session_update_action;
                return this.logger.debug(`[privy:refresh] response: ${h}`), r || ((s = (i = this.callbacks) == null ? void 0 : i.setUser) == null || s.call(i, u.user)), h === "set" && (await this.session.updateWithTokensResponse(u), this.logger.debug("[privy:refresh] tokens stored")), h === "clear" && (await this.session.destroyLocalState(), this.logger.debug("[privy:refresh] tokens cleared"), r || ((o = (a = this.callbacks) == null ? void 0 : a.setUser) == null || o.call(a, null))), h === "ignore" && u.token && (await this.session.storeToken(u.token), this.logger.debug("[privy:refresh] access token stored"), u.identity_token && (this.logger.debug("[privy:refresh] identity token stored"), await this.session.storeIdentityToken(u.identity_token))), this.logger.debug("[privy:refresh] returning response"), u
            } catch (u) {
                throw this.logger.debug(`[privy:refresh] error: ${u.message??"unknown error"}`), u instanceof Mw && u.code === CE.MISSING_OR_INVALID_TOKEN && (await this.session.destroyLocalState(), r || ((l = (c = this.callbacks) == null ? void 0 : c.setUser) == null || l.call(c, null))), u
            }
        }
        async getAccessToken() {
            let [e, r] = await Promise.all([this.session.getToken(), this.session.getRefreshToken()]);
            if (!this.session.tokenIsActive(e) && this.session.hasRefreshCredentials(e, r)) {
                let n = await this.refreshSession(),
                    i = await this.session.getToken();
                return n.token || this.logger.debug("[privy:getAccessToken] expected token received null"), n.token === e && this.logger.debug("[privy:getAccessToken] expected new token in response received existing"), i === e && this.logger.debug("[privy:getAccessToken] expected new token in storage received existing"), n.token ? ? i
            }
            return e
        }
        async getIdentityToken() {
            return await this.session.getIdentityToken()
        }
        async isStorageAccessible() {
            try {
                let e = `privy:__storage__test-${Sm()}`,
                    r = "blobby";
                await this._storage.put(e, r);
                let n = await this._storage.get(e);
                return await this._storage.del(e), n === r
            } catch (e) {
                return this.logger.error(e), !1
            }
        }
        constructor(e) {
            this._sdkVersion = "js-sdk-core:0.53.1", this._cache = new Map, this.logger = dre({
                level: e.logLevel ? ? "ERROR"
            }), this._storage = e.storage, this._analyticsId = null, this._getOrGenerateClientAnalyticsId(), this.baseUrl = e.baseUrl ? ? "https://auth.privy.io", this.appId = e.appId, this.appClientId = e.appClientId, this._sdkVersion = e.sdkVersion ? ? this._sdkVersion, this.callbacks = e.callbacks, this.nativeAppIdentifier = e.nativeAppIdentifier, this.session = new HN({
                storage: this._storage,
                isUsingServerCookies: !1,
                appId: e.appId
            }), this._fetch = z6(globalThis.fetch, {
                retries: 3,
                retryDelay: r => 3 ** r * 500,
                retryOn: [408, 409, 425, 500, 502, 503, 504]
            }), this.session.on("error_storing_tokens", r => {
                this.createAnalyticsEvent("error_updating_tokens_in_storage", {
                    reason: r
                })
            })
        }
    },
    hre = class {
        async get() {
            let {
                user: e
            } = await this._privyInternal.refreshSession();
            return {
                user: e
            }
        }
        async acceptTerms() {
            return {
                user: await this._privyInternal.fetch(AG, {})
            }
        }
        constructor(e) {
            this._privyInternal = e
        }
    };
const VN = t => t.type === "wallet" && t.wallet_client_type === "privy" && t.connector_type === "embedded",
    GN = t => t ? t.linked_accounts.filter(VN).filter(e => e.chain_type === "ethereum").sort((e, r) => e.wallet_index - r.wallet_index) : [],
    C_ = t => GN(t).find(e => e.wallet_index === 0) ? ? null,
    KN = t => t ? t.linked_accounts.filter(VN).filter(e => e.chain_type === "solana").sort((e, r) => e.wallet_index - r.wallet_index) : [],
    fre = t => KN(t).find(e => e.wallet_index === 0) ? ? null,
    pre = (t, e) => !(e === "off" || GN(t).length > 0 || t.linked_accounts.filter(r => r.type === "wallet" && r.chain_type === "ethereum").length > 0 && e !== "all-users"),
    gre = (t, e) => !(e === "off" || KN(t).length > 0 || t.linked_accounts.filter(r => r.type === "wallet" && r.chain_type === "solana").length > 0 && e !== "all-users"),
    _a = async (t, e, r) => {
        var s, a;
        let n = pre(e.user, ((s = r == null ? void 0 : r.ethereum) == null ? void 0 : s.createOnLogin) ? ? "off"),
            i = gre(e.user, ((a = r == null ? void 0 : r.solana) == null ? void 0 : a.createOnLogin) ? ? "off");
        if (n && i) {
            let o = await t.create({
                recoveryMethod: "privy",
                skipCallbacks: !0
            });
            return { ...await t.createSolana({
                    ethereumAccount: C_(o.user) ? ? void 0
                }),
                is_new_user: e.is_new_user,
                oauth_tokens: e.oauth_tokens
            }
        }
        return n ? { ...await t.create({
                recoveryMethod: "privy",
                solanaAccount: fre(e.user) ? ? void 0
            }),
            is_new_user: e.is_new_user,
            oauth_tokens: e.oauth_tokens
        } : i ? { ...await t.createSolana({
                ethereumAccount: C_(e.user) ? ? void 0
            }),
            is_new_user: e.is_new_user,
            oauth_tokens: e.oauth_tokens
        } : e
    };
let mre = class {
        async syncWithToken(e, r, n) {
            var a, o;
            let i = await this._privyInternal.fetch(NV, {
                body: {
                    token: e,
                    mode: n
                }
            });
            await this._privyInternal.session.updateWithTokensResponse(i);
            let s = await _a(this._embedded, i, r == null ? void 0 : r.embedded);
            return (o = (a = this._privyInternal.callbacks) == null ? void 0 : a.setUser) == null || o.call(a, s.user), s
        }
        constructor(e, r) {
            this._privyInternal = e, this._embedded = r
        }
    },
    yre = class {
        async sendCode(e, r) {
            return this._privyInternal.fetch(eG, {
                body: {
                    email: e,
                    token: r
                }
            })
        }
        async loginWithCode(e, r, n, i) {
            var o, c;
            let s = await this._privyInternal.fetch(XV, {
                body: {
                    email: e,
                    code: r,
                    mode: n
                }
            });
            await this._privyInternal.session.updateWithTokensResponse(s);
            let a = await _a(this._embedded, s, i == null ? void 0 : i.embedded);
            return (c = (o = this._privyInternal.callbacks) == null ? void 0 : o.setUser) == null || c.call(o, a.user), a
        }
        async linkWithCode(e, r) {
            await this._privyInternal.fetch(tG, {
                body: {
                    email: e,
                    code: r
                }
            });
            let n = await this._privyInternal.refreshSession();
            return {
                user: n.user,
                identity_token: n.identity_token
            }
        }
        async updateEmail({
            oldEmailAddress: e,
            newEmailAddress: r,
            code: n
        }) {
            await this._privyInternal.fetch(nG, {
                body: {
                    oldAddress: e,
                    newAddress: r,
                    code: n
                }
            });
            let i = await this._privyInternal.refreshSession();
            return {
                user: i.user,
                identity_token: i.identity_token
            }
        }
        async unlink(e) {
            await this._privyInternal.fetch(rG, {
                body: {
                    address: e
                }
            });
            let r = await this._privyInternal.refreshSession();
            return {
                user: r.user,
                identity_token: r.identity_token
            }
        }
        constructor(e, r) {
            this._privyInternal = e, this._embedded = r
        }
    },
    wre = class {
        async initializeAuth({
            relyingParty: e,
            redirectUrl: r,
            token: n
        }) {
            return await this._privyInternal.fetch(OV, {
                body: {
                    relying_party: e,
                    redirect_url: r,
                    token: n
                }
            })
        }
        async getFarcasterStatus({
            channel_token: e
        }) {
            return await this._privyInternal.fetch(DV, {
                headers: {
                    "farcaster-channel-token": e
                }
            })
        }
        async authenticate({
            channel_token: e,
            message: r,
            signature: n,
            fid: i,
            mode: s
        }, a) {
            var l, u;
            let o = await this._privyInternal.fetch(jV, {
                body: {
                    channel_token: e,
                    message: r,
                    signature: n,
                    fid: i,
                    mode: s
                }
            });
            await this._privyInternal.session.updateWithTokensResponse(o);
            let c = await _a(this._embedded, o, a == null ? void 0 : a.embedded);
            return (u = (l = this._privyInternal.callbacks) == null ? void 0 : l.setUser) == null || u.call(l, c.user), c
        }
        async link({
            channel_token: e,
            message: r,
            signature: n,
            fid: i
        }) {
            await this._privyInternal.fetch(RV, {
                body: {
                    channel_token: e,
                    message: r,
                    signature: n,
                    fid: i
                }
            });
            let s = await this._privyInternal.refreshSession();
            return {
                user: s.user,
                identity_token: s.identity_token
            }
        }
        async unlink({
            fid: e
        }) {
            await this._privyInternal.fetch(MV, {
                body: {
                    fid: e
                }
            });
            let r = await this._privyInternal.refreshSession();
            return {
                user: r.user,
                identity_token: r.identity_token
            }
        }
        constructor(e, r) {
            this._privyInternal = e, this._embedded = r
        }
    },
    bre = class {
        async initializeAuth() {
            return await this._privyInternal.fetch(LV, {
                body: {}
            })
        }
        async authenticate({
            message: e,
            signature: r,
            fid: n
        }, i) {
            var o, c;
            let s = await this._privyInternal.fetch(UV, {
                body: {
                    message: e,
                    signature: r,
                    fid: n
                }
            });
            await this._privyInternal.session.updateWithTokensResponse(s);
            let a = await _a(this._embedded, s, i == null ? void 0 : i.embedded);
            return (c = (o = this._privyInternal.callbacks) == null ? void 0 : o.setUser) == null || c.call(o, a.user), a
        }
        constructor(e, r) {
            this._privyInternal = e, this._embedded = r
        }
    },
    vre = class {
        async create(e) {
            var s, a;
            let r = await this._privyInternal.session.getOrCreateGuestCredential(),
                n = await this._privyInternal.fetch(FV, {
                    body: {
                        guest_credential: r
                    }
                });
            await this._privyInternal.session.updateWithTokensResponse(n);
            let i = await _a(this._embedded, n, e == null ? void 0 : e.embedded);
            return (a = (s = this._privyInternal.callbacks) == null ? void 0 : s.setUser) == null || a.call(s, i.user), i
        }
        constructor(e, r) {
            this._privyInternal = e, this._embedded = r
        }
    };
const Fc = "privy:state_code",
    Bc = "privy:code_verifier";
async function xre(t, e) {
    let r = new TextEncoder().encode(t);
    return new Uint8Array(await e("SHA-256", r))
}

function Ere(t) {
    return crypto.getRandomValues(new Uint8Array(t))
}

function q6() {
    return dd(Ere(36))
}

function YN() {
    return q6()
}
async function ZN({
    codeVerifier: t,
    method: e = "S256",
    digest: r = crypto.subtle.digest.bind(crypto.subtle)
}) {
    if (e != "S256") return t; {
        let n = await xre(t, r);
        return dd(n)
    }
}
let _re = class {
        async generateURL(e, r) {
            var a;
            let n = q6(),
                i = YN(),
                s = await ZN({
                    codeVerifier: n,
                    digest: (a = this._crypto) == null ? void 0 : a.digest
                });
            return await Promise.all([this._storage.put(Bc, n), this._storage.put(Fc, i)]), this._privyInternal.fetch(qV, {
                body: {
                    redirect_to: r,
                    provider: e,
                    code_challenge: s,
                    state_code: i
                }
            })
        }
        async loginWithCode(e, r, n, i, s, a) {
            var h, f;
            let [o, c] = await Promise.all([this._storage.get(Bc), this._storage.get(Fc)]);
            if (c !== r) throw this._privyInternal.createAnalyticsEvent("possible_phishing_attempt", {
                flow: "oauth",
                provider: n,
                storedStateCode: c ? ? "",
                returnedStateCode: r ? ? ""
            }), new Qt({
                code: "pkce_state_code_mismatch",
                error: "Unexpected auth flow. This may be a phishing attempt."
            });
            let l = await this._privyInternal.fetch(zV, {
                body: {
                    authorization_code: e,
                    code_type: i,
                    state_code: c,
                    code_verifier: o,
                    mode: s
                }
            });
            await this._privyInternal.session.updateWithTokensResponse(l);
            let u = await _a(this._embedded, l, a == null ? void 0 : a.embedded);
            return await Promise.all([this._storage.del(Bc), this._storage.del(Fc)]), (f = (h = this._privyInternal.callbacks) == null ? void 0 : h.setUser) == null || f.call(h, u.user), u
        }
        async linkWithCode(e, r, n, i) {
            let [s, a] = await Promise.all([this._storage.get(Bc), this._storage.get(Fc)]);
            if (a !== r) throw this._privyInternal.createAnalyticsEvent("possible_phishing_attempt", {
                flow: "oauth",
                provider: n,
                storedStateCode: a ? ? "",
                returnedStateCode: r ? ? ""
            }), new Qt({
                code: "pkce_state_code_mismatch",
                error: "Unexpected auth flow. This may be a phishing attempt."
            });
            let o = await this._privyInternal.fetch(HV, {
                body: {
                    authorization_code: e,
                    code_type: i,
                    state_code: a,
                    code_verifier: s
                }
            });
            await this._privyInternal.session.processOAuthTokens(o.oauth_tokens);
            let c = await this._privyInternal.refreshSession();
            return await Promise.all([this._storage.del(Bc), this._storage.del(Fc)]), {
                user: c.user,
                identity_token: c.identity_token
            }
        }
        async unlink(e, r) {
            await this._privyInternal.fetch(VV, {
                body: {
                    provider: e,
                    subject: r
                }
            });
            let n = await this._privyInternal.refreshSession();
            return {
                user: n.user,
                identity_token: n.identity_token
            }
        }
        constructor(e, r, n, i) {
            this._privyInternal = e, this._embedded = r, this._storage = n, this._crypto = i
        }
    },
    Cre = class {
        async generateRegistrationOptions(e) {
            return await this._privyInternal.fetch(QV, {
                body: {
                    relying_party: e
                }
            })
        }
        async generateAuthenticationOptions(e) {
            return await this._privyInternal.fetch(ZV, {
                body: {
                    relying_party: e
                }
            })
        }
        async generateSignupOptions(e) {
            return await this._privyInternal.fetch(JV, {
                body: {
                    relying_party: e
                }
            })
        }
        async loginWithPasskey(e, r, n, i) {
            var o, c;
            let s = await this._privyInternal.fetch(KV, {
                body: {
                    relying_party: n,
                    challenge: r,
                    authenticator_response: this._transformAuthenticationResponseToSnakeCase(e)
                }
            });
            await this._privyInternal.session.updateWithTokensResponse(s);
            let a = await _a(this._embedded, s, i == null ? void 0 : i.embedded);
            return (c = (o = this._privyInternal.callbacks) == null ? void 0 : o.setUser) == null || c.call(o, a.user), a
        }
        async signupWithPasskey(e, r, n) {
            var a, o;
            let i = await this._privyInternal.fetch(YV, {
                body: {
                    relying_party: r,
                    authenticator_response: this._transformRegistrationResponseToSnakeCase(e)
                }
            });
            await this._privyInternal.session.updateWithTokensResponse(i);
            let s = await _a(this._embedded, i, n == null ? void 0 : n.embedded);
            return (o = (a = this._privyInternal.callbacks) == null ? void 0 : a.setUser) == null || o.call(a, s.user), s
        }
        async linkWithPasskey(e, r) {
            await this._privyInternal.fetch(GV, {
                body: {
                    relying_party: r,
                    authenticator_response: this._transformRegistrationResponseToSnakeCase(e)
                }
            });
            let n = await this._privyInternal.refreshSession();
            return {
                user: n.user,
                identity_token: n.identity_token
            }
        }
        _transformRegistrationResponseToSnakeCase(e) {
            return {
                type: e.type,
                id: e.id,
                raw_id: e.rawId,
                response: {
                    client_data_json: e.response.clientDataJSON,
                    attestation_object: e.response.attestationObject,
                    authenticator_data: e.response.authenticatorData || void 0,
                    transports: e.response.transports || void 0,
                    public_key: e.response.publicKey || void 0,
                    public_key_algorithm: e.response.publicKeyAlgorithm || void 0
                },
                authenticator_attachment: e.authenticatorAttachment || void 0,
                client_extension_results: {
                    app_id: e.clientExtensionResults.appid || void 0,
                    cred_props: e.clientExtensionResults.credProps || void 0,
                    hmac_create_secret: e.clientExtensionResults.hmacCreateSecret || void 0
                }
            }
        }
        _transformAuthenticationResponseToSnakeCase(e) {
            return {
                type: e.type,
                id: e.id,
                raw_id: e.rawId,
                response: {
                    signature: e.response.signature,
                    client_data_json: e.response.clientDataJSON,
                    authenticator_data: e.response.authenticatorData,
                    user_handle: e.response.userHandle || void 0
                },
                authenticator_attachment: e.authenticatorAttachment || void 0,
                client_extension_results: {
                    app_id: e.clientExtensionResults.appid || void 0,
                    cred_props: e.clientExtensionResults.credProps || void 0,
                    hmac_create_secret: e.clientExtensionResults.hmacCreateSecret || void 0
                }
            }
        }
        constructor(e, r) {
            this._privyInternal = e, this._embedded = r
        }
    },
    Are = class {
        async sendCode(e, r) {
            return this._privyInternal.fetch(sG, {
                body: {
                    phoneNumber: e,
                    token: r
                }
            })
        }
        async loginWithCode(e, r, n, i) {
            var o, c;
            let s = await this._privyInternal.fetch(iG, {
                body: {
                    phoneNumber: e,
                    code: r,
                    mode: n
                }
            });
            await this._privyInternal.session.updateWithTokensResponse(s);
            let a = await _a(this._embedded, s, i == null ? void 0 : i.embedded);
            return (c = (o = this._privyInternal.callbacks) == null ? void 0 : o.setUser) == null || c.call(o, a.user), a
        }
        async linkWithCode(e, r) {
            await this._privyInternal.fetch(aG, {
                body: {
                    phoneNumber: e,
                    code: r
                }
            });
            let n = await this._privyInternal.refreshSession();
            return {
                user: n.user,
                identity_token: n.identity_token
            }
        }
        async updatePhone({
            oldPhoneNumber: e,
            newPhoneNumber: r,
            code: n
        }) {
            await this._privyInternal.fetch(cG, {
                body: {
                    old_phone_number: e,
                    new_phone_number: r,
                    code: n
                }
            });
            let i = await this._privyInternal.refreshSession();
            return {
                user: i.user,
                identity_token: i.identity_token
            }
        }
        async unlink(e) {
            await this._privyInternal.fetch(oG, {
                body: {
                    phoneNumber: e
                }
            });
            let r = await this._privyInternal.refreshSession();
            return {
                user: r.user,
                identity_token: r.identity_token
            }
        }
        constructor(e, r) {
            this._privyInternal = e, this._embedded = r
        }
    },
    kre = class {
        async unlinkWallet(e) {
            await this._privyInternal.fetch(vG, {
                body: {
                    address: e
                }
            });
            let r = await this._privyInternal.refreshSession();
            return {
                user: r.user,
                identity_token: r.identity_token
            }
        }
        async linkWithSiwe(e, r, n) {
            let i = r || this._wallet,
                s = n || this._preparedMessage;
            if (!i) throw Error("A wallet must be provided in the init step or as an argument to linkWithSiwe");
            if (!s) throw Error("A message must be generated and signed before being used to link a wallet to privy");
            await this._privyInternal.fetch(wG, {
                body: {
                    message: s,
                    signature: e,
                    chainId: i.chainId,
                    walletClientType: i.walletClientType,
                    connectorType: i.connectorType
                }
            });
            let a = await this._privyInternal.refreshSession();
            return {
                user: a.user,
                identity_token: a.identity_token
            }
        }
        async loginWithSiwe(e, r, n, i, s) {
            var u, h;
            let a = r || this._wallet,
                o = n || this._preparedMessage;
            if (!a) throw Error("A wallet must be provided in the init step or as an argument to loginWithSiwe");
            if (!o) throw Error("A message must be generated and signed before being used to login to privy with a wallet");
            let c = await this._privyInternal.fetch(yG, {
                body: {
                    signature: e,
                    message: o,
                    chainId: a.chainId,
                    walletClientType: a.walletClientType,
                    connectorType: a.connectorType,
                    mode: i
                }
            });
            await this._privyInternal.session.updateWithTokensResponse(c);
            let l = await _a(this._embedded, c, s == null ? void 0 : s.embedded);
            return (h = (u = this._privyInternal.callbacks) == null ? void 0 : u.setUser) == null || h.call(u, l.user), l
        }
        async init(e, r, n) {
            var i;
            this._wallet = e;
            let {
                nonce: s
            } = await this._privyInternal.fetch(ZT, {
                body: {
                    address: e.address
                }
            }), a = `${(i={chainId:e.chainId.toString().replace("eip155:",""),address:e.address,issuedAt:new Date().toISOString(),statement:"By signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.",domain:r,nonce:s,uri:n}).domain} wants you to sign in with your Ethereum account:
${i.address}

${i.statement}

URI: ${i.uri}
Version: 1
Chain ID: ${i.chainId}
Nonce: ${i.nonce}
Issued At: ${i.issuedAt}
Resources:
- https://privy.io`;
            return this._preparedMessage = a, {
                nonce: s,
                message: a
            }
        }
        constructor(e, r) {
            this._wallet = void 0, this._privyInternal = e, this._embedded = r
        }
    },
    Ire = class {
        async unlink({
            address: e
        }) {
            await this._privyInternal.fetch(CG, {
                body: {
                    address: e
                }
            });
            let r = await this._privyInternal.refreshSession();
            return {
                user: r.user,
                identity_token: r.identity_token
            }
        }
        async link({
            message: e,
            signature: r,
            walletClientType: n,
            connectorType: i
        }) {
            await this._privyInternal.fetch(_G, {
                body: {
                    message: e,
                    signature: r,
                    walletClientType: n,
                    connectorType: i
                }
            });
            let s = await this._privyInternal.refreshSession();
            return {
                user: s.user,
                identity_token: s.identity_token
            }
        }
        async login({
            mode: e,
            message: r,
            signature: n,
            walletClientType: i,
            connectorType: s,
            opts: a
        }) {
            var l, u;
            let o = await this._privyInternal.fetch(EG, {
                body: {
                    signature: n,
                    message: r,
                    walletClientType: i,
                    connectorType: s,
                    mode: e
                }
            });
            await this._privyInternal.session.updateWithTokensResponse(o);
            let c = await _a(this._embedded, o, a == null ? void 0 : a.embedded);
            return (u = (l = this._privyInternal.callbacks) == null ? void 0 : l.setUser) == null || u.call(l, c.user), c
        }
        async fetchNonce({
            address: e
        }) {
            let {
                nonce: r
            } = await this._privyInternal.fetch(xG, {
                body: {
                    address: e
                }
            });
            return {
                nonce: r
            }
        }
        constructor(e, r) {
            this._privyInternal = e, this._embedded = r
        }
    },
    $re = class {
        async link(e, r, n) {
            await this._privyInternal.fetch(bG, {
                body: {
                    message: e,
                    signature: r,
                    smart_wallet_type: n
                }
            });
            let i = await this._privyInternal.refreshSession();
            return {
                user: i.user,
                identity_token: i.identity_token
            }
        }
        async init(e) {
            var r;
            let {
                nonce: n
            } = await this._privyInternal.fetch(ZT, {
                body: {
                    address: e.address
                }
            });
            return {
                nonce: n,
                message: `${(r={chainId:e.chainId.toString().replace("eip155:",""),address:e.address,issuedAt:new Date().toISOString(),statement:"By signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.",domain:"privy.io",uri:"https://auth.privy.io",nonce:n}).domain} wants you to sign in with your Ethereum account:
${r.address}

${r.statement}

URI: ${r.uri}
Version: 1
Chain ID: ${r.chainId}
Nonce: ${r.nonce}
Issued At: ${r.issuedAt}
Resources:
- https://privy.io`
            }
        }
        constructor(e) {
            this._privyInternal = e
        }
    },
    Sre = class {
        async logout() {
            var e, r;
            try {
                let n = await this._privyInternal.session.getRefreshToken() ? ? void 0;
                await this._privyInternal.fetch(gG, {
                    body: {
                        refresh_token: n
                    }
                })
            } catch {
                console.warn("Error destroying session")
            }
            await Promise.all([this._privyInternal.session.destroyLocalState({
                reason: "logout"
            }), this._privyInternal.destroyClientAnalyticsId()]), (r = (e = this._privyInternal.callbacks) == null ? void 0 : e.setUser) == null || r.call(e, null)
        }
        constructor(e, r, n, i) {
            this._privyInternal = e, this.customProvider = new mre(this._privyInternal, r), this.phone = new Are(this._privyInternal, r), this.email = new yre(this._privyInternal, r), this.oauth = new _re(this._privyInternal, r, n, i), this.guest = new vre(this._privyInternal, r), this.siwe = new kre(this._privyInternal, r), this.siws = new Ire(this._privyInternal, r), this.smartWallet = new $re(this._privyInternal), this.passkey = new Cre(this._privyInternal, r), this.farcaster = new wre(this._privyInternal, r), this.farcasterV2 = new bre(this._privyInternal, r)
        }
    },
    Tre = class {
        async initOnRampSession(e) {
            return await this._privyInternal.fetch(SV, {
                body: e
            })
        }
        async getStatus(e) {
            return await this._privyInternal.fetch(TV, {
                query: {
                    partnerUserId: e
                }
            })
        }
        constructor(e) {
            this._privyInternal = e
        }
    };
const Pre = {
    prod: {
        url: "https://api.moonpay.com/v1",
        key: "pk_live_hirbpu0cVcLHrjktC9l7fbc9ctjv0SL"
    },
    sandbox: {
        url: "https://api.moonpay.com/v1",
        key: "pk_test_fqWjXZMSFwloh7orvJsRfjiUHXJqFzI"
    }
};
let Nre = new Set([Bs.id, ja.id, Fs.id, fs.id, yh.id, H1.id]),
    Ore = new Set([Bs.id, ja.id, go.id, Fs.id, fs.id]);

function jre(t, e) {
    switch (e) {
        case "native-currency":
            return Nre.has(t);
        case "USDC":
            return Ore.has(t);
        default:
            return console.warn("Unknown asset passed to MoonPay Onramp"), !1
    }
}

function Rre(t, e) {
    switch (t) {
        case ja.id:
            return e === "native-currency" ? "ETH_ARBITRUM" : "USDC_ARBITRUM";
        case yh.id:
            return "AVAX_CCHAIN";
        case Fs.id:
            return e === "native-currency" ? "ETH_BASE" : "USDC_BASE";
        case H1.id:
            return "CELO_CELO";
        case fs.id:
            return e === "native-currency" ? "MATIC_POLYGON" : "USDC_POLYGON";
        case Bs.id:
            return e === "native-currency" ? "ETH_ETHEREUM" : "USDC_ETHEREUM";
        default:
            return console.warn(`Chain ${t} not supported by Moonpay, defaulting to Ethereum mainnet`), "ETH_ETHEREUM"
    }
}
let Mre = class {
        async sign(e) {
            return await this._privyInternal.fetch(kG, {
                body: e
            })
        }
        async getTransactionStatus({
            transactionId: e,
            useSandbox: r
        }) {
            let {
                url: n,
                key: i
            } = Pre[r ? "sandbox" : "prod"], s = await z6(fetch, {
                retries: 3,
                retryDelay: 500
            })(`${n}/transactions/ext/${e}?apiKey=${i}`);
            if (!s.ok) throw new eX({
                error: `Failed to fetch transaction status for Transaction ${e}`,
                code: "failed_to_fetch_moonpay_transaction_status",
                response: s
            });
            let a = await s.json();
            return Array.isArray(a) ? a.at(0) : void 0
        }
        constructor(e) {
            this._privyInternal = e
        }
    },
    Dre = class {
        constructor(e) {
            this.moonpay = new Mre(e), this.coinbase = new Tre(e)
        }
    },
    Lre = class {
        async generateAuthenticationOptions(e) {
            return await this._privyInternal.fetch(BV, {
                body: e
            })
        }
        constructor(e) {
            this._privyInternal = e
        }
    },
    Ure = class {
        async sendCode(e) {
            return await this._privyInternal.fetch(WV, {
                body: e
            })
        }
        constructor(e) {
            this._privyInternal = e
        }
    },
    Fre = class {
        setProxy(e) {
            this.proxy = e
        }
        async getAccessToken() {
            let e = await this.privyInternal.getAccessToken();
            if (!e) throw new Qt({
                error: "Missing access token",
                code: "attempted_rpc_call_before_logged_in"
            });
            return e
        }
        async verifyMfa() {
            if (!this.proxy) throw new Qt({
                error: "Embedded wallet proxy not initialized",
                code: "embedded_wallet_webview_not_loaded"
            });
            return await this.proxy.verifyMfa({
                accessToken: await this.getAccessToken()
            })
        }
        async initEnrollMfa(e) {
            if (!this.proxy) throw new Qt({
                error: "Embedded wallet proxy not initialized",
                code: "embedded_wallet_webview_not_loaded"
            });
            return await this.proxy.initEnrollMfa({ ...e,
                accessToken: await this.getAccessToken()
            })
        }
        async submitEnrollMfa(e) {
            if (!this.proxy) throw new Qt({
                error: "Embedded wallet proxy not initialized",
                code: "embedded_wallet_webview_not_loaded"
            });
            let r = await this.proxy.submitEnrollMfa({ ...e,
                accessToken: await this.getAccessToken()
            });
            return await this.privyInternal.refreshSession(), r
        }
        async unenrollMfa(e) {
            if (!this.proxy) throw new Qt({
                error: "Embedded wallet proxy not initialized",
                code: "embedded_wallet_webview_not_loaded"
            });
            let r = await this.proxy.unenrollMfa({
                method: e,
                accessToken: await this.getAccessToken()
            });
            return await this.privyInternal.refreshSession(), r
        }
        async clearMfa(e) {
            if (!this.proxy) throw new Qt({
                error: "Embedded wallet proxy not initialized",
                code: "embedded_wallet_webview_not_loaded"
            });
            return await this.proxy.clearMfa(e)
        }
        constructor(e, r) {
            this.proxy = r, this.privyInternal = e, this.sms = new Ure(e), this.passkey = new Lre(e)
        }
    },
    Bre = class {
        async init(e) {
            return this._privyInternal.fetch(hG, {
                body: {
                    client_type: e
                }
            })
        }
        async getICloudConfiguration(e) {
            return this._privyInternal.fetch(fG, {
                body: {
                    client_type: e
                }
            })
        }
        constructor(e) {
            this._privyInternal = e
        }
    },
    Wre = class {
        async generateURL(e) {
            var s;
            let r = q6(),
                n = YN(),
                i = await ZN({
                    codeVerifier: r,
                    digest: (s = this._crypto) == null ? void 0 : s.digest
                });
            return await Promise.all([this._storage.put(Bc, r), this._storage.put(Fc, n)]), this._privyInternal.fetch(dG, {
                body: {
                    redirect_to: e,
                    code_challenge: i,
                    state_code: n
                }
            })
        }
        async authorize(e, r) {
            let [n, i] = await Promise.all([this._storage.get(Bc), this._storage.get(Fc)]);
            if (i !== r) throw this._privyInternal.createAnalyticsEvent("possible_phishing_attempt", {
                flow: "recovery_oauth",
                storedStateCode: i ? ? "",
                returnedStateCode: r ? ? ""
            }), new Qt({
                code: "pkce_state_code_mismatch",
                error: "Unexpected auth flow. This may be a phishing attempt."
            });
            let s = await this._privyInternal.fetch(uG, {
                body: {
                    authorization_code: e,
                    state_code: i,
                    code_verifier: n
                }
            });
            return await Promise.all([this._storage.del(Bc), this._storage.del(Fc)]), s
        }
        constructor(e, r, n) {
            this._privyInternal = e, this._storage = r, this._crypto = n
        }
    },
    zre = class {
        async getRecoveryKeyMaterial(e, r) {
            return this._privyInternal.fetch(lG, {
                body: {
                    chain_type: r
                },
                params: {
                    address: e
                }
            })
        }
        constructor(e, r, n) {
            this._privyInternal = e, this.auth = new Wre(this._privyInternal, r, n), this.icloudAuth = new Bre(this._privyInternal)
        }
    },
    qre = class {
        async initialize() {
            await this._privyInternal._initialize()
        }
        setMessagePoster(e) {
            this.embeddedWallet.setMessagePoster(e)
        }
        addOAuthTokensListener(e) {
            return this._privyInternal.session.on("oauth_tokens_granted", e), {
                unsubscribe: () => {
                    this._privyInternal.session.removeListener("oauth_tokens_granted", e)
                }
            }
        }
        setCallbacks(e) {
            this._privyInternal.setCallbacks(e)
        }
        getAccessToken() {
            return this._privyInternal.getAccessToken()
        }
        getIdentityToken() {
            return this._privyInternal.getIdentityToken()
        }
        getCompiledPath(e, r) {
            return this._privyInternal.getPath(e, r)
        }
        async fetchPrivyRoute(e, r) {
            return this._privyInternal.fetch(e, r)
        }
        get logger() {
            return this._privyInternal.logger
        }
        constructor({
            clientId: e,
            ...r
        }) {
            this._privyInternal = new ure({ ...r,
                appClientId: e
            }), this.mfa = new Fre(this._privyInternal), this.mfaPromises = new rre, this.app = new OQ(this._privyInternal), this.embeddedWallet = new tre(this._privyInternal, r.embeddedWalletMessagePoster, r.supportedChains, this.mfa, this.mfaPromises, this.app), this.user = new hre(this._privyInternal), this.auth = new Sre(this._privyInternal, this.embeddedWallet, r.storage, r.crypto), this.recovery = new zre(this._privyInternal, r.storage, r.crypto), this.funding = new Dre(this._privyInternal), this.delegated = new zQ(this._privyInternal), this.crossApp = new GP(this._privyInternal, r.storage)
        }
    };
const Hre = {
        AC: "40123",
        AD: "312345",
        AE: "501234567",
        AF: "701234567",
        AG: "2684641234",
        AI: "2642351234",
        AL: "672123456",
        AM: "77123456",
        AO: "923123456",
        AR: "91123456789",
        AS: "6847331234",
        AT: "664123456",
        AU: "412345678",
        AW: "5601234",
        AX: "412345678",
        AZ: "401234567",
        BA: "61123456",
        BB: "2462501234",
        BD: "1812345678",
        BE: "470123456",
        BF: "70123456",
        BG: "43012345",
        BH: "36001234",
        BI: "79561234",
        BJ: "0195123456",
        BL: "690001234",
        BM: "4413701234",
        BN: "7123456",
        BO: "71234567",
        BQ: "3181234",
        BR: "11961234567",
        BS: "2423591234",
        BT: "17123456",
        BW: "71123456",
        BY: "294911911",
        BZ: "6221234",
        CA: "5062345678",
        CC: "412345678",
        CD: "991234567",
        CF: "70012345",
        CG: "061234567",
        CH: "781234567",
        CI: "0123456789",
        CK: "71234",
        CL: "221234567",
        CM: "671234567",
        CN: "13123456789",
        CO: "3211234567",
        CR: "83123456",
        CU: "51234567",
        CV: "9911234",
        CW: "95181234",
        CX: "412345678",
        CY: "96123456",
        CZ: "601123456",
        DE: "15123456789",
        DJ: "77831001",
        DK: "34412345",
        DM: "7672251234",
        DO: "8092345678",
        DZ: "551234567",
        EC: "991234567",
        EE: "51234567",
        EG: "1001234567",
        EH: "650123456",
        ER: "7123456",
        ES: "612345678",
        ET: "911234567",
        FI: "412345678",
        FJ: "7012345",
        FK: "51234",
        FM: "3501234",
        FO: "211234",
        FR: "612345678",
        GA: "06031234",
        GB: "7400123456",
        GD: "4734031234",
        GE: "555123456",
        GF: "694201234",
        GG: "7781123456",
        GH: "231234567",
        GI: "57123456",
        GL: "221234",
        GM: "3012345",
        GN: "601123456",
        GP: "690001234",
        GQ: "222123456",
        GR: "6912345678",
        GT: "51234567",
        GU: "6713001234",
        GW: "955012345",
        GY: "6091234",
        HK: "51234567",
        HN: "91234567",
        HR: "921234567",
        HT: "34101234",
        HU: "201234567",
        ID: "812345678",
        IE: "850123456",
        IL: "502345678",
        IM: "7924123456",
        IN: "8123456789",
        IO: "3801234",
        IQ: "7912345678",
        IR: "9123456789",
        IS: "6111234",
        IT: "3123456789",
        JE: "7797712345",
        JM: "8762101234",
        JO: "790123456",
        JP: "9012345678",
        KE: "712123456",
        KG: "700123456",
        KH: "91234567",
        KI: "72001234",
        KM: "3212345",
        KN: "8697652917",
        KP: "1921234567",
        KR: "1020000000",
        KW: "50012345",
        KY: "3453231234",
        KZ: "7710009998",
        LA: "2023123456",
        LB: "71123456",
        LC: "7582845678",
        LI: "660234567",
        LK: "712345678",
        LR: "770123456",
        LS: "50123456",
        LT: "61234567",
        LU: "628123456",
        LV: "21234567",
        LY: "912345678",
        MA: "650123456",
        MC: "612345678",
        MD: "62112345",
        ME: "67622901",
        MF: "690001234",
        MG: "321234567",
        MH: "2351234",
        MK: "72345678",
        ML: "65012345",
        MM: "92123456",
        MN: "88123456",
        MO: "66123456",
        MP: "6702345678",
        MQ: "696201234",
        MR: "22123456",
        MS: "6644923456",
        MT: "96961234",
        MU: "52512345",
        MV: "7712345",
        MW: "991234567",
        MX: "2221234567",
        MY: "123456789",
        MZ: "821234567",
        NA: "811234567",
        NC: "751234",
        NE: "93123456",
        NF: "381234",
        NG: "8021234567",
        NI: "81234567",
        NL: "612345678",
        NO: "40612345",
        NP: "9841234567",
        NR: "5551234",
        NU: "8884012",
        NZ: "211234567",
        OM: "92123456",
        PA: "61234567",
        PE: "912345678",
        PF: "87123456",
        PG: "70123456",
        PH: "9051234567",
        PK: "3012345678",
        PL: "512345678",
        PM: "551234",
        PR: "7872345678",
        PS: "599123456",
        PT: "912345678",
        PW: "6201234",
        PY: "961456789",
        QA: "33123456",
        RE: "692123456",
        RO: "712034567",
        RS: "601234567",
        RU: "9123456789",
        RW: "720123456",
        SA: "512345678",
        SB: "7421234",
        SC: "2510123",
        SD: "911231234",
        SE: "701234567",
        SG: "81234567",
        SH: "51234",
        SI: "31234567",
        SJ: "41234567",
        SK: "912123456",
        SL: "25123456",
        SM: "66661212",
        SN: "701234567",
        SO: "71123456",
        SR: "7412345",
        SS: "977123456",
        ST: "9812345",
        SV: "70123456",
        SX: "7215205678",
        SY: "944567890",
        SZ: "76123456",
        TA: "8999",
        TC: "6492311234",
        TD: "63012345",
        TG: "90112345",
        TH: "812345678",
        TJ: "917123456",
        TK: "7290",
        TL: "77212345",
        TM: "66123456",
        TN: "20123456",
        TO: "7715123",
        TR: "5012345678",
        TT: "8682911234",
        TV: "901234",
        TW: "912345678",
        TZ: "621234567",
        UA: "501234567",
        UG: "712345678",
        US: "2015550123",
        UY: "94231234",
        UZ: "912345678",
        VA: "3123456789",
        VC: "7844301234",
        VE: "4121234567",
        VG: "2843001234",
        VI: "3406421234",
        VN: "912345678",
        VU: "5912345",
        WF: "821234",
        WS: "7212345",
        XK: "43201234",
        YE: "712345678",
        YT: "639012345",
        ZA: "711234567",
        ZM: "955123456",
        ZW: "712345678"
    },
    JN = {
        version: 4,
        country_calling_codes: {
            1: ["US", "AG", "AI", "AS", "BB", "BM", "BS", "CA", "DM", "DO", "GD", "GU", "JM", "KN", "KY", "LC", "MP", "MS", "PR", "SX", "TC", "TT", "VC", "VG", "VI"],
            7: ["RU", "KZ"],
            20: ["EG"],
            27: ["ZA"],
            30: ["GR"],
            31: ["NL"],
            32: ["BE"],
            33: ["FR"],
            34: ["ES"],
            36: ["HU"],
            39: ["IT", "VA"],
            40: ["RO"],
            41: ["CH"],
            43: ["AT"],
            44: ["GB", "GG", "IM", "JE"],
            45: ["DK"],
            46: ["SE"],
            47: ["NO", "SJ"],
            48: ["PL"],
            49: ["DE"],
            51: ["PE"],
            52: ["MX"],
            53: ["CU"],
            54: ["AR"],
            55: ["BR"],
            56: ["CL"],
            57: ["CO"],
            58: ["VE"],
            60: ["MY"],
            61: ["AU", "CC", "CX"],
            62: ["ID"],
            63: ["PH"],
            64: ["NZ"],
            65: ["SG"],
            66: ["TH"],
            81: ["JP"],
            82: ["KR"],
            84: ["VN"],
            86: ["CN"],
            90: ["TR"],
            91: ["IN"],
            92: ["PK"],
            93: ["AF"],
            94: ["LK"],
            95: ["MM"],
            98: ["IR"],
            211: ["SS"],
            212: ["MA", "EH"],
            213: ["DZ"],
            216: ["TN"],
            218: ["LY"],
            220: ["GM"],
            221: ["SN"],
            222: ["MR"],
            223: ["ML"],
            224: ["GN"],
            225: ["CI"],
            226: ["BF"],
            227: ["NE"],
            228: ["TG"],
            229: ["BJ"],
            230: ["MU"],
            231: ["LR"],
            232: ["SL"],
            233: ["GH"],
            234: ["NG"],
            235: ["TD"],
            236: ["CF"],
            237: ["CM"],
            238: ["CV"],
            239: ["ST"],
            240: ["GQ"],
            241: ["GA"],
            242: ["CG"],
            243: ["CD"],
            244: ["AO"],
            245: ["GW"],
            246: ["IO"],
            247: ["AC"],
            248: ["SC"],
            249: ["SD"],
            250: ["RW"],
            251: ["ET"],
            252: ["SO"],
            253: ["DJ"],
            254: ["KE"],
            255: ["TZ"],
            256: ["UG"],
            257: ["BI"],
            258: ["MZ"],
            260: ["ZM"],
            261: ["MG"],
            262: ["RE", "YT"],
            263: ["ZW"],
            264: ["NA"],
            265: ["MW"],
            266: ["LS"],
            267: ["BW"],
            268: ["SZ"],
            269: ["KM"],
            290: ["SH", "TA"],
            291: ["ER"],
            297: ["AW"],
            298: ["FO"],
            299: ["GL"],
            350: ["GI"],
            351: ["PT"],
            352: ["LU"],
            353: ["IE"],
            354: ["IS"],
            355: ["AL"],
            356: ["MT"],
            357: ["CY"],
            358: ["FI", "AX"],
            359: ["BG"],
            370: ["LT"],
            371: ["LV"],
            372: ["EE"],
            373: ["MD"],
            374: ["AM"],
            375: ["BY"],
            376: ["AD"],
            377: ["MC"],
            378: ["SM"],
            380: ["UA"],
            381: ["RS"],
            382: ["ME"],
            383: ["XK"],
            385: ["HR"],
            386: ["SI"],
            387: ["BA"],
            389: ["MK"],
            420: ["CZ"],
            421: ["SK"],
            423: ["LI"],
            500: ["FK"],
            501: ["BZ"],
            502: ["GT"],
            503: ["SV"],
            504: ["HN"],
            505: ["NI"],
            506: ["CR"],
            507: ["PA"],
            508: ["PM"],
            509: ["HT"],
            590: ["GP", "BL", "MF"],
            591: ["BO"],
            592: ["GY"],
            593: ["EC"],
            594: ["GF"],
            595: ["PY"],
            596: ["MQ"],
            597: ["SR"],
            598: ["UY"],
            599: ["CW", "BQ"],
            670: ["TL"],
            672: ["NF"],
            673: ["BN"],
            674: ["NR"],
            675: ["PG"],
            676: ["TO"],
            677: ["SB"],
            678: ["VU"],
            679: ["FJ"],
            680: ["PW"],
            681: ["WF"],
            682: ["CK"],
            683: ["NU"],
            685: ["WS"],
            686: ["KI"],
            687: ["NC"],
            688: ["TV"],
            689: ["PF"],
            690: ["TK"],
            691: ["FM"],
            692: ["MH"],
            850: ["KP"],
            852: ["HK"],
            853: ["MO"],
            855: ["KH"],
            856: ["LA"],
            880: ["BD"],
            886: ["TW"],
            960: ["MV"],
            961: ["LB"],
            962: ["JO"],
            963: ["SY"],
            964: ["IQ"],
            965: ["KW"],
            966: ["SA"],
            967: ["YE"],
            968: ["OM"],
            970: ["PS"],
            971: ["AE"],
            972: ["IL"],
            973: ["BH"],
            974: ["QA"],
            975: ["BT"],
            976: ["MN"],
            977: ["NP"],
            992: ["TJ"],
            993: ["TM"],
            994: ["AZ"],
            995: ["GE"],
            996: ["KG"],
            998: ["UZ"]
        },
        countries: {
            AC: ["247", "00", "(?:[01589]\\d|[46])\\d{4}", [5, 6]],
            AD: ["376", "00", "(?:1|6\\d)\\d{7}|[135-9]\\d{5}", [6, 8, 9],
                [
                    ["(\\d{3})(\\d{3})", "$1 $2", ["[135-9]"]],
                    ["(\\d{4})(\\d{4})", "$1 $2", ["1"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]]
                ]
            ],
            AE: ["971", "00", "(?:[4-7]\\d|9[0-689])\\d{7}|800\\d{2,9}|[2-4679]\\d{7}", [5, 6, 7, 8, 9, 10, 11, 12],
                [
                    ["(\\d{3})(\\d{2,9})", "$1 $2", ["60|8"]],
                    ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[236]|[479][2-8]"], "0$1"],
                    ["(\\d{3})(\\d)(\\d{5})", "$1 $2 $3", ["[479]"]],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["5"], "0$1"]
                ], "0"
            ],
            AF: ["93", "00", "[2-7]\\d{8}", [9],
                [
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-7]"], "0$1"]
                ], "0"
            ],
            AG: ["1", "011", "(?:268|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([457]\\d{6})$|1", "268$1", 0, "268"],
            AI: ["1", "011", "(?:264|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2457]\\d{6})$|1", "264$1", 0, "264"],
            AL: ["355", "00", "(?:700\\d\\d|900)\\d{3}|8\\d{5,7}|(?:[2-5]|6\\d)\\d{7}", [6, 7, 8, 9],
                [
                    ["(\\d{3})(\\d{3,4})", "$1 $2", ["80|9"], "0$1"],
                    ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["4[2-6]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2358][2-5]|4"], "0$1"],
                    ["(\\d{3})(\\d{5})", "$1 $2", ["[23578]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["6"], "0$1"]
                ], "0"
            ],
            AM: ["374", "00", "(?:[1-489]\\d|55|60|77)\\d{6}", [8],
                [
                    ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[89]0"], "0 $1"],
                    ["(\\d{3})(\\d{5})", "$1 $2", ["2|3[12]"], "(0$1)"],
                    ["(\\d{2})(\\d{6})", "$1 $2", ["1|47"], "(0$1)"],
                    ["(\\d{2})(\\d{6})", "$1 $2", ["[3-9]"], "0$1"]
                ], "0"
            ],
            AO: ["244", "00", "[29]\\d{8}", [9],
                [
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[29]"]]
                ]
            ],
            AR: ["54", "00", "(?:11|[89]\\d\\d)\\d{8}|[2368]\\d{9}", [10, 11],
                [
                    ["(\\d{4})(\\d{2})(\\d{4})", "$1 $2-$3", ["2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9])", "2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8]))|2(?:2[24-9]|3[1-59]|47)", "2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5[56][46]|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]", "2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|58|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|54(?:4|5[13-7]|6[89])|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:454|85[56])[46]|3(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"], "0$1", 1],
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2-$3", ["1"], "0$1", 1],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["[68]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2-$3", ["[23]"], "0$1", 1],
                    ["(\\d)(\\d{4})(\\d{2})(\\d{4})", "$2 15-$3-$4", ["9(?:2[2-469]|3[3-578])", "9(?:2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9]))", "9(?:2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8])))|92(?:2[24-9]|3[1-59]|47)", "9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5(?:[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]", "9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|5(?:4(?:4|5[13-7]|6[89])|[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"], "0$1", 0, "$1 $2 $3-$4"],
                    ["(\\d)(\\d{2})(\\d{4})(\\d{4})", "$2 15-$3-$4", ["91"], "0$1", 0, "$1 $2 $3-$4"],
                    ["(\\d{3})(\\d{3})(\\d{5})", "$1-$2-$3", ["8"], "0$1"],
                    ["(\\d)(\\d{3})(\\d{3})(\\d{4})", "$2 15-$3-$4", ["9"], "0$1", 0, "$1 $2 $3-$4"]
                ], "0", 0, "0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))15)?", "9$1"
            ],
            AS: ["1", "011", "(?:[58]\\d\\d|684|900)\\d{7}", [10], 0, "1", 0, "([267]\\d{6})$|1", "684$1", 0, "684"],
            AT: ["43", "00", "1\\d{3,12}|2\\d{6,12}|43(?:(?:0\\d|5[02-9])\\d{3,9}|2\\d{4,5}|[3467]\\d{4}|8\\d{4,6}|9\\d{4,7})|5\\d{4,12}|8\\d{7,12}|9\\d{8,12}|(?:[367]\\d|4[0-24-9])\\d{4,11}", [4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
                [
                    ["(\\d)(\\d{3,12})", "$1 $2", ["1(?:11|[2-9])"], "0$1"],
                    ["(\\d{3})(\\d{2})", "$1 $2", ["517"], "0$1"],
                    ["(\\d{2})(\\d{3,5})", "$1 $2", ["5[079]"], "0$1"],
                    ["(\\d{3})(\\d{3,10})", "$1 $2", ["(?:31|4)6|51|6(?:48|5[0-3579]|[6-9])|7(?:20|32|8)|[89]", "(?:31|4)6|51|6(?:485|5[0-3579]|[6-9])|7(?:20|32|8)|[89]"], "0$1"],
                    ["(\\d{4})(\\d{3,9})", "$1 $2", ["[2-467]|5[2-6]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["5"], "0$1"],
                    ["(\\d{2})(\\d{4})(\\d{4,7})", "$1 $2 $3", ["5"], "0$1"]
                ], "0"
            ],
            AU: ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{7}(?:\\d(?:\\d{2})?)?|8[0-24-9]\\d{7})|[2-478]\\d{8}|1\\d{4,7}", [5, 6, 7, 8, 9, 10, 12],
                [
                    ["(\\d{2})(\\d{3,4})", "$1 $2", ["16"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{2,4})", "$1 $2 $3", ["16"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["14|4"], "0$1"],
                    ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["[2378]"], "(0$1)"],
                    ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1(?:30|[89])"]]
                ], "0", 0, "(183[12])|0", 0, 0, 0, [
                    ["(?:(?:2(?:(?:[0-26-9]\\d|3[0-8]|5[0135-9])\\d|4(?:[02-9]\\d|10))|3(?:(?:[0-3589]\\d|6[1-9]|7[0-35-9])\\d|4(?:[0-578]\\d|90))|7(?:[013-57-9]\\d|2[0-8])\\d)\\d\\d|8(?:51(?:0(?:0[03-9]|[12479]\\d|3[2-9]|5[0-8]|6[1-9]|8[0-7])|1(?:[0235689]\\d|1[0-69]|4[0-589]|7[0-47-9])|2(?:0[0-79]|[18][13579]|2[14-9]|3[0-46-9]|[4-6]\\d|7[89]|9[0-4])|[34]\\d\\d)|(?:6[0-8]|[78]\\d)\\d{3}|9(?:[02-9]\\d{3}|1(?:(?:[0-58]\\d|6[0135-9])\\d|7(?:0[0-24-9]|[1-9]\\d)|9(?:[0-46-9]\\d|5[0-79])))))\\d{3}", [9]],
                    ["4(?:79[01]|83[0-389]|94[0-478])\\d{5}|4(?:[0-36]\\d|4[047-9]|5[0-25-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}", [9]],
                    ["180(?:0\\d{3}|2)\\d{3}", [7, 10]],
                    ["190[0-26]\\d{6}", [10]], 0, 0, 0, ["163\\d{2,6}", [5, 6, 7, 8, 9]],
                    ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]],
                    ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]
                ], "0011"
            ],
            AW: ["297", "00", "(?:[25-79]\\d\\d|800)\\d{4}", [7],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[25-9]"]]
                ]
            ],
            AX: ["358", "00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))", "2\\d{4,9}|35\\d{4,5}|(?:60\\d\\d|800)\\d{4,6}|7\\d{5,11}|(?:[14]\\d|3[0-46-9]|50)\\d{4,8}", [5, 6, 7, 8, 9, 10, 11, 12], 0, "0", 0, 0, 0, 0, "18", 0, "00"],
            AZ: ["994", "00", "365\\d{6}|(?:[124579]\\d|60|88)\\d{7}", [9],
                [
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["90"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[28]|2|365|46", "1[28]|2|365[45]|46", "1[28]|2|365(?:4|5[02])|46"], "(0$1)"],
                    ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[13-9]"], "0$1"]
                ], "0"
            ],
            BA: ["387", "00", "6\\d{8}|(?:[35689]\\d|49|70)\\d{6}", [8, 9],
                [
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["6[1-3]|[7-9]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2-$3", ["[3-5]|6[56]"], "0$1"],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["6"], "0$1"]
                ], "0"
            ],
            BB: ["1", "011", "(?:246|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "246$1", 0, "246"],
            BD: ["880", "00", "[1-469]\\d{9}|8[0-79]\\d{7,8}|[2-79]\\d{8}|[2-9]\\d{7}|[3-9]\\d{6}|[57-9]\\d{5}", [6, 7, 8, 9, 10],
                [
                    ["(\\d{2})(\\d{4,6})", "$1-$2", ["31[5-8]|[459]1"], "0$1"],
                    ["(\\d{3})(\\d{3,7})", "$1-$2", ["3(?:[67]|8[013-9])|4(?:6[168]|7|[89][18])|5(?:6[128]|9)|6(?:[15]|28|4[14])|7[2-589]|8(?:0[014-9]|[12])|9[358]|(?:3[2-5]|4[235]|5[2-578]|6[0389]|76|8[3-7]|9[24])1|(?:44|66)[01346-9]"], "0$1"],
                    ["(\\d{4})(\\d{3,6})", "$1-$2", ["[13-9]|2[23]"], "0$1"],
                    ["(\\d)(\\d{7,8})", "$1-$2", ["2"], "0$1"]
                ], "0"
            ],
            BE: ["32", "00", "4\\d{8}|[1-9]\\d{7}", [8, 9],
                [
                    ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:80|9)0"], "0$1"],
                    ["(\\d)(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[239]|4[23]"], "0$1"],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[15-8]"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["4"], "0$1"]
                ], "0"
            ],
            BF: ["226", "00", "(?:[025-7]\\d|44)\\d{6}", [8],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[024-7]"]]
                ]
            ],
            BG: ["359", "00", "00800\\d{7}|[2-7]\\d{6,7}|[89]\\d{6,8}|2\\d{5}", [6, 7, 8, 9, 12],
                [
                    ["(\\d)(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["2"], "0$1"],
                    ["(\\d{3})(\\d{4})", "$1 $2", ["43[1-6]|70[1-9]"], "0$1"],
                    ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{2,3})", "$1 $2 $3", ["[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:70|8)0"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{2})", "$1 $2 $3", ["43[1-7]|7"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[48]|9[08]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1"]
                ], "0"
            ],
            BH: ["973", "00", "[136-9]\\d{7}", [8],
                [
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[13679]|8[02-4679]"]]
                ]
            ],
            BI: ["257", "00", "(?:[267]\\d|31)\\d{6}", [8],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2367]"]]
                ]
            ],
            BJ: ["229", "00", "(?:01\\d|[24-689])\\d{7}", [8, 10],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24-689]"]],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["0"]]
                ]
            ],
            BL: ["590", "00", "(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}", [9], 0, "0", 0, 0, 0, 0, 0, [
                ["590(?:2[7-9]|3[3-7]|5[12]|87)\\d{4}"],
                ["(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"],
                ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"]
            ]],
            BM: ["1", "011", "(?:441|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "441$1", 0, "441"],
            BN: ["673", "00", "[2-578]\\d{6}", [7],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[2-578]"]]
                ]
            ],
            BO: ["591", "00(?:1\\d)?", "8001\\d{5}|(?:[2-467]\\d|50)\\d{6}", [8, 9],
                [
                    ["(\\d)(\\d{7})", "$1 $2", ["[235]|4[46]"]],
                    ["(\\d{8})", "$1", ["[67]"]],
                    ["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["8"]]
                ], "0", 0, "0(1\\d)?"
            ],
            BQ: ["599", "00", "(?:[34]1|7\\d)\\d{5}", [7], 0, 0, 0, 0, 0, 0, "[347]"],
            BR: ["55", "00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)", "[1-467]\\d{9,10}|55[0-46-9]\\d{8}|[34]\\d{7}|55\\d{7,8}|(?:5[0-46-9]|[89]\\d)\\d{7,9}", [8, 9, 10, 11],
                [
                    ["(\\d{4})(\\d{4})", "$1-$2", ["300|4(?:0[02]|37|86)", "300|4(?:0(?:0|20)|370|864)"]],
                    ["(\\d{3})(\\d{2,3})(\\d{4})", "$1 $2 $3", ["(?:[358]|90)0"], "0$1"],
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2-$3", ["(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-57]"], "($1)"],
                    ["(\\d{2})(\\d{5})(\\d{4})", "$1 $2-$3", ["[16][1-9]|[2-57-9]"], "($1)"]
                ], "0", 0, "(?:0|90)(?:(1[245]|2[1-35]|31|4[13]|[56]5|99)(\\d{10,11}))?", "$2"
            ],
            BS: ["1", "011", "(?:242|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([3-8]\\d{6})$|1", "242$1", 0, "242"],
            BT: ["975", "00", "[17]\\d{7}|[2-8]\\d{6}", [7, 8],
                [
                    ["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-68]|7[246]"]],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[67]|7"]]
                ]
            ],
            BW: ["267", "00", "(?:0800|(?:[37]|800)\\d)\\d{6}|(?:[2-6]\\d|90)\\d{5}", [7, 8, 10],
                [
                    ["(\\d{2})(\\d{5})", "$1 $2", ["90"]],
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[24-6]|3[15-9]"]],
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[37]"]],
                    ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["0"]],
                    ["(\\d{3})(\\d{4})(\\d{3})", "$1 $2 $3", ["8"]]
                ]
            ],
            BY: ["375", "810", "(?:[12]\\d|33|44|902)\\d{7}|8(?:0[0-79]\\d{5,7}|[1-7]\\d{9})|8(?:1[0-489]|[5-79]\\d)\\d{7}|8[1-79]\\d{6,7}|8[0-79]\\d{5}|8\\d{5}", [6, 7, 8, 9, 10, 11],
                [
                    ["(\\d{3})(\\d{3})", "$1 $2", ["800"], "8 $1"],
                    ["(\\d{3})(\\d{2})(\\d{2,4})", "$1 $2 $3", ["800"], "8 $1"],
                    ["(\\d{4})(\\d{2})(\\d{3})", "$1 $2-$3", ["1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])", "1(?:5[169]|6(?:3[1-3]|4|5[125])|7(?:1[3-9]|7[0-24-6]|9[2-7]))|2(?:1[35]|2[34]|3[3-5])"], "8 0$1"],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["1(?:[56]|7[467])|2[1-3]"], "8 0$1"],
                    ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[1-4]"], "8 0$1"],
                    ["(\\d{3})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["[89]"], "8 $1"]
                ], "8", 0, "0|80?", 0, 0, 0, 0, "8~10"
            ],
            BZ: ["501", "00", "(?:0800\\d|[2-8])\\d{6}", [7, 11],
                [
                    ["(\\d{3})(\\d{4})", "$1-$2", ["[2-8]"]],
                    ["(\\d)(\\d{3})(\\d{4})(\\d{3})", "$1-$2-$3-$4", ["0"]]
                ]
            ],
            CA: ["1", "011", "[2-9]\\d{9}|3\\d{6}", [7, 10], 0, "1", 0, 0, 0, 0, 0, [
                ["(?:2(?:04|[23]6|[48]9|5[07]|63)|3(?:06|43|54|6[578]|82)|4(?:03|1[68]|[26]8|3[178]|50|74)|5(?:06|1[49]|48|79|8[147])|6(?:04|[18]3|39|47|72)|7(?:0[59]|42|53|78|8[02])|8(?:[06]7|19|25|7[39])|9(?:0[25]|42))[2-9]\\d{6}", [10]],
                ["", [10]],
                ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}", [10]],
                ["900[2-9]\\d{6}", [10]],
                ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|(?:5(?:2[125-9]|33|44|66|77|88)|6(?:22|33))[2-9]\\d{6}", [10]], 0, ["310\\d{4}", [7]], 0, ["600[2-9]\\d{6}", [10]]
            ]],
            CC: ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}", [6, 7, 8, 9, 10, 12], 0, "0", 0, "([59]\\d{7})$|0", "8$1", 0, 0, [
                ["8(?:51(?:0(?:02|31|60|89)|1(?:18|76)|223)|91(?:0(?:1[0-2]|29)|1(?:[28]2|50|79)|2(?:10|64)|3(?:[06]8|22)|4[29]8|62\\d|70[23]|959))\\d{3}", [9]],
                ["4(?:79[01]|83[0-389]|94[0-478])\\d{5}|4(?:[0-36]\\d|4[047-9]|5[0-25-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}", [9]],
                ["180(?:0\\d{3}|2)\\d{3}", [7, 10]],
                ["190[0-26]\\d{6}", [10]], 0, 0, 0, 0, ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]],
                ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]
            ], "0011"],
            CD: ["243", "00", "(?:(?:[189]|5\\d)\\d|2)\\d{7}|[1-68]\\d{6}", [7, 8, 9, 10],
                [
                    ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["88"], "0$1"],
                    ["(\\d{2})(\\d{5})", "$1 $2", ["[1-6]"], "0$1"],
                    ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["2"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[89]"], "0$1"],
                    ["(\\d{2})(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["5"], "0$1"]
                ], "0"
            ],
            CF: ["236", "00", "(?:[27]\\d{3}|8776)\\d{4}", [8],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[278]"]]
                ]
            ],
            CG: ["242", "00", "222\\d{6}|(?:0\\d|80)\\d{7}", [9],
                [
                    ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["8"]],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[02]"]]
                ]
            ],
            CH: ["41", "00", "8\\d{11}|[2-9]\\d{8}", [9, 12],
                [
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8[047]|90"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-79]|81"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["8"], "0$1"]
                ], "0"
            ],
            CI: ["225", "00", "[02]\\d{9}", [10],
                [
                    ["(\\d{2})(\\d{2})(\\d)(\\d{5})", "$1 $2 $3 $4", ["2"]],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3 $4", ["0"]]
                ]
            ],
            CK: ["682", "00", "[2-578]\\d{4}", [5],
                [
                    ["(\\d{2})(\\d{3})", "$1 $2", ["[2-578]"]]
                ]
            ],
            CL: ["56", "(?:0|1(?:1[0-69]|2[02-5]|5[13-58]|69|7[0167]|8[018]))0", "12300\\d{6}|6\\d{9,10}|[2-9]\\d{8}", [9, 10, 11],
                [
                    ["(\\d{5})(\\d{4})", "$1 $2", ["219", "2196"], "($1)"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["44"]],
                    ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2[1-36]"], "($1)"],
                    ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["9[2-9]"]],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["3[2-5]|[47]|5[1-3578]|6[13-57]|8(?:0[1-9]|[1-9])"], "($1)"],
                    ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["60|8"]],
                    ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]],
                    ["(\\d{3})(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["60"]]
                ]
            ],
            CM: ["237", "00", "[26]\\d{8}|88\\d{6,7}", [8, 9],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["88"]],
                    ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["[26]|88"]]
                ]
            ],
            CN: ["86", "00|1(?:[12]\\d|79)\\d\\d00", "(?:(?:1[03-689]|2\\d)\\d\\d|6)\\d{8}|1\\d{10}|[126]\\d{6}(?:\\d(?:\\d{2})?)?|86\\d{5,6}|(?:[3-579]\\d|8[0-57-9])\\d{5,9}", [7, 8, 9, 10, 11, 12],
                [
                    ["(\\d{2})(\\d{5,6})", "$1 $2", ["(?:10|2[0-57-9])[19]|3(?:[157]|35|49|9[1-68])|4(?:1[124-9]|2[179]|6[47-9]|7|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:07|1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3|4[13]|5[1-5]|7[0-79]|9[0-35-9])|(?:4[35]|59|85)[1-9]", "(?:10|2[0-57-9])(?:1[02]|9[56])|8078|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))1", "10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|80781|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))12", "10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|807812|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))123", "10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:078|1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))123"], "0$1"],
                    ["(\\d{3})(\\d{5,6})", "$1 $2", ["3(?:[157]|35|49|9[1-68])|4(?:[17]|2[179]|6[47-9]|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])|(?:4[35]|59|85)[1-9]", "(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))[19]", "85[23](?:10|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:10|9[56])", "85[23](?:100|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:100|9[56])"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["(?:4|80)0"]],
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["10|2(?:[02-57-9]|1[1-9])", "10|2(?:[02-57-9]|1[1-9])", "10[0-79]|2(?:[02-57-9]|1[1-79])|(?:10|21)8(?:0[1-9]|[1-9])"], "0$1", 1],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["3(?:[3-59]|7[02-68])|4(?:[26-8]|3[3-9]|5[2-9])|5(?:3[03-9]|[468]|7[028]|9[2-46-9])|6|7(?:[0-247]|3[04-9]|5[0-4689]|6[2368])|8(?:[1-358]|9[1-7])|9(?:[013479]|5[1-5])|(?:[34]1|55|79|87)[02-9]"], "0$1", 1],
                    ["(\\d{3})(\\d{7,8})", "$1 $2", ["9"]],
                    ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["80"], "0$1", 1],
                    ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["[3-578]"], "0$1", 1],
                    ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["1[3-9]"]],
                    ["(\\d{2})(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["[12]"], "0$1", 1]
                ], "0", 0, "(1(?:[12]\\d|79)\\d\\d)|0", 0, 0, 0, 0, "00"
            ],
            CO: ["57", "00(?:4(?:[14]4|56)|[579])", "(?:46|60\\d\\d)\\d{6}|(?:1\\d|[39])\\d{9}", [8, 10, 11],
                [
                    ["(\\d{4})(\\d{4})", "$1 $2", ["46"]],
                    ["(\\d{3})(\\d{7})", "$1 $2", ["6|90"], "($1)"],
                    ["(\\d{3})(\\d{7})", "$1 $2", ["3[0-357]|9[14]"]],
                    ["(\\d)(\\d{3})(\\d{7})", "$1-$2-$3", ["1"], "0$1", 0, "$1 $2 $3"]
                ], "0", 0, "0([3579]|4(?:[14]4|56))?"
            ],
            CR: ["506", "00", "(?:8\\d|90)\\d{8}|(?:[24-8]\\d{3}|3005)\\d{4}", [8, 10],
                [
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[2-7]|8[3-9]"]],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["[89]"]]
                ], 0, 0, "(19(?:0[0-2468]|1[09]|20|66|77|99))"
            ],
            CU: ["53", "119", "(?:[2-7]|8\\d\\d)\\d{7}|[2-47]\\d{6}|[34]\\d{5}", [6, 7, 8, 10],
                [
                    ["(\\d{2})(\\d{4,6})", "$1 $2", ["2[1-4]|[34]"], "(0$1)"],
                    ["(\\d)(\\d{6,7})", "$1 $2", ["7"], "(0$1)"],
                    ["(\\d)(\\d{7})", "$1 $2", ["[56]"], "0$1"],
                    ["(\\d{3})(\\d{7})", "$1 $2", ["8"], "0$1"]
                ], "0"
            ],
            CV: ["238", "0", "(?:[2-59]\\d\\d|800)\\d{4}", [7],
                [
                    ["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[2-589]"]]
                ]
            ],
            CW: ["599", "00", "(?:[34]1|60|(?:7|9\\d)\\d)\\d{5}", [7, 8],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[3467]"]],
                    ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["9[4-8]"]]
                ], 0, 0, 0, 0, 0, "[69]"
            ],
            CX: ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}", [6, 7, 8, 9, 10, 12], 0, "0", 0, "([59]\\d{7})$|0", "8$1", 0, 0, [
                ["8(?:51(?:0(?:01|30|59|88)|1(?:17|46|75)|2(?:22|35))|91(?:00[6-9]|1(?:[28]1|49|78)|2(?:09|63)|3(?:12|26|75)|4(?:56|97)|64\\d|7(?:0[01]|1[0-2])|958))\\d{3}", [9]],
                ["4(?:79[01]|83[0-389]|94[0-478])\\d{5}|4(?:[0-36]\\d|4[047-9]|5[0-25-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}", [9]],
                ["180(?:0\\d{3}|2)\\d{3}", [7, 10]],
                ["190[0-26]\\d{6}", [10]], 0, 0, 0, 0, ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]],
                ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]
            ], "0011"],
            CY: ["357", "00", "(?:[279]\\d|[58]0)\\d{6}", [8],
                [
                    ["(\\d{2})(\\d{6})", "$1 $2", ["[257-9]"]]
                ]
            ],
            CZ: ["420", "00", "(?:[2-578]\\d|60)\\d{7}|9\\d{8,11}", [9, 10, 11, 12],
                [
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-8]|9[015-7]"]],
                    ["(\\d{2})(\\d{3})(\\d{3})(\\d{2})", "$1 $2 $3 $4", ["96"]],
                    ["(\\d{2})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]],
                    ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]]
                ]
            ],
            DE: ["49", "00", "[2579]\\d{5,14}|49(?:[34]0|69|8\\d)\\d\\d?|49(?:37|49|60|7[089]|9\\d)\\d{1,3}|49(?:2[024-9]|3[2-689]|7[1-7])\\d{1,8}|(?:1|[368]\\d|4[0-8])\\d{3,13}|49(?:[015]\\d|2[13]|31|[46][1-8])\\d{1,9}", [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
                [
                    ["(\\d{2})(\\d{3,13})", "$1 $2", ["3[02]|40|[68]9"], "0$1"],
                    ["(\\d{3})(\\d{3,12})", "$1 $2", ["2(?:0[1-389]|1[124]|2[18]|3[14])|3(?:[35-9][15]|4[015])|906|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1", "2(?:0[1-389]|12[0-8])|3(?:[35-9][15]|4[015])|906|2(?:[13][14]|2[18])|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1"], "0$1"],
                    ["(\\d{4})(\\d{2,11})", "$1 $2", ["[24-6]|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]", "[24-6]|3(?:3(?:0[1-467]|2[127-9]|3[124578]|7[1257-9]|8[1256]|9[145])|4(?:2[135]|4[13578]|9[1346])|5(?:0[14]|2[1-3589]|6[1-4]|7[13468]|8[13568])|6(?:2[1-489]|3[124-6]|6[13]|7[12579]|8[1-356]|9[135])|7(?:2[1-7]|4[145]|6[1-5]|7[1-4])|8(?:21|3[1468]|6|7[1467]|8[136])|9(?:0[12479]|2[1358]|4[134679]|6[1-9]|7[136]|8[147]|9[1468]))|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]|3[68]4[1347]|3(?:47|60)[1356]|3(?:3[46]|46|5[49])[1246]|3[4579]3[1357]"], "0$1"],
                    ["(\\d{3})(\\d{4})", "$1 $2", ["138"], "0$1"],
                    ["(\\d{5})(\\d{2,10})", "$1 $2", ["3"], "0$1"],
                    ["(\\d{3})(\\d{5,11})", "$1 $2", ["181"], "0$1"],
                    ["(\\d{3})(\\d)(\\d{4,10})", "$1 $2 $3", ["1(?:3|80)|9"], "0$1"],
                    ["(\\d{3})(\\d{7,8})", "$1 $2", ["1[67]"], "0$1"],
                    ["(\\d{3})(\\d{7,12})", "$1 $2", ["8"], "0$1"],
                    ["(\\d{5})(\\d{6})", "$1 $2", ["185", "1850", "18500"], "0$1"],
                    ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["7"], "0$1"],
                    ["(\\d{4})(\\d{7})", "$1 $2", ["18[68]"], "0$1"],
                    ["(\\d{4})(\\d{7})", "$1 $2", ["15[1279]"], "0$1"],
                    ["(\\d{5})(\\d{6})", "$1 $2", ["15[03568]", "15(?:[0568]|31)"], "0$1"],
                    ["(\\d{3})(\\d{8})", "$1 $2", ["18"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{7,8})", "$1 $2 $3", ["1(?:6[023]|7)"], "0$1"],
                    ["(\\d{4})(\\d{2})(\\d{7})", "$1 $2 $3", ["15[279]"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{8})", "$1 $2 $3", ["15"], "0$1"]
                ], "0"
            ],
            DJ: ["253", "00", "(?:2\\d|77)\\d{6}", [8],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[27]"]]
                ]
            ],
            DK: ["45", "00", "[2-9]\\d{7}", [8],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-9]"]]
                ]
            ],
            DM: ["1", "011", "(?:[58]\\d\\d|767|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "767$1", 0, "767"],
            DO: ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "8001|8[024]9"],
            DZ: ["213", "00", "(?:[1-4]|[5-79]\\d|80)\\d{7}", [8, 9],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[1-4]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["9"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-8]"], "0$1"]
                ], "0"
            ],
            EC: ["593", "00", "1\\d{9,10}|(?:[2-7]|9\\d)\\d{7}", [8, 9, 10, 11],
                [
                    ["(\\d)(\\d{3})(\\d{4})", "$1 $2-$3", ["[2-7]"], "(0$1)", 0, "$1-$2-$3"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["9"], "0$1"],
                    ["(\\d{4})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["1"]]
                ], "0"
            ],
            EE: ["372", "00", "8\\d{9}|[4578]\\d{7}|(?:[3-8]\\d|90)\\d{5}", [7, 8, 10],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]|88", "[369]|4[3-8]|5(?:[02]|1(?:[0-8]|95)|5[0-478]|6(?:4[0-4]|5[1-589]))|7[1-9]|88"]],
                    ["(\\d{4})(\\d{3,4})", "$1 $2", ["[45]|8(?:00|[1-49])", "[45]|8(?:00[1-9]|[1-49])"]],
                    ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["7"]],
                    ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]]
                ]
            ],
            EG: ["20", "00", "[189]\\d{8,9}|[24-6]\\d{8}|[135]\\d{7}", [8, 9, 10],
                [
                    ["(\\d)(\\d{7,8})", "$1 $2", ["[23]"], "0$1"],
                    ["(\\d{2})(\\d{6,7})", "$1 $2", ["1[35]|[4-6]|8[2468]|9[235-7]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"],
                    ["(\\d{2})(\\d{8})", "$1 $2", ["1"], "0$1"]
                ], "0"
            ],
            EH: ["212", "00", "[5-8]\\d{8}", [9], 0, "0", 0, 0, 0, 0, "528[89]"],
            ER: ["291", "00", "[178]\\d{6}", [7],
                [
                    ["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[178]"], "0$1"]
                ], "0"
            ],
            ES: ["34", "00", "[5-9]\\d{8}", [9],
                [
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[89]00"]],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-9]"]]
                ]
            ],
            ET: ["251", "00", "(?:11|[2-579]\\d)\\d{7}", [9],
                [
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-579]"], "0$1"]
                ], "0"
            ],
            FI: ["358", "00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))", "[1-35689]\\d{4}|7\\d{10,11}|(?:[124-7]\\d|3[0-46-9])\\d{8}|[1-9]\\d{5,8}", [5, 6, 7, 8, 9, 10, 11, 12],
                [
                    ["(\\d{5})", "$1", ["20[2-59]"], "0$1"],
                    ["(\\d{3})(\\d{3,7})", "$1 $2", ["(?:[1-3]0|[68])0|70[07-9]"], "0$1"],
                    ["(\\d{2})(\\d{4,8})", "$1 $2", ["[14]|2[09]|50|7[135]"], "0$1"],
                    ["(\\d{2})(\\d{6,10})", "$1 $2", ["7"], "0$1"],
                    ["(\\d)(\\d{4,9})", "$1 $2", ["(?:19|[2568])[1-8]|3(?:0[1-9]|[1-9])|9"], "0$1"]
                ], "0", 0, 0, 0, 0, "1[03-79]|[2-9]", 0, "00"
            ],
            FJ: ["679", "0(?:0|52)", "45\\d{5}|(?:0800\\d|[235-9])\\d{6}", [7, 11],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[235-9]|45"]],
                    ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["0"]]
                ], 0, 0, 0, 0, 0, 0, 0, "00"
            ],
            FK: ["500", "00", "[2-7]\\d{4}", [5]],
            FM: ["691", "00", "(?:[39]\\d\\d|820)\\d{4}", [7],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[389]"]]
                ]
            ],
            FO: ["298", "00", "[2-9]\\d{5}", [6],
                [
                    ["(\\d{6})", "$1", ["[2-9]"]]
                ], 0, 0, "(10(?:01|[12]0|88))"
            ],
            FR: ["33", "00", "[1-9]\\d{8}", [9],
                [
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0 $1"],
                    ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["[1-79]"], "0$1"]
                ], "0"
            ],
            GA: ["241", "00", "(?:[067]\\d|11)\\d{6}|[2-7]\\d{6}", [7, 8],
                [
                    ["(\\d)(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-7]"], "0$1"],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["0"]],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["11|[67]"], "0$1"]
                ], 0, 0, "0(11\\d{6}|60\\d{6}|61\\d{6}|6[256]\\d{6}|7[467]\\d{6})", "$1"
            ],
            GB: ["44", "00", "[1-357-9]\\d{9}|[18]\\d{8}|8\\d{6}", [7, 9, 10],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["800", "8001", "80011", "800111", "8001111"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["845", "8454", "84546", "845464"], "0$1"],
                    ["(\\d{3})(\\d{6})", "$1 $2", ["800"], "0$1"],
                    ["(\\d{5})(\\d{4,5})", "$1 $2", ["1(?:38|5[23]|69|76|94)", "1(?:(?:38|69)7|5(?:24|39)|768|946)", "1(?:3873|5(?:242|39[4-6])|(?:697|768)[347]|9467)"], "0$1"],
                    ["(\\d{4})(\\d{5,6})", "$1 $2", ["1(?:[2-69][02-9]|[78])"], "0$1"],
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["[25]|7(?:0|6[02-9])", "[25]|7(?:0|6(?:[03-9]|2[356]))"], "0$1"],
                    ["(\\d{4})(\\d{6})", "$1 $2", ["7"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1389]"], "0$1"]
                ], "0", 0, 0, 0, 0, 0, [
                    ["(?:1(?:1(?:3(?:[0-58]\\d\\d|73[0-35])|4(?:(?:[0-5]\\d|70)\\d|69[7-9])|(?:(?:5[0-26-9]|[78][0-49])\\d|6(?:[0-4]\\d|50))\\d)|(?:2(?:(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-47-9]|7[013-9]|9\\d)\\d|1(?:[0-7]\\d|8[0-3]))|(?:3(?:0\\d|1[0-8]|[25][02-9]|3[02-579]|[468][0-46-9]|7[1-35-79]|9[2-578])|4(?:0[03-9]|[137]\\d|[28][02-57-9]|4[02-69]|5[0-8]|[69][0-79])|5(?:0[1-35-9]|[16]\\d|2[024-9]|3[015689]|4[02-9]|5[03-9]|7[0-35-9]|8[0-468]|9[0-57-9])|6(?:0[034689]|1\\d|2[0-35689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0-24578])|7(?:0[0246-9]|2\\d|3[0236-8]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-57-9]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\d|8[02-9]|9[02569])|9(?:0[02-589]|[18]\\d|2[02-689]|3[1-57-9]|4[2-9]|5[0-579]|6[2-47-9]|7[0-24578]|9[2-57]))\\d)\\d)|2(?:0[013478]|3[0189]|4[017]|8[0-46-9]|9[0-2])\\d{3})\\d{4}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-47-9]|8[3-5])))|3(?:6(?:38[2-5]|47[23])|8(?:47[04-9]|64[0157-9]))|4(?:044[1-7]|20(?:2[23]|8\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[1-3]))|5(?:2(?:4(?:3[2-79]|6\\d)|76\\d)|6(?:26[06-9]|686))|6(?:06(?:4\\d|7[4-79])|295[5-7]|35[34]\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|9(?:55[0-4]|77[23]))|7(?:26(?:6[13-9]|7[0-7])|(?:442|688)\\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\\d|37(?:5[2-5]|8[239])|843[2-58])|9(?:0(?:0(?:6[1-8]|85)|52\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\d{3}", [9, 10]],
                    ["7(?:457[0-57-9]|700[01]|911[028])\\d{5}|7(?:[1-3]\\d\\d|4(?:[0-46-9]\\d|5[0-689])|5(?:0[0-8]|[13-9]\\d|2[0-35-9])|7(?:0[1-9]|[1-7]\\d|8[02-9]|9[0-689])|8(?:[014-9]\\d|[23][0-8])|9(?:[024-9]\\d|1[02-9]|3[0-689]))\\d{6}", [10]],
                    ["80[08]\\d{7}|800\\d{6}|8001111"],
                    ["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[2-49]))\\d{7}|845464\\d", [7, 10]],
                    ["70\\d{8}", [10]], 0, ["(?:3[0347]|55)\\d{8}", [10]],
                    ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}", [10]],
                    ["56\\d{8}", [10]]
                ], 0, " x"
            ],
            GD: ["1", "011", "(?:473|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "473$1", 0, "473"],
            GE: ["995", "00", "(?:[3-57]\\d\\d|800)\\d{6}", [9],
                [
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["70"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["32"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[57]"]],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[348]"], "0$1"]
                ], "0"
            ],
            GF: ["594", "00", "(?:[56]94\\d|7093)\\d{5}|(?:80|9\\d)\\d{7}", [9],
                [
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-7]|9[47]"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[89]"], "0$1"]
                ], "0"
            ],
            GG: ["44", "00", "(?:1481|[357-9]\\d{3})\\d{6}|8\\d{6}(?:\\d{2})?", [7, 9, 10], 0, "0", 0, "([25-9]\\d{5})$|0", "1481$1", 0, 0, [
                ["1481[25-9]\\d{5}", [10]],
                ["7(?:(?:781|839)\\d|911[17])\\d{5}", [10]],
                ["80[08]\\d{7}|800\\d{6}|8001111"],
                ["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[0-3]))\\d{7}|845464\\d", [7, 10]],
                ["70\\d{8}", [10]], 0, ["(?:3[0347]|55)\\d{8}", [10]],
                ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}", [10]],
                ["56\\d{8}", [10]]
            ]],
            GH: ["233", "00", "(?:[235]\\d{3}|800)\\d{5}", [8, 9],
                [
                    ["(\\d{3})(\\d{5})", "$1 $2", ["8"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[235]"], "0$1"]
                ], "0"
            ],
            GI: ["350", "00", "(?:[25]\\d|60)\\d{6}", [8],
                [
                    ["(\\d{3})(\\d{5})", "$1 $2", ["2"]]
                ]
            ],
            GL: ["299", "00", "(?:19|[2-689]\\d|70)\\d{4}", [6],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["19|[2-9]"]]
                ]
            ],
            GM: ["220", "00", "[2-9]\\d{6}", [7],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]
                ]
            ],
            GN: ["224", "00", "722\\d{6}|(?:3|6\\d)\\d{7}", [8, 9],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["3"]],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[67]"]]
                ]
            ],
            GP: ["590", "00", "(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}", [9],
                [
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-79]"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]
                ], "0", 0, 0, 0, 0, 0, [
                    ["590(?:0[1-68]|[14][0-24-9]|2[0-68]|3[1-9]|5[3-579]|[68][0-689]|7[08]|9\\d)\\d{4}"],
                    ["(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"],
                    ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"]
                ]
            ],
            GQ: ["240", "00", "222\\d{6}|(?:3\\d|55|[89]0)\\d{7}", [9],
                [
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[235]"]],
                    ["(\\d{3})(\\d{6})", "$1 $2", ["[89]"]]
                ]
            ],
            GR: ["30", "00", "5005000\\d{3}|8\\d{9,11}|(?:[269]\\d|70)\\d{8}", [10, 11, 12],
                [
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["21|7"]],
                    ["(\\d{4})(\\d{6})", "$1 $2", ["2(?:2|3[2-57-9]|4[2-469]|5[2-59]|6[2-9]|7[2-69]|8[2-49])|5"]],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2689]"]],
                    ["(\\d{3})(\\d{3,4})(\\d{5})", "$1 $2 $3", ["8"]]
                ]
            ],
            GT: ["502", "00", "80\\d{6}|(?:1\\d{3}|[2-7])\\d{7}", [8, 11],
                [
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[2-8]"]],
                    ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]]
                ]
            ],
            GU: ["1", "011", "(?:[58]\\d\\d|671|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "671$1", 0, "671"],
            GW: ["245", "00", "[49]\\d{8}|4\\d{6}", [7, 9],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["40"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[49]"]]
                ]
            ],
            GY: ["592", "001", "(?:[2-8]\\d{3}|9008)\\d{3}", [7],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]
                ]
            ],
            HK: ["852", "00(?:30|5[09]|[126-9]?)", "8[0-46-9]\\d{6,7}|9\\d{4,7}|(?:[2-7]|9\\d{3})\\d{7}", [5, 6, 7, 8, 9, 11],
                [
                    ["(\\d{3})(\\d{2,5})", "$1 $2", ["900", "9003"]],
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[2-7]|8[1-4]|9(?:0[1-9]|[1-8])"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]],
                    ["(\\d{3})(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]]
                ], 0, 0, 0, 0, 0, 0, 0, "00"
            ],
            HN: ["504", "00", "8\\d{10}|[237-9]\\d{7}", [8, 11],
                [
                    ["(\\d{4})(\\d{4})", "$1-$2", ["[237-9]"]]
                ]
            ],
            HR: ["385", "00", "[2-69]\\d{8}|80\\d{5,7}|[1-79]\\d{7}|6\\d{6}", [7, 8, 9],
                [
                    ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["6[01]"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["8"], "0$1"],
                    ["(\\d)(\\d{4})(\\d{3})", "$1 $2 $3", ["1"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["6|7[245]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["9"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-57]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"], "0$1"]
                ], "0"
            ],
            HT: ["509", "00", "[2-589]\\d{7}", [8],
                [
                    ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["[2-589]"]]
                ]
            ],
            HU: ["36", "00", "[235-7]\\d{8}|[1-9]\\d{7}", [8, 9],
                [
                    ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "(06 $1)"],
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6|8[2-57-9]|9[2-69]"], "(06 $1)"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-9]"], "06 $1"]
                ], "06"
            ],
            ID: ["62", "00[89]", "00[1-9]\\d{9,14}|(?:[1-36]|8\\d{5})\\d{6}|00\\d{9}|[1-9]\\d{8,10}|[2-9]\\d{7}", [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
                [
                    ["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["15"]],
                    ["(\\d{2})(\\d{5,9})", "$1 $2", ["2[124]|[36]1"], "(0$1)"],
                    ["(\\d{3})(\\d{5,7})", "$1 $2", ["800"], "0$1"],
                    ["(\\d{3})(\\d{5,8})", "$1 $2", ["[2-79]"], "(0$1)"],
                    ["(\\d{3})(\\d{3,4})(\\d{3})", "$1-$2-$3", ["8[1-35-9]"], "0$1"],
                    ["(\\d{3})(\\d{6,8})", "$1 $2", ["1"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["804"], "0$1"],
                    ["(\\d{3})(\\d)(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["80"], "0$1"],
                    ["(\\d{3})(\\d{4})(\\d{4,5})", "$1-$2-$3", ["8"], "0$1"]
                ], "0"
            ],
            IE: ["353", "00", "(?:1\\d|[2569])\\d{6,8}|4\\d{6,9}|7\\d{8}|8\\d{8,9}", [7, 8, 9, 10],
                [
                    ["(\\d{2})(\\d{5})", "$1 $2", ["2[24-9]|47|58|6[237-9]|9[35-9]"], "(0$1)"],
                    ["(\\d{3})(\\d{5})", "$1 $2", ["[45]0"], "(0$1)"],
                    ["(\\d)(\\d{3,4})(\\d{4})", "$1 $2 $3", ["1"], "(0$1)"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2569]|4[1-69]|7[14]"], "(0$1)"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["70"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["81"], "(0$1)"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[78]"], "0$1"],
                    ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]],
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["4"], "(0$1)"],
                    ["(\\d{2})(\\d)(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["8"], "0$1"]
                ], "0"
            ],
            IL: ["972", "0(?:0|1[2-9])", "1\\d{6}(?:\\d{3,5})?|[57]\\d{8}|[1-489]\\d{7}", [7, 8, 9, 10, 11, 12],
                [
                    ["(\\d{4})(\\d{3})", "$1-$2", ["125"]],
                    ["(\\d{4})(\\d{2})(\\d{2})", "$1-$2-$3", ["121"]],
                    ["(\\d)(\\d{3})(\\d{4})", "$1-$2-$3", ["[2-489]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["[57]"], "0$1"],
                    ["(\\d{4})(\\d{3})(\\d{3})", "$1-$2-$3", ["12"]],
                    ["(\\d{4})(\\d{6})", "$1-$2", ["159"]],
                    ["(\\d)(\\d{3})(\\d{3})(\\d{3})", "$1-$2-$3-$4", ["1[7-9]"]],
                    ["(\\d{3})(\\d{1,2})(\\d{3})(\\d{4})", "$1-$2 $3-$4", ["15"]]
                ], "0"
            ],
            IM: ["44", "00", "1624\\d{6}|(?:[3578]\\d|90)\\d{8}", [10], 0, "0", 0, "([25-8]\\d{5})$|0", "1624$1", 0, "74576|(?:16|7[56])24"],
            IN: ["91", "00", "(?:000800|[2-9]\\d\\d)\\d{7}|1\\d{7,12}", [8, 9, 10, 11, 12, 13],
                [
                    ["(\\d{8})", "$1", ["5(?:0|2[23]|3[03]|[67]1|88)", "5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|888)", "5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|8888)"], 0, 1],
                    ["(\\d{4})(\\d{4,5})", "$1 $2", ["180", "1800"], 0, 1],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["140"], 0, 1],
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["11|2[02]|33|4[04]|79[1-7]|80[2-46]", "11|2[02]|33|4[04]|79(?:[1-6]|7[19])|80(?:[2-4]|6[0-589])", "11|2[02]|33|4[04]|79(?:[124-6]|3(?:[02-9]|1[0-24-9])|7(?:1|9[1-6]))|80(?:[2-4]|6[0-589])"], "0$1", 1],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["1(?:2[0-249]|3[0-25]|4[145]|[68]|7[1257])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|5[12]|[78]1)|6(?:12|[2-4]1|5[17]|6[13]|80)|7(?:12|3[134]|4[47]|61|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)|(?:43|59|75)[15]|(?:1[59]|29|67|72)[14]", "1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|674|7(?:(?:2[14]|3[34]|5[15])[2-6]|61[346]|88[0-8])|8(?:70[2-6]|84[235-7]|91[3-7])|(?:1(?:29|60|8[06])|261|552|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))[2-7]", "1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12(?:[2-6]|7[0-8])|74[2-7])|7(?:(?:2[14]|5[15])[2-6]|3171|61[346]|88(?:[2-7]|82))|8(?:70[2-6]|84(?:[2356]|7[19])|91(?:[3-6]|7[19]))|73[134][2-6]|(?:74[47]|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[2-6]|7[19])|(?:1(?:29|60|8[06])|261|552|6(?:[2-4]1|5[17]|6[13]|7(?:1|4[0189])|80)|7(?:12|88[01]))[2-7]"], "0$1", 1],
                    ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2[2457-9]|3[2-5]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1[013-9]|28|3[129]|4[1-35689]|5[29]|6[02-5]|70)|807", "1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1(?:[013-8]|9[6-9])|28[6-8]|3(?:17|2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4|5[0-367])|70[13-7])|807[19]", "1(?:[2-479]|5(?:[0236-9]|5[013-9]))|[2-5]|6(?:2(?:84|95)|355|83)|73179|807(?:1|9[1-3])|(?:1552|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])\\d|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]))[2-7]"], "0$1", 1],
                    ["(\\d{5})(\\d{5})", "$1 $2", ["[6-9]"], "0$1", 1],
                    ["(\\d{4})(\\d{2,4})(\\d{4})", "$1 $2 $3", ["1(?:6|8[06])", "1(?:6|8[06]0)"], 0, 1],
                    ["(\\d{4})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["18"], 0, 1]
                ], "0"
            ],
            IO: ["246", "00", "3\\d{6}", [7],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["3"]]
                ]
            ],
            IQ: ["964", "00", "(?:1|7\\d\\d)\\d{7}|[2-6]\\d{7,8}", [8, 9, 10],
                [
                    ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-6]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"]
                ], "0"
            ],
            IR: ["98", "00", "[1-9]\\d{9}|(?:[1-8]\\d\\d|9)\\d{3,4}", [4, 5, 6, 7, 10],
                [
                    ["(\\d{4,5})", "$1", ["96"], "0$1"],
                    ["(\\d{2})(\\d{4,5})", "$1 $2", ["(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])[12689]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["9"], "0$1"],
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["[1-8]"], "0$1"]
                ], "0"
            ],
            IS: ["354", "00|1(?:0(?:01|[12]0)|100)", "(?:38\\d|[4-9])\\d{6}", [7, 9],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[4-9]"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["3"]]
                ], 0, 0, 0, 0, 0, 0, 0, "00"
            ],
            IT: ["39", "00", "0\\d{5,10}|1\\d{8,10}|3(?:[0-8]\\d{7,10}|9\\d{7,8})|(?:43|55|70)\\d{8}|8\\d{5}(?:\\d{2,4})?", [6, 7, 8, 9, 10, 11, 12],
                [
                    ["(\\d{2})(\\d{4,6})", "$1 $2", ["0[26]"]],
                    ["(\\d{3})(\\d{3,6})", "$1 $2", ["0[13-57-9][0159]|8(?:03|4[17]|9[2-5])", "0[13-57-9][0159]|8(?:03|4[17]|9(?:2|3[04]|[45][0-4]))"]],
                    ["(\\d{4})(\\d{2,6})", "$1 $2", ["0(?:[13-579][2-46-8]|8[236-8])"]],
                    ["(\\d{4})(\\d{4})", "$1 $2", ["894"]],
                    ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["0[26]|5"]],
                    ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["1(?:44|[679])|[378]|43"]],
                    ["(\\d{3})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["0[13-57-9][0159]|14"]],
                    ["(\\d{2})(\\d{4})(\\d{5})", "$1 $2 $3", ["0[26]"]],
                    ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["0"]],
                    ["(\\d{3})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["3"]]
                ], 0, 0, 0, 0, 0, 0, [
                    ["0669[0-79]\\d{1,6}|0(?:1(?:[0159]\\d|[27][1-5]|31|4[1-4]|6[1356]|8[2-57])|2\\d\\d|3(?:[0159]\\d|2[1-4]|3[12]|[48][1-6]|6[2-59]|7[1-7])|4(?:[0159]\\d|[23][1-9]|4[245]|6[1-5]|7[1-4]|81)|5(?:[0159]\\d|2[1-5]|3[2-6]|4[1-79]|6[4-6]|7[1-578]|8[3-8])|6(?:[0-57-9]\\d|6[0-8])|7(?:[0159]\\d|2[12]|3[1-7]|4[2-46]|6[13569]|7[13-6]|8[1-59])|8(?:[0159]\\d|2[3-578]|3[1-356]|[6-8][1-5])|9(?:[0159]\\d|[238][1-5]|4[12]|6[1-8]|7[1-6]))\\d{2,7}", [6, 7, 8, 9, 10, 11]],
                    ["3[2-9]\\d{7,8}|(?:31|43)\\d{8}", [9, 10]],
                    ["80(?:0\\d{3}|3)\\d{3}", [6, 9]],
                    ["(?:0878\\d{3}|89(?:2\\d|3[04]|4(?:[0-4]|[5-9]\\d\\d)|5[0-4]))\\d\\d|(?:1(?:44|6[346])|89(?:38|5[5-9]|9))\\d{6}", [6, 8, 9, 10]],
                    ["1(?:78\\d|99)\\d{6}", [9, 10]],
                    ["3[2-8]\\d{9,10}", [11, 12]], 0, 0, ["55\\d{8}", [10]],
                    ["84(?:[08]\\d{3}|[17])\\d{3}", [6, 9]]
                ]
            ],
            JE: ["44", "00", "1534\\d{6}|(?:[3578]\\d|90)\\d{8}", [10], 0, "0", 0, "([0-24-8]\\d{5})$|0", "1534$1", 0, 0, [
                ["1534[0-24-8]\\d{5}"],
                ["7(?:(?:(?:50|82)9|937)\\d|7(?:00[378]|97\\d))\\d{5}"],
                ["80(?:07(?:35|81)|8901)\\d{4}"],
                ["(?:8(?:4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|90(?:066[59]|1810|71(?:07|55)))\\d{4}"],
                ["701511\\d{4}"], 0, ["(?:3(?:0(?:07(?:35|81)|8901)|3\\d{4}|4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|55\\d{4})\\d{4}"],
                ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}"],
                ["56\\d{8}"]
            ]],
            JM: ["1", "011", "(?:[58]\\d\\d|658|900)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "658|876"],
            JO: ["962", "00", "(?:(?:[2689]|7\\d)\\d|32|53)\\d{6}", [8, 9],
                [
                    ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2356]|87"], "(0$1)"],
                    ["(\\d{3})(\\d{5,6})", "$1 $2", ["[89]"], "0$1"],
                    ["(\\d{2})(\\d{7})", "$1 $2", ["70"], "0$1"],
                    ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["7"], "0$1"]
                ], "0"
            ],
            JP: ["81", "010", "00[1-9]\\d{6,14}|[257-9]\\d{9}|(?:00|[1-9]\\d\\d)\\d{6}", [8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
                [
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1-$2-$3", ["(?:12|57|99)0"], "0$1"],
                    ["(\\d{4})(\\d)(\\d{4})", "$1-$2-$3", ["1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|499|5(?:76|97)|746|8(?:3[89]|47|51)|9(?:80|9[16])", "1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:76|97)9|7468|8(?:3(?:8[7-9]|96)|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]", "1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:769|979[2-69])|7468|8(?:3(?:8[7-9]|96[2457-9])|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["60"], "0$1"],
                    ["(\\d)(\\d{4})(\\d{4})", "$1-$2-$3", ["[36]|4(?:2[09]|7[01])", "[36]|4(?:2(?:0|9[02-69])|7(?:0[019]|1))"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["1(?:1|5[45]|77|88|9[69])|2(?:2[1-37]|3[0-269]|4[59]|5|6[24]|7[1-358]|8[1369]|9[0-38])|4(?:[28][1-9]|3[0-57]|[45]|6[248]|7[2-579]|9[29])|5(?:2|3[0459]|4[0-369]|5[29]|8[02389]|9[0-389])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9[2-6])|8(?:2[124589]|3[26-9]|49|51|6|7[0-468]|8[68]|9[019])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9[1-489])", "1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2(?:[127]|3[014-9])|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9[19])|62|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|8[1-9]|9[29])|5(?:2|3(?:[045]|9[0-8])|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0-2469])|3(?:[29]|60)|49|51|6(?:[0-24]|36|5[0-3589]|7[23]|9[01459])|7[0-468]|8[68])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3[34]|4[0178]))|(?:264|837)[016-9]|2(?:57|93)[015-9]|(?:25[0468]|422|838)[01]|(?:47[59]|59[89]|8(?:6[68]|9))[019]", "1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3(?:[045]|9(?:[0-58]|6[4-9]|7[0-35689]))|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0169])|3(?:[29]|60|7(?:[017-9]|6[6-8]))|49|51|6(?:[0-24]|36[2-57-9]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|7(?:2[2-468]|3[78])|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:8294|96)[1-3]|2(?:57|93)[015-9]|(?:223|8699)[014-9]|(?:25[0468]|422|838)[01]|(?:48|8292|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{4})", "$1-$2-$3", ["[14]|[289][2-9]|5[3-9]|7[2-4679]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["800"], "0$1"],
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2-$3", ["[257-9]"], "0$1"]
                ], "0", 0, "(000[259]\\d{6})$|(?:(?:003768)0?)|0", "$1"
            ],
            KE: ["254", "000", "(?:[17]\\d\\d|900)\\d{6}|(?:2|80)0\\d{6,7}|[4-6]\\d{6,8}", [7, 8, 9, 10],
                [
                    ["(\\d{2})(\\d{5,7})", "$1 $2", ["[24-6]"], "0$1"],
                    ["(\\d{3})(\\d{6})", "$1 $2", ["[17]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[89]"], "0$1"]
                ], "0"
            ],
            KG: ["996", "00", "8\\d{9}|[235-9]\\d{8}", [9, 10],
                [
                    ["(\\d{4})(\\d{5})", "$1 $2", ["3(?:1[346]|[24-79])"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[235-79]|88"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d)(\\d{2,3})", "$1 $2 $3 $4", ["8"], "0$1"]
                ], "0"
            ],
            KH: ["855", "00[14-9]", "1\\d{9}|[1-9]\\d{7,8}", [8, 9, 10],
                [
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-9]"], "0$1"],
                    ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]
                ], "0"
            ],
            KI: ["686", "00", "(?:[37]\\d|6[0-79])\\d{6}|(?:[2-48]\\d|50)\\d{3}", [5, 8], 0, "0"],
            KM: ["269", "00", "[3478]\\d{6}", [7],
                [
                    ["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[3478]"]]
                ]
            ],
            KN: ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "869$1", 0, "869"],
            KP: ["850", "00|99", "85\\d{6}|(?:19\\d|[2-7])\\d{7}", [8, 10],
                [
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"], "0$1"],
                    ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-7]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"]
                ], "0"
            ],
            KR: ["82", "00(?:[125689]|3(?:[46]5|91)|7(?:00|27|3|55|6[126]))", "00[1-9]\\d{8,11}|(?:[12]|5\\d{3})\\d{7}|[13-6]\\d{9}|(?:[1-6]\\d|80)\\d{7}|[3-6]\\d{4,5}|(?:00|7)0\\d{8}", [5, 6, 8, 9, 10, 11, 12, 13, 14],
                [
                    ["(\\d{2})(\\d{3,4})", "$1-$2", ["(?:3[1-3]|[46][1-4]|5[1-5])1"], "0$1"],
                    ["(\\d{4})(\\d{4})", "$1-$2", ["1"]],
                    ["(\\d)(\\d{3,4})(\\d{4})", "$1-$2-$3", ["2"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["[36]0|8"], "0$1"],
                    ["(\\d{2})(\\d{3,4})(\\d{4})", "$1-$2-$3", ["[1346]|5[1-5]"], "0$1"],
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2-$3", ["[57]"], "0$1"],
                    ["(\\d{2})(\\d{5})(\\d{4})", "$1-$2-$3", ["5"], "0$1"]
                ], "0", 0, "0(8(?:[1-46-8]|5\\d\\d))?"
            ],
            KW: ["965", "00", "18\\d{5}|(?:[2569]\\d|41)\\d{6}", [7, 8],
                [
                    ["(\\d{4})(\\d{3,4})", "$1 $2", ["[169]|2(?:[235]|4[1-35-9])|52"]],
                    ["(\\d{3})(\\d{5})", "$1 $2", ["[245]"]]
                ]
            ],
            KY: ["1", "011", "(?:345|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "345$1", 0, "345"],
            KZ: ["7", "810", "(?:33622|8\\d{8})\\d{5}|[78]\\d{9}", [10, 14], 0, "8", 0, 0, 0, 0, "33622|7", 0, "8~10"],
            LA: ["856", "00", "[23]\\d{9}|3\\d{8}|(?:[235-8]\\d|41)\\d{6}", [8, 9, 10],
                [
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["2[13]|3[14]|[4-8]"], "0$1"],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["3"], "0$1"],
                    ["(\\d{2})(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[23]"], "0$1"]
                ], "0"
            ],
            LB: ["961", "00", "[27-9]\\d{7}|[13-9]\\d{6}", [7, 8],
                [
                    ["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[13-69]|7(?:[2-57]|62|8[0-6]|9[04-9])|8[02-9]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[27-9]"]]
                ], "0"
            ],
            LC: ["1", "011", "(?:[58]\\d\\d|758|900)\\d{7}", [10], 0, "1", 0, "([2-8]\\d{6})$|1", "758$1", 0, "758"],
            LI: ["423", "00", "[68]\\d{8}|(?:[2378]\\d|90)\\d{5}", [7, 9],
                [
                    ["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[2379]|8(?:0[09]|7)", "[2379]|8(?:0(?:02|9)|7)"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["69"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]]
                ], "0", 0, "(1001)|0"
            ],
            LK: ["94", "00", "[1-9]\\d{8}", [9],
                [
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[1-689]"], "0$1"]
                ], "0"
            ],
            LR: ["231", "00", "(?:[2457]\\d|33|88)\\d{7}|(?:2\\d|[4-6])\\d{6}", [7, 8, 9],
                [
                    ["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["4[67]|[56]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-578]"], "0$1"]
                ], "0"
            ],
            LS: ["266", "00", "(?:[256]\\d\\d|800)\\d{5}", [8],
                [
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[2568]"]]
                ]
            ],
            LT: ["370", "00", "(?:[3469]\\d|52|[78]0)\\d{6}", [8],
                [
                    ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["52[0-7]"], "(0-$1)", 1],
                    ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[7-9]"], "0 $1", 1],
                    ["(\\d{2})(\\d{6})", "$1 $2", ["37|4(?:[15]|6[1-8])"], "(0-$1)", 1],
                    ["(\\d{3})(\\d{5})", "$1 $2", ["[3-6]"], "(0-$1)", 1]
                ], "0", 0, "[08]"
            ],
            LU: ["352", "00", "35[013-9]\\d{4,8}|6\\d{8}|35\\d{2,4}|(?:[2457-9]\\d|3[0-46-9])\\d{2,9}", [4, 5, 6, 7, 8, 9, 10, 11],
                [
                    ["(\\d{2})(\\d{3})", "$1 $2", ["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]],
                    ["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]],
                    ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["20[2-689]"]],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})", "$1 $2 $3 $4", ["2(?:[0367]|4[3-8])"]],
                    ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["80[01]|90[015]"]],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["20"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})", "$1 $2 $3 $4 $5", ["2(?:[0367]|4[3-8])"]],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{1,5})", "$1 $2 $3 $4", ["[3-57]|8[13-9]|9(?:0[89]|[2-579])|(?:2|80)[2-9]"]]
                ], 0, 0, "(15(?:0[06]|1[12]|[35]5|4[04]|6[26]|77|88|99)\\d)"
            ],
            LV: ["371", "00", "(?:[268]\\d|90)\\d{6}", [8],
                [
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[269]|8[01]"]]
                ]
            ],
            LY: ["218", "00", "[2-9]\\d{8}", [9],
                [
                    ["(\\d{2})(\\d{7})", "$1-$2", ["[2-9]"], "0$1"]
                ], "0"
            ],
            MA: ["212", "00", "[5-8]\\d{8}", [9],
                [
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["5[45]"], "0$1"],
                    ["(\\d{4})(\\d{5})", "$1-$2", ["5(?:2[2-46-9]|3[3-9]|9)|8(?:0[89]|92)"], "0$1"],
                    ["(\\d{2})(\\d{7})", "$1-$2", ["8"], "0$1"],
                    ["(\\d{3})(\\d{6})", "$1-$2", ["[5-7]"], "0$1"]
                ], "0", 0, 0, 0, 0, 0, [
                    ["5(?:2(?:[0-25-79]\\d|3[1-578]|4[02-46-8]|8[0235-7])|3(?:[0-47]\\d|5[02-9]|6[02-8]|8[014-9]|9[3-9])|(?:4[067]|5[03])\\d)\\d{5}"],
                    ["(?:6(?:[0-79]\\d|8[0-247-9])|7(?:[0167]\\d|2[0-8]|5[0-3]|8[0-7]))\\d{6}"],
                    ["80[0-7]\\d{6}"],
                    ["89\\d{7}"], 0, 0, 0, 0, ["(?:592(?:4[0-2]|93)|80[89]\\d\\d)\\d{4}"]
                ]
            ],
            MC: ["377", "00", "(?:[3489]|6\\d)\\d{7}", [8, 9],
                [
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["4"], "0$1"],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[389]"]],
                    ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["6"], "0$1"]
                ], "0"
            ],
            MD: ["373", "00", "(?:[235-7]\\d|[89]0)\\d{6}", [8],
                [
                    ["(\\d{3})(\\d{5})", "$1 $2", ["[89]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["22|3"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[25-7]"], "0$1"]
                ], "0"
            ],
            ME: ["382", "00", "(?:20|[3-79]\\d)\\d{6}|80\\d{6,7}", [8, 9],
                [
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-9]"], "0$1"]
                ], "0"
            ],
            MF: ["590", "00", "(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}", [9], 0, "0", 0, 0, 0, 0, 0, [
                ["590(?:0[079]|[14]3|[27][79]|3[03-7]|5[0-268]|87)\\d{4}"],
                ["(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"],
                ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"]
            ]],
            MG: ["261", "00", "[23]\\d{8}", [9],
                [
                    ["(\\d{2})(\\d{2})(\\d{3})(\\d{2})", "$1 $2 $3 $4", ["[23]"], "0$1"]
                ], "0", 0, "([24-9]\\d{6})$|0", "20$1"
            ],
            MH: ["692", "011", "329\\d{4}|(?:[256]\\d|45)\\d{5}", [7],
                [
                    ["(\\d{3})(\\d{4})", "$1-$2", ["[2-6]"]]
                ], "1"
            ],
            MK: ["389", "00", "[2-578]\\d{7}", [8],
                [
                    ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["2|34[47]|4(?:[37]7|5[47]|64)"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[347]"], "0$1"],
                    ["(\\d{3})(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[58]"], "0$1"]
                ], "0"
            ],
            ML: ["223", "00", "[24-9]\\d{7}", [8],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24-9]"]]
                ]
            ],
            MM: ["95", "00", "1\\d{5,7}|95\\d{6}|(?:[4-7]|9[0-46-9])\\d{6,8}|(?:2|8\\d)\\d{5,8}", [6, 7, 8, 9, 10],
                [
                    ["(\\d)(\\d{2})(\\d{3})", "$1 $2 $3", ["16|2"], "0$1"],
                    ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["4(?:[2-46]|5[3-5])|5|6(?:[1-689]|7[235-7])|7(?:[0-4]|5[2-7])|8[1-5]|(?:60|86)[23]"], "0$1"],
                    ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[12]|452|678|86", "[12]|452|6788|86"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[4-7]|8[1-35]"], "0$1"],
                    ["(\\d)(\\d{3})(\\d{4,6})", "$1 $2 $3", ["9(?:2[0-4]|[35-9]|4[137-9])"], "0$1"],
                    ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"],
                    ["(\\d)(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["92"], "0$1"],
                    ["(\\d)(\\d{5})(\\d{4})", "$1 $2 $3", ["9"], "0$1"]
                ], "0"
            ],
            MN: ["976", "001", "[12]\\d{7,9}|[5-9]\\d{7}", [8, 9, 10],
                [
                    ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["[12]1"], "0$1"],
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[5-9]"]],
                    ["(\\d{3})(\\d{5,6})", "$1 $2", ["[12]2[1-3]"], "0$1"],
                    ["(\\d{4})(\\d{5,6})", "$1 $2", ["[12](?:27|3[2-8]|4[2-68]|5[1-4689])", "[12](?:27|3[2-8]|4[2-68]|5[1-4689])[0-3]"], "0$1"],
                    ["(\\d{5})(\\d{4,5})", "$1 $2", ["[12]"], "0$1"]
                ], "0"
            ],
            MO: ["853", "00", "0800\\d{3}|(?:28|[68]\\d)\\d{6}", [7, 8],
                [
                    ["(\\d{4})(\\d{3})", "$1 $2", ["0"]],
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[268]"]]
                ]
            ],
            MP: ["1", "011", "[58]\\d{9}|(?:67|90)0\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "670$1", 0, "670"],
            MQ: ["596", "00", "(?:596\\d|7091)\\d{5}|(?:69|[89]\\d)\\d{7}", [9],
                [
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-79]|8(?:0[6-9]|[36])"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]
                ], "0"
            ],
            MR: ["222", "00", "(?:[2-4]\\d\\d|800)\\d{5}", [8],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-48]"]]
                ]
            ],
            MS: ["1", "011", "(?:[58]\\d\\d|664|900)\\d{7}", [10], 0, "1", 0, "([34]\\d{6})$|1", "664$1", 0, "664"],
            MT: ["356", "00", "3550\\d{4}|(?:[2579]\\d\\d|800)\\d{5}", [8],
                [
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[2357-9]"]]
                ]
            ],
            MU: ["230", "0(?:0|[24-7]0|3[03])", "(?:[57]|8\\d\\d)\\d{7}|[2-468]\\d{6}", [7, 8, 10],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[2-46]|8[013]"]],
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[57]"]],
                    ["(\\d{5})(\\d{5})", "$1 $2", ["8"]]
                ], 0, 0, 0, 0, 0, 0, 0, "020"
            ],
            MV: ["960", "0(?:0|19)", "(?:800|9[0-57-9]\\d)\\d{7}|[34679]\\d{6}", [7, 10],
                [
                    ["(\\d{3})(\\d{4})", "$1-$2", ["[34679]"]],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"]]
                ], 0, 0, 0, 0, 0, 0, 0, "00"
            ],
            MW: ["265", "00", "(?:[1289]\\d|31|77)\\d{7}|1\\d{6}", [7, 9],
                [
                    ["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["1[2-9]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[137-9]"], "0$1"]
                ], "0"
            ],
            MX: ["52", "0[09]", "[2-9]\\d{9}", [10],
                [
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["33|5[56]|81"]],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-9]"]]
                ], 0, 0, 0, 0, 0, 0, 0, "00"
            ],
            MY: ["60", "00", "1\\d{8,9}|(?:3\\d|[4-9])\\d{7}", [8, 9, 10],
                [
                    ["(\\d)(\\d{3})(\\d{4})", "$1-$2 $3", ["[4-79]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1-$2 $3", ["1(?:[02469]|[378][1-9]|53)|8", "1(?:[02469]|[37][1-9]|53|8(?:[1-46-9]|5[7-9]))|8"], "0$1"],
                    ["(\\d)(\\d{4})(\\d{4})", "$1-$2 $3", ["3"], "0$1"],
                    ["(\\d)(\\d{3})(\\d{2})(\\d{4})", "$1-$2-$3-$4", ["1(?:[367]|80)"]],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2 $3", ["15"], "0$1"],
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2 $3", ["1"], "0$1"]
                ], "0"
            ],
            MZ: ["258", "00", "(?:2|8\\d)\\d{7}", [8, 9],
                [
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2|8[2-79]"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]]
                ]
            ],
            NA: ["264", "00", "[68]\\d{7,8}", [8, 9],
                [
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["88"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["6"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["87"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"]
                ], "0"
            ],
            NC: ["687", "00", "(?:050|[2-57-9]\\d\\d)\\d{3}", [6],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})", "$1.$2.$3", ["[02-57-9]"]]
                ]
            ],
            NE: ["227", "00", "[027-9]\\d{7}", [8],
                [
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["08"]],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[089]|2[013]|7[0467]"]]
                ]
            ],
            NF: ["672", "00", "[13]\\d{5}", [6],
                [
                    ["(\\d{2})(\\d{4})", "$1 $2", ["1[0-3]"]],
                    ["(\\d)(\\d{5})", "$1 $2", ["[13]"]]
                ], 0, 0, "([0-258]\\d{4})$", "3$1"
            ],
            NG: ["234", "009", "(?:20|9\\d)\\d{8}|[78]\\d{9,13}", [10, 11, 12, 13, 14],
                [
                    ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[7-9]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["20[129]"], "0$1"],
                    ["(\\d{4})(\\d{2})(\\d{4})", "$1 $2 $3", ["2"], "0$1"],
                    ["(\\d{3})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["[78]"], "0$1"],
                    ["(\\d{3})(\\d{5})(\\d{5,6})", "$1 $2 $3", ["[78]"], "0$1"]
                ], "0"
            ],
            NI: ["505", "00", "(?:1800|[25-8]\\d{3})\\d{4}", [8],
                [
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[125-8]"]]
                ]
            ],
            NL: ["31", "00", "(?:[124-7]\\d\\d|3(?:[02-9]\\d|1[0-8]))\\d{6}|8\\d{6,9}|9\\d{6,10}|1\\d{4,5}", [5, 6, 7, 8, 9, 10, 11],
                [
                    ["(\\d{3})(\\d{4,7})", "$1 $2", ["[89]0"], "0$1"],
                    ["(\\d{2})(\\d{7})", "$1 $2", ["66"], "0$1"],
                    ["(\\d)(\\d{8})", "$1 $2", ["6"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["1[16-8]|2[259]|3[124]|4[17-9]|5[124679]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-578]|91"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{5})", "$1 $2 $3", ["9"], "0$1"]
                ], "0"
            ],
            NO: ["47", "00", "(?:0|[2-9]\\d{3})\\d{4}", [5, 8],
                [
                    ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["8"]],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-79]"]]
                ], 0, 0, 0, 0, 0, "[02-689]|7[0-8]"
            ],
            NP: ["977", "00", "(?:1\\d|9)\\d{9}|[1-9]\\d{7}", [8, 10, 11],
                [
                    ["(\\d)(\\d{7})", "$1-$2", ["1[2-6]"], "0$1"],
                    ["(\\d{2})(\\d{6})", "$1-$2", ["1[01]|[2-8]|9(?:[1-59]|[67][2-6])"], "0$1"],
                    ["(\\d{3})(\\d{7})", "$1-$2", ["9"]]
                ], "0"
            ],
            NR: ["674", "00", "(?:222|444|(?:55|8\\d)\\d|666|777|999)\\d{4}", [7],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[24-9]"]]
                ]
            ],
            NU: ["683", "00", "(?:[4-7]|888\\d)\\d{3}", [4, 7],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["8"]]
                ]
            ],
            NZ: ["64", "0(?:0|161)", "[1289]\\d{9}|50\\d{5}(?:\\d{2,3})?|[27-9]\\d{7,8}|(?:[34]\\d|6[0-35-9])\\d{6}|8\\d{4,6}", [5, 6, 7, 8, 9, 10],
                [
                    ["(\\d{2})(\\d{3,8})", "$1 $2", ["8[1-79]"], "0$1"],
                    ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["50[036-8]|8|90", "50(?:[0367]|88)|8|90"], "0$1"],
                    ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["24|[346]|7[2-57-9]|9[2-9]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2(?:10|74)|[589]"], "0$1"],
                    ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["1|2[028]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3,5})", "$1 $2 $3", ["2(?:[169]|7[0-35-9])|7"], "0$1"]
                ], "0", 0, 0, 0, 0, 0, 0, "00"
            ],
            OM: ["968", "00", "(?:1505|[279]\\d{3}|500)\\d{4}|800\\d{5,6}", [7, 8, 9],
                [
                    ["(\\d{3})(\\d{4,6})", "$1 $2", ["[58]"]],
                    ["(\\d{2})(\\d{6})", "$1 $2", ["2"]],
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[179]"]]
                ]
            ],
            PA: ["507", "00", "(?:00800|8\\d{3})\\d{6}|[68]\\d{7}|[1-57-9]\\d{6}", [7, 8, 10, 11],
                [
                    ["(\\d{3})(\\d{4})", "$1-$2", ["[1-57-9]"]],
                    ["(\\d{4})(\\d{4})", "$1-$2", ["[68]"]],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]]
                ]
            ],
            PE: ["51", "00|19(?:1[124]|77|90)00", "(?:[14-8]|9\\d)\\d{7}", [8, 9],
                [
                    ["(\\d{3})(\\d{5})", "$1 $2", ["80"], "(0$1)"],
                    ["(\\d)(\\d{7})", "$1 $2", ["1"], "(0$1)"],
                    ["(\\d{2})(\\d{6})", "$1 $2", ["[4-8]"], "(0$1)"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"]]
                ], "0", 0, 0, 0, 0, 0, 0, "00", " Anexo "
            ],
            PF: ["689", "00", "4\\d{5}(?:\\d{2})?|8\\d{7,8}", [6, 8, 9],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["44"]],
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["4|8[7-9]"]],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]]
                ]
            ],
            PG: ["675", "00|140[1-3]", "(?:180|[78]\\d{3})\\d{4}|(?:[2-589]\\d|64)\\d{5}", [7, 8],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["18|[2-69]|85"]],
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[78]"]]
                ], 0, 0, 0, 0, 0, 0, 0, "00"
            ],
            PH: ["63", "00", "(?:[2-7]|9\\d)\\d{8}|2\\d{5}|(?:1800|8)\\d{7,9}", [6, 8, 9, 10, 11, 12, 13],
                [
                    ["(\\d)(\\d{5})", "$1 $2", ["2"], "(0$1)"],
                    ["(\\d{4})(\\d{4,6})", "$1 $2", ["3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|544|88[245]|(?:52|64|86)2", "3(?:230|397|461)|4(?:2(?:35|[46]4|51)|396|4(?:22|63)|59[347]|76[15])|5(?:221|446)|642[23]|8(?:622|8(?:[24]2|5[13]))"], "(0$1)"],
                    ["(\\d{5})(\\d{4})", "$1 $2", ["346|4(?:27|9[35])|883", "3469|4(?:279|9(?:30|56))|8834"], "(0$1)"],
                    ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2"], "(0$1)"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[3-7]|8[2-8]"], "(0$1)"],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"],
                    ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]],
                    ["(\\d{4})(\\d{1,2})(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["1"]]
                ], "0"
            ],
            PK: ["92", "00", "122\\d{6}|[24-8]\\d{10,11}|9(?:[013-9]\\d{8,10}|2(?:[01]\\d\\d|2(?:[06-8]\\d|1[01]))\\d{7})|(?:[2-8]\\d{3}|92(?:[0-7]\\d|8[1-9]))\\d{6}|[24-9]\\d{8}|[89]\\d{7}", [8, 9, 10, 11, 12],
                [
                    ["(\\d{3})(\\d{3})(\\d{2,7})", "$1 $2 $3", ["[89]0"], "0$1"],
                    ["(\\d{4})(\\d{5})", "$1 $2", ["1"]],
                    ["(\\d{3})(\\d{6,7})", "$1 $2", ["2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8])", "9(?:2[3-8]|98)|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:22|3[27-9]|4[2-6]|6[3569]|9[25-7]))[2-9]"], "(0$1)"],
                    ["(\\d{2})(\\d{7,8})", "$1 $2", ["(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]"], "(0$1)"],
                    ["(\\d{5})(\\d{5})", "$1 $2", ["58"], "(0$1)"],
                    ["(\\d{3})(\\d{7})", "$1 $2", ["3"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91"], "(0$1)"],
                    ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[24-9]"], "(0$1)"]
                ], "0"
            ],
            PL: ["48", "00", "(?:6|8\\d\\d)\\d{7}|[1-9]\\d{6}(?:\\d{2})?|[26]\\d{5}", [6, 7, 8, 9, 10],
                [
                    ["(\\d{5})", "$1", ["19"]],
                    ["(\\d{3})(\\d{3})", "$1 $2", ["11|20|64"]],
                    ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])1", "(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])19"]],
                    ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["64"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["21|39|45|5[0137]|6[0469]|7[02389]|8(?:0[14]|8)"]],
                    ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[2-8]|[2-7]|8[1-79]|9[145]"]],
                    ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["8"]]
                ]
            ],
            PM: ["508", "00", "[45]\\d{5}|(?:708|8\\d\\d)\\d{6}", [6, 9],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["[45]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["7"]],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]
                ], "0"
            ],
            PR: ["1", "011", "(?:[589]\\d\\d|787)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "787|939"],
            PS: ["970", "00", "[2489]2\\d{6}|(?:1\\d|5)\\d{8}", [8, 9, 10],
                [
                    ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2489]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["5"], "0$1"],
                    ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]
                ], "0"
            ],
            PT: ["351", "00", "1693\\d{5}|(?:[26-9]\\d|30)\\d{7}", [9],
                [
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["2[12]"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["16|[236-9]"]]
                ]
            ],
            PW: ["680", "01[12]", "(?:[24-8]\\d\\d|345|900)\\d{4}", [7],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]
                ]
            ],
            PY: ["595", "00", "59\\d{4,6}|9\\d{5,10}|(?:[2-46-8]\\d|5[0-8])\\d{4,7}", [6, 7, 8, 9, 10, 11],
                [
                    ["(\\d{3})(\\d{3,6})", "$1 $2", ["[2-9]0"], "0$1"],
                    ["(\\d{2})(\\d{5})", "$1 $2", ["[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]"], "(0$1)"],
                    ["(\\d{3})(\\d{4,5})", "$1 $2", ["2[279]|3[13-5]|4[359]|5|6(?:[34]|7[1-46-8])|7[46-8]|85"], "(0$1)"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2[14-68]|3[26-9]|4[1246-8]|6(?:1|75)|7[1-35]|8[1-36]"], "(0$1)"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["87"]],
                    ["(\\d{3})(\\d{6})", "$1 $2", ["9(?:[5-79]|8[1-7])"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-8]"], "0$1"],
                    ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["9"]]
                ], "0"
            ],
            QA: ["974", "00", "800\\d{4}|(?:2|800)\\d{6}|(?:0080|[3-7])\\d{7}", [7, 8, 9, 11],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["2[136]|8"]],
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[3-7]"]]
                ]
            ],
            RE: ["262", "00", "709\\d{6}|(?:26|[689]\\d)\\d{7}", [9],
                [
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[26-9]"], "0$1"]
                ], "0", 0, 0, 0, 0, 0, [
                    ["26(?:2\\d\\d|3(?:0\\d|1[0-6]))\\d{4}"],
                    ["(?:69(?:2\\d\\d|3(?:[06][0-6]|1[0-3]|2[0-2]|3[0-39]|4\\d|5[0-5]|7[0-37]|8[0-8]|9[0-479]))|7092[0-3])\\d{4}"],
                    ["80\\d{7}"],
                    ["89[1-37-9]\\d{6}"], 0, 0, 0, 0, ["9(?:399[0-3]|479[0-6]|76(?:2[278]|3[0-37]))\\d{4}"],
                    ["8(?:1[019]|2[0156]|84|90)\\d{6}"]
                ]
            ],
            RO: ["40", "00", "(?:[236-8]\\d|90)\\d{7}|[23]\\d{5}", [6, 9],
                [
                    ["(\\d{3})(\\d{3})", "$1 $2", ["2[3-6]", "2[3-6]\\d9"], "0$1"],
                    ["(\\d{2})(\\d{4})", "$1 $2", ["219|31"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[23]1"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[236-9]"], "0$1"]
                ], "0", 0, 0, 0, 0, 0, 0, 0, " int "
            ],
            RS: ["381", "00", "38[02-9]\\d{6,9}|6\\d{7,9}|90\\d{4,8}|38\\d{5,6}|(?:7\\d\\d|800)\\d{3,9}|(?:[12]\\d|3[0-79])\\d{5,10}", [6, 7, 8, 9, 10, 11, 12],
                [
                    ["(\\d{3})(\\d{3,9})", "$1 $2", ["(?:2[389]|39)0|[7-9]"], "0$1"],
                    ["(\\d{2})(\\d{5,10})", "$1 $2", ["[1-36]"], "0$1"]
                ], "0"
            ],
            RU: ["7", "810", "8\\d{13}|[347-9]\\d{9}", [10, 14],
                [
                    ["(\\d{4})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["7(?:1[0-8]|2[1-9])", "7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:1[23]|[2-9]2))", "7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:13[03-69]|62[013-9]))|72[1-57-9]2"], "8 ($1)", 1],
                    ["(\\d{5})(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["7(?:1[0-68]|2[1-9])", "7(?:1(?:[06][3-6]|[18]|2[35]|[3-5][3-5])|2(?:[13][3-5]|[24-689]|7[457]))", "7(?:1(?:0(?:[356]|4[023])|[18]|2(?:3[013-9]|5)|3[45]|43[013-79]|5(?:3[1-8]|4[1-7]|5)|6(?:3[0-35-9]|[4-6]))|2(?:1(?:3[178]|[45])|[24-689]|3[35]|7[457]))|7(?:14|23)4[0-8]|71(?:33|45)[1-79]"], "8 ($1)", 1],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "8 ($1)", 1],
                    ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[349]|8(?:[02-7]|1[1-8])"], "8 ($1)", 1],
                    ["(\\d{4})(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["8"], "8 ($1)"]
                ], "8", 0, 0, 0, 0, 0, [
                    ["336(?:[013-9]\\d|2[013-9])\\d{5}|(?:3(?:0[12]|4[1-35-79]|5[1-3]|65|8[1-58]|9[0145])|4(?:01|1[1356]|2[13467]|7[1-5]|8[1-7]|9[1-689])|8(?:1[1-8]|2[01]|3[13-6]|4[0-8]|5[15-7]|6[0-35-79]|7[1-37-9]))\\d{7}", [10]],
                    ["9\\d{9}", [10]],
                    ["8(?:0[04]|108\\d{3})\\d{7}"],
                    ["80[39]\\d{7}", [10]],
                    ["808\\d{7}", [10]]
                ], "8~10"
            ],
            RW: ["250", "00", "(?:06|[27]\\d\\d|[89]00)\\d{6}", [8, 9],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["0"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[7-9]"], "0$1"]
                ], "0"
            ],
            SA: ["966", "00", "(?:[15]\\d|800|92)\\d{7}", [9, 10],
                [
                    ["(\\d{4})(\\d{5})", "$1 $2", ["9"]],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["5"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]]
                ], "0"
            ],
            SB: ["677", "0[01]", "[6-9]\\d{6}|[1-6]\\d{4}", [5, 7],
                [
                    ["(\\d{2})(\\d{5})", "$1 $2", ["6[89]|7|8[4-9]|9(?:[1-8]|9[0-8])"]]
                ]
            ],
            SC: ["248", "010|0[0-2]", "(?:[2489]\\d|64)\\d{5}", [7],
                [
                    ["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[246]|9[57]"]]
                ], 0, 0, 0, 0, 0, 0, 0, "00"
            ],
            SD: ["249", "00", "[19]\\d{8}", [9],
                [
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[19]"], "0$1"]
                ], "0"
            ],
            SE: ["46", "00", "(?:[26]\\d\\d|9)\\d{9}|[1-9]\\d{8}|[1-689]\\d{7}|[1-4689]\\d{6}|2\\d{5}", [6, 7, 8, 9, 10, 12],
                [
                    ["(\\d{2})(\\d{2,3})(\\d{2})", "$1-$2 $3", ["20"], "0$1", 0, "$1 $2 $3"],
                    ["(\\d{3})(\\d{4})", "$1-$2", ["9(?:00|39|44|9)"], "0$1", 0, "$1 $2"],
                    ["(\\d{2})(\\d{3})(\\d{2})", "$1-$2 $3", ["[12][136]|3[356]|4[0246]|6[03]|90[1-9]"], "0$1", 0, "$1 $2 $3"],
                    ["(\\d)(\\d{2,3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["8"], "0$1", 0, "$1 $2 $3 $4"],
                    ["(\\d{3})(\\d{2,3})(\\d{2})", "$1-$2 $3", ["1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[125689]|4[02-57]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"], "0$1", 0, "$1 $2 $3"],
                    ["(\\d{3})(\\d{2,3})(\\d{3})", "$1-$2 $3", ["9(?:00|39|44)"], "0$1", 0, "$1 $2 $3"],
                    ["(\\d{2})(\\d{2,3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["1[13689]|2[0136]|3[1356]|4[0246]|54|6[03]|90[1-9]"], "0$1", 0, "$1 $2 $3 $4"],
                    ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["10|7"], "0$1", 0, "$1 $2 $3 $4"],
                    ["(\\d)(\\d{3})(\\d{3})(\\d{2})", "$1-$2 $3 $4", ["8"], "0$1", 0, "$1 $2 $3 $4"],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["[13-5]|2(?:[247-9]|5[0138])|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"], "0$1", 0, "$1 $2 $3 $4"],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{3})", "$1-$2 $3 $4", ["9"], "0$1", 0, "$1 $2 $3 $4"],
                    ["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1-$2 $3 $4 $5", ["[26]"], "0$1", 0, "$1 $2 $3 $4 $5"]
                ], "0"
            ],
            SG: ["65", "0[0-3]\\d", "(?:(?:1\\d|8)\\d\\d|7000)\\d{7}|[3689]\\d{7}", [8, 10, 11],
                [
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[369]|8(?:0[1-9]|[1-9])"]],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]],
                    ["(\\d{4})(\\d{4})(\\d{3})", "$1 $2 $3", ["7"]],
                    ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]]
                ]
            ],
            SH: ["290", "00", "(?:[256]\\d|8)\\d{3}", [4, 5], 0, 0, 0, 0, 0, 0, "[256]"],
            SI: ["386", "00|10(?:22|66|88|99)", "[1-7]\\d{7}|8\\d{4,7}|90\\d{4,6}", [5, 6, 7, 8],
                [
                    ["(\\d{2})(\\d{3,6})", "$1 $2", ["8[09]|9"], "0$1"],
                    ["(\\d{3})(\\d{5})", "$1 $2", ["59|8"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[37][01]|4[0139]|51|6"], "0$1"],
                    ["(\\d)(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[1-57]"], "(0$1)"]
                ], "0", 0, 0, 0, 0, 0, 0, "00"
            ],
            SJ: ["47", "00", "0\\d{4}|(?:[489]\\d|79)\\d{6}", [5, 8], 0, 0, 0, 0, 0, 0, "79"],
            SK: ["421", "00", "[2-689]\\d{8}|[2-59]\\d{6}|[2-5]\\d{5}", [6, 7, 9],
                [
                    ["(\\d)(\\d{2})(\\d{3,4})", "$1 $2 $3", ["21"], "0$1"],
                    ["(\\d{2})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["[3-5][1-8]1", "[3-5][1-8]1[67]"], "0$1"],
                    ["(\\d)(\\d{3})(\\d{3})(\\d{2})", "$1/$2 $3 $4", ["2"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[689]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1/$2 $3 $4", ["[3-5]"], "0$1"]
                ], "0"
            ],
            SL: ["232", "00", "(?:[237-9]\\d|66)\\d{6}", [8],
                [
                    ["(\\d{2})(\\d{6})", "$1 $2", ["[236-9]"], "(0$1)"]
                ], "0"
            ],
            SM: ["378", "00", "(?:0549|[5-7]\\d)\\d{6}", [8, 10],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-7]"]],
                    ["(\\d{4})(\\d{6})", "$1 $2", ["0"]]
                ], 0, 0, "([89]\\d{5})$", "0549$1"
            ],
            SN: ["221", "00", "(?:[378]\\d|93)\\d{7}", [9],
                [
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]],
                    ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[379]"]]
                ]
            ],
            SO: ["252", "00", "[346-9]\\d{8}|[12679]\\d{7}|[1-5]\\d{6}|[1348]\\d{5}", [6, 7, 8, 9],
                [
                    ["(\\d{2})(\\d{4})", "$1 $2", ["8[125]"]],
                    ["(\\d{6})", "$1", ["[134]"]],
                    ["(\\d)(\\d{6})", "$1 $2", ["[15]|2[0-79]|3[0-46-8]|4[0-7]"]],
                    ["(\\d)(\\d{7})", "$1 $2", ["(?:2|90)4|[67]"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[348]|64|79|90"]],
                    ["(\\d{2})(\\d{5,7})", "$1 $2", ["1|28|6[0-35-9]|7[67]|9[2-9]"]]
                ], "0"
            ],
            SR: ["597", "00", "(?:[2-5]|68|[78]\\d|90)\\d{5}", [6, 7],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})", "$1-$2-$3", ["56"]],
                    ["(\\d{3})(\\d{3})", "$1-$2", ["[2-5]"]],
                    ["(\\d{3})(\\d{4})", "$1-$2", ["[6-9]"]]
                ]
            ],
            SS: ["211", "00", "[19]\\d{8}", [9],
                [
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[19]"], "0$1"]
                ], "0"
            ],
            ST: ["239", "00", "(?:22|9\\d)\\d{5}", [7],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[29]"]]
                ]
            ],
            SV: ["503", "00", "[267]\\d{7}|(?:80\\d|900)\\d{4}(?:\\d{4})?", [7, 8, 11],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[89]"]],
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[267]"]],
                    ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["[89]"]]
                ]
            ],
            SX: ["1", "011", "7215\\d{6}|(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "(5\\d{6})$|1", "721$1", 0, "721"],
            SY: ["963", "00", "[1-39]\\d{8}|[1-5]\\d{7}", [8, 9],
                [
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-5]"], "0$1", 1],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1", 1]
                ], "0"
            ],
            SZ: ["268", "00", "0800\\d{4}|(?:[237]\\d|900)\\d{6}", [8, 9],
                [
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[0237]"]],
                    ["(\\d{5})(\\d{4})", "$1 $2", ["9"]]
                ]
            ],
            TA: ["290", "00", "8\\d{3}", [4], 0, 0, 0, 0, 0, 0, "8"],
            TC: ["1", "011", "(?:[58]\\d\\d|649|900)\\d{7}", [10], 0, "1", 0, "([2-479]\\d{6})$|1", "649$1", 0, "649"],
            TD: ["235", "00|16", "(?:22|30|[689]\\d|77)\\d{6}", [8],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[236-9]"]]
                ], 0, 0, 0, 0, 0, 0, 0, "00"
            ],
            TG: ["228", "00", "[279]\\d{7}", [8],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[279]"]]
                ]
            ],
            TH: ["66", "00[1-9]", "(?:001800|[2-57]|[689]\\d)\\d{7}|1\\d{7,9}", [8, 9, 10, 13],
                [
                    ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["2"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[13-9]"], "0$1"],
                    ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]
                ], "0"
            ],
            TJ: ["992", "810", "[0-57-9]\\d{8}", [9],
                [
                    ["(\\d{6})(\\d)(\\d{2})", "$1 $2 $3", ["331", "3317"]],
                    ["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["44[02-479]|[34]7"]],
                    ["(\\d{4})(\\d)(\\d{4})", "$1 $2 $3", ["3(?:[1245]|3[12])"]],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[0-57-9]"]]
                ], 0, 0, 0, 0, 0, 0, 0, "8~10"
            ],
            TK: ["690", "00", "[2-47]\\d{3,6}", [4, 5, 6, 7]],
            TL: ["670", "00", "7\\d{7}|(?:[2-47]\\d|[89]0)\\d{5}", [7, 8],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[2-489]|70"]],
                    ["(\\d{4})(\\d{4})", "$1 $2", ["7"]]
                ]
            ],
            TM: ["993", "810", "(?:[1-6]\\d|71)\\d{6}", [8],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["12"], "(8 $1)"],
                    ["(\\d{3})(\\d)(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[1-5]"], "(8 $1)"],
                    ["(\\d{2})(\\d{6})", "$1 $2", ["[67]"], "8 $1"]
                ], "8", 0, 0, 0, 0, 0, 0, "8~10"
            ],
            TN: ["216", "00", "[2-57-9]\\d{7}", [8],
                [
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-57-9]"]]
                ]
            ],
            TO: ["676", "00", "(?:0800|(?:[5-8]\\d\\d|999)\\d)\\d{3}|[2-8]\\d{4}", [5, 7],
                [
                    ["(\\d{2})(\\d{3})", "$1-$2", ["[2-4]|50|6[09]|7[0-24-69]|8[05]"]],
                    ["(\\d{4})(\\d{3})", "$1 $2", ["0"]],
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[5-9]"]]
                ]
            ],
            TR: ["90", "00", "4\\d{6}|8\\d{11,12}|(?:[2-58]\\d\\d|900)\\d{7}", [7, 10, 12, 13],
                [
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["512|8[01589]|90"], "0$1", 1],
                    ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["5(?:[0-59]|61)", "5(?:[0-59]|61[06])", "5(?:[0-59]|61[06]1)"], "0$1", 1],
                    ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24][1-8]|3[1-9]"], "(0$1)", 1],
                    ["(\\d{3})(\\d{3})(\\d{6,7})", "$1 $2 $3", ["80"], "0$1", 1]
                ], "0"
            ],
            TT: ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-46-8]\\d{6})$|1", "868$1", 0, "868"],
            TV: ["688", "00", "(?:2|7\\d\\d|90)\\d{4}", [5, 6, 7],
                [
                    ["(\\d{2})(\\d{3})", "$1 $2", ["2"]],
                    ["(\\d{2})(\\d{4})", "$1 $2", ["90"]],
                    ["(\\d{2})(\\d{5})", "$1 $2", ["7"]]
                ]
            ],
            TW: ["886", "0(?:0[25-79]|19)", "[2-689]\\d{8}|7\\d{9,10}|[2-8]\\d{7}|2\\d{6}", [7, 8, 9, 10, 11],
                [
                    ["(\\d{2})(\\d)(\\d{4})", "$1 $2 $3", ["202"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[258]0"], "0$1"],
                    ["(\\d)(\\d{3,4})(\\d{4})", "$1 $2 $3", ["[23568]|4(?:0[02-48]|[1-47-9])|7[1-9]", "[23568]|4(?:0[2-48]|[1-47-9])|(?:400|7)[1-9]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[49]"], "0$1"],
                    ["(\\d{2})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["7"], "0$1"]
                ], "0", 0, 0, 0, 0, 0, 0, 0, "#"
            ],
            TZ: ["255", "00[056]", "(?:[25-8]\\d|41|90)\\d{7}", [9],
                [
                    ["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[24]"], "0$1"],
                    ["(\\d{2})(\\d{7})", "$1 $2", ["5"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[67]"], "0$1"]
                ], "0"
            ],
            UA: ["380", "00", "[89]\\d{9}|[3-9]\\d{8}", [9, 10],
                [
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6[12][29]|(?:3[1-8]|4[136-8]|5[12457]|6[49])2|(?:56|65)[24]", "6[12][29]|(?:35|4[1378]|5[12457]|6[49])2|(?:56|65)[24]|(?:3[1-46-8]|46)2[013-9]"], "0$1"],
                    ["(\\d{4})(\\d{5})", "$1 $2", ["3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6[0135689]|7[4-6])|6(?:[12][3-7]|[459])", "3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6(?:[015689]|3[02389])|7[4-6])|6(?:[12][3-7]|[459])"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[3-7]|89|9[1-9]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[89]"], "0$1"]
                ], "0", 0, 0, 0, 0, 0, 0, "0~0"
            ],
            UG: ["256", "00[057]", "800\\d{6}|(?:[29]0|[347]\\d)\\d{7}", [9],
                [
                    ["(\\d{4})(\\d{5})", "$1 $2", ["202", "2024"], "0$1"],
                    ["(\\d{3})(\\d{6})", "$1 $2", ["[27-9]|4(?:6[45]|[7-9])"], "0$1"],
                    ["(\\d{2})(\\d{7})", "$1 $2", ["[34]"], "0$1"]
                ], "0"
            ],
            US: ["1", "011", "[2-9]\\d{9}|3\\d{6}", [10],
                [
                    ["(\\d{3})(\\d{4})", "$1-$2", ["310"], 0, 1],
                    ["(\\d{3})(\\d{3})(\\d{4})", "($1) $2-$3", ["[2-9]"], 0, 1, "$1-$2-$3"]
                ], "1", 0, 0, 0, 0, 0, [
                    ["(?:3052(?:0[0-8]|[1-9]\\d)|5056(?:[0-35-9]\\d|4[0-68]))\\d{4}|(?:2742|305[3-9]|472[247-9]|505[2-57-9]|983[2-47-9])\\d{6}|(?:2(?:0[1-35-9]|1[02-9]|2[03-57-9]|3[1459]|4[08]|5[1-46]|6[0279]|7[0269]|8[13])|3(?:0[1-47-9]|1[02-9]|2[0135-79]|3[0-24679]|4[167]|5[0-2]|6[01349]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[023578]|58|6[349]|7[0589]|8[04])|5(?:0[1-47-9]|1[0235-8]|20|3[0149]|4[01]|5[179]|6[1-47]|7[0-5]|8[0256])|6(?:0[1-35-9]|1[024-9]|2[03689]|3[016]|4[0156]|5[01679]|6[0-279]|78|8[0-29])|7(?:0[1-46-8]|1[2-9]|2[04-8]|3[0-247]|4[0378]|5[47]|6[02359]|7[0-59]|8[156])|8(?:0[1-68]|1[02-8]|2[0168]|3[0-2589]|4[03578]|5[046-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[0146-8]|4[01357-9]|5[12469]|7[0-3589]|8[04-69]))[2-9]\\d{6}"],
                    [""],
                    ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"],
                    ["900[2-9]\\d{6}"],
                    ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"], 0, 0, 0, ["305209\\d{4}"]
                ]
            ],
            UY: ["598", "0(?:0|1[3-9]\\d)", "0004\\d{2,9}|[1249]\\d{7}|(?:[49]\\d|80)\\d{5}", [6, 7, 8, 9, 10, 11, 12, 13],
                [
                    ["(\\d{3})(\\d{3,4})", "$1 $2", ["0"]],
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[49]0|8"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1"],
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[124]"]],
                    ["(\\d{3})(\\d{3})(\\d{2,4})", "$1 $2 $3", ["0"]],
                    ["(\\d{3})(\\d{3})(\\d{3})(\\d{2,4})", "$1 $2 $3 $4", ["0"]]
                ], "0", 0, 0, 0, 0, 0, 0, "00", " int. "
            ],
            UZ: ["998", "00", "(?:20|33|[5-9]\\d)\\d{7}", [9],
                [
                    ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[235-9]"]]
                ]
            ],
            VA: ["39", "00", "0\\d{5,10}|3[0-8]\\d{7,10}|55\\d{8}|8\\d{5}(?:\\d{2,4})?|(?:1\\d|39)\\d{7,8}", [6, 7, 8, 9, 10, 11, 12], 0, 0, 0, 0, 0, 0, "06698"],
            VC: ["1", "011", "(?:[58]\\d\\d|784|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "784$1", 0, "784"],
            VE: ["58", "00", "[68]00\\d{7}|(?:[24]\\d|[59]0)\\d{8}", [10],
                [
                    ["(\\d{3})(\\d{7})", "$1-$2", ["[24-689]"], "0$1"]
                ], "0"
            ],
            VG: ["1", "011", "(?:284|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-578]\\d{6})$|1", "284$1", 0, "284"],
            VI: ["1", "011", "[58]\\d{9}|(?:34|90)0\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "340$1", 0, "340"],
            VN: ["84", "00", "[12]\\d{9}|[135-9]\\d{8}|[16]\\d{7}|[16-8]\\d{6}", [7, 8, 9, 10],
                [
                    ["(\\d{2})(\\d{5})", "$1 $2", ["80"], "0$1", 1],
                    ["(\\d{4})(\\d{4,6})", "$1 $2", ["1"], 0, 1],
                    ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["6"], "0$1", 1],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[357-9]"], "0$1", 1],
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["2[48]"], "0$1", 1],
                    ["(\\d{3})(\\d{4})(\\d{3})", "$1 $2 $3", ["2"], "0$1", 1]
                ], "0"
            ],
            VU: ["678", "00", "[57-9]\\d{6}|(?:[238]\\d|48)\\d{3}", [5, 7],
                [
                    ["(\\d{3})(\\d{4})", "$1 $2", ["[57-9]"]]
                ]
            ],
            WF: ["681", "00", "(?:40|72|8\\d{4})\\d{4}|[89]\\d{5}", [6, 9],
                [
                    ["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["[47-9]"]],
                    ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]]
                ]
            ],
            WS: ["685", "0", "(?:[2-6]|8\\d{5})\\d{4}|[78]\\d{6}|[68]\\d{5}", [5, 6, 7, 10],
                [
                    ["(\\d{5})", "$1", ["[2-5]|6[1-9]"]],
                    ["(\\d{3})(\\d{3,7})", "$1 $2", ["[68]"]],
                    ["(\\d{2})(\\d{5})", "$1 $2", ["7"]]
                ]
            ],
            XK: ["383", "00", "2\\d{7,8}|3\\d{7,11}|(?:4\\d\\d|[89]00)\\d{5}", [8, 9, 10, 11, 12],
                [
                    ["(\\d{3})(\\d{5})", "$1 $2", ["[89]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-4]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2|39"], "0$1"],
                    ["(\\d{2})(\\d{7,10})", "$1 $2", ["3"], "0$1"]
                ], "0"
            ],
            YE: ["967", "00", "(?:1|7\\d)\\d{7}|[1-7]\\d{6}", [7, 8, 9],
                [
                    ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-6]|7(?:[24-6]|8[0-7])"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["7"], "0$1"]
                ], "0"
            ],
            YT: ["262", "00", "7093\\d{5}|(?:80|9\\d)\\d{7}|(?:26|63)9\\d{6}", [9], 0, "0", 0, 0, 0, 0, 0, [
                ["269(?:0[0-467]|15|5[0-4]|6\\d|[78]0)\\d{4}"],
                ["(?:639(?:0[0-79]|1[019]|[267]\\d|3[09]|40|5[05-9]|9[04-79])|7093[5-7])\\d{4}"],
                ["80\\d{7}"], 0, 0, 0, 0, 0, ["9(?:(?:39|47)8[01]|769\\d)\\d{4}"]
            ]],
            ZA: ["27", "00", "[1-79]\\d{8}|8\\d{4,9}", [5, 6, 7, 8, 9, 10],
                [
                    ["(\\d{2})(\\d{3,4})", "$1 $2", ["8[1-4]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{2,3})", "$1 $2 $3", ["8[1-4]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["860"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-9]"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"]
                ], "0"
            ],
            ZM: ["260", "00", "800\\d{6}|(?:21|[579]\\d|63)\\d{7}", [9],
                [
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[28]"], "0$1"],
                    ["(\\d{2})(\\d{7})", "$1 $2", ["[579]"], "0$1"]
                ], "0"
            ],
            ZW: ["263", "00", "2(?:[0-57-9]\\d{6,8}|6[0-24-9]\\d{6,7})|[38]\\d{9}|[35-8]\\d{8}|[3-6]\\d{7}|[1-689]\\d{6}|[1-3569]\\d{5}|[1356]\\d{4}", [5, 6, 7, 8, 9, 10],
                [
                    ["(\\d{3})(\\d{3,5})", "$1 $2", ["2(?:0[45]|2[278]|[49]8)|3(?:[09]8|17)|6(?:[29]8|37|75)|[23][78]|(?:33|5[15]|6[68])[78]"], "0$1"],
                    ["(\\d)(\\d{3})(\\d{2,4})", "$1 $2 $3", ["[49]"], "0$1"],
                    ["(\\d{3})(\\d{4})", "$1 $2", ["80"], "0$1"],
                    ["(\\d{2})(\\d{7})", "$1 $2", ["24|8[13-59]|(?:2[05-79]|39|5[45]|6[15-8])2", "2(?:02[014]|4|[56]20|[79]2)|392|5(?:42|525)|6(?:[16-8]21|52[013])|8[13-59]"], "(0$1)"],
                    ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"],
                    ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2(?:1[39]|2[0157]|[378]|[56][14])|3(?:12|29)", "2(?:1[39]|2[0157]|[378]|[56][14])|3(?:123|29)"], "0$1"],
                    ["(\\d{4})(\\d{6})", "$1 $2", ["8"], "0$1"],
                    ["(\\d{2})(\\d{3,5})", "$1 $2", ["1|2(?:0[0-36-9]|12|29|[56])|3(?:1[0-689]|[24-6])|5(?:[0236-9]|1[2-4])|6(?:[013-59]|7[0-46-9])|(?:33|55|6[68])[0-69]|(?:29|3[09]|62)[0-79]"], "0$1"],
                    ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["29[013-9]|39|54"], "0$1"],
                    ["(\\d{4})(\\d{3,5})", "$1 $2", ["(?:25|54)8", "258|5483"], "0$1"]
                ], "0"
            ]
        },
        nonGeographic: {
            800: ["800", 0, "(?:00|[1-9]\\d)\\d{6}", [8],
                [
                    ["(\\d{4})(\\d{4})", "$1 $2", ["\\d"]]
                ], 0, 0, 0, 0, 0, 0, [0, 0, ["(?:00|[1-9]\\d)\\d{6}"]]
            ],
            808: ["808", 0, "[1-9]\\d{7}", [8],
                [
                    ["(\\d{4})(\\d{4})", "$1 $2", ["[1-9]"]]
                ], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, 0, ["[1-9]\\d{7}"]]
            ],
            870: ["870", 0, "7\\d{11}|[235-7]\\d{8}", [9, 12],
                [
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[235-7]"]]
                ], 0, 0, 0, 0, 0, 0, [0, ["(?:[356]|774[45])\\d{8}|7[6-8]\\d{7}"], 0, 0, 0, 0, 0, 0, ["2\\d{8}", [9]]]
            ],
            878: ["878", 0, "10\\d{10}", [12],
                [
                    ["(\\d{2})(\\d{5})(\\d{5})", "$1 $2 $3", ["1"]]
                ], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, ["10\\d{10}"]]
            ],
            881: ["881", 0, "6\\d{9}|[0-36-9]\\d{8}", [9, 10],
                [
                    ["(\\d)(\\d{3})(\\d{5})", "$1 $2 $3", ["[0-37-9]"]],
                    ["(\\d)(\\d{3})(\\d{5,6})", "$1 $2 $3", ["6"]]
                ], 0, 0, 0, 0, 0, 0, [0, ["6\\d{9}|[0-36-9]\\d{8}"]]
            ],
            882: ["882", 0, "[13]\\d{6}(?:\\d{2,5})?|[19]\\d{7}|(?:[25]\\d\\d|4)\\d{7}(?:\\d{2})?", [7, 8, 9, 10, 11, 12],
                [
                    ["(\\d{2})(\\d{5})", "$1 $2", ["16|342"]],
                    ["(\\d{2})(\\d{6})", "$1 $2", ["49"]],
                    ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["1[36]|9"]],
                    ["(\\d{2})(\\d{4})(\\d{3})", "$1 $2 $3", ["3[23]"]],
                    ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["16"]],
                    ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["10|23|3(?:[15]|4[57])|4|51"]],
                    ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["34"]],
                    ["(\\d{2})(\\d{4,5})(\\d{5})", "$1 $2 $3", ["[1-35]"]]
                ], 0, 0, 0, 0, 0, 0, [0, ["342\\d{4}|(?:337|49)\\d{6}|(?:3(?:2|47|7\\d{3})|50\\d{3})\\d{7}", [7, 8, 9, 10, 12]], 0, 0, 0, ["348[57]\\d{7}", [11]], 0, 0, ["1(?:3(?:0[0347]|[13][0139]|2[035]|4[013568]|6[0459]|7[06]|8[15-8]|9[0689])\\d{4}|6\\d{5,10})|(?:345\\d|9[89])\\d{6}|(?:10|2(?:3|85\\d)|3(?:[15]|[69]\\d\\d)|4[15-8]|51)\\d{8}"]]
            ],
            883: ["883", 0, "(?:[1-4]\\d|51)\\d{6,10}", [8, 9, 10, 11, 12],
                [
                    ["(\\d{3})(\\d{3})(\\d{2,8})", "$1 $2 $3", ["[14]|2[24-689]|3[02-689]|51[24-9]"]],
                    ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["510"]],
                    ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["21"]],
                    ["(\\d{4})(\\d{4})(\\d{4})", "$1 $2 $3", ["51[13]"]],
                    ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[235]"]]
                ], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, ["(?:2(?:00\\d\\d|10)|(?:370[1-9]|51\\d0)\\d)\\d{7}|51(?:00\\d{5}|[24-9]0\\d{4,7})|(?:1[0-79]|2[24-689]|3[02-689]|4[0-4])0\\d{5,9}"]]
            ],
            888: ["888", 0, "\\d{11}", [11],
                [
                    ["(\\d{3})(\\d{3})(\\d{5})", "$1 $2 $3"]
                ], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, ["\\d{11}"]]
            ],
            979: ["979", 0, "[1359]\\d{8}", [9],
                [
                    ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["[1359]"]]
                ], 0, 0, 0, 0, 0, 0, [0, 0, 0, ["[1359]\\d{8}"]]
            ]
        }
    };

function ty(t, e) {
    var r = Array.prototype.slice.call(e);
    return r.push(JN), t.apply(this, r)
}

function Vre() {
    return ty(EY, arguments)
}

function kp(t) {
    return fP.call(this, t, JN)
}
kp.prototype = Object.create(fP.prototype, {});
kp.prototype.constructor = kp;

function Gre() {
    return ty($Z, arguments)
}

function H6() {
    return ty(O1, arguments)
}

function Kre() {
    return ty(SZ, arguments)
}
const tg = (t, e) => Vre(String(t), e),
    m2 = (t, e) => `+${H6(e)} ${t}`,
    Yre = t => `*${t.replaceAll("-","").slice(-4)}`,
    Zre = t => new kp(t),
    Jre = Gre().map(t => ({
        code: t,
        callCode: H6(t)
    })),
    Qre = t => {
        var r;
        let e = (r = Kre(t, Hre)) == null ? void 0 : r.formatInternational();
        return e == null ? void 0 : e.substring(e.indexOf(" ") + 1)
    },
    Xre = t => {
        let e = new kp;
        e.input(t);
        let r = e.getCountry() || "US",
            n = e.getCallingCode() || "1";
        return {
            countryCode: r,
            phone: t.replace("+" + n, "")
        }
    },
    ene = (t, e = !0) => t.reduce((r, n) => ({ ...r,
        [n]: e
    }), {}),
    tne = {
        [Bs.id]: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        [I6.id]: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
        [go.id]: "0x0b2c639c533813f4aa9d7837caf62653d097ff85",
        [V1.id]: "0x5fd84259d66Cd46123540766Be93DFE6D43130D7",
        [fs.id]: "0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",
        [i0.id]: "0x41e94eb019c0762f9bfcf9fb1e58725bfb0e7582",
        [Fs.id]: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
        [q1.id]: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
        [yh.id]: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
        [k6.id]: "0x5425890298aed601595a70ab815c96711a31bc65",
        [ja.id]: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
        [z1.id]: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d"
    },
    Vg = {
        "mainnet-beta": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
        devnet: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU",
        testnet: ""
    };
let rne = new Set([Bs.id, Fs.id, go.id, fs.id, ja.id]),
    nne = new Set([Bs.id, Fs.id, fs.id, go.id]),
    ine = {
        buy: "CARD",
        send: "CRYPTO_ACCOUNT"
    },
    sne = {
        USDC: "2b92315d-eab7-5bef-84fa-089a131333f5",
        ETH: "d85dce9b-5b73-5c3c-8978-522ce1d1c1b4",
        BTC: "5b71fc48-3dd3-540c-809b-f8c94d0e68b5",
        SOL: "4f039497-3af8-5bb3-951c-6df9afa9be1c",
        POL: "026bcc1e-9163-591c-a709-34dd18b2e7a1"
    };
Bs.id + "", Fs.id + "", go.id + "", fs.id + "", ja.id + "";

function ane({
    appId: t,
    input: e,
    amount: r,
    blockchain: n,
    asset: i,
    experience: s
}) {
    let a = new URL("https://pay.coinbase.com/buy/select-asset");
    return a.searchParams.set("appId", e.app_id), a.searchParams.set("sessionToken", e.session_token), a.searchParams.set("endPartnerName", `privy:${t}`), a.searchParams.set("defaultExperience", s), a.searchParams.set("presetCryptoAmount", r.startsWith(".") ? `0${r}` : r), a.searchParams.set("defaultNetwork", n), a.searchParams.set("defaultPaymentMethod", ine[s]), a.searchParams.set("defaultAsset", sne[i]), a.searchParams.set("partnerUserId", e.partner_user_id), {
        url: a
    }
}
const one = (t, e) => {
    switch (e) {
        case "native-currency":
            return rne.has(t);
        case "USDC":
            return nne.has(t);
        default:
            return console.warn("Unknown asset passed to Coinbase Onramp"), !1
    }
};
let cne = class {
    async invokeRpc({
        method: e,
        params: r
    }) {
        return await (await fetch(this.cluster.rpcUrl, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                jsonrpc: "2.0",
                id: Sm(),
                method: e,
                params: r
            })
        })).json()
    }
    async getBalance(e) {
        try {
            let r = await this.invokeRpc({
                method: "getBalance",
                params: [e]
            });
            return r.error ? null : BigInt(r.result.value)
        } catch {
            return null
        }
    }
    async getTokenAccountsByOwner(e, r) {
        var n, i, s, a, o;
        try {
            let c = await this.invokeRpc({
                method: "getTokenAccountsByOwner",
                params: [e, {
                    mint: r
                }, {
                    encoding: "jsonParsed"
                }]
            });
            if (c.error) return null;
            let l = (o = (a = (s = (i = (n = c.result.value.at(0)) == null ? void 0 : n.account) == null ? void 0 : i.data) == null ? void 0 : s.parsed) == null ? void 0 : a.info) == null ? void 0 : o.tokenAmount;
            return l ? {
                amount: BigInt(l.amount),
                decimals: l.decimals
            } : null
        } catch {
            return null
        }
    }
    async getAccountInfo(e) {
        var r, n, i;
        try {
            let s = await this.invokeRpc({
                method: "getAccountInfo",
                params: [e, {
                    encoding: "jsonParsed"
                }]
            });
            if (s.error) return null;
            let a = (i = (n = (r = s.result.value) == null ? void 0 : r.data) == null ? void 0 : n.parsed) == null ? void 0 : i.info;
            return a ? {
                decimals: a.decimals
            } : null
        } catch {
            return null
        }
    }
    constructor(e) {
        this.cluster = e
    }
};

function A_(t) {
    return t ? `${t.slice(0,5)}…${t.slice(-4)}` : ""
}

function lne({
    wei: t,
    precision: e = 3
}) {
    return parseFloat(Cd(t)).toFixed(e).replace(/0+$/, "").replace(/\.$/, "")
}

function ri({
    amount: t,
    decimals: e
}) {
    return Nn(BigInt(t), e)
}
const dne = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
    une = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
    hne = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;

function fne(t, e) {
    if (t === "__proto__" || t === "constructor" && e && typeof e == "object" && "prototype" in e) {
        pne(t);
        return
    }
    return e
}

function pne(t) {
    console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`)
}

function Ef(t, e = {}) {
    if (typeof t != "string") return t;
    if (t[0] === '"' && t[t.length - 1] === '"' && t.indexOf("\\") === -1) return t.slice(1, -1);
    const r = t.trim();
    if (r.length <= 9) switch (r.toLowerCase()) {
        case "true":
            return !0;
        case "false":
            return !1;
        case "undefined":
            return;
        case "null":
            return null;
        case "nan":
            return Number.NaN;
        case "infinity":
            return Number.POSITIVE_INFINITY;
        case "-infinity":
            return Number.NEGATIVE_INFINITY
    }
    if (!hne.test(t)) {
        if (e.strict) throw new SyntaxError("[destr] Invalid JSON");
        return t
    }
    try {
        if (dne.test(t) || une.test(t)) {
            if (e.strict) throw new Error("[destr] Possible prototype pollution");
            return JSON.parse(t, fne)
        }
        return JSON.parse(t)
    } catch (n) {
        if (e.strict) throw n;
        return t
    }
}
const gne = /#/g,
    mne = /&/g,
    yne = /\//g,
    wne = /=/g,
    V6 = /\+/g,
    bne = /%5e/gi,
    vne = /%60/gi,
    xne = /%7c/gi,
    Ene = /%20/gi;

function _ne(t) {
    return encodeURI("" + t).replace(xne, "|")
}

function j3(t) {
    return _ne(typeof t == "string" ? t : JSON.stringify(t)).replace(V6, "%2B").replace(Ene, "+").replace(gne, "%23").replace(mne, "%26").replace(vne, "`").replace(bne, "^").replace(yne, "%2F")
}

function y2(t) {
    return j3(t).replace(wne, "%3D")
}

function QN(t = "") {
    try {
        return decodeURIComponent("" + t)
    } catch {
        return "" + t
    }
}

function Cne(t) {
    return QN(t.replace(V6, " "))
}

function Ane(t) {
    return QN(t.replace(V6, " "))
}

function kne(t = "") {
    const e = Object.create(null);
    t[0] === "?" && (t = t.slice(1));
    for (const r of t.split("&")) {
        const n = r.match(/([^=]+)=?(.*)/) || [];
        if (n.length < 2) continue;
        const i = Cne(n[1]);
        if (i === "__proto__" || i === "constructor") continue;
        const s = Ane(n[2] || "");
        e[i] === void 0 ? e[i] = s : Array.isArray(e[i]) ? e[i].push(s) : e[i] = [e[i], s]
    }
    return e
}

function Ine(t, e) {
    return (typeof e == "number" || typeof e == "boolean") && (e = String(e)), e ? Array.isArray(e) ? e.map(r => `${y2(t)}=${j3(r)}`).join("&") : `${y2(t)}=${j3(e)}` : y2(t)
}

function $ne(t) {
    return Object.keys(t).filter(e => t[e] !== void 0).map(e => Ine(e, t[e])).filter(Boolean).join("&")
}
const Sne = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/,
    Tne = /^[\s\w\0+.-]{2,}:([/\\]{2})?/,
    Pne = /^([/\\]\s*){2,}[^/\\]/,
    Nne = /^\.?\//;

function XN(t, e = {}) {
    return typeof e == "boolean" && (e = {
        acceptRelative: e
    }), e.strict ? Sne.test(t) : Tne.test(t) || (e.acceptRelative ? Pne.test(t) : !1)
}

function One(t = "", e) {
    return t.endsWith("/")
}

function jne(t = "", e) {
    return (One(t) ? t.slice(0, -1) : t) || "/"
}

function Rne(t = "", e) {
    return t.endsWith("/") ? t : t + "/"
}

function Mne(t, e) {
    if (Lne(e) || XN(t)) return t;
    const r = jne(e);
    return t.startsWith(r) ? t : Fne(r, t)
}

function Dne(t, e) {
    const r = Bne(t),
        n = { ...kne(r.search),
            ...e
        };
    return r.search = $ne(n), Wne(r)
}

function Lne(t) {
    return !t || t === "/"
}

function Une(t) {
    return t && t !== "/"
}

function Fne(t, ...e) {
    let r = t || "";
    for (const n of e.filter(i => Une(i)))
        if (r) {
            const i = n.replace(Nne, "");
            r = Rne(r) + i
        } else r = n;
    return r
}
const eO = Symbol.for("ufo:protocolRelative");

function Bne(t = "", e) {
    const r = t.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
    if (r) {
        const [, h, f = ""] = r;
        return {
            protocol: h.toLowerCase(),
            pathname: f,
            href: h + f,
            auth: "",
            host: "",
            search: "",
            hash: ""
        }
    }
    if (!XN(t, {
            acceptRelative: !0
        })) return k_(t);
    const [, n = "", i, s = ""] = t.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
    let [, a = "", o = ""] = s.match(/([^#/?]*)(.*)?/) || [];
    n === "file:" && (o = o.replace(/\/(?=[A-Za-z]:)/, ""));
    const {
        pathname: c,
        search: l,
        hash: u
    } = k_(o);
    return {
        protocol: n.toLowerCase(),
        auth: i ? i.slice(0, Math.max(0, i.length - 1)) : "",
        host: a,
        pathname: c,
        search: l,
        hash: u,
        [eO]: !n
    }
}

function k_(t = "") {
    const [e = "", r = "", n = ""] = (t.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
    return {
        pathname: e,
        search: r,
        hash: n
    }
}

function Wne(t) {
    const e = t.pathname || "",
        r = t.search ? (t.search.startsWith("?") ? "" : "?") + t.search : "",
        n = t.hash || "",
        i = t.auth ? t.auth + "@" : "",
        s = t.host || "";
    return (t.protocol || t[eO] ? (t.protocol || "") + "//" : "") + i + s + e + r + n
}
class tO extends Error {
    constructor(e, r) {
        super(e, r), this.name = "FetchError", r != null && r.cause && !this.cause && (this.cause = r.cause)
    }
}

function zne(t) {
    var c, l, u, h, f;
    const e = ((c = t.error) == null ? void 0 : c.message) || ((l = t.error) == null ? void 0 : l.toString()) || "",
        r = ((u = t.request) == null ? void 0 : u.method) || ((h = t.options) == null ? void 0 : h.method) || "GET",
        n = ((f = t.request) == null ? void 0 : f.url) || String(t.request) || "/",
        i = `[${r}] ${JSON.stringify(n)}`,
        s = t.response ? `${t.response.status} ${t.response.statusText}` : "<no response>",
        a = `${i}: ${s}${e?` ${e}`:""}`,
        o = new tO(a, t.error ? {
            cause: t.error
        } : void 0);
    for (const p of ["request", "options", "response"]) Object.defineProperty(o, p, {
        get() {
            return t[p]
        }
    });
    for (const [p, g] of [
            ["data", "_data"],
            ["status", "status"],
            ["statusCode", "status"],
            ["statusText", "statusText"],
            ["statusMessage", "statusText"]
        ]) Object.defineProperty(o, p, {
        get() {
            return t.response && t.response[g]
        }
    });
    return o
}
const qne = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));

function I_(t = "GET") {
    return qne.has(t.toUpperCase())
}

function Hne(t) {
    if (t === void 0) return !1;
    const e = typeof t;
    return e === "string" || e === "number" || e === "boolean" || e === null ? !0 : e !== "object" ? !1 : Array.isArray(t) ? !0 : t.buffer ? !1 : t.constructor && t.constructor.name === "Object" || typeof t.toJSON == "function"
}
const Vne = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"]),
    Gne = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;

function Kne(t = "") {
    if (!t) return "json";
    const e = t.split(";").shift() || "";
    return Gne.test(e) ? "json" : Vne.has(e) || e.startsWith("text/") ? "text" : "blob"
}

function Yne(t, e, r, n) {
    const i = Zne((e == null ? void 0 : e.headers) ? ? (t == null ? void 0 : t.headers), r == null ? void 0 : r.headers, n);
    let s;
    return (r != null && r.query || r != null && r.params || e != null && e.params || e != null && e.query) && (s = { ...r == null ? void 0 : r.params,
        ...r == null ? void 0 : r.query,
        ...e == null ? void 0 : e.params,
        ...e == null ? void 0 : e.query
    }), { ...r,
        ...e,
        query: s,
        params: s,
        headers: i
    }
}

function Zne(t, e, r) {
    if (!e) return new r(t);
    const n = new r(e);
    if (t)
        for (const [i, s] of Symbol.iterator in t || Array.isArray(t) ? t : new r(t)) n.set(i, s);
    return n
}
async function rg(t, e) {
    if (e)
        if (Array.isArray(e))
            for (const r of e) await r(t);
        else await e(t)
}
const Jne = new Set([408, 409, 425, 429, 500, 502, 503, 504]),
    Qne = new Set([101, 204, 205, 304]);

function rO(t = {}) {
    const {
        fetch: e = globalThis.fetch,
        Headers: r = globalThis.Headers,
        AbortController: n = globalThis.AbortController
    } = t;
    async function i(o) {
        const c = o.error && o.error.name === "AbortError" && !o.options.timeout || !1;
        if (o.options.retry !== !1 && !c) {
            let u;
            typeof o.options.retry == "number" ? u = o.options.retry : u = I_(o.options.method) ? 0 : 1;
            const h = o.response && o.response.status || 500;
            if (u > 0 && (Array.isArray(o.options.retryStatusCodes) ? o.options.retryStatusCodes.includes(h) : Jne.has(h))) {
                const f = typeof o.options.retryDelay == "function" ? o.options.retryDelay(o) : o.options.retryDelay || 0;
                return f > 0 && await new Promise(p => setTimeout(p, f)), s(o.request, { ...o.options,
                    retry: u - 1
                })
            }
        }
        const l = zne(o);
        throw Error.captureStackTrace && Error.captureStackTrace(l, s), l
    }
    const s = async function(c, l = {}) {
            const u = {
                request: c,
                options: Yne(c, l, t.defaults, r),
                response: void 0,
                error: void 0
            };
            u.options.method && (u.options.method = u.options.method.toUpperCase()), u.options.onRequest && await rg(u, u.options.onRequest), typeof u.request == "string" && (u.options.baseURL && (u.request = Mne(u.request, u.options.baseURL)), u.options.query && (u.request = Dne(u.request, u.options.query), delete u.options.query), "query" in u.options && delete u.options.query, "params" in u.options && delete u.options.params), u.options.body && I_(u.options.method) && (Hne(u.options.body) ? (u.options.body = typeof u.options.body == "string" ? u.options.body : JSON.stringify(u.options.body), u.options.headers = new r(u.options.headers || {}), u.options.headers.has("content-type") || u.options.headers.set("content-type", "application/json"), u.options.headers.has("accept") || u.options.headers.set("accept", "application/json")) : ("pipeTo" in u.options.body && typeof u.options.body.pipeTo == "function" || typeof u.options.body.pipe == "function") && ("duplex" in u.options || (u.options.duplex = "half")));
            let h;
            if (!u.options.signal && u.options.timeout) {
                const p = new n;
                h = setTimeout(() => {
                    const g = new Error("[TimeoutError]: The operation was aborted due to timeout");
                    g.name = "TimeoutError", g.code = 23, p.abort(g)
                }, u.options.timeout), u.options.signal = p.signal
            }
            try {
                u.response = await e(u.request, u.options)
            } catch (p) {
                return u.error = p, u.options.onRequestError && await rg(u, u.options.onRequestError), await i(u)
            } finally {
                h && clearTimeout(h)
            }
            if ((u.response.body || u.response._bodyInit) && !Qne.has(u.response.status) && u.options.method !== "HEAD") {
                const p = (u.options.parseResponse ? "json" : u.options.responseType) || Kne(u.response.headers.get("content-type") || "");
                switch (p) {
                    case "json":
                        {
                            const g = await u.response.text(),
                                m = u.options.parseResponse || Ef;u.response._data = m(g);
                            break
                        }
                    case "stream":
                        {
                            u.response._data = u.response.body || u.response._bodyInit;
                            break
                        }
                    default:
                        u.response._data = await u.response[p]()
                }
            }
            return u.options.onResponse && await rg(u, u.options.onResponse), !u.options.ignoreResponseError && u.response.status >= 400 && u.response.status < 600 ? (u.options.onResponseError && await rg(u, u.options.onResponseError), await i(u)) : u.response
        },
        a = async function(c, l) {
            return (await s(c, l))._data
        };
    return a.raw = s, a.native = (...o) => e(...o), a.create = (o = {}, c = {}) => rO({ ...t,
        ...c,
        defaults: { ...t.defaults,
            ...c.defaults,
            ...o
        }
    }), a
}
const Tm = function() {
        if (typeof globalThis < "u") return globalThis;
        if (typeof self < "u") return self;
        if (typeof window < "u") return window;
        if (typeof globalThis < "u") return globalThis;
        throw new Error("unable to locate global object")
    }(),
    Xne = Tm.fetch ? (...t) => Tm.fetch(...t) : () => Promise.reject(new Error("[ofetch] global.fetch is not supported!")),
    eie = Tm.Headers,
    tie = Tm.AbortController,
    nO = rO({
        fetch: Xne,
        Headers: eie,
        AbortController: tie
    });
var gt;
let Qn = class extends Error {
        toString() {
            return `${this.type}${this.privyErrorCode?`-${this.privyErrorCode}`:""}: ${this.message}${this.cause?` [cause: ${this.cause}]`:""}`
        }
        constructor(e, r, n) {
            super(e), r instanceof Error && (this.cause = r), this.privyErrorCode = n
        }
    },
    es = class extends Qn {
        constructor(e, r, n, i, s, a) {
            super(n, i, s), this.type = e, this.status = r, this.data = a
        }
    },
    J = class extends Qn {
        constructor(e, r, n) {
            super(e, r, n), this.type = "client_error"
        }
    },
    rie = class extends J {
        constructor() {
            super("Request timed out", void 0, "client_request_timeout")
        }
    },
    br = class extends Qn {
        constructor(e, r, n) {
            super(e, r, n), this.type = "connector_error"
        }
    };
const qt = t => {
        if (t instanceof Qn) return t;
        if (!(t instanceof tO)) return xr(t);
        if (!t.response) return new es("api_error", null, t.message, t);
        let {
            type: e,
            message: r,
            error: n,
            code: i
        } = t.data;
        return new es(e || "ApiError", t.response.status, r || n, t, i, t.data)
    },
    xr = t => t instanceof Qn ? t : t instanceof Error ? new J(t.message, t) : new J(`Internal error: ${t}`);
var ee = ((gt = {}).OAUTH_ACCOUNT_SUSPENDED = "oauth_account_suspended", gt.MISSING_OR_INVALID_PRIVY_APP_ID = "missing_or_invalid_privy_app_id", gt.MISSING_OR_INVALID_PRIVY_ACCOUNT_ID = "missing_or_invalid_privy_account_id", gt.MISSING_OR_INVALID_TOKEN = "missing_or_invalid_token", gt.INVALID_DATA = "invalid_data", gt.INVALID_CAPTCHA = "invalid_captcha", gt.LINKED_TO_ANOTHER_USER = "linked_to_another_user", gt.CANNOT_LINK_MORE_OF_TYPE = "cannot_link_more_of_type", gt.FAILED_TO_LINK_ACCOUNT = "failed_to_link_account", gt.FAILED_TO_UPDATE_ACCOUNT = "failed_to_update_account", gt.USER_EXITED_UPDATE_FLOW = "exited_update_flow", gt.ALLOWLIST_REJECTED = "allowlist_rejected", gt.OAUTH_USER_DENIED = "oauth_user_denied", gt.OAUTH_UNEXPECTED = "oauth_unexpected", gt.UNKNOWN_AUTH_ERROR = "unknown_auth_error", gt.USER_EXITED_AUTH_FLOW = "exited_auth_flow", gt.USER_EXITED_LINK_FLOW = "exited_link_flow", gt.USER_EXITED_SET_PASSWORD_FLOW = "user_exited_set_password_flow", gt.MUST_BE_AUTHENTICATED = "must_be_authenticated", gt.UNKNOWN_CONNECT_WALLET_ERROR = "unknown_connect_wallet_error", gt.GENERIC_CONNECT_WALLET_ERROR = "generic_connect_wallet_error", gt.CLIENT_REQUEST_TIMEOUT = "client_request_timeout", gt.INVALID_CREDENTIALS = "invalid_credentials", gt.MISSING_MFA_CREDENTIALS = "missing_or_invalid_mfa", gt.UNKNOWN_MFA_ERROR = "unknown_mfa_error", gt.EMBEDDED_WALLET_ALREADY_EXISTS = "embedded_wallet_already_exists", gt.EMBEDDED_WALLET_NOT_FOUND = "embedded_wallet_not_found", gt.EMBEDDED_WALLET_CREATE_ERROR = "embedded_wallet_create_error", gt.UNKNOWN_EMBEDDED_WALLET_ERROR = "unknown_embedded_wallet_error", gt.EMBEDDED_WALLET_PASSWORD_UNCONFIRMED = "embedded_wallet_password_unconfirmed", gt.EMBEDDED_WALLET_PASSWORD_ALREADY_EXISTS = "embedded_wallet_password_already_exists", gt.EMBEDDED_WALLET_RECOVERY_ALREADY_EXISTS = "embedded_wallet_recovery_already_exists", gt.TRANSACTION_FAILURE = "transaction_failure", gt.UNSUPPORTED_CHAIN_ID = "unsupported_chain_id", gt.NOT_SUPPORTED = "not_supported", gt.CAPTCHA_TIMEOUT = "captcha_timeout", gt.INVALID_MESSAGE = "invalid_message", gt.UNABLE_TO_SIGN = "unable_to_sign", gt.CAPTCHA_FAILURE = "captcha_failure", gt.CAPTCHA_DISABLED = "captcha_disabled", gt.SESSION_STORAGE_UNAVAILABLE = "session_storage_unavailable", gt.TOO_MANY_REQUESTS = "too_many_requests", gt.USER_LIMIT_REACHED = "max_accounts_reached", gt.DISALLOWED_LOGIN_METHOD = "disallowed_login_method", gt.DISALLOWED_PLUS_EMAIL = "disallowed_plus_email", gt.PASSKEY_NOT_ALLOWED = "passkey_not_allowed", gt.USER_DOES_NOT_EXIST = "user_does_not_exist", gt.INSUFFICIENT_BALANCE = "insufficient_balance", gt.ACCOUNT_TRANSFER_REQUIRED = "account_transfer_required", gt.BUFFER_NOT_DEFINED = "buffer_not_defined", gt.UNSUPPORTED_WALLET_TYPE = "unsupported_wallet_type", gt);
let xl = class extends J {
        constructor() {
            super("Method called before `ready`. Ensure you wait until `ready` is true before calling.")
        }
    },
    Xc = class extends J {
        constructor(e = "Embedded wallet error", r) {
            super(e, r, "unknown_embedded_wallet_error")
        }
    },
    nie = class extends J {
        constructor(e = "User must be authenticated") {
            super(e, void 0, "must_be_authenticated")
        }
    },
    l0 = class extends J {
        constructor(e) {
            super("This application is in development mode and must be upgraded to production to log in new users.", e, "max_accounts_reached")
        }
    };
const iO = "/api/v1/sessions",
    sO = "/api/v1/sessions/logout",
    iie = "/api/v1/siwe/init",
    sie = "/api/v1/siwe/authenticate",
    aie = "/api/v1/siwe/link",
    oie = "/api/v1/siwe/link_smart_wallet",
    cie = "/api/v1/siwe/unlink",
    lie = "/api/v1/siwe/transfer",
    die = "/api/v1/siws/init",
    uie = "/api/v1/siws/authenticate",
    hie = "/api/v1/siws/link",
    fie = "/api/v1/siws/unlink",
    pie = "/api/v1/siws/transfer",
    gie = "/api/v1/farcaster/init",
    mie = "/api/v1/farcaster/authenticate",
    yie = "/api/v1/farcaster/link",
    wie = "/api/v1/farcaster/status",
    bie = "/api/v1/farcaster/unlink",
    vie = "/api/v1/farcaster/transfer",
    xie = "/api/v1/passwordless/init",
    Eie = "/api/v1/passwordless/authenticate",
    _ie = "/api/v1/passwordless/link",
    Cie = "/api/v1/passwordless/unlink",
    Aie = "/api/v1/passwordless/update",
    kie = "/api/v1/passwordless/transfer",
    Iie = "/api/v1/passwordless_sms/init",
    $ie = "/api/v1/passwordless_sms/link",
    Sie = "/api/v1/passwordless_sms/unlink",
    Tie = "/api/v1/passwordless_sms/authenticate",
    Pie = "/api/v1/passwordless_sms/update",
    Nie = "/api/v1/passwordless_sms/transfer",
    aO = "/api/v1/oauth/init",
    oO = "/api/v1/oauth/authenticate",
    cO = "/api/v1/oauth/link",
    Oie = "/api/v1/oauth/unlink",
    jie = "/api/v1/oauth/transfer",
    Rie = "/api/v1/recovery/oauth/init",
    Mie = "/api/v1/recovery/oauth/init_icloud",
    Die = "/api/v1/recovery/oauth/authenticate",
    Lie = "/api/v1/passkeys/link/init",
    Uie = "/api/v1/passkeys/authenticate/init",
    Fie = "/api/v1/passkeys/register/init",
    Bie = "/api/v1/passkeys/link",
    Wie = "/api/v1/passkeys/authenticate",
    zie = "/api/v1/passkeys/register",
    qie = "/api/v1/telegram/authenticate",
    Hie = "/api/v1/telegram/link",
    Vie = "/api/v1/telegram/unlink",
    Gie = "/api/v1/telegram/transfer",
    Kie = "/api/v1/mfa/passwordless_sms/init",
    Yie = "/api/v1/mfa/passkeys/init",
    Zie = "/api/v1/users/me/accept_terms",
    lO = "/api/v1/analytics_events",
    Jie = "/api/v1/custom_jwt_account/authenticate",
    Qie = "/api/v1/custom_jwt_account/link",
    Xie = "/api/v1/guest/authenticate",
    ese = "/api/v1/plugins/moonpay_on_ramp/sign",
    tse = "/api/v1/funding/coinbase_on_ramp/init",
    rse = "/api/v1/funding/coinbase_on_ramp/status",
    nse = "/api/v1/wallets/revoke",
    ise = "/api/v1/users/me",
    sse = "/api/v1/scan/transaction",
    le = () => {
        throw Error("You need to wrap your application with the <PrivyProvider> initialized with your app id.")
    },
    Hh = t => () => {
        throw Error(t.trim())
    },
    dO = v.createContext({
        setAuthenticated: le,
        setUser: le,
        setIsNewUser: le,
        isNewUserThisSession: !1,
        walletConnectionStatus: null,
        setWalletConnectionStatus: le,
        connectors: [],
        solanaWallets: [],
        rpcConfig: {
            rpcUrls: {}
        },
        showFiatPrices: !0,
        chains: [],
        clientAnalyticsId: null,
        pendingTransaction: null,
        client: null,
        privy: null,
        appId: "notAdded",
        onCustomAuthAuthenticated: le,
        hideWalletUIs: {
            current: !1
        },
        nativeTokenSymbolForChainId: le,
        initializeWalletProxy: le,
        getAuthMeta: le,
        getAuthFlow: le,
        closePrivyModal: le,
        openPrivyModal: le,
        connectWallet: le,
        initLoginWithWallet: le,
        loginWithWallet: le,
        initLoginWithFarcaster: le,
        loginWithFarcaster: le,
        loginWithCode: le,
        initLoginWithEmail: le,
        initLoginWithSms: le,
        initUpdateEmail: le,
        initUpdatePhone: le,
        resendEmailCode: le,
        resendSmsCode: le,
        initLoginWithHeadlessOAuth: le,
        loginWithHeadlessOAuth: le,
        crossAppAuthFlow: le,
        initLoginWithOAuth: le,
        loginWithOAuth: le,
        passkeyAuthState: {
            status: "initial"
        },
        setPasskeyAuthState: le,
        initSignupWithPasskey: le,
        signupWithPasskey: le,
        initLoginWithPasskey: le,
        loginWithPasskey: le,
        initLinkWithPasskey: le,
        linkWithPasskey: le,
        refreshSessionAndUser: le,
        walletProxy: null,
        createAnalyticsEvent: le,
        acceptTerms: le,
        getUsdTokenPrice: le,
        getUsdPriceForSol: le,
        getSplTokenMetadata: le,
        recoverEmbeddedWallet: le,
        updateWallets: le,
        fundWallet: le,
        openModal: le,
        setReadyToTrue: le,
        requestFarcasterSignerStatus: le,
        initLoginWithTelegram: le,
        loginWithTelegram: le,
        generateSiweMessage: le,
        generateSiweMessageForSmartWallet: le,
        loginWithSiwe: le,
        linkWithSiwe: le,
        linkSmartWallet: le,
        delegateWallet: le,
        revokeDelegatedWallets: le,
        exportSolanaWallet: le,
        connectCoinbaseSmartWallet: le,
        connectBaseAccount: le,
        initiateAccountTransfer: le,
        emailOtpState: {
            status: "initial"
        },
        setEmailOtpState: le,
        smsOtpState: {
            status: "initial"
        },
        setSmsOtpState: le,
        siweState: {
            status: "initial"
        },
        setSiweState: le,
        oAuthState: {
            status: "initial"
        },
        setOAuthState: le,
        telegramAuthState: {
            status: "initial"
        },
        setTelegramAuthState: le,
        isHeadlessOAuthLoading: !1,
        isHeadlessSigning: le,
        inProgressAuthFlowRef: {
            current: null
        },
        inProgressLoginOrLinkMethodRef: {
            current: null
        },
        baseAccountSdk: void 0,
        setBaseAccountSdk: le
    }),
    $e = () => v.useContext(dO);

function st(t) {
    return t ? new Date(1e3 * t) : null
}

function Bn(t, e) {
    return t.slice().sort((r, n) => (r.firstVerifiedAt ? ? r.verifiedAt).getTime() - (n.firstVerifiedAt ? ? n.verifiedAt).getTime()).find(r => r.type === e)
}
const Xa = t => t ? uO(t).find(e => e.walletIndex === 0) ? ? null : null,
    uO = t => t ? hO(t, "ethereum") : [],
    hO = (t, e) => t.linkedAccounts.filter(r => r.type === "wallet" && r.walletClientType === "privy" && !r.imported && r.chainType === e),
    fO = t => t ? hO(t, "solana") : [],
    Sd = t => t ? fO(t).find(e => e.walletIndex === 0) ? ? null : null,
    R3 = t => (t == null ? void 0 : t.linkedAccounts.find(e => e.type === "wallet" && e.walletClientType === "privy" && e.imported && e.chainType === "ethereum")) || null,
    ry = t => (t == null ? void 0 : t.linkedAccounts.find(e => e.type === "wallet" && e.imported && e.walletClientType === "privy" && e.chainType === "solana")) || null;
let pO = (t, e) => t === e || !(!t.startsWith("0x") || !e.startsWith("0x")) && Zr(t) === Zr(e);
const $s = (t, e) => (t == null ? void 0 : t.linkedAccounts.find(r => r.type === "wallet" && r.walletClientType === "privy" && pO(r.address, e))) || null,
    w2 = (t, e) => t.find(r => pO(r.address, e)) || null,
    Rs = t => Xa(t) ? ? Sd(t);

function Vn(t) {
    if (!t) return null;
    let e = function(E) {
            let _ = [];
            for (let b of E) {
                let A = b.type;
                switch (b.type) {
                    case "wallet":
                        let I = {
                            id: b.id,
                            address: b.address,
                            type: b.type,
                            imported: b.imported,
                            delegated: b.delegated,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at),
                            chainType: b.chain_type,
                            walletClientType: b.wallet_client_type,
                            connectorType: b.connector_type,
                            recoveryMethod: b.recovery_method,
                            walletIndex: b.wallet_index
                        };
                        _.push(I);
                        break;
                    case "smart_wallet":
                        let T = {
                            address: b.address,
                            type: b.type,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at),
                            smartWalletType: b.smart_wallet_type,
                            smartWalletVersion: b.smart_wallet_version
                        };
                        _.push(T);
                        break;
                    case "cross_app":
                        let C = {
                            type: b.type,
                            subject: b.subject,
                            embeddedWallets: b.embedded_wallets,
                            smartWallets: b.smart_wallets,
                            providerApp: {
                                id: b.provider_app_id
                            },
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(C);
                        break;
                    case "email":
                        let $ = {
                            address: b.address,
                            type: b.type,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push($);
                        break;
                    case "phone":
                        let P = {
                            number: b.phoneNumber,
                            type: b.type,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(P);
                        break;
                    case "google_oauth":
                        let N = {
                            subject: b.subject,
                            email: b.email,
                            name: b.name,
                            type: b.type,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(N);
                        break;
                    case "spotify_oauth":
                        let R = {
                            subject: b.subject,
                            email: b.email,
                            name: b.name,
                            type: b.type,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(R);
                        break;
                    case "instagram_oauth":
                        let D = {
                            subject: b.subject,
                            username: b.username,
                            type: b.type,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(D);
                        break;
                    case "twitter_oauth":
                        let S = {
                            subject: b.subject,
                            username: b.username,
                            name: b.name,
                            type: b.type,
                            profilePictureUrl: b.profile_picture_url,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(S);
                        break;
                    case "discord_oauth":
                        let O = {
                            subject: b.subject,
                            username: b.username,
                            email: b.email,
                            type: b.type,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(O);
                        break;
                    case "github_oauth":
                        let M = {
                            subject: b.subject,
                            username: b.username,
                            name: b.name,
                            email: b.email,
                            type: b.type,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(M);
                        break;
                    case "tiktok_oauth":
                        let U = {
                            subject: b.subject,
                            username: b.username,
                            name: b.name,
                            type: b.type,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(U);
                        break;
                    case "line_oauth":
                        let k = {
                            subject: b.subject,
                            name: b.name,
                            email: b.email,
                            profilePictureUrl: b.profile_picture_url,
                            type: b.type,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(k);
                        break;
                    case "linkedin_oauth":
                        let F = {
                            subject: b.subject,
                            name: b.name,
                            email: b.email,
                            vanityName: b.vanity_name,
                            type: b.type,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(F);
                        break;
                    case "apple_oauth":
                        let q = {
                            subject: b.subject,
                            email: b.email,
                            type: b.type,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(q);
                        break;
                    case "custom_auth":
                        _.push({
                            type: b.type,
                            customUserId: b.custom_user_id,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        });
                        break;
                    case "farcaster":
                        let W = {
                            type: b.type,
                            fid: b.fid,
                            ownerAddress: b.owner_address,
                            displayName: b.display_name,
                            username: b.username,
                            bio: b.bio,
                            pfp: b.profile_picture_url,
                            url: b.homepage_url,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at),
                            signerPublicKey: b.signer_public_key
                        };
                        _.push(W);
                        break;
                    case "passkey":
                        let K = {
                            type: b.type,
                            enrolledInMfa: b.enrolled_in_mfa,
                            credentialId: b.credential_id,
                            authenticatorName: b.authenticator_name,
                            createdWithDevice: b.created_with_device,
                            createdWithOs: b.created_with_os,
                            createdWithBrowser: b.created_with_browser,
                            verifiedAt: st(b.verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(K);
                        break;
                    case "telegram":
                        let H = {
                            type: b.type,
                            telegramUserId: b.telegram_user_id,
                            firstName: b.first_name,
                            lastName: b.last_name,
                            username: b.username,
                            photoUrl: b.photo_url,
                            verifiedAt: st(b.first_verified_at),
                            firstVerifiedAt: st(b.first_verified_at),
                            latestVerifiedAt: st(b.latest_verified_at)
                        };
                        _.push(H);
                        break;
                    default:
                        console.warn(`Unrecognized account type: ${A}. Please consider upgrading the Privy SDK.`)
                }
            }
            return _
        }(t.linked_accounts),
        r = Bn(e, "wallet"),
        n = Bn(e, "smart_wallet"),
        i = Bn(e, "email"),
        s = Bn(e, "phone"),
        a = Bn(e, "google_oauth"),
        o = Bn(e, "twitter_oauth"),
        c = Bn(e, "discord_oauth"),
        l = Bn(e, "github_oauth"),
        u = Bn(e, "spotify_oauth"),
        h = Bn(e, "instagram_oauth"),
        f = Bn(e, "tiktok_oauth"),
        p = Bn(e, "line_oauth"),
        g = Bn(e, "linkedin_oauth"),
        m = Bn(e, "apple_oauth"),
        y = Bn(e, "farcaster"),
        w = Bn(e, "telegram"),
        x = t.mfa_methods.map(({
            type: E,
            verified_at: _
        }) => ({
            type: E,
            verifiedAt: st(_)
        }));
    return {
        id: t.id,
        createdAt: st(t.created_at),
        linkedAccounts: e,
        email: i && {
            address: i == null ? void 0 : i.address
        },
        phone: s && {
            number: s == null ? void 0 : s.number
        },
        wallet: r && {
            id: r.id,
            address: r.address,
            chainType: r.chainType,
            walletClientType: r.walletClientType,
            connectorType: r.connectorType,
            recoveryMethod: r.recoveryMethod,
            imported: r.imported,
            delegated: r.delegated,
            walletIndex: r.walletIndex
        },
        smartWallet: n && {
            address: n.address,
            smartWalletType: n.smartWalletType,
            smartWalletVersion: n.smartWalletVersion
        },
        google: a && {
            subject: a.subject,
            email: a.email,
            name: a.name
        },
        twitter: o && {
            subject: o.subject,
            username: o.username,
            name: o.name,
            profilePictureUrl: o.profilePictureUrl
        },
        discord: c && {
            subject: c.subject,
            username: c.username,
            email: c.email
        },
        github: l && {
            subject: l.subject,
            username: l.username,
            name: l.name,
            email: l.email
        },
        spotify: u && {
            subject: u.subject,
            email: u.email,
            name: u.name
        },
        instagram: h && {
            subject: h.subject,
            username: h.username
        },
        tiktok: f && {
            subject: f.subject,
            username: f.username,
            name: f.name
        },
        line: p && {
            subject: p.subject,
            name: p.name,
            email: p.email,
            profilePictureUrl: p.profilePictureUrl
        },
        linkedin: g && {
            subject: g.subject,
            name: g.name,
            email: g.email,
            vanityName: g.vanityName
        },
        apple: m && {
            subject: m.subject,
            email: m.email
        },
        farcaster: y && {
            fid: y.fid,
            ownerAddress: y.ownerAddress,
            displayName: y.displayName,
            username: y.username,
            bio: y.bio,
            pfp: y.pfp,
            url: y.url,
            signerPublicKey: y.signerPublicKey
        },
        telegram: w && {
            telegramUserId: w.telegramUserId,
            firstName: w.firstName,
            lastName: w.lastName,
            username: w.username,
            photoUrl: w.photoUrl
        },
        delegatedWallets: [],
        mfaMethods: x.map(E => E.type),
        hasAcceptedTerms: t.has_accepted_terms ? ? !1,
        isGuest: t.is_guest,
        customMetadata: t.custom_metadata
    }
}
const fn = t => !!t.id && t.recoveryMethod === "privy-v2",
    Td = v.createContext({
        ready: !1,
        authenticated: !1,
        user: null,
        walletConnectors: null,
        connectWallet: le,
        login: le,
        connectOrCreateWallet: le,
        linkEmail: le,
        linkPhone: le,
        linkFarcaster: le,
        linkWallet: le,
        startCrossAppAuthFlow: le,
        linkGoogle: le,
        linkTwitter: le,
        linkDiscord: le,
        linkGithub: le,
        linkSpotify: le,
        linkInstagram: le,
        linkTelegram: le,
        linkTiktok: le,
        linkLine: le,
        linkLinkedIn: le,
        linkApple: le,
        linkPasskey: le,
        updateEmail: le,
        updatePhone: le,
        logout: le,
        getAccessToken: le,
        unlinkEmail: le,
        unlinkPhone: le,
        unlinkWallet: le,
        unlinkGoogle: le,
        unlinkTwitter: le,
        unlinkDiscord: le,
        unlinkGithub: le,
        unlinkSpotify: le,
        unlinkInstagram: le,
        unlinkTiktok: le,
        unlinkLine: le,
        unlinkLinkedIn: le,
        unlinkApple: le,
        unlinkCrossAppAccount: le,
        unlinkFarcaster: le,
        unlinkTelegram: le,
        unlinkPasskey: le,
        signMessage: le,
        signTypedData: le,
        enrollInMfa: le,
        initEnrollmentWithSms: le,
        initEnrollmentWithTotp: le,
        initEnrollmentWithPasskey: le,
        promptMfa: le,
        init: le,
        submitEnrollmentWithSms: le,
        submitEnrollmentWithTotp: le,
        submitEnrollmentWithPasskey: le,
        unenroll: le,
        submit: le,
        cancel: le,
        sendTransaction: le,
        signTransaction: le,
        exportWallet: le,
        setWalletPassword: le,
        setWalletRecovery: le,
        requestFarcasterSignerFromWarpcast: le,
        getFarcasterSignerPublicKey: le,
        signFarcasterMessage: le,
        signMessageWithCrossAppWallet: le,
        signTypedDataWithCrossAppWallet: le,
        sendTransactionWithCrossAppWallet: le,
        isModalOpen: !1,
        mfaMethods: []
    }),
    $t = () => v.useContext(Td),
    G6 = () => {
        let {
            getAccessToken: t
        } = $t(), {
            walletProxy: e
        } = $e();
        return v.useMemo(() => ({
            signWithUserSigner: async ({
                message: r
            }) => {
                if (!e) throw Error("Wallet proxy not initialized");
                let n = await t();
                if (!n) throw Error("User must be authenticated");
                let {
                    signature: i
                } = await e.signWithUserSigner({
                    accessToken: n,
                    message: r
                });
                return {
                    signature: i
                }
            }
        }), [e, t])
    };
class uo {
    constructor(e, r) {
        this.scope = e, this.module = r
    }
    storeObject(e, r) {
        this.setItem(e, JSON.stringify(r))
    }
    loadObject(e) {
        const r = this.getItem(e);
        return r ? JSON.parse(r) : void 0
    }
    setItem(e, r) {
        localStorage.setItem(this.scopedKey(e), r)
    }
    getItem(e) {
        return localStorage.getItem(this.scopedKey(e))
    }
    removeItem(e) {
        localStorage.removeItem(this.scopedKey(e))
    }
    clear() {
        const e = this.scopedKey(""),
            r = [];
        for (let n = 0; n < localStorage.length; n++) {
            const i = localStorage.key(n);
            typeof i == "string" && i.startsWith(e) && r.push(i)
        }
        r.forEach(n => localStorage.removeItem(n))
    }
    scopedKey(e) {
        return `-${this.scope}${this.module?`:${this.module}`:""}:${e}`
    }
    static clearAll() {
        new uo("CBWSDK").clear(), new uo("walletlink").clear()
    }
}
const Lr = {
        rpc: {
            invalidInput: -32e3,
            resourceNotFound: -32001,
            resourceUnavailable: -32002,
            transactionRejected: -32003,
            methodNotSupported: -32004,
            limitExceeded: -32005,
            parse: -32700,
            invalidRequest: -32600,
            methodNotFound: -32601,
            invalidParams: -32602,
            internal: -32603
        },
        provider: {
            userRejectedRequest: 4001,
            unauthorized: 4100,
            unsupportedMethod: 4200,
            disconnected: 4900,
            chainDisconnected: 4901,
            unsupportedChain: 4902
        }
    },
    M3 = {
        "-32700": {
            standard: "JSON RPC 2.0",
            message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        },
        "-32600": {
            standard: "JSON RPC 2.0",
            message: "The JSON sent is not a valid Request object."
        },
        "-32601": {
            standard: "JSON RPC 2.0",
            message: "The method does not exist / is not available."
        },
        "-32602": {
            standard: "JSON RPC 2.0",
            message: "Invalid method parameter(s)."
        },
        "-32603": {
            standard: "JSON RPC 2.0",
            message: "Internal JSON-RPC error."
        },
        "-32000": {
            standard: "EIP-1474",
            message: "Invalid input."
        },
        "-32001": {
            standard: "EIP-1474",
            message: "Resource not found."
        },
        "-32002": {
            standard: "EIP-1474",
            message: "Resource unavailable."
        },
        "-32003": {
            standard: "EIP-1474",
            message: "Transaction rejected."
        },
        "-32004": {
            standard: "EIP-1474",
            message: "Method not supported."
        },
        "-32005": {
            standard: "EIP-1474",
            message: "Request limit exceeded."
        },
        4001: {
            standard: "EIP-1193",
            message: "User rejected the request."
        },
        4100: {
            standard: "EIP-1193",
            message: "The requested account and/or method has not been authorized by the user."
        },
        4200: {
            standard: "EIP-1193",
            message: "The requested method is not supported by this Ethereum provider."
        },
        4900: {
            standard: "EIP-1193",
            message: "The provider is disconnected from all chains."
        },
        4901: {
            standard: "EIP-1193",
            message: "The provider is disconnected from the specified chain."
        },
        4902: {
            standard: "EIP-3085",
            message: "Unrecognized chain ID."
        }
    },
    gO = "Unspecified error message.",
    ase = "Unspecified server error.";

function K6(t, e = gO) {
    if (t && Number.isInteger(t)) {
        const r = t.toString();
        if (D3(M3, r)) return M3[r].message;
        if (mO(t)) return ase
    }
    return e
}

function ose(t) {
    if (!Number.isInteger(t)) return !1;
    const e = t.toString();
    return !!(M3[e] || mO(t))
}

function cse(t, {
    shouldIncludeStack: e = !1
} = {}) {
    const r = {};
    if (t && typeof t == "object" && !Array.isArray(t) && D3(t, "code") && ose(t.code)) {
        const n = t;
        r.code = n.code, n.message && typeof n.message == "string" ? (r.message = n.message, D3(n, "data") && (r.data = n.data)) : (r.message = K6(r.code), r.data = {
            originalError: $_(t)
        })
    } else r.code = Lr.rpc.internal, r.message = S_(t, "message") ? t.message : gO, r.data = {
        originalError: $_(t)
    };
    return e && (r.stack = S_(t, "stack") ? t.stack : void 0), r
}

function mO(t) {
    return t >= -32099 && t <= -32e3
}

function $_(t) {
    return t && typeof t == "object" && !Array.isArray(t) ? Object.assign({}, t) : t
}

function D3(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e)
}

function S_(t, e) {
    return typeof t == "object" && t !== null && e in t && typeof t[e] == "string"
}
const Kt = {
    rpc: {
        parse: t => ys(Lr.rpc.parse, t),
        invalidRequest: t => ys(Lr.rpc.invalidRequest, t),
        invalidParams: t => ys(Lr.rpc.invalidParams, t),
        methodNotFound: t => ys(Lr.rpc.methodNotFound, t),
        internal: t => ys(Lr.rpc.internal, t),
        server: t => {
            if (!t || typeof t != "object" || Array.isArray(t)) throw new Error("Ethereum RPC Server errors must provide single object argument.");
            const {
                code: e
            } = t;
            if (!Number.isInteger(e) || e > -32005 || e < -32099) throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
            return ys(e, t)
        },
        invalidInput: t => ys(Lr.rpc.invalidInput, t),
        resourceNotFound: t => ys(Lr.rpc.resourceNotFound, t),
        resourceUnavailable: t => ys(Lr.rpc.resourceUnavailable, t),
        transactionRejected: t => ys(Lr.rpc.transactionRejected, t),
        methodNotSupported: t => ys(Lr.rpc.methodNotSupported, t),
        limitExceeded: t => ys(Lr.rpc.limitExceeded, t)
    },
    provider: {
        userRejectedRequest: t => Xd(Lr.provider.userRejectedRequest, t),
        unauthorized: t => Xd(Lr.provider.unauthorized, t),
        unsupportedMethod: t => Xd(Lr.provider.unsupportedMethod, t),
        disconnected: t => Xd(Lr.provider.disconnected, t),
        chainDisconnected: t => Xd(Lr.provider.chainDisconnected, t),
        unsupportedChain: t => Xd(Lr.provider.unsupportedChain, t),
        custom: t => {
            if (!t || typeof t != "object" || Array.isArray(t)) throw new Error("Ethereum Provider custom errors must provide single object argument.");
            const {
                code: e,
                message: r,
                data: n
            } = t;
            if (!r || typeof r != "string") throw new Error('"message" must be a nonempty string');
            return new bO(e, r, n)
        }
    }
};

function ys(t, e) {
    const [r, n] = yO(e);
    return new wO(t, r || K6(t), n)
}

function Xd(t, e) {
    const [r, n] = yO(e);
    return new bO(t, r || K6(t), n)
}

function yO(t) {
    if (t) {
        if (typeof t == "string") return [t];
        if (typeof t == "object" && !Array.isArray(t)) {
            const {
                message: e,
                data: r
            } = t;
            if (e && typeof e != "string") throw new Error("Must specify string message.");
            return [e || void 0, r]
        }
    }
    return []
}
class wO extends Error {
    constructor(e, r, n) {
        if (!Number.isInteger(e)) throw new Error('"code" must be an integer.');
        if (!r || typeof r != "string") throw new Error('"message" must be a nonempty string.');
        super(r), this.code = e, n !== void 0 && (this.data = n)
    }
}
class bO extends wO {
    constructor(e, r, n) {
        if (!lse(e)) throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        super(e, r, n)
    }
}

function lse(t) {
    return Number.isInteger(t) && t >= 1e3 && t <= 4999
}

function Y6() {
    return t => t
}
const Ip = Y6(),
    dse = Y6(),
    use = Y6();

function Ro(t) {
    return Math.floor(t)
}
const vO = /^[0-9]*$/,
    xO = /^[a-f0-9]*$/;

function Pl(t) {
    return Z6(crypto.getRandomValues(new Uint8Array(t)))
}

function Z6(t) {
    return [...t].map(e => e.toString(16).padStart(2, "0")).join("")
}

function Gg(t) {
    return new Uint8Array(t.match(/.{1,2}/g).map(e => Number.parseInt(e, 16)))
}

function Mf(t, e = !1) {
    const r = t.toString("hex");
    return Ip(e ? `0x${r}` : r)
}

function b2(t) {
    return Mf(L3(t), !0)
}

function La(t) {
    return use(t.toString(10))
}

function Vc(t) {
    return Ip(`0x${BigInt(t).toString(16)}`)
}

function EO(t) {
    return t.startsWith("0x") || t.startsWith("0X")
}

function J6(t) {
    return EO(t) ? t.slice(2) : t
}

function _O(t) {
    return EO(t) ? `0x${t.slice(2)}` : `0x${t}`
}

function ny(t) {
    if (typeof t != "string") return !1;
    const e = J6(t).toLowerCase();
    return xO.test(e)
}

function hse(t, e = !1) {
    if (typeof t == "string") {
        const r = J6(t).toLowerCase();
        if (xO.test(r)) return Ip(e ? `0x${r}` : r)
    }
    throw Kt.rpc.invalidParams(`"${String(t)}" is not a hexadecimal string`)
}

function Q6(t, e = !1) {
    let r = hse(t, !1);
    return r.length % 2 === 1 && (r = Ip(`0${r}`)), e ? Ip(`0x${r}`) : r
}

function _c(t) {
    if (typeof t == "string") {
        const e = J6(t).toLowerCase();
        if (ny(e) && e.length === 40) return dse(_O(e))
    }
    throw Kt.rpc.invalidParams(`Invalid Ethereum address: ${String(t)}`)
}

function L3(t) {
    if (Ve.isBuffer(t)) return t;
    if (typeof t == "string") {
        if (ny(t)) {
            const e = Q6(t, !1);
            return Ve.from(e, "hex")
        }
        return Ve.from(t, "utf8")
    }
    throw Kt.rpc.invalidParams(`Not binary data: ${String(t)}`)
}

function Df(t) {
    if (typeof t == "number" && Number.isInteger(t)) return Ro(t);
    if (typeof t == "string") {
        if (vO.test(t)) return Ro(Number(t));
        if (ny(t)) return Ro(Number(BigInt(Q6(t, !0))))
    }
    throw Kt.rpc.invalidParams(`Not an integer: ${String(t)}`)
}

function Vh(t) {
    if (t !== null && (typeof t == "bigint" || pse(t))) return BigInt(t.toString(10));
    if (typeof t == "number") return BigInt(Df(t));
    if (typeof t == "string") {
        if (vO.test(t)) return BigInt(t);
        if (ny(t)) return BigInt(Q6(t, !0))
    }
    throw Kt.rpc.invalidParams(`Not an integer: ${String(t)}`)
}

function fse(t) {
    if (typeof t == "string") return JSON.parse(t);
    if (typeof t == "object") return t;
    throw Kt.rpc.invalidParams(`Not a JSON string or an object: ${String(t)}`)
}

function pse(t) {
    if (t == null || typeof t.constructor != "function") return !1;
    const {
        constructor: e
    } = t;
    return typeof e.config == "function" && typeof e.EUCLID == "number"
}
async function gse() {
    return crypto.subtle.generateKey({
        name: "ECDH",
        namedCurve: "P-256"
    }, !0, ["deriveKey"])
}
async function mse(t, e) {
    return crypto.subtle.deriveKey({
        name: "ECDH",
        public: e
    }, t, {
        name: "AES-GCM",
        length: 256
    }, !1, ["encrypt", "decrypt"])
}
async function yse(t, e) {
    const r = crypto.getRandomValues(new Uint8Array(12)),
        n = await crypto.subtle.encrypt({
            name: "AES-GCM",
            iv: r
        }, t, new TextEncoder().encode(e));
    return {
        iv: r,
        cipherText: n
    }
}
async function wse(t, {
    iv: e,
    cipherText: r
}) {
    const n = await crypto.subtle.decrypt({
        name: "AES-GCM",
        iv: e
    }, t, r);
    return new TextDecoder().decode(n)
}

function CO(t) {
    switch (t) {
        case "public":
            return "spki";
        case "private":
            return "pkcs8"
    }
}
async function AO(t, e) {
    const r = CO(t),
        n = await crypto.subtle.exportKey(r, e);
    return Z6(new Uint8Array(n))
}
async function kO(t, e) {
    const r = CO(t),
        n = Gg(e).buffer;
    return await crypto.subtle.importKey(r, new Uint8Array(n), {
        name: "ECDH",
        namedCurve: "P-256"
    }, !0, t === "private" ? ["deriveKey"] : [])
}
async function bse(t, e) {
    const r = JSON.stringify(t, (n, i) => {
        if (!(i instanceof Error)) return i;
        const s = i;
        return Object.assign(Object.assign({}, s.code ? {
            code: s.code
        } : {}), {
            message: s.message
        })
    });
    return yse(e, r)
}
async function vse(t, e) {
    return JSON.parse(await wse(e, t))
}
const v2 = {
        storageKey: "ownPrivateKey",
        keyType: "private"
    },
    x2 = {
        storageKey: "ownPublicKey",
        keyType: "public"
    },
    E2 = {
        storageKey: "peerPublicKey",
        keyType: "public"
    };
class xse {
    constructor() {
        this.storage = new uo("CBWSDK", "SCWKeyManager"), this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null
    }
    async getOwnPublicKey() {
        return await this.loadKeysIfNeeded(), this.ownPublicKey
    }
    async getSharedSecret() {
        return await this.loadKeysIfNeeded(), this.sharedSecret
    }
    async setPeerPublicKey(e) {
        this.sharedSecret = null, this.peerPublicKey = e, await this.storeKey(E2, e), await this.loadKeysIfNeeded()
    }
    async clear() {
        this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null, this.storage.removeItem(x2.storageKey), this.storage.removeItem(v2.storageKey), this.storage.removeItem(E2.storageKey)
    }
    async generateKeyPair() {
        const e = await gse();
        this.ownPrivateKey = e.privateKey, this.ownPublicKey = e.publicKey, await this.storeKey(v2, e.privateKey), await this.storeKey(x2, e.publicKey)
    }
    async loadKeysIfNeeded() {
        if (this.ownPrivateKey === null && (this.ownPrivateKey = await this.loadKey(v2)), this.ownPublicKey === null && (this.ownPublicKey = await this.loadKey(x2)), (this.ownPrivateKey === null || this.ownPublicKey === null) && await this.generateKeyPair(), this.peerPublicKey === null && (this.peerPublicKey = await this.loadKey(E2)), this.sharedSecret === null) {
            if (this.ownPrivateKey === null || this.peerPublicKey === null) return;
            this.sharedSecret = await mse(this.ownPrivateKey, this.peerPublicKey)
        }
    }
    async loadKey(e) {
        const r = this.storage.getItem(e.storageKey);
        return r ? kO(e.keyType, r) : null
    }
    async storeKey(e, r) {
        const n = await AO(e.keyType, r);
        this.storage.setItem(e.storageKey, n)
    }
}
const d0 = "4.3.2",
    IO = "@coinbase/wallet-sdk";
async function X6(t, e) {
    const r = Object.assign(Object.assign({}, t), {
            jsonrpc: "2.0",
            id: crypto.randomUUID()
        }),
        n = await window.fetch(e, {
            method: "POST",
            body: JSON.stringify(r),
            mode: "cors",
            headers: {
                "Content-Type": "application/json",
                "X-Cbw-Sdk-Version": d0,
                "X-Cbw-Sdk-Platform": IO
            }
        }),
        {
            result: i,
            error: s
        } = await n.json();
    if (s) throw s;
    return i
}

function Ese() {
    return globalThis.coinbaseWalletExtension
}

function _se() {
    var t, e;
    try {
        const r = globalThis;
        return (t = r.ethereum) !== null && t !== void 0 ? t : (e = r.top) === null || e === void 0 ? void 0 : e.ethereum
    } catch {
        return
    }
}

function Cse({
    metadata: t,
    preference: e
}) {
    var r, n;
    const {
        appName: i,
        appLogoUrl: s,
        appChainIds: a
    } = t;
    if (e.options !== "smartWalletOnly") {
        const c = Ese();
        if (c) return (r = c.setAppInfo) === null || r === void 0 || r.call(c, i, s, a, e), c
    }
    const o = _se();
    if (o != null && o.isCoinbaseBrowser) return (n = o.setAppInfo) === null || n === void 0 || n.call(o, i, s, a, e), o
}

function Ase(t) {
    if (!t || typeof t != "object" || Array.isArray(t)) throw Kt.rpc.invalidParams({
        message: "Expected a single, non-array, object argument.",
        data: t
    });
    const {
        method: e,
        params: r
    } = t;
    if (typeof e != "string" || e.length === 0) throw Kt.rpc.invalidParams({
        message: "'args.method' must be a non-empty string.",
        data: t
    });
    if (r !== void 0 && !Array.isArray(r) && (typeof r != "object" || r === null)) throw Kt.rpc.invalidParams({
        message: "'args.params' must be an object or array if provided.",
        data: t
    });
    switch (e) {
        case "eth_sign":
        case "eth_signTypedData_v2":
        case "eth_subscribe":
        case "eth_unsubscribe":
            throw Kt.provider.unsupportedMethod()
    }
}
const T_ = "accounts",
    P_ = "activeChain",
    N_ = "availableChains",
    O_ = "walletCapabilities";
class kse {
    constructor(e) {
        var r, n, i;
        this.metadata = e.metadata, this.communicator = e.communicator, this.callback = e.callback, this.keyManager = new xse, this.storage = new uo("CBWSDK", "SCWStateManager"), this.accounts = (r = this.storage.loadObject(T_)) !== null && r !== void 0 ? r : [], this.chain = this.storage.loadObject(P_) || {
            id: (i = (n = e.metadata.appChainIds) === null || n === void 0 ? void 0 : n[0]) !== null && i !== void 0 ? i : 1
        }, this.handshake = this.handshake.bind(this), this.request = this.request.bind(this), this.createRequestMessage = this.createRequestMessage.bind(this), this.decryptResponseMessage = this.decryptResponseMessage.bind(this)
    }
    async handshake(e) {
        var r, n, i, s;
        await ((n = (r = this.communicator).waitForPopupLoaded) === null || n === void 0 ? void 0 : n.call(r));
        const a = await this.createRequestMessage({
                handshake: {
                    method: e.method,
                    params: Object.assign({}, this.metadata, (i = e.params) !== null && i !== void 0 ? i : {})
                }
            }),
            o = await this.communicator.postRequestAndWaitForResponse(a);
        if ("failure" in o.content) throw o.content.failure;
        const c = await kO("public", o.sender);
        await this.keyManager.setPeerPublicKey(c);
        const u = (await this.decryptResponseMessage(o)).result;
        if ("error" in u) throw u.error;
        switch (e.method) {
            case "eth_requestAccounts":
                {
                    const h = u.value;this.accounts = h,
                    this.storage.storeObject(T_, h),
                    (s = this.callback) === null || s === void 0 || s.call(this, "accountsChanged", h);
                    break
                }
        }
    }
    async request(e) {
        var r;
        if (this.accounts.length === 0) switch (e.method) {
            case "wallet_sendCalls":
                return this.sendRequestToPopup(e);
            default:
                throw Kt.provider.unauthorized()
        }
        switch (e.method) {
            case "eth_requestAccounts":
                return (r = this.callback) === null || r === void 0 || r.call(this, "connect", {
                    chainId: Vc(this.chain.id)
                }), this.accounts;
            case "eth_accounts":
                return this.accounts;
            case "eth_coinbase":
                return this.accounts[0];
            case "net_version":
                return this.chain.id;
            case "eth_chainId":
                return Vc(this.chain.id);
            case "wallet_getCapabilities":
                return this.storage.loadObject(O_);
            case "wallet_switchEthereumChain":
                return this.handleSwitchChainRequest(e);
            case "eth_ecRecover":
            case "personal_sign":
            case "wallet_sign":
            case "personal_ecRecover":
            case "eth_signTransaction":
            case "eth_sendTransaction":
            case "eth_signTypedData_v1":
            case "eth_signTypedData_v3":
            case "eth_signTypedData_v4":
            case "eth_signTypedData":
            case "wallet_addEthereumChain":
            case "wallet_watchAsset":
            case "wallet_sendCalls":
            case "wallet_showCallsStatus":
            case "wallet_grantPermissions":
                return this.sendRequestToPopup(e);
            default:
                if (!this.chain.rpcUrl) throw Kt.rpc.internal("No RPC URL set for chain");
                return X6(e, this.chain.rpcUrl)
        }
    }
    async sendRequestToPopup(e) {
        var r, n;
        await ((n = (r = this.communicator).waitForPopupLoaded) === null || n === void 0 ? void 0 : n.call(r));
        const i = await this.sendEncryptedRequest(e),
            a = (await this.decryptResponseMessage(i)).result;
        if ("error" in a) throw a.error;
        return a.value
    }
    async cleanup() {
        var e, r;
        this.storage.clear(), await this.keyManager.clear(), this.accounts = [], this.chain = {
            id: (r = (e = this.metadata.appChainIds) === null || e === void 0 ? void 0 : e[0]) !== null && r !== void 0 ? r : 1
        }
    }
    async handleSwitchChainRequest(e) {
        var r;
        const n = e.params;
        if (!n || !(!((r = n[0]) === null || r === void 0) && r.chainId)) throw Kt.rpc.invalidParams();
        const i = Df(n[0].chainId);
        if (this.updateChain(i)) return null;
        const a = await this.sendRequestToPopup(e);
        return a === null && this.updateChain(i), a
    }
    async sendEncryptedRequest(e) {
        const r = await this.keyManager.getSharedSecret();
        if (!r) throw Kt.provider.unauthorized("No valid session found, try requestAccounts before other methods");
        const n = await bse({
                action: e,
                chainId: this.chain.id
            }, r),
            i = await this.createRequestMessage({
                encrypted: n
            });
        return this.communicator.postRequestAndWaitForResponse(i)
    }
    async createRequestMessage(e) {
        const r = await AO("public", await this.keyManager.getOwnPublicKey());
        return {
            id: crypto.randomUUID(),
            sender: r,
            content: e,
            timestamp: new Date
        }
    }
    async decryptResponseMessage(e) {
        var r, n;
        const i = e.content;
        if ("failure" in i) throw i.failure;
        const s = await this.keyManager.getSharedSecret();
        if (!s) throw Kt.provider.unauthorized("Invalid session");
        const a = await vse(i.encrypted, s),
            o = (r = a.data) === null || r === void 0 ? void 0 : r.chains;
        if (o) {
            const l = Object.entries(o).map(([u, h]) => ({
                id: Number(u),
                rpcUrl: h
            }));
            this.storage.storeObject(N_, l), this.updateChain(this.chain.id, l)
        }
        const c = (n = a.data) === null || n === void 0 ? void 0 : n.capabilities;
        return c && this.storage.storeObject(O_, c), a
    }
    updateChain(e, r) {
        var n;
        const i = r ? ? this.storage.loadObject(N_),
            s = i == null ? void 0 : i.find(a => a.id === e);
        return s ? (s !== this.chain && (this.chain = s, this.storage.storeObject(P_, s), (n = this.callback) === null || n === void 0 || n.call(this, "chainChanged", Vc(s.id))), !0) : !1
    }
}
var yr = {},
    Ct = {},
    j_;

function Ise() {
    if (j_) return Ct;
    j_ = 1, Object.defineProperty(Ct, "__esModule", {
        value: !0
    }), Ct.toBig = Ct.shrSL = Ct.shrSH = Ct.rotrSL = Ct.rotrSH = Ct.rotrBL = Ct.rotrBH = Ct.rotr32L = Ct.rotr32H = Ct.rotlSL = Ct.rotlSH = Ct.rotlBL = Ct.rotlBH = Ct.add5L = Ct.add5H = Ct.add4L = Ct.add4H = Ct.add3L = Ct.add3H = void 0, Ct.add = w, Ct.fromBig = r, Ct.split = n;
    const t = BigInt(2 ** 32 - 1),
        e = BigInt(32);

    function r(C, $ = !1) {
        return $ ? {
            h: Number(C & t),
            l: Number(C >> e & t)
        } : {
            h: Number(C >> e & t) | 0,
            l: Number(C & t) | 0
        }
    }

    function n(C, $ = !1) {
        const P = C.length;
        let N = new Uint32Array(P),
            R = new Uint32Array(P);
        for (let D = 0; D < P; D++) {
            const {
                h: S,
                l: O
            } = r(C[D], $);
            [N[D], R[D]] = [S, O]
        }
        return [N, R]
    }
    const i = (C, $) => BigInt(C >>> 0) << e | BigInt($ >>> 0);
    Ct.toBig = i;
    const s = (C, $, P) => C >>> P;
    Ct.shrSH = s;
    const a = (C, $, P) => C << 32 - P | $ >>> P;
    Ct.shrSL = a;
    const o = (C, $, P) => C >>> P | $ << 32 - P;
    Ct.rotrSH = o;
    const c = (C, $, P) => C << 32 - P | $ >>> P;
    Ct.rotrSL = c;
    const l = (C, $, P) => C << 64 - P | $ >>> P - 32;
    Ct.rotrBH = l;
    const u = (C, $, P) => C >>> P - 32 | $ << 64 - P;
    Ct.rotrBL = u;
    const h = (C, $) => $;
    Ct.rotr32H = h;
    const f = (C, $) => C;
    Ct.rotr32L = f;
    const p = (C, $, P) => C << P | $ >>> 32 - P;
    Ct.rotlSH = p;
    const g = (C, $, P) => $ << P | C >>> 32 - P;
    Ct.rotlSL = g;
    const m = (C, $, P) => $ << P - 32 | C >>> 64 - P;
    Ct.rotlBH = m;
    const y = (C, $, P) => C << P - 32 | $ >>> 64 - P;
    Ct.rotlBL = y;

    function w(C, $, P, N) {
        const R = ($ >>> 0) + (N >>> 0);
        return {
            h: C + P + (R / 2 ** 32 | 0) | 0,
            l: R | 0
        }
    }
    const x = (C, $, P) => (C >>> 0) + ($ >>> 0) + (P >>> 0);
    Ct.add3L = x;
    const E = (C, $, P, N) => $ + P + N + (C / 2 ** 32 | 0) | 0;
    Ct.add3H = E;
    const _ = (C, $, P, N) => (C >>> 0) + ($ >>> 0) + (P >>> 0) + (N >>> 0);
    Ct.add4L = _;
    const b = (C, $, P, N, R) => $ + P + N + R + (C / 2 ** 32 | 0) | 0;
    Ct.add4H = b;
    const A = (C, $, P, N, R) => (C >>> 0) + ($ >>> 0) + (P >>> 0) + (N >>> 0) + (R >>> 0);
    Ct.add5L = A;
    const I = (C, $, P, N, R, D) => $ + P + N + R + D + (C / 2 ** 32 | 0) | 0;
    Ct.add5H = I;
    const T = {
        fromBig: r,
        split: n,
        toBig: i,
        shrSH: s,
        shrSL: a,
        rotrSH: o,
        rotrSL: c,
        rotrBH: l,
        rotrBL: u,
        rotr32H: h,
        rotr32L: f,
        rotlSH: p,
        rotlSL: g,
        rotlBH: m,
        rotlBL: y,
        add: w,
        add3L: x,
        add3H: E,
        add4L: _,
        add4H: b,
        add5H: I,
        add5L: A
    };
    return Ct.default = T, Ct
}
var _2 = {},
    Gh = {},
    R_;

function $se() {
    return R_ || (R_ = 1, Object.defineProperty(Gh, "__esModule", {
        value: !0
    }), Gh.crypto = void 0, Gh.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0), Gh
}
var M_;

function Sse() {
    return M_ || (M_ = 1, function(t) { /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.wrapXOFConstructorWithOpts = t.wrapConstructorWithOpts = t.wrapConstructor = t.Hash = t.nextTick = t.swap32IfBE = t.byteSwapIfBE = t.swap8IfBE = t.isLE = void 0, t.isBytes = r, t.anumber = n, t.abytes = i, t.ahash = s, t.aexists = a, t.aoutput = o, t.u8 = c, t.u32 = l, t.clean = u, t.createView = h, t.rotr = f, t.rotl = p, t.byteSwap = g, t.byteSwap32 = m, t.bytesToHex = x, t.hexToBytes = b, t.asyncLoop = I, t.utf8ToBytes = T, t.bytesToUtf8 = C, t.toBytes = $, t.kdfInputToBytes = P, t.concatBytes = N, t.checkOpts = R, t.createHasher = S, t.createOptHasher = O, t.createXOFer = M, t.randomBytes = U;
        const e = $se();

        function r(k) {
            return k instanceof Uint8Array || ArrayBuffer.isView(k) && k.constructor.name === "Uint8Array"
        }

        function n(k) {
            if (!Number.isSafeInteger(k) || k < 0) throw new Error("positive integer expected, got " + k)
        }

        function i(k, ...F) {
            if (!r(k)) throw new Error("Uint8Array expected");
            if (F.length > 0 && !F.includes(k.length)) throw new Error("Uint8Array expected of length " + F + ", got length=" + k.length)
        }

        function s(k) {
            if (typeof k != "function" || typeof k.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
            n(k.outputLen), n(k.blockLen)
        }

        function a(k, F = !0) {
            if (k.destroyed) throw new Error("Hash instance has been destroyed");
            if (F && k.finished) throw new Error("Hash#digest() has already been called")
        }

        function o(k, F) {
            i(k);
            const q = F.outputLen;
            if (k.length < q) throw new Error("digestInto() expects output buffer of length at least " + q)
        }

        function c(k) {
            return new Uint8Array(k.buffer, k.byteOffset, k.byteLength)
        }

        function l(k) {
            return new Uint32Array(k.buffer, k.byteOffset, Math.floor(k.byteLength / 4))
        }

        function u(...k) {
            for (let F = 0; F < k.length; F++) k[F].fill(0)
        }

        function h(k) {
            return new DataView(k.buffer, k.byteOffset, k.byteLength)
        }

        function f(k, F) {
            return k << 32 - F | k >>> F
        }

        function p(k, F) {
            return k << F | k >>> 32 - F >>> 0
        }
        t.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;

        function g(k) {
            return k << 24 & 4278190080 | k << 8 & 16711680 | k >>> 8 & 65280 | k >>> 24 & 255
        }
        t.swap8IfBE = t.isLE ? k => k : k => g(k), t.byteSwapIfBE = t.swap8IfBE;

        function m(k) {
            for (let F = 0; F < k.length; F++) k[F] = g(k[F]);
            return k
        }
        t.swap32IfBE = t.isLE ? k => k : m;
        const y = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function",
            w = Array.from({
                length: 256
            }, (k, F) => F.toString(16).padStart(2, "0"));

        function x(k) {
            if (i(k), y) return k.toHex();
            let F = "";
            for (let q = 0; q < k.length; q++) F += w[k[q]];
            return F
        }
        const E = {
            _0: 48,
            _9: 57,
            A: 65,
            F: 70,
            a: 97,
            f: 102
        };

        function _(k) {
            if (k >= E._0 && k <= E._9) return k - E._0;
            if (k >= E.A && k <= E.F) return k - (E.A - 10);
            if (k >= E.a && k <= E.f) return k - (E.a - 10)
        }

        function b(k) {
            if (typeof k != "string") throw new Error("hex string expected, got " + typeof k);
            if (y) return Uint8Array.fromHex(k);
            const F = k.length,
                q = F / 2;
            if (F % 2) throw new Error("hex string expected, got unpadded hex of length " + F);
            const W = new Uint8Array(q);
            for (let K = 0, H = 0; K < q; K++, H += 2) {
                const j = _(k.charCodeAt(H)),
                    V = _(k.charCodeAt(H + 1));
                if (j === void 0 || V === void 0) {
                    const Y = k[H] + k[H + 1];
                    throw new Error('hex string expected, got non-hex character "' + Y + '" at index ' + H)
                }
                W[K] = j * 16 + V
            }
            return W
        }
        const A = async () => {};
        t.nextTick = A;
        async function I(k, F, q) {
            let W = Date.now();
            for (let K = 0; K < k; K++) {
                q(K);
                const H = Date.now() - W;
                H >= 0 && H < F || (await (0, t.nextTick)(), W += H)
            }
        }

        function T(k) {
            if (typeof k != "string") throw new Error("string expected");
            return new Uint8Array(new TextEncoder().encode(k))
        }

        function C(k) {
            return new TextDecoder().decode(k)
        }

        function $(k) {
            return typeof k == "string" && (k = T(k)), i(k), k
        }

        function P(k) {
            return typeof k == "string" && (k = T(k)), i(k), k
        }

        function N(...k) {
            let F = 0;
            for (let W = 0; W < k.length; W++) {
                const K = k[W];
                i(K), F += K.length
            }
            const q = new Uint8Array(F);
            for (let W = 0, K = 0; W < k.length; W++) {
                const H = k[W];
                q.set(H, K), K += H.length
            }
            return q
        }

        function R(k, F) {
            if (F !== void 0 && {}.toString.call(F) !== "[object Object]") throw new Error("options should be object or undefined");
            return Object.assign(k, F)
        }
        class D {}
        t.Hash = D;

        function S(k) {
            const F = W => k().update($(W)).digest(),
                q = k();
            return F.outputLen = q.outputLen, F.blockLen = q.blockLen, F.create = () => k(), F
        }

        function O(k) {
            const F = (W, K) => k(K).update($(W)).digest(),
                q = k({});
            return F.outputLen = q.outputLen, F.blockLen = q.blockLen, F.create = W => k(W), F
        }

        function M(k) {
            const F = (W, K) => k(K).update($(W)).digest(),
                q = k({});
            return F.outputLen = q.outputLen, F.blockLen = q.blockLen, F.create = W => k(W), F
        }
        t.wrapConstructor = S, t.wrapConstructorWithOpts = O, t.wrapXOFConstructorWithOpts = M;

        function U(k = 32) {
            if (e.crypto && typeof e.crypto.getRandomValues == "function") return e.crypto.getRandomValues(new Uint8Array(k));
            if (e.crypto && typeof e.crypto.randomBytes == "function") return Uint8Array.from(e.crypto.randomBytes(k));
            throw new Error("crypto.getRandomValues must be defined")
        }
    }(_2)), _2
}
var D_;

function Tse() {
    if (D_) return yr;
    D_ = 1, Object.defineProperty(yr, "__esModule", {
        value: !0
    }), yr.shake256 = yr.shake128 = yr.keccak_512 = yr.keccak_384 = yr.keccak_256 = yr.keccak_224 = yr.sha3_512 = yr.sha3_384 = yr.sha3_256 = yr.sha3_224 = yr.Keccak = void 0, yr.keccakP = y;
    const t = Ise(),
        e = Sse(),
        r = BigInt(0),
        n = BigInt(1),
        i = BigInt(2),
        s = BigInt(7),
        a = BigInt(256),
        o = BigInt(113),
        c = [],
        l = [],
        u = [];
    for (let _ = 0, b = n, A = 1, I = 0; _ < 24; _++) {
        [A, I] = [I, (2 * A + 3 * I) % 5], c.push(2 * (5 * I + A)), l.push((_ + 1) * (_ + 2) / 2 % 64);
        let T = r;
        for (let C = 0; C < 7; C++) b = (b << n ^ (b >> s) * o) % a, b & i && (T ^= n << (n << BigInt(C)) - n);
        u.push(T)
    }
    const h = (0, t.split)(u, !0),
        f = h[0],
        p = h[1],
        g = (_, b, A) => A > 32 ? (0, t.rotlBH)(_, b, A) : (0, t.rotlSH)(_, b, A),
        m = (_, b, A) => A > 32 ? (0, t.rotlBL)(_, b, A) : (0, t.rotlSL)(_, b, A);

    function y(_, b = 24) {
        const A = new Uint32Array(10);
        for (let I = 24 - b; I < 24; I++) {
            for (let $ = 0; $ < 10; $++) A[$] = _[$] ^ _[$ + 10] ^ _[$ + 20] ^ _[$ + 30] ^ _[$ + 40];
            for (let $ = 0; $ < 10; $ += 2) {
                const P = ($ + 8) % 10,
                    N = ($ + 2) % 10,
                    R = A[N],
                    D = A[N + 1],
                    S = g(R, D, 1) ^ A[P],
                    O = m(R, D, 1) ^ A[P + 1];
                for (let M = 0; M < 50; M += 10) _[$ + M] ^= S, _[$ + M + 1] ^= O
            }
            let T = _[2],
                C = _[3];
            for (let $ = 0; $ < 24; $++) {
                const P = l[$],
                    N = g(T, C, P),
                    R = m(T, C, P),
                    D = c[$];
                T = _[D], C = _[D + 1], _[D] = N, _[D + 1] = R
            }
            for (let $ = 0; $ < 50; $ += 10) {
                for (let P = 0; P < 10; P++) A[P] = _[$ + P];
                for (let P = 0; P < 10; P++) _[$ + P] ^= ~A[(P + 2) % 10] & A[(P + 4) % 10]
            }
            _[0] ^= f[I], _[1] ^= p[I]
        }(0, e.clean)(A)
    }
    class w extends e.Hash {
        constructor(b, A, I, T = !1, C = 24) {
            if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = b, this.suffix = A, this.outputLen = I, this.enableXOF = T, this.rounds = C, (0, e.anumber)(I), !(0 < b && b < 200)) throw new Error("only keccak-f1600 function is supported");
            this.state = new Uint8Array(200), this.state32 = (0, e.u32)(this.state)
        }
        clone() {
            return this._cloneInto()
        }
        keccak() {
            (0, e.swap32IfBE)(this.state32), y(this.state32, this.rounds), (0, e.swap32IfBE)(this.state32), this.posOut = 0, this.pos = 0
        }
        update(b) {
            (0, e.aexists)(this), b = (0, e.toBytes)(b), (0, e.abytes)(b);
            const {
                blockLen: A,
                state: I
            } = this, T = b.length;
            for (let C = 0; C < T;) {
                const $ = Math.min(A - this.pos, T - C);
                for (let P = 0; P < $; P++) I[this.pos++] ^= b[C++];
                this.pos === A && this.keccak()
            }
            return this
        }
        finish() {
            if (this.finished) return;
            this.finished = !0;
            const {
                state: b,
                suffix: A,
                pos: I,
                blockLen: T
            } = this;
            b[I] ^= A, (A & 128) !== 0 && I === T - 1 && this.keccak(), b[T - 1] ^= 128, this.keccak()
        }
        writeInto(b) {
            (0, e.aexists)(this, !1), (0, e.abytes)(b), this.finish();
            const A = this.state,
                {
                    blockLen: I
                } = this;
            for (let T = 0, C = b.length; T < C;) {
                this.posOut >= I && this.keccak();
                const $ = Math.min(I - this.posOut, C - T);
                b.set(A.subarray(this.posOut, this.posOut + $), T), this.posOut += $, T += $
            }
            return b
        }
        xofInto(b) {
            if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
            return this.writeInto(b)
        }
        xof(b) {
            return (0, e.anumber)(b), this.xofInto(new Uint8Array(b))
        }
        digestInto(b) {
            if ((0, e.aoutput)(b, this), this.finished) throw new Error("digest() was already called");
            return this.writeInto(b), this.destroy(), b
        }
        digest() {
            return this.digestInto(new Uint8Array(this.outputLen))
        }
        destroy() {
            this.destroyed = !0, (0, e.clean)(this.state)
        }
        _cloneInto(b) {
            const {
                blockLen: A,
                suffix: I,
                outputLen: T,
                rounds: C,
                enableXOF: $
            } = this;
            return b || (b = new w(A, I, T, $, C)), b.state32.set(this.state32), b.pos = this.pos, b.posOut = this.posOut, b.finished = this.finished, b.rounds = C, b.suffix = I, b.outputLen = T, b.enableXOF = $, b.destroyed = this.destroyed, b
        }
    }
    yr.Keccak = w;
    const x = (_, b, A) => (0, e.createHasher)(() => new w(b, _, A));
    yr.sha3_224 = x(6, 144, 224 / 8), yr.sha3_256 = x(6, 136, 256 / 8), yr.sha3_384 = x(6, 104, 384 / 8), yr.sha3_512 = x(6, 72, 512 / 8), yr.keccak_224 = x(1, 144, 224 / 8), yr.keccak_256 = x(1, 136, 256 / 8), yr.keccak_384 = x(1, 104, 384 / 8), yr.keccak_512 = x(1, 72, 512 / 8);
    const E = (_, b, A) => (0, e.createXOFer)((I = {}) => new w(b, _, I.dkLen === void 0 ? A : I.dkLen, !0));
    return yr.shake128 = E(31, 168, 128 / 8), yr.shake256 = E(31, 136, 256 / 8), yr
}
var C2, L_;

function $O() {
    if (L_) return C2;
    L_ = 1;
    const {
        keccak_256: t
    } = Tse();

    function e(p) {
        return Ve.allocUnsafe(p).fill(0)
    }

    function r(p) {
        return p.toString(2).length
    }

    function n(p, g) {
        let m = p.toString(16);
        m.length % 2 !== 0 && (m = "0" + m);
        const y = m.match(/.{1,2}/g).map(w => parseInt(w, 16));
        for (; y.length < g;) y.unshift(0);
        return Ve.from(y)
    }

    function i(p, g) {
        const m = p < 0 n;
        let y;
        if (m) {
            const w = (1 n << BigInt(g)) - 1 n;
            y = (~p & w) + 1 n
        } else y = p;
        return y &= (1 n << BigInt(g)) - 1 n, y
    }

    function s(p, g, m) {
        const y = e(g);
        return p = o(p), m ? p.length < g ? (p.copy(y), y) : p.slice(0, g) : p.length < g ? (p.copy(y, g - p.length), y) : p.slice(-g)
    }

    function a(p, g) {
        return s(p, g, !0)
    }

    function o(p) {
        if (!Ve.isBuffer(p))
            if (Array.isArray(p)) p = Ve.from(p);
            else if (typeof p == "string") h(p) ? p = Ve.from(u(f(p)), "hex") : p = Ve.from(p);
        else if (typeof p == "number") p = intToBuffer(p);
        else if (p == null) p = Ve.allocUnsafe(0);
        else if (typeof p == "bigint") p = n(p);
        else if (p.toArray) p = Ve.from(p.toArray());
        else throw new Error("invalid type");
        return p
    }

    function c(p) {
        return p = o(p), "0x" + p.toString("hex")
    }

    function l(p, g) {
        if (p = o(p), g || (g = 256), g !== 256) throw new Error("unsupported");
        return Ve.from(t(new Uint8Array(p)))
    }

    function u(p) {
        return p.length % 2 ? "0" + p : p
    }

    function h(p) {
        return typeof p == "string" && p.match(/^0x[0-9A-Fa-f]*$/)
    }

    function f(p) {
        return typeof p == "string" && p.startsWith("0x") ? p.slice(2) : p
    }
    return C2 = {
        zeros: e,
        setLength: s,
        setLengthRight: a,
        isHexString: h,
        stripHexPrefix: f,
        toBuffer: o,
        bufferToHex: c,
        keccak: l,
        bitLengthFromBigInt: r,
        bufferBEFromBigInt: n,
        twosFromBigInt: i
    }, C2
}
var A2, U_;

function Pse() {
    if (U_) return A2;
    U_ = 1;
    const t = $O();

    function e(f) {
        return f.startsWith("int[") ? "int256" + f.slice(3) : f === "int" ? "int256" : f.startsWith("uint[") ? "uint256" + f.slice(4) : f === "uint" ? "uint256" : f.startsWith("fixed[") ? "fixed128x128" + f.slice(5) : f === "fixed" ? "fixed128x128" : f.startsWith("ufixed[") ? "ufixed128x128" + f.slice(6) : f === "ufixed" ? "ufixed128x128" : f
    }

    function r(f) {
        return Number.parseInt(/^\D+(\d+)$/.exec(f)[1], 10)
    }

    function n(f) {
        var p = /^\D+(\d+)x(\d+)$/.exec(f);
        return [Number.parseInt(p[1], 10), Number.parseInt(p[2], 10)]
    }

    function i(f) {
        var p = f.match(/(.*)\[(.*?)\]$/);
        return p ? p[2] === "" ? "dynamic" : Number.parseInt(p[2], 10) : null
    }

    function s(f) {
        var p = typeof f;
        if (p === "string" || p === "number") return BigInt(f);
        if (p === "bigint") return f;
        throw new Error("Argument is not a number")
    }

    function a(f, p) {
        var g, m, y, w;
        if (f === "address") return a("uint160", s(p));
        if (f === "bool") return a("uint8", p ? 1 : 0);
        if (f === "string") return a("bytes", new Ve(p, "utf8"));
        if (c(f)) {
            if (typeof p.length > "u") throw new Error("Not an array?");
            if (g = i(f), g !== "dynamic" && g !== 0 && p.length > g) throw new Error("Elements exceed array size: " + g);
            y = [], f = f.slice(0, f.lastIndexOf("[")), typeof p == "string" && (p = JSON.parse(p));
            for (w in p) y.push(a(f, p[w]));
            if (g === "dynamic") {
                var x = a("uint256", p.length);
                y.unshift(x)
            }
            return Ve.concat(y)
        } else {
            if (f === "bytes") return p = new Ve(p), y = Ve.concat([a("uint256", p.length), p]), p.length % 32 !== 0 && (y = Ve.concat([y, t.zeros(32 - p.length % 32)])), y;
            if (f.startsWith("bytes")) {
                if (g = r(f), g < 1 || g > 32) throw new Error("Invalid bytes<N> width: " + g);
                return t.setLengthRight(p, 32)
            } else if (f.startsWith("uint")) {
                if (g = r(f), g % 8 || g < 8 || g > 256) throw new Error("Invalid uint<N> width: " + g);
                m = s(p);
                const E = t.bitLengthFromBigInt(m);
                if (E > g) throw new Error("Supplied uint exceeds width: " + g + " vs " + E);
                if (m < 0) throw new Error("Supplied uint is negative");
                return t.bufferBEFromBigInt(m, 32)
            } else if (f.startsWith("int")) {
                if (g = r(f), g % 8 || g < 8 || g > 256) throw new Error("Invalid int<N> width: " + g);
                m = s(p);
                const E = t.bitLengthFromBigInt(m);
                if (E > g) throw new Error("Supplied int exceeds width: " + g + " vs " + E);
                const _ = t.twosFromBigInt(m, 256);
                return t.bufferBEFromBigInt(_, 32)
            } else if (f.startsWith("ufixed")) {
                if (g = n(f), m = s(p), m < 0) throw new Error("Supplied ufixed is negative");
                return a("uint256", m * BigInt(2) ** BigInt(g[1]))
            } else if (f.startsWith("fixed")) return g = n(f), a("int256", s(p) * BigInt(2) ** BigInt(g[1]))
        }
        throw new Error("Unsupported or invalid type: " + f)
    }

    function o(f) {
        return f === "string" || f === "bytes" || i(f) === "dynamic"
    }

    function c(f) {
        return f.lastIndexOf("]") === f.length - 1
    }

    function l(f, p) {
        var g = [],
            m = [],
            y = 32 * f.length;
        for (var w in f) {
            var x = e(f[w]),
                E = p[w],
                _ = a(x, E);
            o(x) ? (g.push(a("uint256", y)), m.push(_), y += _.length) : g.push(_)
        }
        return Ve.concat(g.concat(m))
    }

    function u(f, p) {
        if (f.length !== p.length) throw new Error("Number of types are not matching the values");
        for (var g, m, y = [], w = 0; w < f.length; w++) {
            var x = e(f[w]),
                E = p[w];
            if (x === "bytes") y.push(E);
            else if (x === "string") y.push(new Ve(E, "utf8"));
            else if (x === "bool") y.push(new Ve(E ? "01" : "00", "hex"));
            else if (x === "address") y.push(t.setLength(E, 20));
            else if (x.startsWith("bytes")) {
                if (g = r(x), g < 1 || g > 32) throw new Error("Invalid bytes<N> width: " + g);
                y.push(t.setLengthRight(E, g))
            } else if (x.startsWith("uint")) {
                if (g = r(x), g % 8 || g < 8 || g > 256) throw new Error("Invalid uint<N> width: " + g);
                m = s(E);
                const _ = t.bitLengthFromBigInt(m);
                if (_ > g) throw new Error("Supplied uint exceeds width: " + g + " vs " + _);
                y.push(t.bufferBEFromBigInt(m, g / 8))
            } else if (x.startsWith("int")) {
                if (g = r(x), g % 8 || g < 8 || g > 256) throw new Error("Invalid int<N> width: " + g);
                m = s(E);
                const _ = t.bitLengthFromBigInt(m);
                if (_ > g) throw new Error("Supplied int exceeds width: " + g + " vs " + _);
                const b = t.twosFromBigInt(m, g);
                y.push(t.bufferBEFromBigInt(b, g / 8))
            } else throw new Error("Unsupported or invalid type: " + x)
        }
        return Ve.concat(y)
    }

    function h(f, p) {
        return t.keccak(u(f, p))
    }
    return A2 = {
        rawEncode: l,
        solidityPack: u,
        soliditySHA3: h
    }, A2
}
var k2, F_;

function Nse() {
    if (F_) return k2;
    F_ = 1;
    const t = $O(),
        e = Pse(),
        r = {
            type: "object",
            properties: {
                types: {
                    type: "object",
                    additionalProperties: {
                        type: "array",
                        items: {
                            type: "object",
                            properties: {
                                name: {
                                    type: "string"
                                },
                                type: {
                                    type: "string"
                                }
                            },
                            required: ["name", "type"]
                        }
                    }
                },
                primaryType: {
                    type: "string"
                },
                domain: {
                    type: "object"
                },
                message: {
                    type: "object"
                }
            },
            required: ["types", "primaryType", "domain", "message"]
        },
        n = {
            encodeData(s, a, o, c = !0) {
                const l = ["bytes32"],
                    u = [this.hashType(s, o)];
                if (c) {
                    const h = (f, p, g) => {
                        if (o[p] !== void 0) return ["bytes32", g == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : t.keccak(this.encodeData(p, g, o, c))];
                        if (g === void 0) throw new Error(`missing value for field ${f} of type ${p}`);
                        if (p === "bytes") return ["bytes32", t.keccak(g)];
                        if (p === "string") return typeof g == "string" && (g = Ve.from(g, "utf8")), ["bytes32", t.keccak(g)];
                        if (p.lastIndexOf("]") === p.length - 1) {
                            const m = p.slice(0, p.lastIndexOf("[")),
                                y = g.map(w => h(f, m, w));
                            return ["bytes32", t.keccak(e.rawEncode(y.map(([w]) => w), y.map(([, w]) => w)))]
                        }
                        return [p, g]
                    };
                    for (const f of o[s]) {
                        const [p, g] = h(f.name, f.type, a[f.name]);
                        l.push(p), u.push(g)
                    }
                } else
                    for (const h of o[s]) {
                        let f = a[h.name];
                        if (f !== void 0)
                            if (h.type === "bytes") l.push("bytes32"), f = t.keccak(f), u.push(f);
                            else if (h.type === "string") l.push("bytes32"), typeof f == "string" && (f = Ve.from(f, "utf8")), f = t.keccak(f), u.push(f);
                        else if (o[h.type] !== void 0) l.push("bytes32"), f = t.keccak(this.encodeData(h.type, f, o, c)), u.push(f);
                        else {
                            if (h.type.lastIndexOf("]") === h.type.length - 1) throw new Error("Arrays currently unimplemented in encodeData");
                            l.push(h.type), u.push(f)
                        }
                    }
                return e.rawEncode(l, u)
            },
            encodeType(s, a) {
                let o = "",
                    c = this.findTypeDependencies(s, a).filter(l => l !== s);
                c = [s].concat(c.sort());
                for (const l of c) {
                    if (!a[l]) throw new Error("No type definition specified: " + l);
                    o += l + "(" + a[l].map(({
                        name: h,
                        type: f
                    }) => f + " " + h).join(",") + ")"
                }
                return o
            },
            findTypeDependencies(s, a, o = []) {
                if (s = s.match(/^\w*/)[0], o.includes(s) || a[s] === void 0) return o;
                o.push(s);
                for (const c of a[s])
                    for (const l of this.findTypeDependencies(c.type, a, o)) !o.includes(l) && o.push(l);
                return o
            },
            hashStruct(s, a, o, c = !0) {
                return t.keccak(this.encodeData(s, a, o, c))
            },
            hashType(s, a) {
                return t.keccak(this.encodeType(s, a))
            },
            sanitizeData(s) {
                const a = {};
                for (const o in r.properties) s[o] && (a[o] = s[o]);
                return a.types && (a.types = Object.assign({
                    EIP712Domain: []
                }, a.types)), a
            },
            hash(s, a = !0) {
                const o = this.sanitizeData(s),
                    c = [Ve.from("1901", "hex")];
                return c.push(this.hashStruct("EIP712Domain", o.domain, o.types, a)), o.primaryType !== "EIP712Domain" && c.push(this.hashStruct(o.primaryType, o.message, o.types, a)), t.keccak(Ve.concat(c))
            }
        };
    k2 = {
        TYPED_MESSAGE_SCHEMA: r,
        TypedDataUtils: n,
        hashForSignTypedDataLegacy: function(s) {
            return i(s.data)
        },
        hashForSignTypedData_v3: function(s) {
            return n.hash(s.data, !1)
        },
        hashForSignTypedData_v4: function(s) {
            return n.hash(s.data)
        }
    };

    function i(s) {
        const a = new Error("Expect argument to be non-empty array");
        if (typeof s != "object" || !s.length) throw a;
        const o = s.map(function(u) {
                return u.type === "bytes" ? t.toBuffer(u.value) : u.value
            }),
            c = s.map(function(u) {
                return u.type
            }),
            l = s.map(function(u) {
                if (!u.name) throw a;
                return u.type + " " + u.name
            });
        return e.soliditySHA3(["bytes32", "bytes32"], [e.soliditySHA3(new Array(s.length).fill("string"), l), e.soliditySHA3(c, o)])
    }
    return k2
}
var Ose = Nse();
const ng = Oa(Ose),
    jse = "walletUsername",
    U3 = "Addresses",
    Rse = "AppVersion";

function kn(t) {
    return t.errorMessage !== void 0
}
class Mse {
    constructor(e) {
        this.secret = e
    }
    async encrypt(e) {
        const r = this.secret;
        if (r.length !== 64) throw Error("secret must be 256 bits");
        const n = crypto.getRandomValues(new Uint8Array(12)),
            i = await crypto.subtle.importKey("raw", Gg(r), {
                name: "aes-gcm"
            }, !1, ["encrypt", "decrypt"]),
            s = new TextEncoder,
            a = await window.crypto.subtle.encrypt({
                name: "AES-GCM",
                iv: n
            }, i, s.encode(e)),
            o = 16,
            c = a.slice(a.byteLength - o),
            l = a.slice(0, a.byteLength - o),
            u = new Uint8Array(c),
            h = new Uint8Array(l),
            f = new Uint8Array([...n, ...u, ...h]);
        return Z6(f)
    }
    async decrypt(e) {
        const r = this.secret;
        if (r.length !== 64) throw Error("secret must be 256 bits");
        return new Promise((n, i) => {
            (async function() {
                const s = await crypto.subtle.importKey("raw", Gg(r), {
                        name: "aes-gcm"
                    }, !1, ["encrypt", "decrypt"]),
                    a = Gg(e),
                    o = a.slice(0, 12),
                    c = a.slice(12, 28),
                    l = a.slice(28),
                    u = new Uint8Array([...l, ...c]),
                    h = {
                        name: "AES-GCM",
                        iv: new Uint8Array(o)
                    };
                try {
                    const f = await window.crypto.subtle.decrypt(h, s, u),
                        p = new TextDecoder;
                    n(p.decode(f))
                } catch (f) {
                    i(f)
                }
            })()
        })
    }
}
class Dse {
    constructor(e, r, n) {
        this.linkAPIUrl = e, this.sessionId = r;
        const i = `${r}:${n}`;
        this.auth = `Basic ${btoa(i)}`
    }
    async markUnseenEventsAsSeen(e) {
        return Promise.all(e.map(r => fetch(`${this.linkAPIUrl}/events/${r.eventId}/seen`, {
            method: "POST",
            headers: {
                Authorization: this.auth
            }
        }))).catch(r => console.error("Unabled to mark event as failed:", r))
    }
    async fetchUnseenEvents() {
        var e;
        const r = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
            headers: {
                Authorization: this.auth
            }
        });
        if (r.ok) {
            const {
                events: n,
                error: i
            } = await r.json();
            if (i) throw new Error(`Check unseen events failed: ${i}`);
            const s = (e = n == null ? void 0 : n.filter(a => a.event === "Web3Response").map(a => ({
                type: "Event",
                sessionId: this.sessionId,
                eventId: a.id,
                event: a.event,
                data: a.data
            }))) !== null && e !== void 0 ? e : [];
            return this.markUnseenEventsAsSeen(s), s
        }
        throw new Error(`Check unseen events failed: ${r.status}`)
    }
}
var Wo;
(function(t) {
    t[t.DISCONNECTED = 0] = "DISCONNECTED", t[t.CONNECTING = 1] = "CONNECTING", t[t.CONNECTED = 2] = "CONNECTED"
})(Wo || (Wo = {}));
class Lse {
    setConnectionStateListener(e) {
        this.connectionStateListener = e
    }
    setIncomingDataListener(e) {
        this.incomingDataListener = e
    }
    constructor(e, r = WebSocket) {
        this.WebSocketClass = r, this.webSocket = null, this.pendingData = [], this.url = e.replace(/^http/, "ws")
    }
    async connect() {
        if (this.webSocket) throw new Error("webSocket object is not null");
        return new Promise((e, r) => {
            var n;
            let i;
            try {
                this.webSocket = i = new this.WebSocketClass(this.url)
            } catch (s) {
                r(s);
                return
            }(n = this.connectionStateListener) === null || n === void 0 || n.call(this, Wo.CONNECTING), i.onclose = s => {
                var a;
                this.clearWebSocket(), r(new Error(`websocket error ${s.code}: ${s.reason}`)), (a = this.connectionStateListener) === null || a === void 0 || a.call(this, Wo.DISCONNECTED)
            }, i.onopen = s => {
                var a;
                e(), (a = this.connectionStateListener) === null || a === void 0 || a.call(this, Wo.CONNECTED), this.pendingData.length > 0 && ([...this.pendingData].forEach(c => this.sendData(c)), this.pendingData = [])
            }, i.onmessage = s => {
                var a, o;
                if (s.data === "h")(a = this.incomingDataListener) === null || a === void 0 || a.call(this, {
                    type: "Heartbeat"
                });
                else try {
                    const c = JSON.parse(s.data);
                    (o = this.incomingDataListener) === null || o === void 0 || o.call(this, c)
                } catch {}
            }
        })
    }
    disconnect() {
        var e;
        const {
            webSocket: r
        } = this;
        if (r) {
            this.clearWebSocket(), (e = this.connectionStateListener) === null || e === void 0 || e.call(this, Wo.DISCONNECTED), this.connectionStateListener = void 0, this.incomingDataListener = void 0;
            try {
                r.close()
            } catch {}
        }
    }
    sendData(e) {
        const {
            webSocket: r
        } = this;
        if (!r) {
            this.pendingData.push(e), this.connect();
            return
        }
        r.send(e)
    }
    clearWebSocket() {
        const {
            webSocket: e
        } = this;
        e && (this.webSocket = null, e.onclose = null, e.onerror = null, e.onmessage = null, e.onopen = null)
    }
}
const B_ = 1e4,
    Use = 6e4;
class Fse {
    constructor({
        session: e,
        linkAPIUrl: r,
        listener: n
    }) {
        this.destroyed = !1, this.lastHeartbeatResponse = 0, this.nextReqId = Ro(1), this._connected = !1, this._linked = !1, this.shouldFetchUnseenEventsOnConnect = !1, this.requestResolutions = new Map, this.handleSessionMetadataUpdated = s => {
            if (!s) return;
            new Map([
                ["__destroyed", this.handleDestroyed],
                ["EthereumAddress", this.handleAccountUpdated],
                ["WalletUsername", this.handleWalletUsernameUpdated],
                ["AppVersion", this.handleAppVersionUpdated],
                ["ChainId", o => s.JsonRpcUrl && this.handleChainUpdated(o, s.JsonRpcUrl)]
            ]).forEach((o, c) => {
                const l = s[c];
                l !== void 0 && o(l)
            })
        }, this.handleDestroyed = s => {
            var a;
            s === "1" && ((a = this.listener) === null || a === void 0 || a.resetAndReload())
        }, this.handleAccountUpdated = async s => {
            var a;
            const o = await this.cipher.decrypt(s);
            (a = this.listener) === null || a === void 0 || a.accountUpdated(o)
        }, this.handleMetadataUpdated = async (s, a) => {
            var o;
            const c = await this.cipher.decrypt(a);
            (o = this.listener) === null || o === void 0 || o.metadataUpdated(s, c)
        }, this.handleWalletUsernameUpdated = async s => {
            this.handleMetadataUpdated(jse, s)
        }, this.handleAppVersionUpdated = async s => {
            this.handleMetadataUpdated(Rse, s)
        }, this.handleChainUpdated = async (s, a) => {
            var o;
            const c = await this.cipher.decrypt(s),
                l = await this.cipher.decrypt(a);
            (o = this.listener) === null || o === void 0 || o.chainUpdated(c, l)
        }, this.session = e, this.cipher = new Mse(e.secret), this.listener = n;
        const i = new Lse(`${r}/rpc`, WebSocket);
        i.setConnectionStateListener(async s => {
            let a = !1;
            switch (s) {
                case Wo.DISCONNECTED:
                    if (!this.destroyed) {
                        const o = async () => {
                            await new Promise(c => setTimeout(c, 5e3)), this.destroyed || i.connect().catch(() => {
                                o()
                            })
                        };
                        o()
                    }
                    break;
                case Wo.CONNECTED:
                    a = await this.handleConnected(), this.updateLastHeartbeat(), setInterval(() => {
                        this.heartbeat()
                    }, B_), this.shouldFetchUnseenEventsOnConnect && this.fetchUnseenEventsAPI();
                    break;
                case Wo.CONNECTING:
                    break
            }
            this.connected !== a && (this.connected = a)
        }), i.setIncomingDataListener(s => {
            var a;
            switch (s.type) {
                case "Heartbeat":
                    this.updateLastHeartbeat();
                    return;
                case "IsLinkedOK":
                case "Linked":
                    {
                        const o = s.type === "IsLinkedOK" ? s.linked : void 0;this.linked = o || s.onlineGuests > 0;
                        break
                    }
                case "GetSessionConfigOK":
                case "SessionConfigUpdated":
                    {
                        this.handleSessionMetadataUpdated(s.metadata);
                        break
                    }
                case "Event":
                    {
                        this.handleIncomingEvent(s);
                        break
                    }
            }
            s.id !== void 0 && ((a = this.requestResolutions.get(s.id)) === null || a === void 0 || a(s))
        }), this.ws = i, this.http = new Dse(r, e.id, e.key)
    }
    connect() {
        if (this.destroyed) throw new Error("instance is destroyed");
        this.ws.connect()
    }
    async destroy() {
        this.destroyed || (await this.makeRequest({
            type: "SetSessionConfig",
            id: Ro(this.nextReqId++),
            sessionId: this.session.id,
            metadata: {
                __destroyed: "1"
            }
        }, {
            timeout: 1e3
        }), this.destroyed = !0, this.ws.disconnect(), this.listener = void 0)
    }
    get connected() {
        return this._connected
    }
    set connected(e) {
        this._connected = e
    }
    get linked() {
        return this._linked
    }
    set linked(e) {
        var r, n;
        this._linked = e, e && ((r = this.onceLinked) === null || r === void 0 || r.call(this)), (n = this.listener) === null || n === void 0 || n.linkedUpdated(e)
    }
    setOnceLinked(e) {
        return new Promise(r => {
            this.linked ? e().then(r) : this.onceLinked = () => {
                e().then(r), this.onceLinked = void 0
            }
        })
    }
    async handleIncomingEvent(e) {
        var r;
        if (e.type !== "Event" || e.event !== "Web3Response") return;
        const n = await this.cipher.decrypt(e.data),
            i = JSON.parse(n);
        if (i.type !== "WEB3_RESPONSE") return;
        const {
            id: s,
            response: a
        } = i;
        (r = this.listener) === null || r === void 0 || r.handleWeb3ResponseMessage(s, a)
    }
    async checkUnseenEvents() {
        if (!this.connected) {
            this.shouldFetchUnseenEventsOnConnect = !0;
            return
        }
        await new Promise(e => setTimeout(e, 250));
        try {
            await this.fetchUnseenEventsAPI()
        } catch (e) {
            console.error("Unable to check for unseen events", e)
        }
    }
    async fetchUnseenEventsAPI() {
        this.shouldFetchUnseenEventsOnConnect = !1, (await this.http.fetchUnseenEvents()).forEach(r => this.handleIncomingEvent(r))
    }
    async publishEvent(e, r, n = !1) {
        const i = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, r), {
                origin: location.origin,
                location: location.href,
                relaySource: "coinbaseWalletExtension" in window && window.coinbaseWalletExtension ? "injected_sdk" : "sdk"
            }))),
            s = {
                type: "PublishEvent",
                id: Ro(this.nextReqId++),
                sessionId: this.session.id,
                event: e,
                data: i,
                callWebhook: n
            };
        return this.setOnceLinked(async () => {
            const a = await this.makeRequest(s);
            if (a.type === "Fail") throw new Error(a.error || "failed to publish event");
            return a.eventId
        })
    }
    sendData(e) {
        this.ws.sendData(JSON.stringify(e))
    }
    updateLastHeartbeat() {
        this.lastHeartbeatResponse = Date.now()
    }
    heartbeat() {
        if (Date.now() - this.lastHeartbeatResponse > B_ * 2) {
            this.ws.disconnect();
            return
        }
        try {
            this.ws.sendData("h")
        } catch {}
    }
    async makeRequest(e, r = {
        timeout: Use
    }) {
        const n = e.id;
        this.sendData(e);
        let i;
        return Promise.race([new Promise((s, a) => {
            i = window.setTimeout(() => {
                a(new Error(`request ${n} timed out`))
            }, r.timeout)
        }), new Promise(s => {
            this.requestResolutions.set(n, a => {
                clearTimeout(i), s(a), this.requestResolutions.delete(n)
            })
        })])
    }
    async handleConnected() {
        return (await this.makeRequest({
            type: "HostSession",
            id: Ro(this.nextReqId++),
            sessionId: this.session.id,
            sessionKey: this.session.key
        })).type === "Fail" ? !1 : (this.sendData({
            type: "IsLinked",
            id: Ro(this.nextReqId++),
            sessionId: this.session.id
        }), this.sendData({
            type: "GetSessionConfig",
            id: Ro(this.nextReqId++),
            sessionId: this.session.id
        }), !0)
    }
}
class Bse {
    constructor() {
        this._nextRequestId = 0, this.callbacks = new Map
    }
    makeRequestId() {
        this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
        const e = this._nextRequestId,
            r = _O(e.toString(16));
        return this.callbacks.get(r) && this.callbacks.delete(r), e
    }
}
const W_ = "session:id",
    z_ = "session:secret",
    q_ = "session:linked";
class Lu {
    constructor(e, r, n, i = !1) {
        this.storage = e, this.id = r, this.secret = n, this.key = jW(bS(`${r}, ${n} WalletLink`)), this._linked = !!i
    }
    static create(e) {
        const r = Pl(16),
            n = Pl(32);
        return new Lu(e, r, n).save()
    }
    static load(e) {
        const r = e.getItem(W_),
            n = e.getItem(q_),
            i = e.getItem(z_);
        return r && i ? new Lu(e, r, i, n === "1") : null
    }
    get linked() {
        return this._linked
    }
    set linked(e) {
        this._linked = e, this.persistLinked()
    }
    save() {
        return this.storage.setItem(W_, this.id), this.storage.setItem(z_, this.secret), this.persistLinked(), this
    }
    persistLinked() {
        this.storage.setItem(q_, this._linked ? "1" : "0")
    }
}

function Wse() {
    try {
        return window.frameElement !== null
    } catch {
        return !1
    }
}

function zse() {
    try {
        return Wse() && window.top ? window.top.location : window.location
    } catch {
        return window.location
    }
}

function qse() {
    var t;
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((t = window == null ? void 0 : window.navigator) === null || t === void 0 ? void 0 : t.userAgent)
}

function SO() {
    var t, e;
    return (e = (t = window == null ? void 0 : window.matchMedia) === null || t === void 0 ? void 0 : t.call(window, "(prefers-color-scheme: dark)").matches) !== null && e !== void 0 ? e : !1
}
const Hse = '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}';

function TO() {
    const t = document.createElement("style");
    t.type = "text/css", t.appendChild(document.createTextNode(Hse)), document.documentElement.appendChild(t)
}

function PO(t) {
    var e, r, n = "";
    if (typeof t == "string" || typeof t == "number") n += t;
    else if (typeof t == "object")
        if (Array.isArray(t))
            for (e = 0; e < t.length; e++) t[e] && (r = PO(t[e])) && (n && (n += " "), n += r);
        else
            for (e in t) t[e] && (n && (n += " "), n += e);
    return n
}

function Lf() {
    for (var t, e, r = 0, n = ""; r < arguments.length;)(t = arguments[r++]) && (e = PO(t)) && (n && (n += " "), n += e);
    return n
}
var iy, kr, NO, Nl, H_, OO, F3, ex, B3, W3, $p = {},
    jO = [],
    Vse = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,
    tx = Array.isArray;

function Gc(t, e) {
    for (var r in e) t[r] = e[r];
    return t
}

function RO(t) {
    t && t.parentNode && t.parentNode.removeChild(t)
}

function or(t, e, r) {
    var n, i, s, a = {};
    for (s in e) s == "key" ? n = e[s] : s == "ref" ? i = e[s] : a[s] = e[s];
    if (arguments.length > 2 && (a.children = arguments.length > 3 ? iy.call(arguments, 2) : r), typeof t == "function" && t.defaultProps != null)
        for (s in t.defaultProps) a[s] === void 0 && (a[s] = t.defaultProps[s]);
    return Kg(t, a, n, i, null)
}

function Kg(t, e, r, n, i) {
    var s = {
        type: t,
        props: e,
        key: r,
        ref: n,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        constructor: void 0,
        __v: i ? ? ++NO,
        __i: -1,
        __u: 0
    };
    return i == null && kr.vnode != null && kr.vnode(s), s
}

function sy(t) {
    return t.children
}

function Yg(t, e) {
    this.props = t, this.context = e
}

function th(t, e) {
    if (e == null) return t.__ ? th(t.__, t.__i + 1) : null;
    for (var r; e < t.__k.length; e++)
        if ((r = t.__k[e]) != null && r.__e != null) return r.__e;
    return typeof t.type == "function" ? th(t) : null
}

function MO(t) {
    var e, r;
    if ((t = t.__) != null && t.__c != null) {
        for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++)
            if ((r = t.__k[e]) != null && r.__e != null) {
                t.__e = t.__c.base = r.__e;
                break
            }
        return MO(t)
    }
}

function V_(t) {
    (!t.__d && (t.__d = !0) && Nl.push(t) && !Pm.__r++ || H_ !== kr.debounceRendering) && ((H_ = kr.debounceRendering) || OO)(Pm)
}

function Pm() {
    var t, e, r, n, i, s, a, o;
    for (Nl.sort(F3); t = Nl.shift();) t.__d && (e = Nl.length, n = void 0, s = (i = (r = t).__v).__e, a = [], o = [], r.__P && ((n = Gc({}, i)).__v = i.__v + 1, kr.vnode && kr.vnode(n), rx(r.__P, n, i, r.__n, r.__P.namespaceURI, 32 & i.__u ? [s] : null, a, s ? ? th(i), !!(32 & i.__u), o), n.__v = i.__v, n.__.__k[n.__i] = n, UO(a, n, o), n.__e != s && MO(n)), Nl.length > e && Nl.sort(F3));
    Pm.__r = 0
}

function DO(t, e, r, n, i, s, a, o, c, l, u) {
    var h, f, p, g, m, y = n && n.__k || jO,
        w = e.length;
    for (r.__d = c, Gse(r, e, y), c = r.__d, h = 0; h < w; h++)(p = r.__k[h]) != null && (f = p.__i === -1 ? $p : y[p.__i] || $p, p.__i = h, rx(t, p, f, i, s, a, o, c, l, u), g = p.__e, p.ref && f.ref != p.ref && (f.ref && nx(f.ref, null, p), u.push(p.ref, p.__c || g, p)), m == null && g != null && (m = g), 65536 & p.__u || f.__k === p.__k ? c = LO(p, c, t) : typeof p.type == "function" && p.__d !== void 0 ? c = p.__d : g && (c = g.nextSibling), p.__d = void 0, p.__u &= -196609);
    r.__d = c, r.__e = m
}

function Gse(t, e, r) {
    var n, i, s, a, o, c = e.length,
        l = r.length,
        u = l,
        h = 0;
    for (t.__k = [], n = 0; n < c; n++)(i = e[n]) != null && typeof i != "boolean" && typeof i != "function" ? (a = n + h, (i = t.__k[n] = typeof i == "string" || typeof i == "number" || typeof i == "bigint" || i.constructor == String ? Kg(null, i, null, null, null) : tx(i) ? Kg(sy, {
        children: i
    }, null, null, null) : i.constructor === void 0 && i.__b > 0 ? Kg(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v) : i).__ = t, i.__b = t.__b + 1, s = null, (o = i.__i = Kse(i, r, a, u)) !== -1 && (u--, (s = r[o]) && (s.__u |= 131072)), s == null || s.__v === null ? (o == -1 && h--, typeof i.type != "function" && (i.__u |= 65536)) : o !== a && (o == a - 1 ? h-- : o == a + 1 ? h++ : (o > a ? h-- : h++, i.__u |= 65536))) : i = t.__k[n] = null;
    if (u)
        for (n = 0; n < l; n++)(s = r[n]) != null && (131072 & s.__u) == 0 && (s.__e == t.__d && (t.__d = th(s)), FO(s, s))
}

function LO(t, e, r) {
    var n, i;
    if (typeof t.type == "function") {
        for (n = t.__k, i = 0; n && i < n.length; i++) n[i] && (n[i].__ = t, e = LO(n[i], e, r));
        return e
    }
    t.__e != e && (e && t.type && !r.contains(e) && (e = th(t)), r.insertBefore(t.__e, e || null), e = t.__e);
    do e = e && e.nextSibling; while (e != null && e.nodeType === 8);
    return e
}

function Kse(t, e, r, n) {
    var i = t.key,
        s = t.type,
        a = r - 1,
        o = r + 1,
        c = e[r];
    if (c === null || c && i == c.key && s === c.type && (131072 & c.__u) == 0) return r;
    if (n > (c != null && (131072 & c.__u) == 0 ? 1 : 0))
        for (; a >= 0 || o < e.length;) {
            if (a >= 0) {
                if ((c = e[a]) && (131072 & c.__u) == 0 && i == c.key && s === c.type) return a;
                a--
            }
            if (o < e.length) {
                if ((c = e[o]) && (131072 & c.__u) == 0 && i == c.key && s === c.type) return o;
                o++
            }
        }
    return -1
}

function G_(t, e, r) {
    e[0] === "-" ? t.setProperty(e, r ? ? "") : t[e] = r == null ? "" : typeof r != "number" || Vse.test(e) ? r : r + "px"
}

function ig(t, e, r, n, i) {
    var s;
    e: if (e === "style")
        if (typeof r == "string") t.style.cssText = r;
        else {
            if (typeof n == "string" && (t.style.cssText = n = ""), n)
                for (e in n) r && e in r || G_(t.style, e, "");
            if (r)
                for (e in r) n && r[e] === n[e] || G_(t.style, e, r[e])
        }
    else if (e[0] === "o" && e[1] === "n") s = e !== (e = e.replace(/(PointerCapture)$|Capture$/i, "$1")), e = e.toLowerCase() in t || e === "onFocusOut" || e === "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), t.l || (t.l = {}), t.l[e + s] = r, r ? n ? r.u = n.u : (r.u = ex, t.addEventListener(e, s ? W3 : B3, s)) : t.removeEventListener(e, s ? W3 : B3, s);
    else {
        if (i == "http://www.w3.org/2000/svg") e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e != "popover" && e in t) try {
            t[e] = r ? ? "";
            break e
        } catch {}
        typeof r == "function" || (r == null || r === !1 && e[4] !== "-" ? t.removeAttribute(e) : t.setAttribute(e, e == "popover" && r == 1 ? "" : r))
    }
}

function K_(t) {
    return function(e) {
        if (this.l) {
            var r = this.l[e.type + t];
            if (e.t == null) e.t = ex++;
            else if (e.t < r.u) return;
            return r(kr.event ? kr.event(e) : e)
        }
    }
}

function rx(t, e, r, n, i, s, a, o, c, l) {
    var u, h, f, p, g, m, y, w, x, E, _, b, A, I, T, C, $ = e.type;
    if (e.constructor !== void 0) return null;
    128 & r.__u && (c = !!(32 & r.__u), s = [o = e.__e = r.__e]), (u = kr.__b) && u(e);
    e: if (typeof $ == "function") try {
        if (w = e.props, x = "prototype" in $ && $.prototype.render, E = (u = $.contextType) && n[u.__c], _ = u ? E ? E.props.value : u.__ : n, r.__c ? y = (h = e.__c = r.__c).__ = h.__E : (x ? e.__c = h = new $(w, _) : (e.__c = h = new Yg(w, _), h.constructor = $, h.render = Zse), E && E.sub(h), h.props = w, h.state || (h.state = {}), h.context = _, h.__n = n, f = h.__d = !0, h.__h = [], h._sb = []), x && h.__s == null && (h.__s = h.state), x && $.getDerivedStateFromProps != null && (h.__s == h.state && (h.__s = Gc({}, h.__s)), Gc(h.__s, $.getDerivedStateFromProps(w, h.__s))), p = h.props, g = h.state, h.__v = e, f) x && $.getDerivedStateFromProps == null && h.componentWillMount != null && h.componentWillMount(), x && h.componentDidMount != null && h.__h.push(h.componentDidMount);
        else {
            if (x && $.getDerivedStateFromProps == null && w !== p && h.componentWillReceiveProps != null && h.componentWillReceiveProps(w, _), !h.__e && (h.shouldComponentUpdate != null && h.shouldComponentUpdate(w, h.__s, _) === !1 || e.__v === r.__v)) {
                for (e.__v !== r.__v && (h.props = w, h.state = h.__s, h.__d = !1), e.__e = r.__e, e.__k = r.__k, e.__k.some(function(P) {
                        P && (P.__ = e)
                    }), b = 0; b < h._sb.length; b++) h.__h.push(h._sb[b]);
                h._sb = [], h.__h.length && a.push(h);
                break e
            }
            h.componentWillUpdate != null && h.componentWillUpdate(w, h.__s, _), x && h.componentDidUpdate != null && h.__h.push(function() {
                h.componentDidUpdate(p, g, m)
            })
        }
        if (h.context = _, h.props = w, h.__P = t, h.__e = !1, A = kr.__r, I = 0, x) {
            for (h.state = h.__s, h.__d = !1, A && A(e), u = h.render(h.props, h.state, h.context), T = 0; T < h._sb.length; T++) h.__h.push(h._sb[T]);
            h._sb = []
        } else
            do h.__d = !1, A && A(e), u = h.render(h.props, h.state, h.context), h.state = h.__s; while (h.__d && ++I < 25);
        h.state = h.__s, h.getChildContext != null && (n = Gc(Gc({}, n), h.getChildContext())), x && !f && h.getSnapshotBeforeUpdate != null && (m = h.getSnapshotBeforeUpdate(p, g)), DO(t, tx(C = u != null && u.type === sy && u.key == null ? u.props.children : u) ? C : [C], e, r, n, i, s, a, o, c, l), h.base = e.__e, e.__u &= -161, h.__h.length && a.push(h), y && (h.__E = h.__ = null)
    } catch (P) {
        if (e.__v = null, c || s != null) {
            for (e.__u |= c ? 160 : 32; o && o.nodeType === 8 && o.nextSibling;) o = o.nextSibling;
            s[s.indexOf(o)] = null, e.__e = o
        } else e.__e = r.__e, e.__k = r.__k;
        kr.__e(P, e, r)
    } else s == null && e.__v === r.__v ? (e.__k = r.__k, e.__e = r.__e) : e.__e = Yse(r.__e, e, r, n, i, s, a, c, l);
    (u = kr.diffed) && u(e)
}

function UO(t, e, r) {
    e.__d = void 0;
    for (var n = 0; n < r.length; n++) nx(r[n], r[++n], r[++n]);
    kr.__c && kr.__c(e, t), t.some(function(i) {
        try {
            t = i.__h, i.__h = [], t.some(function(s) {
                s.call(i)
            })
        } catch (s) {
            kr.__e(s, i.__v)
        }
    })
}

function Yse(t, e, r, n, i, s, a, o, c) {
    var l, u, h, f, p, g, m, y = r.props,
        w = e.props,
        x = e.type;
    if (x === "svg" ? i = "http://www.w3.org/2000/svg" : x === "math" ? i = "http://www.w3.org/1998/Math/MathML" : i || (i = "http://www.w3.org/1999/xhtml"), s != null) {
        for (l = 0; l < s.length; l++)
            if ((p = s[l]) && "setAttribute" in p == !!x && (x ? p.localName === x : p.nodeType === 3)) {
                t = p, s[l] = null;
                break
            }
    }
    if (t == null) {
        if (x === null) return document.createTextNode(w);
        t = document.createElementNS(i, x, w.is && w), o && (kr.__m && kr.__m(e, s), o = !1), s = null
    }
    if (x === null) y === w || o && t.data === w || (t.data = w);
    else {
        if (s = s && iy.call(t.childNodes), y = r.props || $p, !o && s != null)
            for (y = {}, l = 0; l < t.attributes.length; l++) y[(p = t.attributes[l]).name] = p.value;
        for (l in y)
            if (p = y[l], l != "children") {
                if (l == "dangerouslySetInnerHTML") h = p;
                else if (!(l in w)) {
                    if (l == "value" && "defaultValue" in w || l == "checked" && "defaultChecked" in w) continue;
                    ig(t, l, null, p, i)
                }
            }
        for (l in w) p = w[l], l == "children" ? f = p : l == "dangerouslySetInnerHTML" ? u = p : l == "value" ? g = p : l == "checked" ? m = p : o && typeof p != "function" || y[l] === p || ig(t, l, p, y[l], i);
        if (u) o || h && (u.__html === h.__html || u.__html === t.innerHTML) || (t.innerHTML = u.__html), e.__k = [];
        else if (h && (t.innerHTML = ""), DO(t, tx(f) ? f : [f], e, r, n, x === "foreignObject" ? "http://www.w3.org/1999/xhtml" : i, s, a, s ? s[0] : r.__k && th(r, 0), o, c), s != null)
            for (l = s.length; l--;) RO(s[l]);
        o || (l = "value", x === "progress" && g == null ? t.removeAttribute("value") : g !== void 0 && (g !== t[l] || x === "progress" && !g || x === "option" && g !== y[l]) && ig(t, l, g, y[l], i), l = "checked", m !== void 0 && m !== t[l] && ig(t, l, m, y[l], i))
    }
    return t
}

function nx(t, e, r) {
    try {
        if (typeof t == "function") {
            var n = typeof t.__u == "function";
            n && t.__u(), n && e == null || (t.__u = t(e))
        } else t.current = e
    } catch (i) {
        kr.__e(i, r)
    }
}

function FO(t, e, r) {
    var n, i;
    if (kr.unmount && kr.unmount(t), (n = t.ref) && (n.current && n.current !== t.__e || nx(n, null, e)), (n = t.__c) != null) {
        if (n.componentWillUnmount) try {
            n.componentWillUnmount()
        } catch (s) {
            kr.__e(s, e)
        }
        n.base = n.__P = null
    }
    if (n = t.__k)
        for (i = 0; i < n.length; i++) n[i] && FO(n[i], e, r || typeof t.type != "function");
    r || RO(t.__e), t.__c = t.__ = t.__e = t.__d = void 0
}

function Zse(t, e, r) {
    return this.constructor(t, r)
}

function z3(t, e, r) {
    var n, i, s, a;
    kr.__ && kr.__(t, e), i = (n = !1) ? null : e.__k, s = [], a = [], rx(e, t = e.__k = or(sy, null, [t]), i || $p, $p, e.namespaceURI, i ? null : e.firstChild ? iy.call(e.childNodes) : null, s, i ? i.__e : e.firstChild, n, a), UO(s, t, a)
}
iy = jO.slice, kr = {
    __e: function(t, e, r, n) {
        for (var i, s, a; e = e.__;)
            if ((i = e.__c) && !i.__) try {
                if ((s = i.constructor) && s.getDerivedStateFromError != null && (i.setState(s.getDerivedStateFromError(t)), a = i.__d), i.componentDidCatch != null && (i.componentDidCatch(t, n || {}), a = i.__d), a) return i.__E = i
            } catch (o) {
                t = o
            }
        throw t
    }
}, NO = 0, Yg.prototype.setState = function(t, e) {
    var r;
    r = this.__s != null && this.__s !== this.state ? this.__s : this.__s = Gc({}, this.state), typeof t == "function" && (t = t(Gc({}, r), this.props)), t && Gc(r, t), t != null && this.__v && (e && this._sb.push(e), V_(this))
}, Yg.prototype.forceUpdate = function(t) {
    this.__v && (this.__e = !0, t && this.__h.push(t), V_(this))
}, Yg.prototype.render = sy, Nl = [], OO = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, F3 = function(t, e) {
    return t.__v.__b - e.__v.__b
}, Pm.__r = 0, ex = 0, B3 = K_(!1), W3 = K_(!0);
var Sp, Fr, I2, Y_, q3 = 0,
    BO = [],
    Qr = kr,
    Z_ = Qr.__b,
    J_ = Qr.__r,
    Q_ = Qr.diffed,
    X_ = Qr.__c,
    e9 = Qr.unmount,
    t9 = Qr.__;

function ix(t, e) {
    Qr.__h && Qr.__h(Fr, t, q3 || e), q3 = 0;
    var r = Fr.__H || (Fr.__H = {
        __: [],
        __h: []
    });
    return t >= r.__.length && r.__.push({}), r.__[t]
}

function r9(t) {
    return q3 = 1, Jse(zO, t)
}

function Jse(t, e, r) {
    var n = ix(Sp++, 2);
    if (n.t = t, !n.__c && (n.__ = [zO(void 0, e), function(o) {
            var c = n.__N ? n.__N[0] : n.__[0],
                l = n.t(c, o);
            c !== l && (n.__N = [l, n.__[1]], n.__c.setState({}))
        }], n.__c = Fr, !Fr.u)) {
        var i = function(o, c, l) {
            if (!n.__c.__H) return !0;
            var u = n.__c.__H.__.filter(function(f) {
                return !!f.__c
            });
            if (u.every(function(f) {
                    return !f.__N
                })) return !s || s.call(this, o, c, l);
            var h = !1;
            return u.forEach(function(f) {
                if (f.__N) {
                    var p = f.__[0];
                    f.__ = f.__N, f.__N = void 0, p !== f.__[0] && (h = !0)
                }
            }), !(!h && n.__c.props === o) && (!s || s.call(this, o, c, l))
        };
        Fr.u = !0;
        var s = Fr.shouldComponentUpdate,
            a = Fr.componentWillUpdate;
        Fr.componentWillUpdate = function(o, c, l) {
            if (this.__e) {
                var u = s;
                s = void 0, i(o, c, l), s = u
            }
            a && a.call(this, o, c, l)
        }, Fr.shouldComponentUpdate = i
    }
    return n.__N || n.__
}

function Qse(t, e) {
    var r = ix(Sp++, 3);
    !Qr.__s && WO(r.__H, e) && (r.__ = t, r.i = e, Fr.__H.__h.push(r))
}

function iOe(t, e) {
    var r = ix(Sp++, 7);
    return WO(r.__H, e) && (r.__ = t(), r.__H = e, r.__h = t), r.__
}

function Xse() {
    for (var t; t = BO.shift();)
        if (t.__P && t.__H) try {
            t.__H.__h.forEach(Zg), t.__H.__h.forEach(H3), t.__H.__h = []
        } catch (e) {
            t.__H.__h = [], Qr.__e(e, t.__v)
        }
}
Qr.__b = function(t) {
    Fr = null, Z_ && Z_(t)
}, Qr.__ = function(t, e) {
    t && e.__k && e.__k.__m && (t.__m = e.__k.__m), t9 && t9(t, e)
}, Qr.__r = function(t) {
    J_ && J_(t), Sp = 0;
    var e = (Fr = t.__c).__H;
    e && (I2 === Fr ? (e.__h = [], Fr.__h = [], e.__.forEach(function(r) {
        r.__N && (r.__ = r.__N), r.i = r.__N = void 0
    })) : (e.__h.forEach(Zg), e.__h.forEach(H3), e.__h = [], Sp = 0)), I2 = Fr
}, Qr.diffed = function(t) {
    Q_ && Q_(t);
    var e = t.__c;
    e && e.__H && (e.__H.__h.length && (BO.push(e) !== 1 && Y_ === Qr.requestAnimationFrame || ((Y_ = Qr.requestAnimationFrame) || eae)(Xse)), e.__H.__.forEach(function(r) {
        r.i && (r.__H = r.i), r.i = void 0
    })), I2 = Fr = null
}, Qr.__c = function(t, e) {
    e.some(function(r) {
        try {
            r.__h.forEach(Zg), r.__h = r.__h.filter(function(n) {
                return !n.__ || H3(n)
            })
        } catch (n) {
            e.some(function(i) {
                i.__h && (i.__h = [])
            }), e = [], Qr.__e(n, r.__v)
        }
    }), X_ && X_(t, e)
}, Qr.unmount = function(t) {
    e9 && e9(t);
    var e, r = t.__c;
    r && r.__H && (r.__H.__.forEach(function(n) {
        try {
            Zg(n)
        } catch (i) {
            e = i
        }
    }), r.__H = void 0, e && Qr.__e(e, r.__v))
};
var n9 = typeof requestAnimationFrame == "function";

function eae(t) {
    var e, r = function() {
            clearTimeout(n), n9 && cancelAnimationFrame(e), setTimeout(t)
        },
        n = setTimeout(r, 100);
    n9 && (e = requestAnimationFrame(r))
}

function Zg(t) {
    var e = Fr,
        r = t.__c;
    typeof r == "function" && (t.__c = void 0, r()), Fr = e
}

function H3(t) {
    var e = Fr;
    t.__c = t.__(), Fr = e
}

function WO(t, e) {
    return !t || t.length !== e.length || e.some(function(r, n) {
        return r !== t[n]
    })
}

function zO(t, e) {
    return typeof e == "function" ? e(t) : e
}
const tae = ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}",
    rae = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+",
    nae = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=";
class qO {
    constructor() {
        this.items = new Map, this.nextItemKey = 0, this.root = null, this.darkMode = SO()
    }
    attach(e) {
        this.root = document.createElement("div"), this.root.className = "-cbwsdk-snackbar-root", e.appendChild(this.root), this.render()
    }
    presentItem(e) {
        const r = this.nextItemKey++;
        return this.items.set(r, e), this.render(), () => {
            this.items.delete(r), this.render()
        }
    }
    clear() {
        this.items.clear(), this.render()
    }
    render() {
        this.root && z3(or("div", null, or(HO, {
            darkMode: this.darkMode
        }, Array.from(this.items.entries()).map(([e, r]) => or(iae, Object.assign({}, r, {
            key: e
        }))))), this.root)
    }
}
const HO = t => or("div", {
        class: Lf("-cbwsdk-snackbar-container")
    }, or("style", null, tae), or("div", {
        class: "-cbwsdk-snackbar"
    }, t.children)),
    iae = ({
        autoExpand: t,
        message: e,
        menuItems: r
    }) => {
        const [n, i] = r9(!0), [s, a] = r9(t ? ? !1);
        Qse(() => {
            const c = [window.setTimeout(() => {
                i(!1)
            }, 1), window.setTimeout(() => {
                a(!0)
            }, 1e4)];
            return () => {
                c.forEach(window.clearTimeout)
            }
        });
        const o = () => {
            a(!s)
        };
        return or("div", {
            class: Lf("-cbwsdk-snackbar-instance", n && "-cbwsdk-snackbar-instance-hidden", s && "-cbwsdk-snackbar-instance-expanded")
        }, or("div", {
            class: "-cbwsdk-snackbar-instance-header",
            onClick: o
        }, or("img", {
            src: rae,
            class: "-cbwsdk-snackbar-instance-header-cblogo"
        }), " ", or("div", {
            class: "-cbwsdk-snackbar-instance-header-message"
        }, e), or("div", {
            class: "-gear-container"
        }, !s && or("svg", {
            width: "24",
            height: "24",
            viewBox: "0 0 24 24",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg"
        }, or("circle", {
            cx: "12",
            cy: "12",
            r: "12",
            fill: "#F5F7F8"
        })), or("img", {
            src: nae,
            class: "-gear-icon",
            title: "Expand"
        }))), r && r.length > 0 && or("div", {
            class: "-cbwsdk-snackbar-instance-menu"
        }, r.map((c, l) => or("div", {
            class: Lf("-cbwsdk-snackbar-instance-menu-item", c.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"),
            onClick: c.onClick,
            key: l
        }, or("svg", {
            width: c.svgWidth,
            height: c.svgHeight,
            viewBox: "0 0 10 11",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg"
        }, or("path", {
            "fill-rule": c.defaultFillRule,
            "clip-rule": c.defaultClipRule,
            d: c.path,
            fill: "#AAAAAA"
        })), or("span", {
            class: Lf("-cbwsdk-snackbar-instance-menu-item-info", c.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red")
        }, c.info)))))
    },
    VO = "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z";
class sae {
    constructor() {
        this.attached = !1, this.snackbar = new qO
    }
    attach() {
        if (this.attached) throw new Error("Coinbase Wallet SDK UI is already attached");
        const e = document.documentElement,
            r = document.createElement("div");
        r.className = "-cbwsdk-css-reset", e.appendChild(r), this.snackbar.attach(r), this.attached = !0, TO()
    }
    showConnecting(e) {
        let r;
        return e.isUnlinkedErrorState ? r = {
            autoExpand: !0,
            message: "Connection lost",
            menuItems: [{
                isRed: !1,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: e.onResetConnection
            }]
        } : r = {
            message: "Confirm on phone",
            menuItems: [{
                isRed: !0,
                info: "Cancel transaction",
                svgWidth: "11",
                svgHeight: "11",
                path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
                defaultFillRule: "inherit",
                defaultClipRule: "inherit",
                onClick: e.onCancel
            }, {
                isRed: !1,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: VO,
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: e.onResetConnection
            }]
        }, this.snackbar.presentItem(r)
    }
}
const aae = ".-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}";
class oae {
    constructor() {
        this.root = null, this.darkMode = SO()
    }
    attach() {
        const e = document.documentElement;
        this.root = document.createElement("div"), this.root.className = "-cbwsdk-css-reset", e.appendChild(this.root), TO()
    }
    present(e) {
        this.render(e)
    }
    clear() {
        this.render(null)
    }
    render(e) {
        this.root && (z3(null, this.root), e && z3(or(cae, Object.assign({}, e, {
            onDismiss: () => {
                this.clear()
            },
            darkMode: this.darkMode
        })), this.root))
    }
}
const cae = ({
        title: t,
        buttonText: e,
        darkMode: r,
        onButtonClick: n,
        onDismiss: i
    }) => {
        const s = r ? "dark" : "light";
        return or(HO, {
            darkMode: r
        }, or("div", {
            class: "-cbwsdk-redirect-dialog"
        }, or("style", null, aae), or("div", {
            class: "-cbwsdk-redirect-dialog-backdrop",
            onClick: i
        }), or("div", {
            class: Lf("-cbwsdk-redirect-dialog-box", s)
        }, or("p", null, t), or("button", {
            onClick: n
        }, e))))
    },
    lae = "https://keys.coinbase.com/connect",
    dae = "https://rpc.wallet.coinbase.com",
    i9 = "https://www.walletlink.org",
    uae = "https://go.cb-w.com/walletlink";
class s9 {
    constructor() {
        this.attached = !1, this.redirectDialog = new oae
    }
    attach() {
        if (this.attached) throw new Error("Coinbase Wallet SDK UI is already attached");
        this.redirectDialog.attach(), this.attached = !0
    }
    redirectToCoinbaseWallet(e) {
        const r = new URL(uae);
        r.searchParams.append("redirect_url", zse().href), e && r.searchParams.append("wl_url", e);
        const n = document.createElement("a");
        n.target = "cbw-opener", n.href = r.href, n.rel = "noreferrer noopener", n.click()
    }
    openCoinbaseWalletDeeplink(e) {
        this.redirectDialog.present({
            title: "Redirecting to Coinbase Wallet...",
            buttonText: "Open",
            onButtonClick: () => {
                this.redirectToCoinbaseWallet(e)
            }
        }), setTimeout(() => {
            this.redirectToCoinbaseWallet(e)
        }, 99)
    }
    showConnecting(e) {
        return () => {
            this.redirectDialog.clear()
        }
    }
}
class Mo {
    constructor(e) {
        this.chainCallbackParams = {
            chainId: "",
            jsonRpcUrl: ""
        }, this.isMobileWeb = qse(), this.linkedUpdated = s => {
            this.isLinked = s;
            const a = this.storage.getItem(U3);
            if (s && (this._session.linked = s), this.isUnlinkedErrorState = !1, a) {
                const o = a.split(" "),
                    c = this.storage.getItem("IsStandaloneSigning") === "true";
                o[0] !== "" && !s && this._session.linked && !c && (this.isUnlinkedErrorState = !0)
            }
        }, this.metadataUpdated = (s, a) => {
            this.storage.setItem(s, a)
        }, this.chainUpdated = (s, a) => {
            this.chainCallbackParams.chainId === s && this.chainCallbackParams.jsonRpcUrl === a || (this.chainCallbackParams = {
                chainId: s,
                jsonRpcUrl: a
            }, this.chainCallback && this.chainCallback(a, Number.parseInt(s, 10)))
        }, this.accountUpdated = s => {
            this.accountsCallback && this.accountsCallback([s]), Mo.accountRequestCallbackIds.size > 0 && (Array.from(Mo.accountRequestCallbackIds.values()).forEach(a => {
                this.invokeCallback(a, {
                    method: "requestEthereumAccounts",
                    result: [s]
                })
            }), Mo.accountRequestCallbackIds.clear())
        }, this.resetAndReload = this.resetAndReload.bind(this), this.linkAPIUrl = e.linkAPIUrl, this.storage = e.storage, this.metadata = e.metadata, this.accountsCallback = e.accountsCallback, this.chainCallback = e.chainCallback;
        const {
            session: r,
            ui: n,
            connection: i
        } = this.subscribe();
        this._session = r, this.connection = i, this.relayEventManager = new Bse, this.ui = n, this.ui.attach()
    }
    subscribe() {
        const e = Lu.load(this.storage) || Lu.create(this.storage),
            {
                linkAPIUrl: r
            } = this,
            n = new Fse({
                session: e,
                linkAPIUrl: r,
                listener: this
            }),
            i = this.isMobileWeb ? new s9 : new sae;
        return n.connect(), {
            session: e,
            ui: i,
            connection: n
        }
    }
    resetAndReload() {
        this.connection.destroy().then(() => {
            const e = Lu.load(this.storage);
            (e == null ? void 0 : e.id) === this._session.id && uo.clearAll(), document.location.reload()
        }).catch(e => {})
    }
    signEthereumTransaction(e) {
        return this.sendRequest({
            method: "signEthereumTransaction",
            params: {
                fromAddress: e.fromAddress,
                toAddress: e.toAddress,
                weiValue: La(e.weiValue),
                data: Mf(e.data, !0),
                nonce: e.nonce,
                gasPriceInWei: e.gasPriceInWei ? La(e.gasPriceInWei) : null,
                maxFeePerGas: e.gasPriceInWei ? La(e.gasPriceInWei) : null,
                maxPriorityFeePerGas: e.gasPriceInWei ? La(e.gasPriceInWei) : null,
                gasLimit: e.gasLimit ? La(e.gasLimit) : null,
                chainId: e.chainId,
                shouldSubmit: !1
            }
        })
    }
    signAndSubmitEthereumTransaction(e) {
        return this.sendRequest({
            method: "signEthereumTransaction",
            params: {
                fromAddress: e.fromAddress,
                toAddress: e.toAddress,
                weiValue: La(e.weiValue),
                data: Mf(e.data, !0),
                nonce: e.nonce,
                gasPriceInWei: e.gasPriceInWei ? La(e.gasPriceInWei) : null,
                maxFeePerGas: e.maxFeePerGas ? La(e.maxFeePerGas) : null,
                maxPriorityFeePerGas: e.maxPriorityFeePerGas ? La(e.maxPriorityFeePerGas) : null,
                gasLimit: e.gasLimit ? La(e.gasLimit) : null,
                chainId: e.chainId,
                shouldSubmit: !0
            }
        })
    }
    submitEthereumTransaction(e, r) {
        return this.sendRequest({
            method: "submitEthereumTransaction",
            params: {
                signedTransaction: Mf(e, !0),
                chainId: r
            }
        })
    }
    getWalletLinkSession() {
        return this._session
    }
    sendRequest(e) {
        let r = null;
        const n = Pl(8),
            i = s => {
                this.publishWeb3RequestCanceledEvent(n), this.handleErrorResponse(n, e.method, s), r == null || r()
            };
        return new Promise((s, a) => {
            r = this.ui.showConnecting({
                isUnlinkedErrorState: this.isUnlinkedErrorState,
                onCancel: i,
                onResetConnection: this.resetAndReload
            }), this.relayEventManager.callbacks.set(n, o => {
                if (r == null || r(), kn(o)) return a(new Error(o.errorMessage));
                s(o)
            }), this.publishWeb3RequestEvent(n, e)
        })
    }
    publishWeb3RequestEvent(e, r) {
        const n = {
            type: "WEB3_REQUEST",
            id: e,
            request: r
        };
        this.publishEvent("Web3Request", n, !0).then(i => {}).catch(i => {
            this.handleWeb3ResponseMessage(n.id, {
                method: r.method,
                errorMessage: i.message
            })
        }), this.isMobileWeb && this.openCoinbaseWalletDeeplink(r.method)
    }
    openCoinbaseWalletDeeplink(e) {
        if (this.ui instanceof s9) switch (e) {
            case "requestEthereumAccounts":
            case "switchEthereumChain":
                return;
            default:
                window.addEventListener("blur", () => {
                    window.addEventListener("focus", () => {
                        this.connection.checkUnseenEvents()
                    }, {
                        once: !0
                    })
                }, {
                    once: !0
                }), this.ui.openCoinbaseWalletDeeplink();
                break
        }
    }
    publishWeb3RequestCanceledEvent(e) {
        const r = {
            type: "WEB3_REQUEST_CANCELED",
            id: e
        };
        this.publishEvent("Web3RequestCanceled", r, !1).then()
    }
    publishEvent(e, r, n) {
        return this.connection.publishEvent(e, r, n)
    }
    handleWeb3ResponseMessage(e, r) {
        if (r.method === "requestEthereumAccounts") {
            Mo.accountRequestCallbackIds.forEach(n => this.invokeCallback(n, r)), Mo.accountRequestCallbackIds.clear();
            return
        }
        this.invokeCallback(e, r)
    }
    handleErrorResponse(e, r, n) {
        var i;
        const s = (i = n == null ? void 0 : n.message) !== null && i !== void 0 ? i : "Unspecified error message.";
        this.handleWeb3ResponseMessage(e, {
            method: r,
            errorMessage: s
        })
    }
    invokeCallback(e, r) {
        const n = this.relayEventManager.callbacks.get(e);
        n && (n(r), this.relayEventManager.callbacks.delete(e))
    }
    requestEthereumAccounts() {
        const {
            appName: e,
            appLogoUrl: r
        } = this.metadata, n = {
            method: "requestEthereumAccounts",
            params: {
                appName: e,
                appLogoUrl: r
            }
        }, i = Pl(8);
        return new Promise((s, a) => {
            this.relayEventManager.callbacks.set(i, o => {
                if (kn(o)) return a(new Error(o.errorMessage));
                s(o)
            }), Mo.accountRequestCallbackIds.add(i), this.publishWeb3RequestEvent(i, n)
        })
    }
    watchAsset(e, r, n, i, s, a) {
        const o = {
            method: "watchAsset",
            params: {
                type: e,
                options: {
                    address: r,
                    symbol: n,
                    decimals: i,
                    image: s
                },
                chainId: a
            }
        };
        let c = null;
        const l = Pl(8),
            u = h => {
                this.publishWeb3RequestCanceledEvent(l), this.handleErrorResponse(l, o.method, h), c == null || c()
            };
        return c = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: u,
            onResetConnection: this.resetAndReload
        }), new Promise((h, f) => {
            this.relayEventManager.callbacks.set(l, p => {
                if (c == null || c(), kn(p)) return f(new Error(p.errorMessage));
                h(p)
            }), this.publishWeb3RequestEvent(l, o)
        })
    }
    addEthereumChain(e, r, n, i, s, a) {
        const o = {
            method: "addEthereumChain",
            params: {
                chainId: e,
                rpcUrls: r,
                blockExplorerUrls: i,
                chainName: s,
                iconUrls: n,
                nativeCurrency: a
            }
        };
        let c = null;
        const l = Pl(8),
            u = h => {
                this.publishWeb3RequestCanceledEvent(l), this.handleErrorResponse(l, o.method, h), c == null || c()
            };
        return c = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: u,
            onResetConnection: this.resetAndReload
        }), new Promise((h, f) => {
            this.relayEventManager.callbacks.set(l, p => {
                if (c == null || c(), kn(p)) return f(new Error(p.errorMessage));
                h(p)
            }), this.publishWeb3RequestEvent(l, o)
        })
    }
    switchEthereumChain(e, r) {
        const n = {
            method: "switchEthereumChain",
            params: Object.assign({
                chainId: e
            }, {
                address: r
            })
        };
        let i = null;
        const s = Pl(8),
            a = o => {
                this.publishWeb3RequestCanceledEvent(s), this.handleErrorResponse(s, n.method, o), i == null || i()
            };
        return i = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: a,
            onResetConnection: this.resetAndReload
        }), new Promise((o, c) => {
            this.relayEventManager.callbacks.set(s, l => {
                if (i == null || i(), kn(l) && l.errorCode) return c(Kt.provider.custom({
                    code: l.errorCode,
                    message: "Unrecognized chain ID. Try adding the chain using addEthereumChain first."
                }));
                if (kn(l)) return c(new Error(l.errorMessage));
                o(l)
            }), this.publishWeb3RequestEvent(s, n)
        })
    }
}
Mo.accountRequestCallbackIds = new Set;
const a9 = "DefaultChainId",
    o9 = "DefaultJsonRpcUrl";
class GO {
    constructor(e) {
        this._relay = null, this._addresses = [], this.metadata = e.metadata, this._storage = new uo("walletlink", i9), this.callback = e.callback || null;
        const r = this._storage.getItem(U3);
        if (r) {
            const n = r.split(" ");
            n[0] !== "" && (this._addresses = n.map(i => _c(i)))
        }
        this.initializeRelay()
    }
    getSession() {
        const e = this.initializeRelay(),
            {
                id: r,
                secret: n
            } = e.getWalletLinkSession();
        return {
            id: r,
            secret: n
        }
    }
    async handshake() {
        await this._eth_requestAccounts()
    }
    get selectedAddress() {
        return this._addresses[0] || void 0
    }
    get jsonRpcUrl() {
        var e;
        return (e = this._storage.getItem(o9)) !== null && e !== void 0 ? e : void 0
    }
    set jsonRpcUrl(e) {
        this._storage.setItem(o9, e)
    }
    updateProviderInfo(e, r) {
        var n;
        this.jsonRpcUrl = e;
        const i = this.getChainId();
        this._storage.setItem(a9, r.toString(10)), Df(r) !== i && ((n = this.callback) === null || n === void 0 || n.call(this, "chainChanged", Vc(r)))
    }
    async watchAsset(e) {
        const r = Array.isArray(e) ? e[0] : e;
        if (!r.type) throw Kt.rpc.invalidParams("Type is required");
        if ((r == null ? void 0 : r.type) !== "ERC20") throw Kt.rpc.invalidParams(`Asset of type '${r.type}' is not supported`);
        if (!(r != null && r.options)) throw Kt.rpc.invalidParams("Options are required");
        if (!(r != null && r.options.address)) throw Kt.rpc.invalidParams("Address is required");
        const n = this.getChainId(),
            {
                address: i,
                symbol: s,
                image: a,
                decimals: o
            } = r.options,
            l = await this.initializeRelay().watchAsset(r.type, i, s, o, a, n == null ? void 0 : n.toString());
        return kn(l) ? !1 : !!l.result
    }
    async addEthereumChain(e) {
        var r, n;
        const i = e[0];
        if (((r = i.rpcUrls) === null || r === void 0 ? void 0 : r.length) === 0) throw Kt.rpc.invalidParams("please pass in at least 1 rpcUrl");
        if (!i.chainName || i.chainName.trim() === "") throw Kt.rpc.invalidParams("chainName is a required field");
        if (!i.nativeCurrency) throw Kt.rpc.invalidParams("nativeCurrency is a required field");
        const s = Number.parseInt(i.chainId, 16);
        if (s === this.getChainId()) return !1;
        const a = this.initializeRelay(),
            {
                rpcUrls: o = [],
                blockExplorerUrls: c = [],
                chainName: l,
                iconUrls: u = [],
                nativeCurrency: h
            } = i,
            f = await a.addEthereumChain(s.toString(), o, u, c, l, h);
        if (kn(f)) return !1;
        if (((n = f.result) === null || n === void 0 ? void 0 : n.isApproved) === !0) return this.updateProviderInfo(o[0], s), null;
        throw Kt.rpc.internal("unable to add ethereum chain")
    }
    async switchEthereumChain(e) {
        const r = e[0],
            n = Number.parseInt(r.chainId, 16),
            s = await this.initializeRelay().switchEthereumChain(n.toString(10), this.selectedAddress || void 0);
        if (kn(s)) throw s;
        const a = s.result;
        return a.isApproved && a.rpcUrl.length > 0 && this.updateProviderInfo(a.rpcUrl, n), null
    }
    async cleanup() {
        this.callback = null, this._relay && this._relay.resetAndReload(), this._storage.clear()
    }
    _setAddresses(e, r) {
        var n;
        if (!Array.isArray(e)) throw new Error("addresses is not an array");
        const i = e.map(s => _c(s));
        JSON.stringify(i) !== JSON.stringify(this._addresses) && (this._addresses = i, (n = this.callback) === null || n === void 0 || n.call(this, "accountsChanged", i), this._storage.setItem(U3, i.join(" ")))
    }
    async request(e) {
        const r = e.params || [];
        switch (e.method) {
            case "eth_accounts":
                return [...this._addresses];
            case "eth_coinbase":
                return this.selectedAddress || null;
            case "net_version":
                return this.getChainId().toString(10);
            case "eth_chainId":
                return Vc(this.getChainId());
            case "eth_requestAccounts":
                return this._eth_requestAccounts();
            case "eth_ecRecover":
            case "personal_ecRecover":
                return this.ecRecover(e);
            case "personal_sign":
                return this.personalSign(e);
            case "eth_signTransaction":
                return this._eth_signTransaction(r);
            case "eth_sendRawTransaction":
                return this._eth_sendRawTransaction(r);
            case "eth_sendTransaction":
                return this._eth_sendTransaction(r);
            case "eth_signTypedData_v1":
            case "eth_signTypedData_v3":
            case "eth_signTypedData_v4":
            case "eth_signTypedData":
                return this.signTypedData(e);
            case "wallet_addEthereumChain":
                return this.addEthereumChain(r);
            case "wallet_switchEthereumChain":
                return this.switchEthereumChain(r);
            case "wallet_watchAsset":
                return this.watchAsset(r);
            default:
                if (!this.jsonRpcUrl) throw Kt.rpc.internal("No RPC URL set for chain");
                return X6(e, this.jsonRpcUrl)
        }
    }
    _ensureKnownAddress(e) {
        const r = _c(e);
        if (!this._addresses.map(i => _c(i)).includes(r)) throw new Error("Unknown Ethereum address")
    }
    _prepareTransactionParams(e) {
        const r = e.from ? _c(e.from) : this.selectedAddress;
        if (!r) throw new Error("Ethereum address is unavailable");
        this._ensureKnownAddress(r);
        const n = e.to ? _c(e.to) : null,
            i = e.value != null ? Vh(e.value) : BigInt(0),
            s = e.data ? L3(e.data) : Ve.alloc(0),
            a = e.nonce != null ? Df(e.nonce) : null,
            o = e.gasPrice != null ? Vh(e.gasPrice) : null,
            c = e.maxFeePerGas != null ? Vh(e.maxFeePerGas) : null,
            l = e.maxPriorityFeePerGas != null ? Vh(e.maxPriorityFeePerGas) : null,
            u = e.gas != null ? Vh(e.gas) : null,
            h = e.chainId ? Df(e.chainId) : this.getChainId();
        return {
            fromAddress: r,
            toAddress: n,
            weiValue: i,
            data: s,
            nonce: a,
            gasPriceInWei: o,
            maxFeePerGas: c,
            maxPriorityFeePerGas: l,
            gasLimit: u,
            chainId: h
        }
    }
    async ecRecover(e) {
        const {
            method: r,
            params: n
        } = e;
        if (!Array.isArray(n)) throw Kt.rpc.invalidParams();
        const s = await this.initializeRelay().sendRequest({
            method: "ethereumAddressFromSignedMessage",
            params: {
                message: b2(n[0]),
                signature: b2(n[1]),
                addPrefix: r === "personal_ecRecover"
            }
        });
        if (kn(s)) throw s;
        return s.result
    }
    getChainId() {
        var e;
        return Number.parseInt((e = this._storage.getItem(a9)) !== null && e !== void 0 ? e : "1", 10)
    }
    async _eth_requestAccounts() {
        var e, r;
        if (this._addresses.length > 0) return (e = this.callback) === null || e === void 0 || e.call(this, "connect", {
            chainId: Vc(this.getChainId())
        }), this._addresses;
        const i = await this.initializeRelay().requestEthereumAccounts();
        if (kn(i)) throw i;
        if (!i.result) throw new Error("accounts received is empty");
        return this._setAddresses(i.result), (r = this.callback) === null || r === void 0 || r.call(this, "connect", {
            chainId: Vc(this.getChainId())
        }), this._addresses
    }
    async personalSign({
        params: e
    }) {
        if (!Array.isArray(e)) throw Kt.rpc.invalidParams();
        const r = e[1],
            n = e[0];
        this._ensureKnownAddress(r);
        const s = await this.initializeRelay().sendRequest({
            method: "signEthereumMessage",
            params: {
                address: _c(r),
                message: b2(n),
                addPrefix: !0,
                typedDataJson: null
            }
        });
        if (kn(s)) throw s;
        return s.result
    }
    async _eth_signTransaction(e) {
        const r = this._prepareTransactionParams(e[0] || {}),
            i = await this.initializeRelay().signEthereumTransaction(r);
        if (kn(i)) throw i;
        return i.result
    }
    async _eth_sendRawTransaction(e) {
        const r = L3(e[0]),
            i = await this.initializeRelay().submitEthereumTransaction(r, this.getChainId());
        if (kn(i)) throw i;
        return i.result
    }
    async _eth_sendTransaction(e) {
        const r = this._prepareTransactionParams(e[0] || {}),
            i = await this.initializeRelay().signAndSubmitEthereumTransaction(r);
        if (kn(i)) throw i;
        return i.result
    }
    async signTypedData(e) {
        const {
            method: r,
            params: n
        } = e;
        if (!Array.isArray(n)) throw Kt.rpc.invalidParams();
        const i = l => {
                const u = {
                    eth_signTypedData_v1: ng.hashForSignTypedDataLegacy,
                    eth_signTypedData_v3: ng.hashForSignTypedData_v3,
                    eth_signTypedData_v4: ng.hashForSignTypedData_v4,
                    eth_signTypedData: ng.hashForSignTypedData_v4
                };
                return Mf(u[r]({
                    data: fse(l)
                }), !0)
            },
            s = n[r === "eth_signTypedData_v1" ? 1 : 0],
            a = n[r === "eth_signTypedData_v1" ? 0 : 1];
        this._ensureKnownAddress(s);
        const c = await this.initializeRelay().sendRequest({
            method: "signEthereumMessage",
            params: {
                address: _c(s),
                message: i(a),
                typedDataJson: JSON.stringify(a, null, 2),
                addPrefix: !1
            }
        });
        if (kn(c)) throw c;
        return c.result
    }
    initializeRelay() {
        return this._relay || (this._relay = new Mo({
            linkAPIUrl: i9,
            storage: this._storage,
            metadata: this.metadata,
            accountsCallback: this._setAddresses.bind(this),
            chainCallback: this.updateProviderInfo.bind(this)
        })), this._relay
    }
}
const KO = "SignerType",
    YO = new uo("CBWSDK", "SignerConfigurator");

function hae() {
    return YO.getItem(KO)
}

function fae(t) {
    YO.setItem(KO, t)
}
async function pae(t) {
    const {
        communicator: e,
        metadata: r,
        handshakeRequest: n,
        callback: i
    } = t;
    mae(e, r, i).catch(() => {});
    const s = {
            id: crypto.randomUUID(),
            event: "selectSignerType",
            data: Object.assign(Object.assign({}, t.preference), {
                handshakeRequest: n
            })
        },
        {
            data: a
        } = await e.postRequestAndWaitForResponse(s);
    return a
}

function gae(t) {
    const {
        signerType: e,
        metadata: r,
        communicator: n,
        callback: i
    } = t;
    switch (e) {
        case "scw":
            return new kse({
                metadata: r,
                callback: i,
                communicator: n
            });
        case "walletlink":
            return new GO({
                metadata: r,
                callback: i
            })
    }
}
async function mae(t, e, r) {
    await t.onMessage(({
        event: i
    }) => i === "WalletLinkSessionRequest");
    const n = new GO({
        metadata: e,
        callback: r
    });
    t.postMessage({
        event: "WalletLinkUpdate",
        data: {
            session: n.getSession()
        }
    }), await n.handshake(), t.postMessage({
        event: "WalletLinkUpdate",
        data: {
            connected: !0
        }
    })
}
const yae = `Coinbase Wallet SDK requires the Cross-Origin-Opener-Policy header to not be set to 'same-origin'. This is to ensure that the SDK can communicate with the Coinbase Smart Wallet app.

Please see https://www.smartwallet.dev/guides/tips/popup-tips#cross-origin-opener-policy for more information.`,
    wae = () => {
        let t;
        return {
            getCrossOriginOpenerPolicy: () => t === void 0 ? "undefined" : t,
            checkCrossOriginOpenerPolicy: async () => {
                if (typeof window > "u") {
                    t = "non-browser-env";
                    return
                }
                try {
                    const e = `${window.location.origin}${window.location.pathname}`,
                        r = await fetch(e, {
                            method: "HEAD"
                        });
                    if (!r.ok) throw new Error(`HTTP error! status: ${r.status}`);
                    const n = r.headers.get("Cross-Origin-Opener-Policy");
                    t = n ? ? "null", t === "same-origin" && console.error(yae)
                } catch (e) {
                    console.error("Error checking Cross-Origin-Opener-Policy:", e.message), t = "error"
                }
            }
        }
    },
    {
        checkCrossOriginOpenerPolicy: bae,
        getCrossOriginOpenerPolicy: vae
    } = wae(),
    c9 = 420,
    l9 = 540,
    xae = {
        isRed: !1,
        info: "Retry",
        svgWidth: "10",
        svgHeight: "11",
        path: VO,
        defaultFillRule: "evenodd",
        defaultClipRule: "evenodd"
    },
    Eae = "Popup was blocked. Try again.";
let sg = null;

function _ae(t) {
    const e = (window.innerWidth - c9) / 2 + window.screenX,
        r = (window.innerHeight - l9) / 2 + window.screenY;
    Aae(t);

    function n() {
        const s = `wallet_${crypto.randomUUID()}`,
            a = window.open(t, s, `width=${c9}, height=${l9}, left=${e}, top=${r}`);
        return a == null || a.focus(), a || null
    }
    let i = n();
    if (!i) {
        const s = kae();
        return new Promise((a, o) => {
            s.presentItem({
                autoExpand: !0,
                message: Eae,
                menuItems: [Object.assign(Object.assign({}, xae), {
                    onClick: () => {
                        i = n(), i ? a(i) : o(Kt.rpc.internal("Popup window was blocked")), s.clear()
                    }
                })]
            })
        })
    }
    return Promise.resolve(i)
}

function Cae(t) {
    t && !t.closed && t.close()
}

function Aae(t) {
    const e = {
        sdkName: IO,
        sdkVersion: d0,
        origin: window.location.origin,
        coop: vae()
    };
    for (const [r, n] of Object.entries(e)) t.searchParams.append(r, n.toString())
}

function kae() {
    if (!sg) {
        const t = document.createElement("div");
        t.className = "-cbwsdk-css-reset", document.body.appendChild(t), sg = new qO, sg.attach(t)
    }
    return sg
}
class Iae {
    constructor({
        url: e = lae,
        metadata: r,
        preference: n
    }) {
        this.popup = null, this.listeners = new Map, this.postMessage = async i => {
            (await this.waitForPopupLoaded()).postMessage(i, this.url.origin)
        }, this.postRequestAndWaitForResponse = async i => {
            const s = this.onMessage(({
                requestId: a
            }) => a === i.id);
            return this.postMessage(i), await s
        }, this.onMessage = async i => new Promise((s, a) => {
            const o = c => {
                if (c.origin !== this.url.origin) return;
                const l = c.data;
                i(l) && (s(l), window.removeEventListener("message", o), this.listeners.delete(o))
            };
            window.addEventListener("message", o), this.listeners.set(o, {
                reject: a
            })
        }), this.disconnect = () => {
            Cae(this.popup), this.popup = null, this.listeners.forEach(({
                reject: i
            }, s) => {
                i(Kt.provider.userRejectedRequest("Request rejected")), window.removeEventListener("message", s)
            }), this.listeners.clear()
        }, this.waitForPopupLoaded = async () => this.popup && !this.popup.closed ? (this.popup.focus(), this.popup) : (this.popup = await _ae(this.url), this.onMessage(({
            event: i
        }) => i === "PopupUnload").then(this.disconnect).catch(() => {}), this.onMessage(({
            event: i
        }) => i === "PopupLoaded").then(i => {
            this.postMessage({
                requestId: i.id,
                data: {
                    version: d0,
                    metadata: this.metadata,
                    preference: this.preference,
                    location: window.location.toString()
                }
            })
        }).then(() => {
            if (!this.popup) throw Kt.rpc.internal();
            return this.popup
        })), this.url = new URL(e), this.metadata = r, this.preference = n
    }
}

function $ae(t) {
    const e = cse(Sae(t), {
            shouldIncludeStack: !0
        }),
        r = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
    return r.searchParams.set("version", d0), r.searchParams.set("code", e.code.toString()), r.searchParams.set("message", e.message), Object.assign(Object.assign({}, e), {
        docUrl: r.href
    })
}

function Sae(t) {
    var e;
    if (typeof t == "string") return {
        message: t,
        code: Lr.rpc.internal
    };
    if (kn(t)) {
        const r = t.errorMessage,
            n = (e = t.errorCode) !== null && e !== void 0 ? e : r.match(/(denied|rejected)/i) ? Lr.provider.userRejectedRequest : void 0;
        return Object.assign(Object.assign({}, t), {
            message: r,
            code: n,
            data: {
                method: t.method
            }
        })
    }
    return t
}
class Tae extends Ed {}
var Pae = function(t, e) {
    var r = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++) e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
    return r
};
class Nae extends Tae {
    constructor(e) {
        var {
            metadata: r
        } = e, n = e.preference, {
            keysUrl: i
        } = n, s = Pae(n, ["keysUrl"]);
        super(), this.signer = null, this.isCoinbaseWallet = !0, this.metadata = r, this.preference = s, this.communicator = new Iae({
            url: i,
            metadata: r,
            preference: s
        });
        const a = hae();
        a && (this.signer = this.initSigner(a))
    }
    async request(e) {
        try {
            if (Ase(e), !this.signer) switch (e.method) {
                case "eth_requestAccounts":
                    {
                        const r = await this.requestSignerSelection(e),
                            n = this.initSigner(r);await n.handshake(e),
                        this.signer = n,
                        fae(r);
                        break
                    }
                case "wallet_sendCalls":
                    {
                        const r = this.initSigner("scw");await r.handshake({
                            method: "handshake"
                        });
                        const n = await r.request(e);
                        return await r.cleanup(),
                        n
                    }
                case "wallet_getCallsStatus":
                    return X6(e, dae);
                case "net_version":
                    return 1;
                case "eth_chainId":
                    return Vc(1);
                default:
                    throw Kt.provider.unauthorized("Must call 'eth_requestAccounts' before other methods")
            }
            return await this.signer.request(e)
        } catch (r) {
            const {
                code: n
            } = r;
            return n === Lr.provider.unauthorized && this.disconnect(), Promise.reject($ae(r))
        }
    }
    async enable() {
        return console.warn('.enable() has been deprecated. Please use .request({ method: "eth_requestAccounts" }) instead.'), await this.request({
            method: "eth_requestAccounts"
        })
    }
    async disconnect() {
        var e;
        await ((e = this.signer) === null || e === void 0 ? void 0 : e.cleanup()), this.signer = null, uo.clearAll(), this.emit("disconnect", Kt.provider.disconnected("User initiated disconnection"))
    }
    requestSignerSelection(e) {
        return pae({
            communicator: this.communicator,
            preference: this.preference,
            metadata: this.metadata,
            handshakeRequest: e,
            callback: this.emit.bind(this)
        })
    }
    initSigner(e) {
        return gae({
            signerType: e,
            metadata: this.metadata,
            communicator: this.communicator,
            callback: this.emit.bind(this)
        })
    }
}

function Oae(t) {
    if (t) {
        if (!["all", "smartWalletOnly", "eoaOnly"].includes(t.options)) throw new Error(`Invalid options: ${t.options}`);
        if (t.attribution && t.attribution.auto !== void 0 && t.attribution.dataSuffix !== void 0) throw new Error("Attribution cannot contain both auto and dataSuffix properties")
    }
}

function jae(t) {
    var e;
    const r = {
        metadata: t.metadata,
        preference: t.preference
    };
    return (e = Cse(r)) !== null && e !== void 0 ? e : new Nae(r)
}
const Rae = {
    options: "all"
};

function d9(t) {
    var e;
    new uo("CBWSDK").setItem("VERSION", d0), bae();
    const n = {
        metadata: {
            appName: t.appName || "Dapp",
            appLogoUrl: t.appLogoUrl || "",
            appChainIds: t.appChainIds || []
        },
        preference: Object.assign(Rae, (e = t.preference) !== null && e !== void 0 ? e : {})
    };
    Oae(n.preference);
    let i = null;
    return {
        getProvider: () => (i || (i = jae(n)), i)
    }
}
let $2 = {
    0: "legacy",
    1: "eip2930",
    2: "eip1559",
    3: "eip4844",
    4: "eip7702"
};
const Mae = {
    legacy: 0,
    eip2930: 1,
    eip1559: 2,
    eip4844: 3,
    eip7702: 4
};
let eu = t => t !== void 0 ? BigInt(t) : void 0;

function ZO(t) {
    let e, {
        type: r = 2,
        ...n
    } = typeof t == "string" ? JSON.parse(t) : t;
    n.accessList && Array.isArray(n.accessList) ? e = n.accessList.map(l => Array.isArray(l) ? {
        address: l[0],
        storageKeys: l[1]
    } : l) : n.accessList && (e = Object.entries(n.accessList).map(l => ({
        address: l[0],
        storageKeys: l[1]
    })));
    let i = Number(n.chainId ? ? 1),
        s = Jn(n.data) ? n.data : n.data ? cn(Uint8Array.from(n.data)) : void 0,
        a = n.nonce ? Number(n.nonce) : void 0,
        o = {
            chainId: i,
            data: s,
            nonce: a,
            value: eu(n.value),
            gas: eu(n.gas ? ? n.gasLimit)
        },
        c = Number(r);
    if (c === 0) return { ...n,
        type: $2[c],
        ...o,
        gasPrice: eu(n.gasPrice),
        accessList: void 0,
        maxFeePerGas: void 0,
        maxPriorityFeePerGas: void 0
    };
    if (c === 1) return { ...n,
        type: $2[c],
        ...o,
        gasPrice: eu(n.gasPrice),
        accessList: e,
        maxFeePerGas: void 0,
        maxPriorityFeePerGas: void 0
    };
    if (c === 2) return { ...n,
        type: $2[c],
        ...o,
        nonce: a,
        accessList: e,
        maxFeePerGas: eu(n.maxFeePerGas),
        maxPriorityFeePerGas: eu(n.maxPriorityFeePerGas),
        gasPrice: void 0,
        maxFeePerBlobGas: void 0
    };
    throw Error(`Unsupported transaction type: ${r}`)
}
const Dae = ({
        as: t = "div",
        ...e
    }, r) => d.jsx(t, { ...e,
        ref: r
    }),
    Lae = v.forwardRef(Dae),
    Uae = "https://challenges.cloudflare.com/turnstile/v0/api.js",
    Nm = "cf-turnstile-script",
    Fae = "cf-turnstile",
    JO = "onloadTurnstileCallback",
    Om = t => !!document.getElementById(t),
    Bae = ({
        render: t = "explicit",
        onLoadCallbackName: e = JO,
        scriptOptions: {
            nonce: r = "",
            defer: n = !0,
            async: i = !0,
            id: s = "",
            appendTo: a,
            onError: o,
            crossOrigin: c = ""
        } = {}
    }) => {
        const l = s || Nm;
        if (Om(l)) return;
        const u = document.createElement("script");
        if (u.id = l, u.src = `${Uae}?onload=${e}&render=${t}`, document.querySelector(`script[src="${u.src}"]`)) return;
        u.defer = !!n, u.async = !!i, r && (u.nonce = r), c && (u.crossOrigin = c), o && (u.onerror = o), (a === "body" ? document.body : document.getElementsByTagName("head")[0]).appendChild(u)
    },
    Ua = {
        normal: {
            width: 300,
            height: 65
        },
        compact: {
            width: 130,
            height: 120
        },
        invisible: {
            width: 0,
            height: 0,
            overflow: "hidden"
        },
        interactionOnly: {
            width: "fit-content",
            height: "auto"
        }
    };

function Wae(t) {
    let e;
    return t !== "invisible" && (e = t), e
}

function zae(t = Nm) {
    const [e, r] = v.useState(!1);
    return v.useEffect(() => {
        const n = () => {
                Om(t) && r(!0)
            },
            i = new MutationObserver(n);
        return i.observe(document, {
            childList: !0,
            subtree: !0
        }), n(), () => {
            i.disconnect()
        }
    }, [t]), e
}
const QO = v.forwardRef((t, e) => {
    const {
        scriptOptions: r,
        options: n = {},
        siteKey: i,
        onWidgetLoad: s,
        onSuccess: a,
        onExpire: o,
        onError: c,
        onBeforeInteractive: l,
        onAfterInteractive: u,
        onUnsupported: h,
        onLoadScript: f,
        id: p,
        style: g,
        as: m = "div",
        injectScript: y = !0,
        ...w
    } = t, x = n.size ? ? "normal", [E, _] = v.useState(n.execution === "execute" ? Ua.invisible : n.appearance === "interaction-only" ? Ua.interactionOnly : Ua[x]), b = v.useRef(null), A = v.useRef(!1), [I, T] = v.useState(), [C, $] = v.useState(!1), P = p ? ? Fae, N = y ? (r == null ? void 0 : r.id) || `${Nm}__${P}` : (r == null ? void 0 : r.id) || Nm, R = zae(N), D = r != null && r.onLoadCallbackName ? `${r.onLoadCallbackName}__${P}` : `${JO}__${P}`, S = v.useMemo(() => ({
        sitekey: i,
        action: n.action,
        cData: n.cData,
        callback: a,
        "error-callback": c,
        "expired-callback": o,
        "before-interactive-callback": l,
        "after-interactive-callback": u,
        "unsupported-callback": h,
        theme: n.theme ? ? "auto",
        language: n.language ? ? "auto",
        tabindex: n.tabIndex,
        "response-field": n.responseField,
        "response-field-name": n.responseFieldName,
        size: Wae(x),
        retry: n.retry ? ? "auto",
        "retry-interval": n.retryInterval ? ? 8e3,
        "refresh-expired": n.refreshExpired ? ? "auto",
        execution: n.execution ? ? "render",
        appearance: n.appearance ? ? "always"
    }), [i, n, a, c, o, x, l, u, h]), O = v.useMemo(() => JSON.stringify(S), [S]);
    return v.useImperativeHandle(e, () => {
        if (typeof window > "u" || !R) return;
        const {
            turnstile: M
        } = window;
        return {
            getResponse() {
                if (!(M != null && M.getResponse) || !I) {
                    console.warn("Turnstile has not been loaded");
                    return
                }
                return M.getResponse(I)
            },
            reset() {
                if (!(M != null && M.reset) || !I) {
                    console.warn("Turnstile has not been loaded");
                    return
                }
                n.execution === "execute" && _(Ua.invisible);
                try {
                    M.reset(I)
                } catch (U) {
                    console.warn(`Failed to reset Turnstile widget ${I}`, U)
                }
            },
            remove() {
                if (!(M != null && M.remove) || !I) {
                    console.warn("Turnstile has not been loaded");
                    return
                }
                T(""), _(Ua.invisible), M.remove(I)
            },
            render() {
                if (!(M != null && M.render) || !b.current || I) {
                    console.warn("Turnstile has not been loaded or widget already rendered");
                    return
                }
                const U = M.render(b.current, S);
                return T(U), n.execution !== "execute" && _(Ua[x]), U
            },
            execute() {
                if (n.execution === "execute") {
                    if (!(M != null && M.execute) || !b.current || !I) {
                        console.warn("Turnstile has not been loaded or widget has not been rendered");
                        return
                    }
                    M.execute(b.current, S), _(Ua[x])
                }
            },
            isExpired() {
                if (!(M != null && M.isExpired) || !I) {
                    console.warn("Turnstile has not been loaded");
                    return
                }
                return M.isExpired(I)
            }
        }
    }, [R, I, n.execution, x, S, b]), v.useEffect(() => (window[D] = () => $(!0), () => {
        delete window[D]
    }), [D]), v.useEffect(() => {
        y && !C && Bae({
            onLoadCallbackName: D,
            scriptOptions: { ...r,
                id: N
            }
        })
    }, [y, C, D, r, N]), v.useEffect(() => {
        R && !C && window.turnstile && $(!0)
    }, [C, R]), v.useEffect(() => {
        if (!i) {
            console.warn("sitekey was not provided");
            return
        }
        if (!R || !b.current || !C || A.current) return;
        const M = window.turnstile.render(b.current, S);
        T(M), A.current = !0
    }, [R, i, S, A, C]), v.useEffect(() => {
        if (window.turnstile && b.current && I) {
            Om(I) && window.turnstile.remove(I);
            const M = window.turnstile.render(b.current, S);
            T(M), A.current = !0
        }
    }, [O, i]), v.useEffect(() => {
        if (window.turnstile && I && Om(I)) return s == null || s(I), () => {
            window.turnstile.remove(I)
        }
    }, [I, s]), v.useEffect(() => {
        _(n.execution === "execute" ? Ua.invisible : S.appearance === "interaction-only" ? Ua.interactionOnly : Ua[x])
    }, [n.execution, x, S.appearance]), v.useEffect(() => {
        !R || typeof f != "function" || f()
    }, [R, f]), d.jsx(Lae, {
        ref: b,
        as: m,
        id: P,
        style: { ...E,
            ...g
        },
        ...w
    })
});
QO.displayName = "Turnstile";

function jm(t) {
    "@babel/helpers - typeof";
    return jm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    } : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }, jm(t)
}
var qae = /^\s+/,
    Hae = /\s+$/;

function tt(t, e) {
    if (t = t || "", e = e || {}, t instanceof tt) return t;
    if (!(this instanceof tt)) return new tt(t, e);
    var r = Vae(t);
    this._originalInput = t, this._r = r.r, this._g = r.g, this._b = r.b, this._a = r.a, this._roundA = Math.round(100 * this._a) / 100, this._format = e.format || r.format, this._gradientType = e.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = r.ok
}
tt.prototype = {
    isDark: function() {
        return this.getBrightness() < 128
    },
    isLight: function() {
        return !this.isDark()
    },
    isValid: function() {
        return this._ok
    },
    getOriginalInput: function() {
        return this._originalInput
    },
    getFormat: function() {
        return this._format
    },
    getAlpha: function() {
        return this._a
    },
    getBrightness: function() {
        var e = this.toRgb();
        return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3
    },
    getLuminance: function() {
        var e = this.toRgb(),
            r, n, i, s, a, o;
        return r = e.r / 255, n = e.g / 255, i = e.b / 255, r <= .03928 ? s = r / 12.92 : s = Math.pow((r + .055) / 1.055, 2.4), n <= .03928 ? a = n / 12.92 : a = Math.pow((n + .055) / 1.055, 2.4), i <= .03928 ? o = i / 12.92 : o = Math.pow((i + .055) / 1.055, 2.4), .2126 * s + .7152 * a + .0722 * o
    },
    setAlpha: function(e) {
        return this._a = XO(e), this._roundA = Math.round(100 * this._a) / 100, this
    },
    toHsv: function() {
        var e = h9(this._r, this._g, this._b);
        return {
            h: e.h * 360,
            s: e.s,
            v: e.v,
            a: this._a
        }
    },
    toHsvString: function() {
        var e = h9(this._r, this._g, this._b),
            r = Math.round(e.h * 360),
            n = Math.round(e.s * 100),
            i = Math.round(e.v * 100);
        return this._a == 1 ? "hsv(" + r + ", " + n + "%, " + i + "%)" : "hsva(" + r + ", " + n + "%, " + i + "%, " + this._roundA + ")"
    },
    toHsl: function() {
        var e = u9(this._r, this._g, this._b);
        return {
            h: e.h * 360,
            s: e.s,
            l: e.l,
            a: this._a
        }
    },
    toHslString: function() {
        var e = u9(this._r, this._g, this._b),
            r = Math.round(e.h * 360),
            n = Math.round(e.s * 100),
            i = Math.round(e.l * 100);
        return this._a == 1 ? "hsl(" + r + ", " + n + "%, " + i + "%)" : "hsla(" + r + ", " + n + "%, " + i + "%, " + this._roundA + ")"
    },
    toHex: function(e) {
        return f9(this._r, this._g, this._b, e)
    },
    toHexString: function(e) {
        return "#" + this.toHex(e)
    },
    toHex8: function(e) {
        return Zae(this._r, this._g, this._b, this._a, e)
    },
    toHex8String: function(e) {
        return "#" + this.toHex8(e)
    },
    toRgb: function() {
        return {
            r: Math.round(this._r),
            g: Math.round(this._g),
            b: Math.round(this._b),
            a: this._a
        }
    },
    toRgbString: function() {
        return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")"
    },
    toPercentageRgb: function() {
        return {
            r: Math.round(Tr(this._r, 255) * 100) + "%",
            g: Math.round(Tr(this._g, 255) * 100) + "%",
            b: Math.round(Tr(this._b, 255) * 100) + "%",
            a: this._a
        }
    },
    toPercentageRgbString: function() {
        return this._a == 1 ? "rgb(" + Math.round(Tr(this._r, 255) * 100) + "%, " + Math.round(Tr(this._g, 255) * 100) + "%, " + Math.round(Tr(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(Tr(this._r, 255) * 100) + "%, " + Math.round(Tr(this._g, 255) * 100) + "%, " + Math.round(Tr(this._b, 255) * 100) + "%, " + this._roundA + ")"
    },
    toName: function() {
        return this._a === 0 ? "transparent" : this._a < 1 ? !1 : coe[f9(this._r, this._g, this._b, !0)] || !1
    },
    toFilter: function(e) {
        var r = "#" + p9(this._r, this._g, this._b, this._a),
            n = r,
            i = this._gradientType ? "GradientType = 1, " : "";
        if (e) {
            var s = tt(e);
            n = "#" + p9(s._r, s._g, s._b, s._a)
        }
        return "progid:DXImageTransform.Microsoft.gradient(" + i + "startColorstr=" + r + ",endColorstr=" + n + ")"
    },
    toString: function(e) {
        var r = !!e;
        e = e || this._format;
        var n = !1,
            i = this._a < 1 && this._a >= 0,
            s = !r && i && (e === "hex" || e === "hex6" || e === "hex3" || e === "hex4" || e === "hex8" || e === "name");
        return s ? e === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (n = this.toRgbString()), e === "prgb" && (n = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (n = this.toHexString()), e === "hex3" && (n = this.toHexString(!0)), e === "hex4" && (n = this.toHex8String(!0)), e === "hex8" && (n = this.toHex8String()), e === "name" && (n = this.toName()), e === "hsl" && (n = this.toHslString()), e === "hsv" && (n = this.toHsvString()), n || this.toHexString())
    },
    clone: function() {
        return tt(this.toString())
    },
    _applyModification: function(e, r) {
        var n = e.apply(null, [this].concat([].slice.call(r)));
        return this._r = n._r, this._g = n._g, this._b = n._b, this.setAlpha(n._a), this
    },
    lighten: function() {
        return this._applyModification(eoe, arguments)
    },
    brighten: function() {
        return this._applyModification(toe, arguments)
    },
    darken: function() {
        return this._applyModification(roe, arguments)
    },
    desaturate: function() {
        return this._applyModification(Jae, arguments)
    },
    saturate: function() {
        return this._applyModification(Qae, arguments)
    },
    greyscale: function() {
        return this._applyModification(Xae, arguments)
    },
    spin: function() {
        return this._applyModification(noe, arguments)
    },
    _applyCombination: function(e, r) {
        return e.apply(null, [this].concat([].slice.call(r)))
    },
    analogous: function() {
        return this._applyCombination(aoe, arguments)
    },
    complement: function() {
        return this._applyCombination(ioe, arguments)
    },
    monochromatic: function() {
        return this._applyCombination(ooe, arguments)
    },
    splitcomplement: function() {
        return this._applyCombination(soe, arguments)
    },
    triad: function() {
        return this._applyCombination(g9, [3])
    },
    tetrad: function() {
        return this._applyCombination(g9, [4])
    }
};
tt.fromRatio = function(t, e) {
    if (jm(t) == "object") {
        var r = {};
        for (var n in t) t.hasOwnProperty(n) && (n === "a" ? r[n] = t[n] : r[n] = _f(t[n]));
        t = r
    }
    return tt(t, e)
};

function Vae(t) {
    var e = {
            r: 0,
            g: 0,
            b: 0
        },
        r = 1,
        n = null,
        i = null,
        s = null,
        a = !1,
        o = !1;
    return typeof t == "string" && (t = hoe(t)), jm(t) == "object" && (xo(t.r) && xo(t.g) && xo(t.b) ? (e = Gae(t.r, t.g, t.b), a = !0, o = String(t.r).substr(-1) === "%" ? "prgb" : "rgb") : xo(t.h) && xo(t.s) && xo(t.v) ? (n = _f(t.s), i = _f(t.v), e = Yae(t.h, n, i), a = !0, o = "hsv") : xo(t.h) && xo(t.s) && xo(t.l) && (n = _f(t.s), s = _f(t.l), e = Kae(t.h, n, s), a = !0, o = "hsl"), t.hasOwnProperty("a") && (r = t.a)), r = XO(r), {
        ok: a,
        format: t.format || o,
        r: Math.min(255, Math.max(e.r, 0)),
        g: Math.min(255, Math.max(e.g, 0)),
        b: Math.min(255, Math.max(e.b, 0)),
        a: r
    }
}

function Gae(t, e, r) {
    return {
        r: Tr(t, 255) * 255,
        g: Tr(e, 255) * 255,
        b: Tr(r, 255) * 255
    }
}

function u9(t, e, r) {
    t = Tr(t, 255), e = Tr(e, 255), r = Tr(r, 255);
    var n = Math.max(t, e, r),
        i = Math.min(t, e, r),
        s, a, o = (n + i) / 2;
    if (n == i) s = a = 0;
    else {
        var c = n - i;
        switch (a = o > .5 ? c / (2 - n - i) : c / (n + i), n) {
            case t:
                s = (e - r) / c + (e < r ? 6 : 0);
                break;
            case e:
                s = (r - t) / c + 2;
                break;
            case r:
                s = (t - e) / c + 4;
                break
        }
        s /= 6
    }
    return {
        h: s,
        s: a,
        l: o
    }
}

function Kae(t, e, r) {
    var n, i, s;
    t = Tr(t, 360), e = Tr(e, 100), r = Tr(r, 100);

    function a(l, u, h) {
        return h < 0 && (h += 1), h > 1 && (h -= 1), h < 1 / 6 ? l + (u - l) * 6 * h : h < 1 / 2 ? u : h < 2 / 3 ? l + (u - l) * (2 / 3 - h) * 6 : l
    }
    if (e === 0) n = i = s = r;
    else {
        var o = r < .5 ? r * (1 + e) : r + e - r * e,
            c = 2 * r - o;
        n = a(c, o, t + 1 / 3), i = a(c, o, t), s = a(c, o, t - 1 / 3)
    }
    return {
        r: n * 255,
        g: i * 255,
        b: s * 255
    }
}

function h9(t, e, r) {
    t = Tr(t, 255), e = Tr(e, 255), r = Tr(r, 255);
    var n = Math.max(t, e, r),
        i = Math.min(t, e, r),
        s, a, o = n,
        c = n - i;
    if (a = n === 0 ? 0 : c / n, n == i) s = 0;
    else {
        switch (n) {
            case t:
                s = (e - r) / c + (e < r ? 6 : 0);
                break;
            case e:
                s = (r - t) / c + 2;
                break;
            case r:
                s = (t - e) / c + 4;
                break
        }
        s /= 6
    }
    return {
        h: s,
        s: a,
        v: o
    }
}

function Yae(t, e, r) {
    t = Tr(t, 360) * 6, e = Tr(e, 100), r = Tr(r, 100);
    var n = Math.floor(t),
        i = t - n,
        s = r * (1 - e),
        a = r * (1 - i * e),
        o = r * (1 - (1 - i) * e),
        c = n % 6,
        l = [r, a, s, s, o, r][c],
        u = [o, r, r, a, s, s][c],
        h = [s, s, o, r, r, a][c];
    return {
        r: l * 255,
        g: u * 255,
        b: h * 255
    }
}

function f9(t, e, r, n) {
    var i = [fa(Math.round(t).toString(16)), fa(Math.round(e).toString(16)), fa(Math.round(r).toString(16))];
    return n && i[0].charAt(0) == i[0].charAt(1) && i[1].charAt(0) == i[1].charAt(1) && i[2].charAt(0) == i[2].charAt(1) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("")
}

function Zae(t, e, r, n, i) {
    var s = [fa(Math.round(t).toString(16)), fa(Math.round(e).toString(16)), fa(Math.round(r).toString(16)), fa(ej(n))];
    return i && s[0].charAt(0) == s[0].charAt(1) && s[1].charAt(0) == s[1].charAt(1) && s[2].charAt(0) == s[2].charAt(1) && s[3].charAt(0) == s[3].charAt(1) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("")
}

function p9(t, e, r, n) {
    var i = [fa(ej(n)), fa(Math.round(t).toString(16)), fa(Math.round(e).toString(16)), fa(Math.round(r).toString(16))];
    return i.join("")
}
tt.equals = function(t, e) {
    return !t || !e ? !1 : tt(t).toRgbString() == tt(e).toRgbString()
};
tt.random = function() {
    return tt.fromRatio({
        r: Math.random(),
        g: Math.random(),
        b: Math.random()
    })
};

function Jae(t, e) {
    e = e === 0 ? 0 : e || 10;
    var r = tt(t).toHsl();
    return r.s -= e / 100, r.s = ay(r.s), tt(r)
}

function Qae(t, e) {
    e = e === 0 ? 0 : e || 10;
    var r = tt(t).toHsl();
    return r.s += e / 100, r.s = ay(r.s), tt(r)
}

function Xae(t) {
    return tt(t).desaturate(100)
}

function eoe(t, e) {
    e = e === 0 ? 0 : e || 10;
    var r = tt(t).toHsl();
    return r.l += e / 100, r.l = ay(r.l), tt(r)
}

function toe(t, e) {
    e = e === 0 ? 0 : e || 10;
    var r = tt(t).toRgb();
    return r.r = Math.max(0, Math.min(255, r.r - Math.round(255 * -(e / 100)))), r.g = Math.max(0, Math.min(255, r.g - Math.round(255 * -(e / 100)))), r.b = Math.max(0, Math.min(255, r.b - Math.round(255 * -(e / 100)))), tt(r)
}

function roe(t, e) {
    e = e === 0 ? 0 : e || 10;
    var r = tt(t).toHsl();
    return r.l -= e / 100, r.l = ay(r.l), tt(r)
}

function noe(t, e) {
    var r = tt(t).toHsl(),
        n = (r.h + e) % 360;
    return r.h = n < 0 ? 360 + n : n, tt(r)
}

function ioe(t) {
    var e = tt(t).toHsl();
    return e.h = (e.h + 180) % 360, tt(e)
}

function g9(t, e) {
    if (isNaN(e) || e <= 0) throw new Error("Argument to polyad must be a positive number");
    for (var r = tt(t).toHsl(), n = [tt(t)], i = 360 / e, s = 1; s < e; s++) n.push(tt({
        h: (r.h + s * i) % 360,
        s: r.s,
        l: r.l
    }));
    return n
}

function soe(t) {
    var e = tt(t).toHsl(),
        r = e.h;
    return [tt(t), tt({
        h: (r + 72) % 360,
        s: e.s,
        l: e.l
    }), tt({
        h: (r + 216) % 360,
        s: e.s,
        l: e.l
    })]
}

function aoe(t, e, r) {
    e = e || 6, r = r || 30;
    var n = tt(t).toHsl(),
        i = 360 / r,
        s = [tt(t)];
    for (n.h = (n.h - (i * e >> 1) + 720) % 360; --e;) n.h = (n.h + i) % 360, s.push(tt(n));
    return s
}

function ooe(t, e) {
    e = e || 6;
    for (var r = tt(t).toHsv(), n = r.h, i = r.s, s = r.v, a = [], o = 1 / e; e--;) a.push(tt({
        h: n,
        s: i,
        v: s
    })), s = (s + o) % 1;
    return a
}
tt.mix = function(t, e, r) {
    r = r === 0 ? 0 : r || 50;
    var n = tt(t).toRgb(),
        i = tt(e).toRgb(),
        s = r / 100,
        a = {
            r: (i.r - n.r) * s + n.r,
            g: (i.g - n.g) * s + n.g,
            b: (i.b - n.b) * s + n.b,
            a: (i.a - n.a) * s + n.a
        };
    return tt(a)
};
tt.readability = function(t, e) {
    var r = tt(t),
        n = tt(e);
    return (Math.max(r.getLuminance(), n.getLuminance()) + .05) / (Math.min(r.getLuminance(), n.getLuminance()) + .05)
};
tt.isReadable = function(t, e, r) {
    var n = tt.readability(t, e),
        i, s;
    switch (s = !1, i = foe(r), i.level + i.size) {
        case "AAsmall":
        case "AAAlarge":
            s = n >= 4.5;
            break;
        case "AAlarge":
            s = n >= 3;
            break;
        case "AAAsmall":
            s = n >= 7;
            break
    }
    return s
};
tt.mostReadable = function(t, e, r) {
    var n = null,
        i = 0,
        s, a, o, c;
    r = r || {}, a = r.includeFallbackColors, o = r.level, c = r.size;
    for (var l = 0; l < e.length; l++) s = tt.readability(t, e[l]), s > i && (i = s, n = tt(e[l]));
    return tt.isReadable(t, n, {
        level: o,
        size: c
    }) || !a ? n : (r.includeFallbackColors = !1, tt.mostReadable(t, ["#fff", "#000"], r))
};
var V3 = tt.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
    },
    coe = tt.hexNames = loe(V3);

function loe(t) {
    var e = {};
    for (var r in t) t.hasOwnProperty(r) && (e[t[r]] = r);
    return e
}

function XO(t) {
    return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t
}

function Tr(t, e) {
    doe(t) && (t = "100%");
    var r = uoe(t);
    return t = Math.min(e, Math.max(0, parseFloat(t))), r && (t = parseInt(t * e, 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : t % e / parseFloat(e)
}

function ay(t) {
    return Math.min(1, Math.max(0, t))
}

function Gi(t) {
    return parseInt(t, 16)
}

function doe(t) {
    return typeof t == "string" && t.indexOf(".") != -1 && parseFloat(t) === 1
}

function uoe(t) {
    return typeof t == "string" && t.indexOf("%") != -1
}

function fa(t) {
    return t.length == 1 ? "0" + t : "" + t
}

function _f(t) {
    return t <= 1 && (t = t * 100 + "%"), t
}

function ej(t) {
    return Math.round(parseFloat(t) * 255).toString(16)
}

function m9(t) {
    return Gi(t) / 255
}
var ra = function() {
    var t = "[-\\+]?\\d+%?",
        e = "[-\\+]?\\d*\\.\\d+%?",
        r = "(?:" + e + ")|(?:" + t + ")",
        n = "[\\s|\\(]+(" + r + ")[,|\\s]+(" + r + ")[,|\\s]+(" + r + ")\\s*\\)?",
        i = "[\\s|\\(]+(" + r + ")[,|\\s]+(" + r + ")[,|\\s]+(" + r + ")[,|\\s]+(" + r + ")\\s*\\)?";
    return {
        CSS_UNIT: new RegExp(r),
        rgb: new RegExp("rgb" + n),
        rgba: new RegExp("rgba" + i),
        hsl: new RegExp("hsl" + n),
        hsla: new RegExp("hsla" + i),
        hsv: new RegExp("hsv" + n),
        hsva: new RegExp("hsva" + i),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    }
}();

function xo(t) {
    return !!ra.CSS_UNIT.exec(t)
}

function hoe(t) {
    t = t.replace(qae, "").replace(Hae, "").toLowerCase();
    var e = !1;
    if (V3[t]) t = V3[t], e = !0;
    else if (t == "transparent") return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        format: "name"
    };
    var r;
    return (r = ra.rgb.exec(t)) ? {
        r: r[1],
        g: r[2],
        b: r[3]
    } : (r = ra.rgba.exec(t)) ? {
        r: r[1],
        g: r[2],
        b: r[3],
        a: r[4]
    } : (r = ra.hsl.exec(t)) ? {
        h: r[1],
        s: r[2],
        l: r[3]
    } : (r = ra.hsla.exec(t)) ? {
        h: r[1],
        s: r[2],
        l: r[3],
        a: r[4]
    } : (r = ra.hsv.exec(t)) ? {
        h: r[1],
        s: r[2],
        v: r[3]
    } : (r = ra.hsva.exec(t)) ? {
        h: r[1],
        s: r[2],
        v: r[3],
        a: r[4]
    } : (r = ra.hex8.exec(t)) ? {
        r: Gi(r[1]),
        g: Gi(r[2]),
        b: Gi(r[3]),
        a: m9(r[4]),
        format: e ? "name" : "hex8"
    } : (r = ra.hex6.exec(t)) ? {
        r: Gi(r[1]),
        g: Gi(r[2]),
        b: Gi(r[3]),
        format: e ? "name" : "hex"
    } : (r = ra.hex4.exec(t)) ? {
        r: Gi(r[1] + "" + r[1]),
        g: Gi(r[2] + "" + r[2]),
        b: Gi(r[3] + "" + r[3]),
        a: m9(r[4] + "" + r[4]),
        format: e ? "name" : "hex8"
    } : (r = ra.hex3.exec(t)) ? {
        r: Gi(r[1] + "" + r[1]),
        g: Gi(r[2] + "" + r[2]),
        b: Gi(r[3] + "" + r[3]),
        format: e ? "name" : "hex"
    } : !1
}

function foe(t) {
    var e, r;
    return t = t || {
        level: "AA",
        size: "small"
    }, e = (t.level || "AA").toUpperCase(), r = (t.size || "small").toLowerCase(), e !== "AA" && e !== "AAA" && (e = "AA"), r !== "small" && r !== "large" && (r = "small"), {
        level: e,
        size: r
    }
}

function poe({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M10.5 1.5H8.25A2.25 2.25 0 0 0 6 3.75v16.5a2.25 2.25 0 0 0 2.25 2.25h7.5A2.25 2.25 0 0 0 18 20.25V3.75a2.25 2.25 0 0 0-2.25-2.25H13.5m-3 0V3h3V1.5m-3 0h3m-3 18.75h3"
    }))
}
const oy = v.forwardRef(poe);

function goe({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M7.864 4.243A7.5 7.5 0 0 1 19.5 10.5c0 2.92-.556 5.709-1.568 8.268M5.742 6.364A7.465 7.465 0 0 0 4.5 10.5a7.464 7.464 0 0 1-1.15 3.993m1.989 3.559A11.209 11.209 0 0 0 8.25 10.5a3.75 3.75 0 1 1 7.5 0c0 .527-.021 1.049-.064 1.565M12 10.5a14.94 14.94 0 0 1-3.6 9.75m6.633-4.596a18.666 18.666 0 0 1-2.485 5.33"
    }))
}
const sx = v.forwardRef(goe);

function moe({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M2.25 6.75c0 8.284 6.716 15 15 15h2.25a2.25 2.25 0 0 0 2.25-2.25v-1.372c0-.516-.351-.966-.852-1.091l-4.423-1.106c-.44-.11-.902.055-1.173.417l-.97 1.293c-.282.376-.769.542-1.21.38a12.035 12.035 0 0 1-7.143-7.143c-.162-.441.004-.928.38-1.21l1.293-.97c.363-.271.527-.734.417-1.173L6.963 3.102a1.125 1.125 0 0 0-1.091-.852H4.5A2.25 2.25 0 0 0 2.25 4.5v2.25Z"
    }))
}
const Ca = v.forwardRef(moe);

function yoe({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M9 12.75 11.25 15 15 9.75m-3-7.036A11.959 11.959 0 0 1 3.598 6 11.99 11.99 0 0 0 3 9.749c0 5.592 3.824 10.29 9 11.623 5.176-1.332 9-6.03 9-11.622 0-1.31-.21-2.571-.598-3.751h-.152c-3.196 0-6.1-1.248-8.25-3.285Z"
    }))
}
const hd = v.forwardRef(yoe);

function woe({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"
    }))
}
const tj = v.forwardRef(woe);

function boe({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3"
    }))
}
const voe = v.forwardRef(boe);

function xoe({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 5.25h.008v.008H12v-.008Z"
    }))
}
const Ql = v.forwardRef(xoe);

function Eoe({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M6 18 18 6M6 6l12 12"
    }))
}
const _oe = v.forwardRef(Eoe);

function Coe({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 0v-7.5A2.25 2.25 0 0 1 5.25 9h13.5A2.25 2.25 0 0 1 21 11.25v7.5"
    }))
}
const Aoe = v.forwardRef(Coe);

function koe({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"
    }))
}
const yo = v.forwardRef(koe);

function Ioe({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "m19.5 8.25-7.5 7.5-7.5-7.5"
    }))
}
const cy = v.forwardRef(Ioe),
    y9 = t => {
        let e;
        const r = new Set,
            n = (l, u) => {
                const h = typeof l == "function" ? l(e) : l;
                if (!Object.is(h, e)) {
                    const f = e;
                    e = u ? ? (typeof h != "object" || h === null) ? h : Object.assign({}, e, h), r.forEach(p => p(e, f))
                }
            },
            i = () => e,
            o = {
                setState: n,
                getState: i,
                getInitialState: () => c,
                subscribe: l => (r.add(l), () => r.delete(l))
            },
            c = e = t(n, i, o);
        return o
    },
    $oe = t => t ? y9(t) : y9,
    Soe = t => t;

function Toe(t, e = Soe) {
    const r = at.useSyncExternalStore(t.subscribe, () => e(t.getState()), () => e(t.getInitialState()));
    return at.useDebugValue(r), r
}
const w9 = t => {
        const e = $oe(t),
            r = n => Toe(e, n);
        return Object.assign(r, e), r
    },
    vh = t => t ? w9(t) : w9,
    rj = typeof document < "u" ? at.useLayoutEffect : () => {};

function Poe(t) {
    const e = v.useRef(null);
    return rj(() => {
        e.current = t
    }, [t]), v.useCallback((...r) => {
        const n = e.current;
        return n == null ? void 0 : n(...r)
    }, [])
}
const dl = t => {
        var e;
        return (e = t == null ? void 0 : t.ownerDocument) !== null && e !== void 0 ? e : document
    },
    Fl = t => t && "window" in t && t.window === t ? t : dl(t).defaultView || window;

function Noe(t) {
    return t !== null && typeof t == "object" && "nodeType" in t && typeof t.nodeType == "number"
}

function Ooe(t) {
    return Noe(t) && t.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in t
}
let joe = !1;

function ax() {
    return joe
}

function nj(t, e) {
    if (!ax()) return e && t ? t.contains(e) : !1;
    if (!t || !e) return !1;
    let r = e;
    for (; r !== null;) {
        if (r === t) return !0;
        r.tagName === "SLOT" && r.assignedSlot ? r = r.assignedSlot.parentNode : Ooe(r) ? r = r.host : r = r.parentNode
    }
    return !1
}
const G3 = (t = document) => {
    var e;
    if (!ax()) return t.activeElement;
    let r = t.activeElement;
    for (; r && "shadowRoot" in r && (!((e = r.shadowRoot) === null || e === void 0) && e.activeElement);) r = r.shadowRoot.activeElement;
    return r
};

function ij(t) {
    return ax() && t.target.shadowRoot && t.composedPath ? t.composedPath()[0] : t.target
}

function Roe(t) {
    var e;
    return typeof window > "u" || window.navigator == null ? !1 : ((e = window.navigator.userAgentData) === null || e === void 0 ? void 0 : e.brands.some(r => t.test(r.brand))) || t.test(window.navigator.userAgent)
}

function Moe(t) {
    var e;
    return typeof window < "u" && window.navigator != null ? t.test(((e = window.navigator.userAgentData) === null || e === void 0 ? void 0 : e.platform) || window.navigator.platform) : !1
}

function sj(t) {
    let e = null;
    return () => (e == null && (e = t()), e)
}
const Doe = sj(function() {
        return Moe(/^Mac/i)
    }),
    Loe = sj(function() {
        return Roe(/Android/i)
    });

function aj() {
    let t = v.useRef(new Map),
        e = v.useCallback((i, s, a, o) => {
            let c = o != null && o.once ? (...l) => {
                t.current.delete(a), a(...l)
            } : a;
            t.current.set(a, {
                type: s,
                eventTarget: i,
                fn: c,
                options: o
            }), i.addEventListener(s, c, o)
        }, []),
        r = v.useCallback((i, s, a, o) => {
            var c;
            let l = ((c = t.current.get(a)) === null || c === void 0 ? void 0 : c.fn) || a;
            i.removeEventListener(s, l, o), t.current.delete(a)
        }, []),
        n = v.useCallback(() => {
            t.current.forEach((i, s) => {
                r(i.eventTarget, i.type, s, i.options)
            })
        }, [r]);
    return v.useEffect(() => n, [n]), {
        addGlobalListener: e,
        removeGlobalListener: r,
        removeAllGlobalListeners: n
    }
}

function Uoe(t) {
    return t.mozInputSource === 0 && t.isTrusted ? !0 : Loe() && t.pointerType ? t.type === "click" && t.buttons === 1 : t.detail === 0 && !t.pointerType
}

function oj(t) {
    let e = t;
    return e.nativeEvent = t, e.isDefaultPrevented = () => e.defaultPrevented, e.isPropagationStopped = () => e.cancelBubble, e.persist = () => {}, e
}

function Foe(t, e) {
    Object.defineProperty(t, "target", {
        value: e
    }), Object.defineProperty(t, "currentTarget", {
        value: e
    })
}

function cj(t) {
    let e = v.useRef({
        isFocused: !1,
        observer: null
    });
    rj(() => {
        const n = e.current;
        return () => {
            n.observer && (n.observer.disconnect(), n.observer = null)
        }
    }, []);
    let r = Poe(n => {
        t == null || t(n)
    });
    return v.useCallback(n => {
        if (n.target instanceof HTMLButtonElement || n.target instanceof HTMLInputElement || n.target instanceof HTMLTextAreaElement || n.target instanceof HTMLSelectElement) {
            e.current.isFocused = !0;
            let i = n.target,
                s = a => {
                    if (e.current.isFocused = !1, i.disabled) {
                        let o = oj(a);
                        r(o)
                    }
                    e.current.observer && (e.current.observer.disconnect(), e.current.observer = null)
                };
            i.addEventListener("focusout", s, {
                once: !0
            }), e.current.observer = new MutationObserver(() => {
                if (e.current.isFocused && i.disabled) {
                    var a;
                    (a = e.current.observer) === null || a === void 0 || a.disconnect();
                    let o = i === document.activeElement ? null : document.activeElement;
                    i.dispatchEvent(new FocusEvent("blur", {
                        relatedTarget: o
                    })), i.dispatchEvent(new FocusEvent("focusout", {
                        bubbles: !0,
                        relatedTarget: o
                    }))
                }
            }), e.current.observer.observe(i, {
                attributes: !0,
                attributeFilter: ["disabled"]
            })
        }
    }, [r])
}
let Boe = !1,
    u0 = null,
    K3 = new Set,
    Uf = new Map,
    fd = !1,
    Y3 = !1;
const Woe = {
    Tab: !0,
    Escape: !0
};

function ox(t, e) {
    for (let r of K3) r(t, e)
}

function zoe(t) {
    return !(t.metaKey || !Doe() && t.altKey || t.ctrlKey || t.key === "Control" || t.key === "Shift" || t.key === "Meta")
}

function Rm(t) {
    fd = !0, zoe(t) && (u0 = "keyboard", ox("keyboard", t))
}

function Uu(t) {
    u0 = "pointer", (t.type === "mousedown" || t.type === "pointerdown") && (fd = !0, ox("pointer", t))
}

function lj(t) {
    Uoe(t) && (fd = !0, u0 = "virtual")
}

function dj(t) {
    t.target === window || t.target === document || Boe || !t.isTrusted || (!fd && !Y3 && (u0 = "virtual", ox("virtual", t)), fd = !1, Y3 = !1)
}

function uj() {
    fd = !1, Y3 = !0
}

function Z3(t) {
    if (typeof window > "u" || typeof document > "u" || Uf.get(Fl(t))) return;
    const e = Fl(t),
        r = dl(t);
    let n = e.HTMLElement.prototype.focus;
    e.HTMLElement.prototype.focus = function() {
        fd = !0, n.apply(this, arguments)
    }, r.addEventListener("keydown", Rm, !0), r.addEventListener("keyup", Rm, !0), r.addEventListener("click", lj, !0), e.addEventListener("focus", dj, !0), e.addEventListener("blur", uj, !1), typeof PointerEvent < "u" && (r.addEventListener("pointerdown", Uu, !0), r.addEventListener("pointermove", Uu, !0), r.addEventListener("pointerup", Uu, !0)), e.addEventListener("beforeunload", () => {
        hj(t)
    }, {
        once: !0
    }), Uf.set(e, {
        focus: n
    })
}
const hj = (t, e) => {
    const r = Fl(t),
        n = dl(t);
    e && n.removeEventListener("DOMContentLoaded", e), Uf.has(r) && (r.HTMLElement.prototype.focus = Uf.get(r).focus, n.removeEventListener("keydown", Rm, !0), n.removeEventListener("keyup", Rm, !0), n.removeEventListener("click", lj, !0), r.removeEventListener("focus", dj, !0), r.removeEventListener("blur", uj, !1), typeof PointerEvent < "u" && (n.removeEventListener("pointerdown", Uu, !0), n.removeEventListener("pointermove", Uu, !0), n.removeEventListener("pointerup", Uu, !0)), Uf.delete(r))
};

function qoe(t) {
    const e = dl(t);
    let r;
    return e.readyState !== "loading" ? Z3(t) : (r = () => {
        Z3(t)
    }, e.addEventListener("DOMContentLoaded", r)), () => hj(t, r)
}
typeof document < "u" && qoe();

function fj() {
    return u0 !== "pointer"
}
const Hoe = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);

function Voe(t, e, r) {
    let n = dl(r == null ? void 0 : r.target);
    const i = typeof window < "u" ? Fl(r == null ? void 0 : r.target).HTMLInputElement : HTMLInputElement,
        s = typeof window < "u" ? Fl(r == null ? void 0 : r.target).HTMLTextAreaElement : HTMLTextAreaElement,
        a = typeof window < "u" ? Fl(r == null ? void 0 : r.target).HTMLElement : HTMLElement,
        o = typeof window < "u" ? Fl(r == null ? void 0 : r.target).KeyboardEvent : KeyboardEvent;
    return t = t || n.activeElement instanceof i && !Hoe.has(n.activeElement.type) || n.activeElement instanceof s || n.activeElement instanceof a && n.activeElement.isContentEditable, !(t && e === "keyboard" && r instanceof o && !Woe[r.key])
}

function Goe(t, e, r) {
    Z3(), v.useEffect(() => {
        let n = (i, s) => {
            Voe(!!(r != null && r.isTextInput), i, s) && t(fj())
        };
        return K3.add(n), () => {
            K3.delete(n)
        }
    }, e)
}

function Koe(t) {
    let {
        isDisabled: e,
        onFocus: r,
        onBlur: n,
        onFocusChange: i
    } = t;
    const s = v.useCallback(c => {
            if (c.target === c.currentTarget) return n && n(c), i && i(!1), !0
        }, [n, i]),
        a = cj(s),
        o = v.useCallback(c => {
            const l = dl(c.target),
                u = l ? G3(l) : G3();
            c.target === c.currentTarget && u === ij(c.nativeEvent) && (r && r(c), i && i(!0), a(c))
        }, [i, r, a]);
    return {
        focusProps: {
            onFocus: !e && (r || i || n) ? o : void 0,
            onBlur: !e && (n || i) ? s : void 0
        }
    }
}

function Yoe(t) {
    let {
        isDisabled: e,
        onBlurWithin: r,
        onFocusWithin: n,
        onFocusWithinChange: i
    } = t, s = v.useRef({
        isFocusWithin: !1
    }), {
        addGlobalListener: a,
        removeAllGlobalListeners: o
    } = aj(), c = v.useCallback(h => {
        h.currentTarget.contains(h.target) && s.current.isFocusWithin && !h.currentTarget.contains(h.relatedTarget) && (s.current.isFocusWithin = !1, o(), r && r(h), i && i(!1))
    }, [r, i, s, o]), l = cj(c), u = v.useCallback(h => {
        if (!h.currentTarget.contains(h.target)) return;
        const f = dl(h.target),
            p = G3(f);
        if (!s.current.isFocusWithin && p === ij(h.nativeEvent)) {
            n && n(h), i && i(!0), s.current.isFocusWithin = !0, l(h);
            let g = h.currentTarget;
            a(f, "focus", m => {
                if (s.current.isFocusWithin && !nj(g, m.target)) {
                    let y = new f.defaultView.FocusEvent("blur", {
                        relatedTarget: m.target
                    });
                    Foe(y, g);
                    let w = oj(y);
                    c(w)
                }
            }, {
                capture: !0
            })
        }
    }, [n, i, l, a, c]);
    return e ? {
        focusWithinProps: {
            onFocus: void 0,
            onBlur: void 0
        }
    } : {
        focusWithinProps: {
            onFocus: u,
            onBlur: c
        }
    }
}
let J3 = !1,
    S2 = 0;

function Zoe() {
    J3 = !0, setTimeout(() => {
        J3 = !1
    }, 50)
}

function b9(t) {
    t.pointerType === "touch" && Zoe()
}

function Joe() {
    if (!(typeof document > "u")) return typeof PointerEvent < "u" && document.addEventListener("pointerup", b9), S2++, () => {
        S2--, !(S2 > 0) && typeof PointerEvent < "u" && document.removeEventListener("pointerup", b9)
    }
}

function Qoe(t) {
    let {
        onHoverStart: e,
        onHoverChange: r,
        onHoverEnd: n,
        isDisabled: i
    } = t, [s, a] = v.useState(!1), o = v.useRef({
        isHovered: !1,
        ignoreEmulatedMouseEvents: !1,
        pointerType: "",
        target: null
    }).current;
    v.useEffect(Joe, []);
    let {
        addGlobalListener: c,
        removeAllGlobalListeners: l
    } = aj(), {
        hoverProps: u,
        triggerHoverEnd: h
    } = v.useMemo(() => {
        let f = (m, y) => {
                if (o.pointerType = y, i || y === "touch" || o.isHovered || !m.currentTarget.contains(m.target)) return;
                o.isHovered = !0;
                let w = m.currentTarget;
                o.target = w, c(dl(m.target), "pointerover", x => {
                    o.isHovered && o.target && !nj(o.target, x.target) && p(x, x.pointerType)
                }, {
                    capture: !0
                }), e && e({
                    type: "hoverstart",
                    target: w,
                    pointerType: y
                }), r && r(!0), a(!0)
            },
            p = (m, y) => {
                let w = o.target;
                o.pointerType = "", o.target = null, !(y === "touch" || !o.isHovered || !w) && (o.isHovered = !1, l(), n && n({
                    type: "hoverend",
                    target: w,
                    pointerType: y
                }), r && r(!1), a(!1))
            },
            g = {};
        return typeof PointerEvent < "u" && (g.onPointerEnter = m => {
            J3 && m.pointerType === "mouse" || f(m, m.pointerType)
        }, g.onPointerLeave = m => {
            !i && m.currentTarget.contains(m.target) && p(m, m.pointerType)
        }), {
            hoverProps: g,
            triggerHoverEnd: p
        }
    }, [e, r, n, i, o, c, l]);
    return v.useEffect(() => {
        i && h({
            currentTarget: o.target
        }, o.pointerType)
    }, [i]), {
        hoverProps: u,
        isHovered: s
    }
}

function Xoe(t = {}) {
    let {
        autoFocus: e = !1,
        isTextInput: r,
        within: n
    } = t, i = v.useRef({
        isFocused: !1,
        isFocusVisible: e || fj()
    }), [s, a] = v.useState(!1), [o, c] = v.useState(() => i.current.isFocused && i.current.isFocusVisible), l = v.useCallback(() => c(i.current.isFocused && i.current.isFocusVisible), []), u = v.useCallback(p => {
        i.current.isFocused = p, a(p), l()
    }, [l]);
    Goe(p => {
        i.current.isFocusVisible = p, l()
    }, [], {
        isTextInput: r
    });
    let {
        focusProps: h
    } = Koe({
        isDisabled: n,
        onFocusChange: u
    }), {
        focusWithinProps: f
    } = Yoe({
        isDisabled: !n,
        onFocusWithinChange: u
    });
    return {
        isFocused: s,
        isFocusVisible: o,
        focusProps: n ? f : h
    }
}
var ece = Object.defineProperty,
    tce = (t, e, r) => e in t ? ece(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    T2 = (t, e, r) => (tce(t, typeof e != "symbol" ? e + "" : e, r), r);
let rce = class {
        constructor() {
            T2(this, "current", this.detect()), T2(this, "handoffState", "pending"), T2(this, "currentId", 0)
        }
        set(e) {
            this.current !== e && (this.handoffState = "pending", this.currentId = 0, this.current = e)
        }
        reset() {
            this.set(this.detect())
        }
        nextId() {
            return ++this.currentId
        }
        get isServer() {
            return this.current === "server"
        }
        get isClient() {
            return this.current === "client"
        }
        detect() {
            return typeof window > "u" || typeof document > "u" ? "server" : "client"
        }
        handoff() {
            this.handoffState === "pending" && (this.handoffState = "complete")
        }
        get isHandoffComplete() {
            return this.handoffState === "complete"
        }
    },
    Xl = new rce;

function Pd(t) {
    var e, r;
    return Xl.isServer ? null : t ? "ownerDocument" in t ? t.ownerDocument : "current" in t ? (r = (e = t.current) == null ? void 0 : e.ownerDocument) != null ? r : document : null : document
}

function ly(t) {
    typeof queueMicrotask == "function" ? queueMicrotask(t) : Promise.resolve().then(t).catch(e => setTimeout(() => {
        throw e
    }))
}

function qs() {
    let t = [],
        e = {
            addEventListener(r, n, i, s) {
                return r.addEventListener(n, i, s), e.add(() => r.removeEventListener(n, i, s))
            },
            requestAnimationFrame(...r) {
                let n = requestAnimationFrame(...r);
                return e.add(() => cancelAnimationFrame(n))
            },
            nextFrame(...r) {
                return e.requestAnimationFrame(() => e.requestAnimationFrame(...r))
            },
            setTimeout(...r) {
                let n = setTimeout(...r);
                return e.add(() => clearTimeout(n))
            },
            microTask(...r) {
                let n = {
                    current: !0
                };
                return ly(() => {
                    n.current && r[0]()
                }), e.add(() => {
                    n.current = !1
                })
            },
            style(r, n, i) {
                let s = r.style.getPropertyValue(n);
                return Object.assign(r.style, {
                    [n]: i
                }), this.add(() => {
                    Object.assign(r.style, {
                        [n]: s
                    })
                })
            },
            group(r) {
                let n = qs();
                return r(n), this.add(() => n.dispose())
            },
            add(r) {
                return t.includes(r) || t.push(r), () => {
                    let n = t.indexOf(r);
                    if (n >= 0)
                        for (let i of t.splice(n, 1)) i()
                }
            },
            dispose() {
                for (let r of t.splice(0)) r()
            }
        };
    return e
}

function xh() {
    let [t] = v.useState(qs);
    return v.useEffect(() => () => t.dispose(), [t]), t
}
let lr = (t, e) => {
    Xl.isServer ? v.useEffect(t, e) : v.useLayoutEffect(t, e)
};

function Nd(t) {
    let e = v.useRef(t);
    return lr(() => {
        e.current = t
    }, [t]), e
}
let xt = function(t) {
    let e = Nd(t);
    return at.useCallback((...r) => e.current(...r), [e])
};

function nce(t) {
    let e = t.width / 2,
        r = t.height / 2;
    return {
        top: t.clientY - r,
        right: t.clientX + e,
        bottom: t.clientY + r,
        left: t.clientX - e
    }
}

function ice(t, e) {
    return !(!t || !e || t.right < e.left || t.left > e.right || t.bottom < e.top || t.top > e.bottom)
}

function sce({
    disabled: t = !1
} = {}) {
    let e = v.useRef(null),
        [r, n] = v.useState(!1),
        i = xh(),
        s = xt(() => {
            e.current = null, n(!1), i.dispose()
        }),
        a = xt(o => {
            if (i.dispose(), e.current === null) {
                e.current = o.currentTarget, n(!0); {
                    let c = Pd(o.currentTarget);
                    i.addEventListener(c, "pointerup", s, !1), i.addEventListener(c, "pointermove", l => {
                        if (e.current) {
                            let u = nce(l);
                            n(ice(u, e.current.getBoundingClientRect()))
                        }
                    }, !1), i.addEventListener(c, "pointercancel", s, !1)
                }
            }
        });
    return {
        pressed: r,
        pressProps: t ? {} : {
            onPointerDown: a,
            onPointerUp: s,
            onClick: s
        }
    }
}
let ace = v.createContext(void 0);

function pj() {
    return v.useContext(ace)
}

function Q3(...t) {
    return Array.from(new Set(t.flatMap(e => typeof e == "string" ? e.split(" ") : []))).filter(Boolean).join(" ")
}

function Aa(t, e, ...r) {
    if (t in e) {
        let i = e[t];
        return typeof i == "function" ? i(...r) : i
    }
    let n = new Error(`Tried to handle "${t}" but there is no handler defined. Only defined handlers are: ${Object.keys(e).map(i=>`"${i}"`).join(", ")}.`);
    throw Error.captureStackTrace && Error.captureStackTrace(n, Aa), n
}
var rh = (t => (t[t.None = 0] = "None", t[t.RenderStrategy = 1] = "RenderStrategy", t[t.Static = 2] = "Static", t))(rh || {}),
    Kc = (t => (t[t.Unmount = 0] = "Unmount", t[t.Hidden = 1] = "Hidden", t))(Kc || {});

function tn() {
    let t = cce();
    return v.useCallback(e => oce({
        mergeRefs: t,
        ...e
    }), [t])
}

function oce({
    ourProps: t,
    theirProps: e,
    slot: r,
    defaultTag: n,
    features: i,
    visible: s = !0,
    name: a,
    mergeRefs: o
}) {
    o = o ? ? lce;
    let c = gj(e, t);
    if (s) return ag(c, r, n, a, o);
    let l = i ? ? 0;
    if (l & 2) {
        let {
            static: u = !1,
            ...h
        } = c;
        if (u) return ag(h, r, n, a, o)
    }
    if (l & 1) {
        let {
            unmount: u = !0,
            ...h
        } = c;
        return Aa(u ? 0 : 1, {
            0() {
                return null
            },
            1() {
                return ag({ ...h,
                    hidden: !0,
                    style: {
                        display: "none"
                    }
                }, r, n, a, o)
            }
        })
    }
    return ag(c, r, n, a, o)
}

function ag(t, e = {}, r, n, i) {
    let {
        as: s = r,
        children: a,
        refName: o = "ref",
        ...c
    } = P2(t, ["unmount", "static"]), l = t.ref !== void 0 ? {
        [o]: t.ref
    } : {}, u = typeof a == "function" ? a(e) : a;
    "className" in c && c.className && typeof c.className == "function" && (c.className = c.className(e)), c["aria-labelledby"] && c["aria-labelledby"] === c.id && (c["aria-labelledby"] = void 0);
    let h = {};
    if (e) {
        let f = !1,
            p = [];
        for (let [g, m] of Object.entries(e)) typeof m == "boolean" && (f = !0), m === !0 && p.push(g.replace(/([A-Z])/g, y => `-${y.toLowerCase()}`));
        if (f) {
            h["data-headlessui-state"] = p.join(" ");
            for (let g of p) h[`data-${g}`] = ""
        }
    }
    if (s === v.Fragment && (Object.keys(Il(c)).length > 0 || Object.keys(Il(h)).length > 0))
        if (!v.isValidElement(u) || Array.isArray(u) && u.length > 1) {
            if (Object.keys(Il(c)).length > 0) throw new Error(['Passing props on "Fragment"!', "", `The current component <${n} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(Il(c)).concat(Object.keys(Il(h))).map(f => `  - ${f}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map(f => `  - ${f}`).join(`
`)].join(`
`))
        } else {
            let f = u.props,
                p = f == null ? void 0 : f.className,
                g = typeof p == "function" ? (...w) => Q3(p(...w), c.className) : Q3(p, c.className),
                m = g ? {
                    className: g
                } : {},
                y = gj(u.props, Il(P2(c, ["ref"])));
            for (let w in h) w in y && delete h[w];
            return v.cloneElement(u, Object.assign({}, y, h, l, {
                ref: i(dce(u), l.ref)
            }, m))
        }
    return v.createElement(s, Object.assign({}, P2(c, ["ref"]), s !== v.Fragment && l, s !== v.Fragment && h), u)
}

function cce() {
    let t = v.useRef([]),
        e = v.useCallback(r => {
            for (let n of t.current) n != null && (typeof n == "function" ? n(r) : n.current = r)
        }, []);
    return (...r) => {
        if (!r.every(n => n == null)) return t.current = r, e
    }
}

function lce(...t) {
    return t.every(e => e == null) ? void 0 : e => {
        for (let r of t) r != null && (typeof r == "function" ? r(e) : r.current = e)
    }
}

function gj(...t) {
    if (t.length === 0) return {};
    if (t.length === 1) return t[0];
    let e = {},
        r = {};
    for (let n of t)
        for (let i in n) i.startsWith("on") && typeof n[i] == "function" ? (r[i] != null || (r[i] = []), r[i].push(n[i])) : e[i] = n[i];
    if (e.disabled || e["aria-disabled"])
        for (let n in r) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(n) && (r[n] = [i => {
            var s;
            return (s = i == null ? void 0 : i.preventDefault) == null ? void 0 : s.call(i)
        }]);
    for (let n in r) Object.assign(e, {
        [n](i, ...s) {
            let a = r[n];
            for (let o of a) {
                if ((i instanceof Event || (i == null ? void 0 : i.nativeEvent) instanceof Event) && i.defaultPrevented) return;
                o(i, ...s)
            }
        }
    });
    return e
}

function mj(...t) {
    if (t.length === 0) return {};
    if (t.length === 1) return t[0];
    let e = {},
        r = {};
    for (let n of t)
        for (let i in n) i.startsWith("on") && typeof n[i] == "function" ? (r[i] != null || (r[i] = []), r[i].push(n[i])) : e[i] = n[i];
    for (let n in r) Object.assign(e, {
        [n](...i) {
            let s = r[n];
            for (let a of s) a == null || a(...i)
        }
    });
    return e
}

function Dr(t) {
    var e;
    return Object.assign(v.forwardRef(t), {
        displayName: (e = t.displayName) != null ? e : t.name
    })
}

function Il(t) {
    let e = Object.assign({}, t);
    for (let r in e) e[r] === void 0 && delete e[r];
    return e
}

function P2(t, e = []) {
    let r = Object.assign({}, t);
    for (let n of e) n in r && delete r[n];
    return r
}

function dce(t) {
    return at.version.split(".")[0] >= "19" ? t.props.ref : t.ref
}
let uce = "span";
var Mm = (t => (t[t.None = 1] = "None", t[t.Focusable = 2] = "Focusable", t[t.Hidden = 4] = "Hidden", t))(Mm || {});

function hce(t, e) {
    var r;
    let {
        features: n = 1,
        ...i
    } = t, s = {
        ref: e,
        "aria-hidden": (n & 2) === 2 ? !0 : (r = i["aria-hidden"]) != null ? r : void 0,
        hidden: (n & 4) === 4 ? !0 : void 0,
        style: {
            position: "fixed",
            top: 1,
            left: 1,
            width: 1,
            height: 0,
            padding: 0,
            margin: -1,
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            whiteSpace: "nowrap",
            borderWidth: "0",
            ...(n & 4) === 4 && (n & 2) !== 2 && {
                display: "none"
            }
        }
    };
    return tn()({
        ourProps: s,
        theirProps: i,
        slot: {},
        defaultTag: uce,
        name: "Hidden"
    })
}
let X3 = Dr(hce),
    fce = v.createContext(void 0);

function pce() {
    return v.useContext(fce)
}

function cx(t) {
    return typeof t != "object" || t === null ? !1 : "nodeType" in t
}

function Go(t) {
    return cx(t) && "tagName" in t
}

function os(t) {
    return Go(t) && "accessKey" in t
}

function ro(t) {
    return Go(t) && "tabIndex" in t
}

function gce(t) {
    return Go(t) && "style" in t
}

function mce(t) {
    return os(t) && t.nodeName === "IFRAME"
}

function yj(t) {
    return os(t) && t.nodeName === "INPUT"
}

function v9(t) {
    return os(t) && t.nodeName === "LABEL"
}

function yce(t) {
    return os(t) && t.nodeName === "FIELDSET"
}

function wj(t) {
    return os(t) && t.nodeName === "LEGEND"
}

function wce(t) {
    return Go(t) ? t.matches('a[href],audio[controls],button,details,embed,iframe,img[usemap],input:not([type="hidden"]),label,select,textarea,video[controls]') : !1
}

function bce(t) {
    let e = t.parentElement,
        r = null;
    for (; e && !yce(e);) wj(e) && (r = e), e = e.parentElement;
    let n = (e == null ? void 0 : e.getAttribute("disabled")) === "";
    return n && vce(r) ? !1 : n
}

function vce(t) {
    if (!t) return !1;
    let e = t.previousElementSibling;
    for (; e !== null;) {
        if (wj(e)) return !1;
        e = e.previousElementSibling
    }
    return !0
}
let bj = Symbol();

function xce(t, e = !0) {
    return Object.assign(t, {
        [bj]: e
    })
}

function yi(...t) {
    let e = v.useRef(t);
    v.useEffect(() => {
        e.current = t
    }, [t]);
    let r = xt(n => {
        for (let i of e.current) i != null && (typeof i == "function" ? i(n) : i.current = n)
    });
    return t.every(n => n == null || (n == null ? void 0 : n[bj])) ? void 0 : r
}
let lx = v.createContext(null);
lx.displayName = "DescriptionContext";

function vj() {
    let t = v.useContext(lx);
    if (t === null) {
        let e = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
        throw Error.captureStackTrace && Error.captureStackTrace(e, vj), e
    }
    return t
}

function xj() {
    let [t, e] = v.useState([]);
    return [t.length > 0 ? t.join(" ") : void 0, v.useMemo(() => function(r) {
        let n = xt(s => (e(a => [...a, s]), () => e(a => {
                let o = a.slice(),
                    c = o.indexOf(s);
                return c !== -1 && o.splice(c, 1), o
            }))),
            i = v.useMemo(() => ({
                register: n,
                slot: r.slot,
                name: r.name,
                props: r.props,
                value: r.value
            }), [n, r.slot, r.name, r.props, r.value]);
        return at.createElement(lx.Provider, {
            value: i
        }, r.children)
    }, [e])]
}
let Ece = "p";

function _ce(t, e) {
    let r = v.useId(),
        n = pj(),
        {
            id: i = `headlessui-description-${r}`,
            ...s
        } = t,
        a = vj(),
        o = yi(e);
    lr(() => a.register(i), [i, a.register]);
    let c = n || !1,
        l = v.useMemo(() => ({ ...a.slot,
            disabled: c
        }), [a.slot, c]),
        u = {
            ref: o,
            ...a.props,
            id: i
        };
    return tn()({
        ourProps: u,
        theirProps: s,
        slot: l,
        defaultTag: Ece,
        name: a.name || "Description"
    })
}
let Cce = Dr(_ce),
    Ace = Object.assign(Cce, {});
var pn = (t => (t.Space = " ", t.Enter = "Enter", t.Escape = "Escape", t.Backspace = "Backspace", t.Delete = "Delete", t.ArrowLeft = "ArrowLeft", t.ArrowUp = "ArrowUp", t.ArrowRight = "ArrowRight", t.ArrowDown = "ArrowDown", t.Home = "Home", t.End = "End", t.PageUp = "PageUp", t.PageDown = "PageDown", t.Tab = "Tab", t))(pn || {});
let dy = v.createContext(null);
dy.displayName = "LabelContext";

function dx() {
    let t = v.useContext(dy);
    if (t === null) {
        let e = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
        throw Error.captureStackTrace && Error.captureStackTrace(e, dx), e
    }
    return t
}

function kce(t) {
    var e, r, n;
    let i = (r = (e = v.useContext(dy)) == null ? void 0 : e.value) != null ? r : void 0;
    return ((n = void 0) != null ? n : 0) > 0 ? [i, ...t].filter(Boolean).join(" ") : i
}

function Ej({
    inherit: t = !1
} = {}) {
    let e = kce(),
        [r, n] = v.useState([]),
        i = t ? [e, ...r].filter(Boolean) : r;
    return [i.length > 0 ? i.join(" ") : void 0, v.useMemo(() => function(s) {
        let a = xt(c => (n(l => [...l, c]), () => n(l => {
                let u = l.slice(),
                    h = u.indexOf(c);
                return h !== -1 && u.splice(h, 1), u
            }))),
            o = v.useMemo(() => ({
                register: a,
                slot: s.slot,
                name: s.name,
                props: s.props,
                value: s.value
            }), [a, s.slot, s.name, s.props, s.value]);
        return at.createElement(dy.Provider, {
            value: o
        }, s.children)
    }, [n])]
}
let Ice = "label";

function $ce(t, e) {
    var r;
    let n = v.useId(),
        i = dx(),
        s = pce(),
        a = pj(),
        {
            id: o = `headlessui-label-${n}`,
            htmlFor: c = s ? ? ((r = i.props) == null ? void 0 : r.htmlFor),
            passive: l = !1,
            ...u
        } = t,
        h = yi(e);
    lr(() => i.register(o), [o, i.register]);
    let f = xt(y => {
            let w = y.currentTarget;
            if (!(y.target !== y.currentTarget && wce(y.target)) && (v9(w) && y.preventDefault(), i.props && "onClick" in i.props && typeof i.props.onClick == "function" && i.props.onClick(y), v9(w))) {
                let x = document.getElementById(w.htmlFor);
                if (x) {
                    let E = x.getAttribute("disabled");
                    if (E === "true" || E === "") return;
                    let _ = x.getAttribute("aria-disabled");
                    if (_ === "true" || _ === "") return;
                    (yj(x) && (x.type === "file" || x.type === "radio" || x.type === "checkbox") || x.role === "radio" || x.role === "checkbox" || x.role === "switch") && x.click(), x.focus({
                        preventScroll: !0
                    })
                }
            }
        }),
        p = a || !1,
        g = v.useMemo(() => ({ ...i.slot,
            disabled: p
        }), [i.slot, p]),
        m = {
            ref: h,
            ...i.props,
            id: o,
            htmlFor: c,
            onClick: f
        };
    return l && ("onClick" in m && (delete m.htmlFor, delete m.onClick), "onClick" in u && delete u.onClick), tn()({
        ourProps: m,
        theirProps: u,
        slot: g,
        defaultTag: c ? Ice : "div",
        name: i.name || "Label"
    })
}
let Sce = Dr($ce);
Object.assign(Sce, {});
let Tce = v.createContext(() => {});

function Pce({
    value: t,
    children: e
}) {
    return at.createElement(Tce.Provider, {
        value: t
    }, e)
}

function tu(t, e, r) {
    let n = r.initialDeps ? ? [],
        i;

    function s() {
        var a, o, c, l;
        let u;
        r.key && ((a = r.debug) != null && a.call(r)) && (u = Date.now());
        const h = t();
        if (!(h.length !== n.length || h.some((g, m) => n[m] !== g))) return i;
        n = h;
        let p;
        if (r.key && ((o = r.debug) != null && o.call(r)) && (p = Date.now()), i = e(...h), r.key && ((c = r.debug) != null && c.call(r))) {
            const g = Math.round((Date.now() - u) * 100) / 100,
                m = Math.round((Date.now() - p) * 100) / 100,
                y = m / 16,
                w = (x, E) => {
                    for (x = String(x); x.length < E;) x = " " + x;
                    return x
                };
            console.info(`%c⏱ ${w(m,5)} /${w(g,5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0,Math.min(120-120*y,120))}deg 100% 31%);`, r == null ? void 0 : r.key)
        }
        return (l = r == null ? void 0 : r.onChange) == null || l.call(r, i), i
    }
    return s.updateDeps = a => {
        n = a
    }, s
}

function x9(t, e) {
    if (t === void 0) throw new Error("Unexpected undefined");
    return t
}
const Nce = (t, e) => Math.abs(t - e) <= 1,
    Oce = (t, e, r) => {
        let n;
        return function(...i) {
            t.clearTimeout(n), n = t.setTimeout(() => e.apply(this, i), r)
        }
    },
    E9 = t => {
        const {
            offsetWidth: e,
            offsetHeight: r
        } = t;
        return {
            width: e,
            height: r
        }
    },
    jce = t => t,
    Rce = t => {
        const e = Math.max(t.startIndex - t.overscan, 0),
            r = Math.min(t.endIndex + t.overscan, t.count - 1),
            n = [];
        for (let i = e; i <= r; i++) n.push(i);
        return n
    },
    Mce = (t, e) => {
        const r = t.scrollElement;
        if (!r) return;
        const n = t.targetWindow;
        if (!n) return;
        const i = a => {
            const {
                width: o,
                height: c
            } = a;
            e({
                width: Math.round(o),
                height: Math.round(c)
            })
        };
        if (i(E9(r)), !n.ResizeObserver) return () => {};
        const s = new n.ResizeObserver(a => {
            const o = () => {
                const c = a[0];
                if (c != null && c.borderBoxSize) {
                    const l = c.borderBoxSize[0];
                    if (l) {
                        i({
                            width: l.inlineSize,
                            height: l.blockSize
                        });
                        return
                    }
                }
                i(E9(r))
            };
            t.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(o) : o()
        });
        return s.observe(r, {
            box: "border-box"
        }), () => {
            s.unobserve(r)
        }
    },
    _9 = {
        passive: !0
    },
    C9 = typeof window > "u" ? !0 : "onscrollend" in window,
    Dce = (t, e) => {
        const r = t.scrollElement;
        if (!r) return;
        const n = t.targetWindow;
        if (!n) return;
        let i = 0;
        const s = t.options.useScrollendEvent && C9 ? () => {} : Oce(n, () => {
                e(i, !1)
            }, t.options.isScrollingResetDelay),
            a = u => () => {
                const {
                    horizontal: h,
                    isRtl: f
                } = t.options;
                i = h ? r.scrollLeft * (f && -1 || 1) : r.scrollTop, s(), e(i, u)
            },
            o = a(!0),
            c = a(!1);
        c(), r.addEventListener("scroll", o, _9);
        const l = t.options.useScrollendEvent && C9;
        return l && r.addEventListener("scrollend", c, _9), () => {
            r.removeEventListener("scroll", o), l && r.removeEventListener("scrollend", c)
        }
    },
    Lce = (t, e, r) => {
        if (e != null && e.borderBoxSize) {
            const n = e.borderBoxSize[0];
            if (n) return Math.round(n[r.options.horizontal ? "inlineSize" : "blockSize"])
        }
        return t[r.options.horizontal ? "offsetWidth" : "offsetHeight"]
    },
    Uce = (t, {
        adjustments: e = 0,
        behavior: r
    }, n) => {
        var i, s;
        const a = t + e;
        (s = (i = n.scrollElement) == null ? void 0 : i.scrollTo) == null || s.call(i, {
            [n.options.horizontal ? "left" : "top"]: a,
            behavior: r
        })
    };
class Fce {
    constructor(e) {
        this.unsubs = [], this.scrollElement = null, this.targetWindow = null, this.isScrolling = !1, this.scrollToIndexTimeoutId = null, this.measurementsCache = [], this.itemSizeCache = new Map, this.pendingMeasuredCacheIndexes = [], this.scrollRect = null, this.scrollOffset = null, this.scrollDirection = null, this.scrollAdjustments = 0, this.elementsCache = new Map, this.observer = (() => {
            let r = null;
            const n = () => r || (!this.targetWindow || !this.targetWindow.ResizeObserver ? null : r = new this.targetWindow.ResizeObserver(i => {
                i.forEach(s => {
                    const a = () => {
                        this._measureElement(s.target, s)
                    };
                    this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(a) : a()
                })
            }));
            return {
                disconnect: () => {
                    var i;
                    (i = n()) == null || i.disconnect(), r = null
                },
                observe: i => {
                    var s;
                    return (s = n()) == null ? void 0 : s.observe(i, {
                        box: "border-box"
                    })
                },
                unobserve: i => {
                    var s;
                    return (s = n()) == null ? void 0 : s.unobserve(i)
                }
            }
        })(), this.range = null, this.setOptions = r => {
            Object.entries(r).forEach(([n, i]) => {
                typeof i > "u" && delete r[n]
            }), this.options = {
                debug: !1,
                initialOffset: 0,
                overscan: 1,
                paddingStart: 0,
                paddingEnd: 0,
                scrollPaddingStart: 0,
                scrollPaddingEnd: 0,
                horizontal: !1,
                getItemKey: jce,
                rangeExtractor: Rce,
                onChange: () => {},
                measureElement: Lce,
                initialRect: {
                    width: 0,
                    height: 0
                },
                scrollMargin: 0,
                gap: 0,
                indexAttribute: "data-index",
                initialMeasurementsCache: [],
                lanes: 1,
                isScrollingResetDelay: 150,
                enabled: !0,
                isRtl: !1,
                useScrollendEvent: !1,
                useAnimationFrameWithResizeObserver: !1,
                ...r
            }
        }, this.notify = r => {
            var n, i;
            (i = (n = this.options).onChange) == null || i.call(n, this, r)
        }, this.maybeNotify = tu(() => (this.calculateRange(), [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]), r => {
            this.notify(r)
        }, {
            key: !1,
            debug: () => this.options.debug,
            initialDeps: [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]
        }), this.cleanup = () => {
            this.unsubs.filter(Boolean).forEach(r => r()), this.unsubs = [], this.observer.disconnect(), this.scrollElement = null, this.targetWindow = null
        }, this._didMount = () => () => {
            this.cleanup()
        }, this._willUpdate = () => {
            var r;
            const n = this.options.enabled ? this.options.getScrollElement() : null;
            if (this.scrollElement !== n) {
                if (this.cleanup(), !n) {
                    this.maybeNotify();
                    return
                }
                this.scrollElement = n, this.scrollElement && "ownerDocument" in this.scrollElement ? this.targetWindow = this.scrollElement.ownerDocument.defaultView : this.targetWindow = ((r = this.scrollElement) == null ? void 0 : r.window) ? ? null, this.elementsCache.forEach(i => {
                    this.observer.observe(i)
                }), this._scrollToOffset(this.getScrollOffset(), {
                    adjustments: void 0,
                    behavior: void 0
                }), this.unsubs.push(this.options.observeElementRect(this, i => {
                    this.scrollRect = i, this.maybeNotify()
                })), this.unsubs.push(this.options.observeElementOffset(this, (i, s) => {
                    this.scrollAdjustments = 0, this.scrollDirection = s ? this.getScrollOffset() < i ? "forward" : "backward" : null, this.scrollOffset = i, this.isScrolling = s, this.maybeNotify()
                }))
            }
        }, this.getSize = () => this.options.enabled ? (this.scrollRect = this.scrollRect ? ? this.options.initialRect, this.scrollRect[this.options.horizontal ? "width" : "height"]) : (this.scrollRect = null, 0), this.getScrollOffset = () => this.options.enabled ? (this.scrollOffset = this.scrollOffset ? ? (typeof this.options.initialOffset == "function" ? this.options.initialOffset() : this.options.initialOffset), this.scrollOffset) : (this.scrollOffset = null, 0), this.getFurthestMeasurement = (r, n) => {
            const i = new Map,
                s = new Map;
            for (let a = n - 1; a >= 0; a--) {
                const o = r[a];
                if (i.has(o.lane)) continue;
                const c = s.get(o.lane);
                if (c == null || o.end > c.end ? s.set(o.lane, o) : o.end < c.end && i.set(o.lane, !0), i.size === this.options.lanes) break
            }
            return s.size === this.options.lanes ? Array.from(s.values()).sort((a, o) => a.end === o.end ? a.index - o.index : a.end - o.end)[0] : void 0
        }, this.getMeasurementOptions = tu(() => [this.options.count, this.options.paddingStart, this.options.scrollMargin, this.options.getItemKey, this.options.enabled], (r, n, i, s, a) => (this.pendingMeasuredCacheIndexes = [], {
            count: r,
            paddingStart: n,
            scrollMargin: i,
            getItemKey: s,
            enabled: a
        }), {
            key: !1
        }), this.getMeasurements = tu(() => [this.getMeasurementOptions(), this.itemSizeCache], ({
            count: r,
            paddingStart: n,
            scrollMargin: i,
            getItemKey: s,
            enabled: a
        }, o) => {
            if (!a) return this.measurementsCache = [], this.itemSizeCache.clear(), [];
            this.measurementsCache.length === 0 && (this.measurementsCache = this.options.initialMeasurementsCache, this.measurementsCache.forEach(u => {
                this.itemSizeCache.set(u.key, u.size)
            }));
            const c = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
            this.pendingMeasuredCacheIndexes = [];
            const l = this.measurementsCache.slice(0, c);
            for (let u = c; u < r; u++) {
                const h = s(u),
                    f = this.options.lanes === 1 ? l[u - 1] : this.getFurthestMeasurement(l, u),
                    p = f ? f.end + this.options.gap : n + i,
                    g = o.get(h),
                    m = typeof g == "number" ? g : this.options.estimateSize(u),
                    y = p + m,
                    w = f ? f.lane : u % this.options.lanes;
                l[u] = {
                    index: u,
                    start: p,
                    size: m,
                    end: y,
                    key: h,
                    lane: w
                }
            }
            return this.measurementsCache = l, l
        }, {
            key: !1,
            debug: () => this.options.debug
        }), this.calculateRange = tu(() => [this.getMeasurements(), this.getSize(), this.getScrollOffset(), this.options.lanes], (r, n, i, s) => this.range = r.length > 0 && n > 0 ? Bce({
            measurements: r,
            outerSize: n,
            scrollOffset: i,
            lanes: s
        }) : null, {
            key: !1,
            debug: () => this.options.debug
        }), this.getVirtualIndexes = tu(() => {
            let r = null,
                n = null;
            const i = this.calculateRange();
            return i && (r = i.startIndex, n = i.endIndex), this.maybeNotify.updateDeps([this.isScrolling, r, n]), [this.options.rangeExtractor, this.options.overscan, this.options.count, r, n]
        }, (r, n, i, s, a) => s === null || a === null ? [] : r({
            startIndex: s,
            endIndex: a,
            overscan: n,
            count: i
        }), {
            key: !1,
            debug: () => this.options.debug
        }), this.indexFromElement = r => {
            const n = this.options.indexAttribute,
                i = r.getAttribute(n);
            return i ? parseInt(i, 10) : (console.warn(`Missing attribute name '${n}={index}' on measured element.`), -1)
        }, this._measureElement = (r, n) => {
            const i = this.indexFromElement(r),
                s = this.measurementsCache[i];
            if (!s) return;
            const a = s.key,
                o = this.elementsCache.get(a);
            o !== r && (o && this.observer.unobserve(o), this.observer.observe(r), this.elementsCache.set(a, r)), r.isConnected && this.resizeItem(i, this.options.measureElement(r, n, this))
        }, this.resizeItem = (r, n) => {
            const i = this.measurementsCache[r];
            if (!i) return;
            const s = this.itemSizeCache.get(i.key) ? ? i.size,
                a = n - s;
            a !== 0 && ((this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(i, a, this) : this.scrollDirection === "backward" && i.start < this.getScrollOffset() + this.scrollAdjustments) && this._scrollToOffset(this.getScrollOffset(), {
                adjustments: this.scrollAdjustments += a,
                behavior: void 0
            }), this.pendingMeasuredCacheIndexes.push(i.index), this.itemSizeCache = new Map(this.itemSizeCache.set(i.key, n)), this.notify(!1))
        }, this.measureElement = r => {
            if (!r) {
                this.elementsCache.forEach((n, i) => {
                    n.isConnected || (this.observer.unobserve(n), this.elementsCache.delete(i))
                });
                return
            }
            this._measureElement(r, void 0)
        }, this.getVirtualItems = tu(() => [this.getVirtualIndexes(), this.getMeasurements()], (r, n) => {
            const i = [];
            for (let s = 0, a = r.length; s < a; s++) {
                const o = r[s],
                    c = n[o];
                i.push(c)
            }
            return i
        }, {
            key: !1,
            debug: () => this.options.debug
        }), this.getVirtualItemForOffset = r => {
            const n = this.getMeasurements();
            if (n.length !== 0) return x9(n[_j(0, n.length - 1, i => x9(n[i]).start, r)])
        }, this.getOffsetForAlignment = (r, n, i = 0) => {
            const s = this.getSize(),
                a = this.getScrollOffset();
            n === "auto" && (n = r >= a + s ? "end" : "start"), n === "center" ? r += (i - s) / 2 : n === "end" && (r -= s);
            const o = this.getTotalSize() - s;
            return Math.max(Math.min(o, r), 0)
        }, this.getOffsetForIndex = (r, n = "auto") => {
            r = Math.max(0, Math.min(r, this.options.count - 1));
            const i = this.measurementsCache[r];
            if (!i) return;
            const s = this.getSize(),
                a = this.getScrollOffset();
            if (n === "auto")
                if (i.end >= a + s - this.options.scrollPaddingEnd) n = "end";
                else if (i.start <= a + this.options.scrollPaddingStart) n = "start";
            else return [a, n];
            const o = n === "end" ? i.end + this.options.scrollPaddingEnd : i.start - this.options.scrollPaddingStart;
            return [this.getOffsetForAlignment(o, n, i.size), n]
        }, this.isDynamicMode = () => this.elementsCache.size > 0, this.cancelScrollToIndex = () => {
            this.scrollToIndexTimeoutId !== null && this.targetWindow && (this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId), this.scrollToIndexTimeoutId = null)
        }, this.scrollToOffset = (r, {
            align: n = "start",
            behavior: i
        } = {}) => {
            this.cancelScrollToIndex(), i === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."), this._scrollToOffset(this.getOffsetForAlignment(r, n), {
                adjustments: void 0,
                behavior: i
            })
        }, this.scrollToIndex = (r, {
            align: n = "auto",
            behavior: i
        } = {}) => {
            r = Math.max(0, Math.min(r, this.options.count - 1)), this.cancelScrollToIndex(), i === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
            const s = this.getOffsetForIndex(r, n);
            if (!s) return;
            const [a, o] = s;
            this._scrollToOffset(a, {
                adjustments: void 0,
                behavior: i
            }), i !== "smooth" && this.isDynamicMode() && this.targetWindow && (this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {
                if (this.scrollToIndexTimeoutId = null, this.elementsCache.has(this.options.getItemKey(r))) {
                    const l = this.getOffsetForIndex(r, o);
                    if (!l) return;
                    const [u] = l, h = this.getScrollOffset();
                    Nce(u, h) || this.scrollToIndex(r, {
                        align: o,
                        behavior: i
                    })
                } else this.scrollToIndex(r, {
                    align: o,
                    behavior: i
                })
            }))
        }, this.scrollBy = (r, {
            behavior: n
        } = {}) => {
            this.cancelScrollToIndex(), n === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."), this._scrollToOffset(this.getScrollOffset() + r, {
                adjustments: void 0,
                behavior: n
            })
        }, this.getTotalSize = () => {
            var r;
            const n = this.getMeasurements();
            let i;
            if (n.length === 0) i = this.options.paddingStart;
            else if (this.options.lanes === 1) i = ((r = n[n.length - 1]) == null ? void 0 : r.end) ? ? 0;
            else {
                const s = Array(this.options.lanes).fill(null);
                let a = n.length - 1;
                for (; a >= 0 && s.some(o => o === null);) {
                    const o = n[a];
                    s[o.lane] === null && (s[o.lane] = o.end), a--
                }
                i = Math.max(...s.filter(o => o !== null))
            }
            return Math.max(i - this.options.scrollMargin + this.options.paddingEnd, 0)
        }, this._scrollToOffset = (r, {
            adjustments: n,
            behavior: i
        }) => {
            this.options.scrollToFn(r, {
                behavior: i,
                adjustments: n
            }, this)
        }, this.measure = () => {
            this.itemSizeCache = new Map, this.notify(!1)
        }, this.setOptions(e)
    }
}
const _j = (t, e, r, n) => {
    for (; t <= e;) {
        const i = (t + e) / 2 | 0,
            s = r(i);
        if (s < n) t = i + 1;
        else if (s > n) e = i - 1;
        else return i
    }
    return t > 0 ? t - 1 : 0
};

function Bce({
    measurements: t,
    outerSize: e,
    scrollOffset: r,
    lanes: n
}) {
    const i = t.length - 1,
        s = c => t[c].start;
    if (t.length <= n) return {
        startIndex: 0,
        endIndex: i
    };
    let a = _j(0, i, s, r),
        o = a;
    if (n === 1)
        for (; o < i && t[o].end < r + e;) o++;
    else if (n > 1) {
        const c = Array(n).fill(0);
        for (; o < i && c.some(u => u < r + e);) {
            const u = t[o];
            c[u.lane] = u.end, o++
        }
        const l = Array(n).fill(r + e);
        for (; a >= 0 && l.some(u => u >= r);) {
            const u = t[a];
            l[u.lane] = u.start, a--
        }
        a = Math.max(0, a - a % n), o = Math.min(i, o + (n - 1 - o % n))
    }
    return {
        startIndex: a,
        endIndex: o
    }
}
const A9 = typeof document < "u" ? v.useLayoutEffect : v.useEffect;

function Wce(t) {
    const e = v.useReducer(() => ({}), {})[1],
        r = { ...t,
            onChange: (i, s) => {
                var a;
                s ? Zo.flushSync(e) : e(), (a = t.onChange) == null || a.call(t, i, s)
            }
        },
        [n] = v.useState(() => new Fce(r));
    return n.setOptions(r), A9(() => n._didMount(), []), A9(() => n._willUpdate()), n
}

function zce(t) {
    return Wce({
        observeElementRect: Mce,
        observeElementOffset: Dce,
        scrollToFn: Uce,
        ...t
    })
}

function qce(t) {
    if (t === null) return {
        width: 0,
        height: 0
    };
    let {
        width: e,
        height: r
    } = t.getBoundingClientRect();
    return {
        width: e,
        height: r
    }
}

function Hce(t, e = !1) {
    let [r, n] = v.useReducer(() => ({}), {}), i = v.useMemo(() => qce(t), [t, r]);
    return lr(() => {
        if (!t) return;
        let s = new ResizeObserver(n);
        return s.observe(t), () => {
            s.disconnect()
        }
    }, [t]), e ? {
        width: `${i.width}px`,
        height: `${i.height}px`
    } : i
}
let Cj = class extends Map {
    constructor(e) {
        super(), this.factory = e
    }
    get(e) {
        let r = super.get(e);
        return r === void 0 && (r = this.factory(e), this.set(e, r)), r
    }
};
var Vce = Object.defineProperty,
    Gce = (t, e, r) => e in t ? Vce(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Kce = (t, e, r) => (Gce(t, e + "", r), r),
    Aj = (t, e, r) => {
        if (!e.has(t)) throw TypeError("Cannot " + r)
    },
    ws = (t, e, r) => (Aj(t, e, "read from private field"), r ? r.call(t) : e.get(t)),
    N2 = (t, e, r) => {
        if (e.has(t)) throw TypeError("Cannot add the same private member more than once");
        e instanceof WeakSet ? e.add(t) : e.set(t, r)
    },
    k9 = (t, e, r, n) => (Aj(t, e, "write to private field"), e.set(t, r), r),
    Ga, Cf, Af;
let kj = class {
    constructor(e) {
        N2(this, Ga, {}), N2(this, Cf, new Cj(() => new Set)), N2(this, Af, new Set), Kce(this, "disposables", qs()), k9(this, Ga, e)
    }
    dispose() {
        this.disposables.dispose()
    }
    get state() {
        return ws(this, Ga)
    }
    subscribe(e, r) {
        let n = {
            selector: e,
            callback: r,
            current: e(ws(this, Ga))
        };
        return ws(this, Af).add(n), this.disposables.add(() => {
            ws(this, Af).delete(n)
        })
    }
    on(e, r) {
        return ws(this, Cf).get(e).add(r), this.disposables.add(() => {
            ws(this, Cf).get(e).delete(r)
        })
    }
    send(e) {
        let r = this.reduce(ws(this, Ga), e);
        if (r !== ws(this, Ga)) {
            k9(this, Ga, r);
            for (let n of ws(this, Af)) {
                let i = n.selector(ws(this, Ga));
                Ij(n.current, i) || (n.current = i, n.callback(i))
            }
            for (let n of ws(this, Cf).get(e.type)) n(ws(this, Ga), e)
        }
    }
};
Ga = new WeakMap, Cf = new WeakMap, Af = new WeakMap;

function Ij(t, e) {
    return Object.is(t, e) ? !0 : typeof t != "object" || t === null || typeof e != "object" || e === null ? !1 : Array.isArray(t) && Array.isArray(e) ? t.length !== e.length ? !1 : O2(t[Symbol.iterator](), e[Symbol.iterator]()) : t instanceof Map && e instanceof Map || t instanceof Set && e instanceof Set ? t.size !== e.size ? !1 : O2(t.entries(), e.entries()) : I9(t) && I9(e) ? O2(Object.entries(t)[Symbol.iterator](), Object.entries(e)[Symbol.iterator]()) : !1
}

function O2(t, e) {
    do {
        let r = t.next(),
            n = e.next();
        if (r.done && n.done) return !0;
        if (r.done || n.done || !Object.is(r.value, n.value)) return !1
    } while (!0)
}

function I9(t) {
    if (Object.prototype.toString.call(t) !== "[object Object]") return !1;
    let e = Object.getPrototypeOf(t);
    return e === null || Object.getPrototypeOf(e) === null
}

function $9(t) {
    let [e, r] = t(), n = qs();
    return (...i) => {
        e(...i), n.dispose(), n.microTask(r)
    }
}
var Yce = Object.defineProperty,
    Zce = (t, e, r) => e in t ? Yce(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    S9 = (t, e, r) => (Zce(t, typeof e != "symbol" ? e + "" : e, r), r),
    $j = (t => (t[t.Push = 0] = "Push", t[t.Pop = 1] = "Pop", t))($j || {});
let Jce = {
        0(t, e) {
            let r = e.id,
                n = t.stack,
                i = t.stack.indexOf(r);
            if (i !== -1) {
                let s = t.stack.slice();
                return s.splice(i, 1), s.push(r), n = s, { ...t,
                    stack: n
                }
            }
            return { ...t,
                stack: [...t.stack, r]
            }
        },
        1(t, e) {
            let r = e.id,
                n = t.stack.indexOf(r);
            if (n === -1) return t;
            let i = t.stack.slice();
            return i.splice(n, 1), { ...t,
                stack: i
            }
        }
    },
    Qce = class Sj extends kj {
        constructor() {
            super(...arguments), S9(this, "actions", {
                push: e => this.send({
                    type: 0,
                    id: e
                }),
                pop: e => this.send({
                    type: 1,
                    id: e
                })
            }), S9(this, "selectors", {
                isTop: (e, r) => e.stack[e.stack.length - 1] === r,
                inStack: (e, r) => e.stack.includes(r)
            })
        }
        static new() {
            return new Sj({
                stack: []
            })
        }
        reduce(e, r) {
            return Aa(r.type, Jce, e, r)
        }
    };
const uy = new Cj(() => Qce.new());

function pa(t, e, r = Ij) {
    return WW.useSyncExternalStoreWithSelector(xt(n => t.subscribe(Xce, n)), xt(() => t.state), xt(() => t.state), xt(e), r)
}

function Xce(t) {
    return t
}

function h0(t, e) {
    let r = v.useId(),
        n = uy.get(e),
        [i, s] = pa(n, v.useCallback(a => [n.selectors.isTop(a, r), n.selectors.inStack(a, r)], [n, r]));
    return lr(() => {
        if (t) return n.actions.push(r), () => n.actions.pop(r)
    }, [n, t, r]), t ? s ? i : !0 : !1
}
let e5 = new Map,
    Ff = new Map;

function T9(t) {
    var e;
    let r = (e = Ff.get(t)) != null ? e : 0;
    return Ff.set(t, r + 1), r !== 0 ? () => P9(t) : (e5.set(t, {
        "aria-hidden": t.getAttribute("aria-hidden"),
        inert: t.inert
    }), t.setAttribute("aria-hidden", "true"), t.inert = !0, () => P9(t))
}

function P9(t) {
    var e;
    let r = (e = Ff.get(t)) != null ? e : 1;
    if (r === 1 ? Ff.delete(t) : Ff.set(t, r - 1), r !== 1) return;
    let n = e5.get(t);
    n && (n["aria-hidden"] === null ? t.removeAttribute("aria-hidden") : t.setAttribute("aria-hidden", n["aria-hidden"]), t.inert = n.inert, e5.delete(t))
}

function Tj(t, {
    allowed: e,
    disallowed: r
} = {}) {
    let n = h0(t, "inert-others");
    lr(() => {
        var i, s;
        if (!n) return;
        let a = qs();
        for (let c of (i = r == null ? void 0 : r()) != null ? i : []) c && a.add(T9(c));
        let o = (s = e == null ? void 0 : e()) != null ? s : [];
        for (let c of o) {
            if (!c) continue;
            let l = Pd(c);
            if (!l) continue;
            let u = c.parentElement;
            for (; u && u !== l.body;) {
                for (let h of u.children) o.some(f => h.contains(f)) || a.add(T9(h));
                u = u.parentElement
            }
        }
        return a.dispose
    }, [n, e, r])
}

function Pj(t, e, r) {
    let n = Nd(i => {
        let s = i.getBoundingClientRect();
        s.x === 0 && s.y === 0 && s.width === 0 && s.height === 0 && r()
    });
    v.useEffect(() => {
        if (!t) return;
        let i = e === null ? null : os(e) ? e : e.current;
        if (!i) return;
        let s = qs();
        if (typeof ResizeObserver < "u") {
            let a = new ResizeObserver(() => n.current(i));
            a.observe(i), s.add(() => a.disconnect())
        }
        if (typeof IntersectionObserver < "u") {
            let a = new IntersectionObserver(() => n.current(i));
            a.observe(i), s.add(() => a.disconnect())
        }
        return () => s.dispose()
    }, [e, n, t])
}
let Dm = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(t => `${t}:not([tabindex='-1'])`).join(","),
    ele = ["[data-autofocus]"].map(t => `${t}:not([tabindex='-1'])`).join(",");
var ua = (t => (t[t.First = 1] = "First", t[t.Previous = 2] = "Previous", t[t.Next = 4] = "Next", t[t.Last = 8] = "Last", t[t.WrapAround = 16] = "WrapAround", t[t.NoScroll = 32] = "NoScroll", t[t.AutoFocus = 64] = "AutoFocus", t))(ua || {}),
    t5 = (t => (t[t.Error = 0] = "Error", t[t.Overflow = 1] = "Overflow", t[t.Success = 2] = "Success", t[t.Underflow = 3] = "Underflow", t))(t5 || {}),
    tle = (t => (t[t.Previous = -1] = "Previous", t[t.Next = 1] = "Next", t))(tle || {});

function Nj(t = document.body) {
    return t == null ? [] : Array.from(t.querySelectorAll(Dm)).sort((e, r) => Math.sign((e.tabIndex || Number.MAX_SAFE_INTEGER) - (r.tabIndex || Number.MAX_SAFE_INTEGER)))
}

function rle(t = document.body) {
    return t == null ? [] : Array.from(t.querySelectorAll(ele)).sort((e, r) => Math.sign((e.tabIndex || Number.MAX_SAFE_INTEGER) - (r.tabIndex || Number.MAX_SAFE_INTEGER)))
}
var ux = (t => (t[t.Strict = 0] = "Strict", t[t.Loose = 1] = "Loose", t))(ux || {});

function hx(t, e = 0) {
    var r;
    return t === ((r = Pd(t)) == null ? void 0 : r.body) ? !1 : Aa(e, {
        0() {
            return t.matches(Dm)
        },
        1() {
            let n = t;
            for (; n !== null;) {
                if (n.matches(Dm)) return !0;
                n = n.parentElement
            }
            return !1
        }
    })
}

function Oj(t) {
    let e = Pd(t);
    qs().nextFrame(() => {
        e && ro(e.activeElement) && !hx(e.activeElement, 0) && no(t)
    })
}
var nle = (t => (t[t.Keyboard = 0] = "Keyboard", t[t.Mouse = 1] = "Mouse", t))(nle || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", t => {
    t.metaKey || t.altKey || t.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "")
}, !0), document.addEventListener("click", t => {
    t.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : t.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "")
}, !0));

function no(t) {
    t == null || t.focus({
        preventScroll: !0
    })
}
let ile = ["textarea", "input"].join(",");

function sle(t) {
    var e, r;
    return (r = (e = t == null ? void 0 : t.matches) == null ? void 0 : e.call(t, ile)) != null ? r : !1
}

function jj(t, e = r => r) {
    return t.slice().sort((r, n) => {
        let i = e(r),
            s = e(n);
        if (i === null || s === null) return 0;
        let a = i.compareDocumentPosition(s);
        return a & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : a & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0
    })
}

function ale(t, e) {
    return Fu(Nj(), e, {
        relativeTo: t
    })
}

function Fu(t, e, {
    sorted: r = !0,
    relativeTo: n = null,
    skipElements: i = []
} = {}) {
    let s = Array.isArray(t) ? t.length > 0 ? t[0].ownerDocument : document : t.ownerDocument,
        a = Array.isArray(t) ? r ? jj(t) : t : e & 64 ? rle(t) : Nj(t);
    i.length > 0 && a.length > 1 && (a = a.filter(p => !i.some(g => g != null && "current" in g ? (g == null ? void 0 : g.current) === p : g === p))), n = n ? ? s.activeElement;
    let o = (() => {
            if (e & 5) return 1;
            if (e & 10) return -1;
            throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
        })(),
        c = (() => {
            if (e & 1) return 0;
            if (e & 2) return Math.max(0, a.indexOf(n)) - 1;
            if (e & 4) return Math.max(0, a.indexOf(n)) + 1;
            if (e & 8) return a.length - 1;
            throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
        })(),
        l = e & 32 ? {
            preventScroll: !0
        } : {},
        u = 0,
        h = a.length,
        f;
    do {
        if (u >= h || u + h <= 0) return 0;
        let p = c + u;
        if (e & 16) p = (p + h) % h;
        else {
            if (p < 0) return 3;
            if (p >= h) return 1
        }
        f = a[p], f == null || f.focus(l), u += o
    } while (f !== s.activeElement);
    return e & 6 && sle(f) && f.select(), 2
}

function Rj() {
    return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0
}

function ole() {
    return /Android/gi.test(window.navigator.userAgent)
}

function N9() {
    return Rj() || ole()
}

function $u(t, e, r, n) {
    let i = Nd(r);
    v.useEffect(() => {
        if (!t) return;

        function s(a) {
            i.current(a)
        }
        return document.addEventListener(e, s, n), () => document.removeEventListener(e, s, n)
    }, [t, e, n])
}

function Mj(t, e, r, n) {
    let i = Nd(r);
    v.useEffect(() => {
        if (!t) return;

        function s(a) {
            i.current(a)
        }
        return window.addEventListener(e, s, n), () => window.removeEventListener(e, s, n)
    }, [t, e, n])
}
const O9 = 30;

function Dj(t, e, r) {
    let n = Nd(r),
        i = v.useCallback(function(o, c) {
            if (o.defaultPrevented) return;
            let l = c(o);
            if (l === null || !l.getRootNode().contains(l) || !l.isConnected) return;
            let u = function h(f) {
                return typeof f == "function" ? h(f()) : Array.isArray(f) || f instanceof Set ? f : [f]
            }(e);
            for (let h of u)
                if (h !== null && (h.contains(l) || o.composed && o.composedPath().includes(h))) return;
            return !hx(l, ux.Loose) && l.tabIndex !== -1 && o.preventDefault(), n.current(o, l)
        }, [n, e]),
        s = v.useRef(null);
    $u(t, "pointerdown", o => {
        var c, l;
        N9() || (s.current = ((l = (c = o.composedPath) == null ? void 0 : c.call(o)) == null ? void 0 : l[0]) || o.target)
    }, !0), $u(t, "pointerup", o => {
        if (N9() || !s.current) return;
        let c = s.current;
        return s.current = null, i(o, () => c)
    }, !0);
    let a = v.useRef({
        x: 0,
        y: 0
    });
    $u(t, "touchstart", o => {
        a.current.x = o.touches[0].clientX, a.current.y = o.touches[0].clientY
    }, !0), $u(t, "touchend", o => {
        let c = {
            x: o.changedTouches[0].clientX,
            y: o.changedTouches[0].clientY
        };
        if (!(Math.abs(c.x - a.current.x) >= O9 || Math.abs(c.y - a.current.y) >= O9)) return i(o, () => ro(o.target) ? o.target : null)
    }, !0), Mj(t, "blur", o => i(o, () => mce(window.document.activeElement) ? window.document.activeElement : null), !0)
}

function nh(...t) {
    return v.useMemo(() => Pd(...t), [...t])
}
var cle = (t => (t[t.Ignore = 0] = "Ignore", t[t.Select = 1] = "Select", t[t.Close = 2] = "Close", t))(cle || {});
const og = {
        Ignore: {
            kind: 0
        },
        Select: t => ({
            kind: 1,
            target: t
        }),
        Close: {
            kind: 2
        }
    },
    lle = 200;

function dle(t, {
    trigger: e,
    action: r,
    close: n,
    select: i
}) {
    let s = v.useRef(null);
    $u(t && e !== null, "pointerdown", a => {
        cx(a == null ? void 0 : a.target) && e != null && e.contains(a.target) && (s.current = new Date)
    }), $u(t && e !== null, "pointerup", a => {
        if (s.current === null || !ro(a.target)) return;
        let o = r(a),
            c = new Date().getTime() - s.current.getTime();
        switch (s.current = null, o.kind) {
            case 0:
                return;
            case 1:
                {
                    c > lle && (i(o.target), n());
                    break
                }
            case 2:
                {
                    n();
                    break
                }
        }
    }, {
        capture: !0
    })
}

function Lj(t, e, r, n) {
    let i = Nd(r);
    v.useEffect(() => {
        t = t ? ? window;

        function s(a) {
            i.current(a)
        }
        return t.addEventListener(e, s, n), () => t.removeEventListener(e, s, n)
    }, [t, e, n])
}

function ule(t, e) {
    return v.useMemo(() => {
        var r;
        if (t.type) return t.type;
        let n = (r = t.as) != null ? r : "button";
        if (typeof n == "string" && n.toLowerCase() === "button" || (e == null ? void 0 : e.tagName) === "BUTTON" && !e.hasAttribute("type")) return "button"
    }, [t.type, t.as, e])
}

function hle(t) {
    return v.useSyncExternalStore(t.subscribe, t.getSnapshot, t.getSnapshot)
}

function fle(t, e) {
    let r = t(),
        n = new Set;
    return {
        getSnapshot() {
            return r
        },
        subscribe(i) {
            return n.add(i), () => n.delete(i)
        },
        dispatch(i, ...s) {
            let a = e[i].call(r, ...s);
            a && (r = a, n.forEach(o => o()))
        }
    }
}

function ple() {
    let t;
    return {
        before({
            doc: e
        }) {
            var r;
            let n = e.documentElement,
                i = (r = e.defaultView) != null ? r : window;
            t = Math.max(0, i.innerWidth - n.clientWidth)
        },
        after({
            doc: e,
            d: r
        }) {
            let n = e.documentElement,
                i = Math.max(0, n.clientWidth - n.offsetWidth),
                s = Math.max(0, t - i);
            r.style(n, "paddingRight", `${s}px`)
        }
    }
}

function gle() {
    return Rj() ? {
        before({
            doc: t,
            d: e,
            meta: r
        }) {
            function n(i) {
                return r.containers.flatMap(s => s()).some(s => s.contains(i))
            }
            e.microTask(() => {
                var i;
                if (window.getComputedStyle(t.documentElement).scrollBehavior !== "auto") {
                    let o = qs();
                    o.style(t.documentElement, "scrollBehavior", "auto"), e.add(() => e.microTask(() => o.dispose()))
                }
                let s = (i = window.scrollY) != null ? i : window.pageYOffset,
                    a = null;
                e.addEventListener(t, "click", o => {
                    if (ro(o.target)) try {
                        let c = o.target.closest("a");
                        if (!c) return;
                        let {
                            hash: l
                        } = new URL(c.href), u = t.querySelector(l);
                        ro(u) && !n(u) && (a = u)
                    } catch {}
                }, !0), e.addEventListener(t, "touchstart", o => {
                    if (ro(o.target) && gce(o.target))
                        if (n(o.target)) {
                            let c = o.target;
                            for (; c.parentElement && n(c.parentElement);) c = c.parentElement;
                            e.style(c, "overscrollBehavior", "contain")
                        } else e.style(o.target, "touchAction", "none")
                }), e.addEventListener(t, "touchmove", o => {
                    if (ro(o.target)) {
                        if (yj(o.target)) return;
                        if (n(o.target)) {
                            let c = o.target;
                            for (; c.parentElement && c.dataset.headlessuiPortal !== "" && !(c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth);) c = c.parentElement;
                            c.dataset.headlessuiPortal === "" && o.preventDefault()
                        } else o.preventDefault()
                    }
                }, {
                    passive: !1
                }), e.add(() => {
                    var o;
                    let c = (o = window.scrollY) != null ? o : window.pageYOffset;
                    s !== c && window.scrollTo(0, s), a && a.isConnected && (a.scrollIntoView({
                        block: "nearest"
                    }), a = null)
                })
            })
        }
    } : {}
}

function mle() {
    return {
        before({
            doc: t,
            d: e
        }) {
            e.style(t.documentElement, "overflow", "hidden")
        }
    }
}

function yle(t) {
    let e = {};
    for (let r of t) Object.assign(e, r(e));
    return e
}
let Bl = fle(() => new Map, {
    PUSH(t, e) {
        var r;
        let n = (r = this.get(t)) != null ? r : {
            doc: t,
            count: 0,
            d: qs(),
            meta: new Set
        };
        return n.count++, n.meta.add(e), this.set(t, n), this
    },
    POP(t, e) {
        let r = this.get(t);
        return r && (r.count--, r.meta.delete(e)), this
    },
    SCROLL_PREVENT({
        doc: t,
        d: e,
        meta: r
    }) {
        let n = {
                doc: t,
                d: e,
                meta: yle(r)
            },
            i = [gle(), ple(), mle()];
        i.forEach(({
            before: s
        }) => s == null ? void 0 : s(n)), i.forEach(({
            after: s
        }) => s == null ? void 0 : s(n))
    },
    SCROLL_ALLOW({
        d: t
    }) {
        t.dispose()
    },
    TEARDOWN({
        doc: t
    }) {
        this.delete(t)
    }
});
Bl.subscribe(() => {
    let t = Bl.getSnapshot(),
        e = new Map;
    for (let [r] of t) e.set(r, r.documentElement.style.overflow);
    for (let r of t.values()) {
        let n = e.get(r.doc) === "hidden",
            i = r.count !== 0;
        (i && !n || !i && n) && Bl.dispatch(r.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", r), r.count === 0 && Bl.dispatch("TEARDOWN", r)
    }
});

function wle(t, e, r = () => ({
    containers: []
})) {
    let n = hle(Bl),
        i = e ? n.get(e) : void 0,
        s = i ? i.count > 0 : !1;
    return lr(() => {
        if (!(!e || !t)) return Bl.dispatch("PUSH", e, r), () => Bl.dispatch("POP", e, r)
    }, [t, e]), s
}

function Uj(t, e, r = () => [document.body]) {
    let n = h0(t, "scroll-lock");
    wle(n, e, i => {
        var s;
        return {
            containers: [...(s = i.containers) != null ? s : [], r]
        }
    })
}

function j9(t) {
    return [t.screenX, t.screenY]
}

function ble() {
    let t = v.useRef([-1, -1]);
    return {
        wasMoved(e) {
            let r = j9(e);
            return t.current[0] === r[0] && t.current[1] === r[1] ? !1 : (t.current = r, !0)
        },
        update(e) {
            t.current = j9(e)
        }
    }
}

function vle(t = 0) {
    let [e, r] = v.useState(t), n = v.useCallback(c => r(c), [e]), i = v.useCallback(c => r(l => l | c), [e]), s = v.useCallback(c => (e & c) === c, [e]), a = v.useCallback(c => r(l => l & ~c), [r]), o = v.useCallback(c => r(l => l ^ c), [r]);
    return {
        flags: e,
        setFlag: n,
        addFlag: i,
        hasFlag: s,
        removeFlag: a,
        toggleFlag: o
    }
}
var xle = {},
    R9, M9;
typeof jn < "u" && typeof globalThis < "u" && typeof Element < "u" && ((R9 = jn == null ? void 0 : xle) == null ? void 0 : R9.NODE_ENV) === "test" && typeof((M9 = Element == null ? void 0 : Element.prototype) == null ? void 0 : M9.getAnimations) > "u" && (Element.prototype.getAnimations = function() {
    return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)), []
});
var Ele = (t => (t[t.None = 0] = "None", t[t.Closed = 1] = "Closed", t[t.Enter = 2] = "Enter", t[t.Leave = 4] = "Leave", t))(Ele || {});

function Fj(t) {
    let e = {};
    for (let r in t) t[r] === !0 && (e[`data-${r}`] = "");
    return e
}

function Bj(t, e, r, n) {
    let [i, s] = v.useState(r), {
        hasFlag: a,
        addFlag: o,
        removeFlag: c
    } = vle(t && i ? 3 : 0), l = v.useRef(!1), u = v.useRef(!1), h = xh();
    return lr(() => {
        var f;
        if (t) {
            if (r && s(!0), !e) {
                r && o(3);
                return
            }
            return (f = n == null ? void 0 : n.start) == null || f.call(n, r), _le(e, {
                inFlight: l,
                prepare() {
                    u.current ? u.current = !1 : u.current = l.current, l.current = !0, !u.current && (r ? (o(3), c(4)) : (o(4), c(2)))
                },
                run() {
                    u.current ? r ? (c(3), o(4)) : (c(4), o(3)) : r ? c(1) : o(1)
                },
                done() {
                    var p;
                    u.current && typeof e.getAnimations == "function" && e.getAnimations().length > 0 || (l.current = !1, c(7), r || s(!1), (p = n == null ? void 0 : n.end) == null || p.call(n, r))
                }
            })
        }
    }, [t, r, e, h]), t ? [i, {
        closed: a(1),
        enter: a(2),
        leave: a(4),
        transition: a(2) || a(4)
    }] : [r, {
        closed: void 0,
        enter: void 0,
        leave: void 0,
        transition: void 0
    }]
}

function _le(t, {
    prepare: e,
    run: r,
    done: n,
    inFlight: i
}) {
    let s = qs();
    return Ale(t, {
        prepare: e,
        inFlight: i
    }), s.nextFrame(() => {
        r(), s.requestAnimationFrame(() => {
            s.add(Cle(t, n))
        })
    }), s.dispose
}

function Cle(t, e) {
    var r, n;
    let i = qs();
    if (!t) return i.dispose;
    let s = !1;
    i.add(() => {
        s = !0
    });
    let a = (n = (r = t.getAnimations) == null ? void 0 : r.call(t).filter(o => o instanceof CSSTransition)) != null ? n : [];
    return a.length === 0 ? (e(), i.dispose) : (Promise.allSettled(a.map(o => o.finished)).then(() => {
        s || e()
    }), i.dispose)
}

function Ale(t, {
    inFlight: e,
    prepare: r
}) {
    if (e != null && e.current) {
        r();
        return
    }
    let n = t.style.transition;
    t.style.transition = "none", r(), t.offsetHeight, t.style.transition = n
}

function kle(t, {
    container: e,
    accept: r,
    walk: n
}) {
    let i = v.useRef(r),
        s = v.useRef(n);
    v.useEffect(() => {
        i.current = r, s.current = n
    }, [r, n]), lr(() => {
        if (!e || !t) return;
        let a = Pd(e);
        if (!a) return;
        let o = i.current,
            c = s.current,
            l = Object.assign(h => o(h), {
                acceptNode: o
            }),
            u = a.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, l, !1);
        for (; u.nextNode();) c(u.currentNode)
    }, [e, t, i, s])
}

function fx(t, e) {
    let r = v.useRef([]),
        n = xt(t);
    v.useEffect(() => {
        let i = [...r.current];
        for (let [s, a] of e.entries())
            if (r.current[s] !== a) {
                let o = n(e, i);
                return r.current = e, o
            }
    }, [n, ...e])
}

function hy() {
    return typeof window < "u"
}

function Eh(t) {
    return Wj(t) ? (t.nodeName || "").toLowerCase() : "#document"
}

function is(t) {
    var e;
    return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window
}

function wo(t) {
    var e;
    return (e = (Wj(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement
}

function Wj(t) {
    return hy() ? t instanceof Node || t instanceof is(t).Node : !1
}

function ci(t) {
    return hy() ? t instanceof Element || t instanceof is(t).Element : !1
}

function ho(t) {
    return hy() ? t instanceof HTMLElement || t instanceof is(t).HTMLElement : !1
}

function D9(t) {
    return !hy() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof is(t).ShadowRoot
}

function f0(t) {
    const {
        overflow: e,
        overflowX: r,
        overflowY: n,
        display: i
    } = ka(t);
    return /auto|scroll|overlay|hidden|clip/.test(e + n + r) && !["inline", "contents"].includes(i)
}

function Ile(t) {
    return ["table", "td", "th"].includes(Eh(t))
}

function fy(t) {
    return [":popover-open", ":modal"].some(e => {
        try {
            return t.matches(e)
        } catch {
            return !1
        }
    })
}

function px(t) {
    const e = gx(),
        r = ci(t) ? ka(t) : t;
    return ["transform", "translate", "scale", "rotate", "perspective"].some(n => r[n] ? r[n] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !e && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !e && (r.filter ? r.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(n => (r.willChange || "").includes(n)) || ["paint", "layout", "strict", "content"].some(n => (r.contain || "").includes(n))
}

function $le(t) {
    let e = nl(t);
    for (; ho(e) && !ih(e);) {
        if (px(e)) return e;
        if (fy(e)) return null;
        e = nl(e)
    }
    return null
}

function gx() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}

function ih(t) {
    return ["html", "body", "#document"].includes(Eh(t))
}

function ka(t) {
    return is(t).getComputedStyle(t)
}

function py(t) {
    return ci(t) ? {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    } : {
        scrollLeft: t.scrollX,
        scrollTop: t.scrollY
    }
}

function nl(t) {
    if (Eh(t) === "html") return t;
    const e = t.assignedSlot || t.parentNode || D9(t) && t.host || wo(t);
    return D9(e) ? e.host : e
}

function zj(t) {
    const e = nl(t);
    return ih(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : ho(e) && f0(e) ? e : zj(e)
}

function Tp(t, e, r) {
    var n;
    e === void 0 && (e = []), r === void 0 && (r = !0);
    const i = zj(t),
        s = i === ((n = t.ownerDocument) == null ? void 0 : n.body),
        a = is(i);
    if (s) {
        const o = r5(a);
        return e.concat(a, a.visualViewport || [], f0(i) ? i : [], o && r ? Tp(o) : [])
    }
    return e.concat(i, Tp(i, [], r))
}

function r5(t) {
    return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null
}

function Sle() {
    const t = navigator.userAgentData;
    return t && Array.isArray(t.brands) ? t.brands.map(e => {
        let {
            brand: r,
            version: n
        } = e;
        return r + "/" + n
    }).join(" ") : navigator.userAgent
}
const pd = Math.min,
    Kn = Math.max,
    Pp = Math.round,
    cg = Math.floor,
    io = t => ({
        x: t,
        y: t
    }),
    Tle = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
    },
    Ple = {
        start: "end",
        end: "start"
    };

function L9(t, e, r) {
    return Kn(t, pd(e, r))
}

function _h(t, e) {
    return typeof t == "function" ? t(e) : t
}

function il(t) {
    return t.split("-")[0]
}

function p0(t) {
    return t.split("-")[1]
}

function qj(t) {
    return t === "x" ? "y" : "x"
}

function Hj(t) {
    return t === "y" ? "height" : "width"
}

function zo(t) {
    return ["top", "bottom"].includes(il(t)) ? "y" : "x"
}

function Vj(t) {
    return qj(zo(t))
}

function Nle(t, e, r) {
    r === void 0 && (r = !1);
    const n = p0(t),
        i = Vj(t),
        s = Hj(i);
    let a = i === "x" ? n === (r ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
    return e.reference[s] > e.floating[s] && (a = Lm(a)), [a, Lm(a)]
}

function Ole(t) {
    const e = Lm(t);
    return [n5(t), e, n5(e)]
}

function n5(t) {
    return t.replace(/start|end/g, e => Ple[e])
}

function jle(t, e, r) {
    const n = ["left", "right"],
        i = ["right", "left"],
        s = ["top", "bottom"],
        a = ["bottom", "top"];
    switch (t) {
        case "top":
        case "bottom":
            return r ? e ? i : n : e ? n : i;
        case "left":
        case "right":
            return e ? s : a;
        default:
            return []
    }
}

function Rle(t, e, r, n) {
    const i = p0(t);
    let s = jle(il(t), r === "start", n);
    return i && (s = s.map(a => a + "-" + i), e && (s = s.concat(s.map(n5)))), s
}

function Lm(t) {
    return t.replace(/left|right|bottom|top/g, e => Tle[e])
}

function Mle(t) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...t
    }
}

function Dle(t) {
    return typeof t != "number" ? Mle(t) : {
        top: t,
        right: t,
        bottom: t,
        left: t
    }
}

function Um(t) {
    const {
        x: e,
        y: r,
        width: n,
        height: i
    } = t;
    return {
        width: n,
        height: i,
        top: r,
        left: e,
        right: e + n,
        bottom: r + i,
        x: e,
        y: r
    }
}

function U9(t, e, r) {
    let {
        reference: n,
        floating: i
    } = t;
    const s = zo(e),
        a = Vj(e),
        o = Hj(a),
        c = il(e),
        l = s === "y",
        u = n.x + n.width / 2 - i.width / 2,
        h = n.y + n.height / 2 - i.height / 2,
        f = n[o] / 2 - i[o] / 2;
    let p;
    switch (c) {
        case "top":
            p = {
                x: u,
                y: n.y - i.height
            };
            break;
        case "bottom":
            p = {
                x: u,
                y: n.y + n.height
            };
            break;
        case "right":
            p = {
                x: n.x + n.width,
                y: h
            };
            break;
        case "left":
            p = {
                x: n.x - i.width,
                y: h
            };
            break;
        default:
            p = {
                x: n.x,
                y: n.y
            }
    }
    switch (p0(e)) {
        case "start":
            p[a] -= f * (r && l ? -1 : 1);
            break;
        case "end":
            p[a] += f * (r && l ? -1 : 1);
            break
    }
    return p
}
const Lle = async (t, e, r) => {
    const {
        placement: n = "bottom",
        strategy: i = "absolute",
        middleware: s = [],
        platform: a
    } = r, o = s.filter(Boolean), c = await (a.isRTL == null ? void 0 : a.isRTL(e));
    let l = await a.getElementRects({
            reference: t,
            floating: e,
            strategy: i
        }),
        {
            x: u,
            y: h
        } = U9(l, n, c),
        f = n,
        p = {},
        g = 0;
    for (let m = 0; m < o.length; m++) {
        const {
            name: y,
            fn: w
        } = o[m], {
            x,
            y: E,
            data: _,
            reset: b
        } = await w({
            x: u,
            y: h,
            initialPlacement: n,
            placement: f,
            strategy: i,
            middlewareData: p,
            rects: l,
            platform: a,
            elements: {
                reference: t,
                floating: e
            }
        });
        u = x ? ? u, h = E ? ? h, p = { ...p,
            [y]: { ...p[y],
                ..._
            }
        }, b && g <= 50 && (g++, typeof b == "object" && (b.placement && (f = b.placement), b.rects && (l = b.rects === !0 ? await a.getElementRects({
            reference: t,
            floating: e,
            strategy: i
        }) : b.rects), {
            x: u,
            y: h
        } = U9(l, f, c)), m = -1)
    }
    return {
        x: u,
        y: h,
        placement: f,
        strategy: i,
        middlewareData: p
    }
};
async function gy(t, e) {
    var r;
    e === void 0 && (e = {});
    const {
        x: n,
        y: i,
        platform: s,
        rects: a,
        elements: o,
        strategy: c
    } = t, {
        boundary: l = "clippingAncestors",
        rootBoundary: u = "viewport",
        elementContext: h = "floating",
        altBoundary: f = !1,
        padding: p = 0
    } = _h(e, t), g = Dle(p), y = o[f ? h === "floating" ? "reference" : "floating" : h], w = Um(await s.getClippingRect({
        element: (r = await (s.isElement == null ? void 0 : s.isElement(y))) == null || r ? y : y.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(o.floating)),
        boundary: l,
        rootBoundary: u,
        strategy: c
    })), x = h === "floating" ? {
        x: n,
        y: i,
        width: a.floating.width,
        height: a.floating.height
    } : a.reference, E = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(o.floating)), _ = await (s.isElement == null ? void 0 : s.isElement(E)) ? await (s.getScale == null ? void 0 : s.getScale(E)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }, b = Um(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: o,
        rect: x,
        offsetParent: E,
        strategy: c
    }) : x);
    return {
        top: (w.top - b.top + g.top) / _.y,
        bottom: (b.bottom - w.bottom + g.bottom) / _.y,
        left: (w.left - b.left + g.left) / _.x,
        right: (b.right - w.right + g.right) / _.x
    }
}
const Ule = function(t) {
    return t === void 0 && (t = {}), {
        name: "flip",
        options: t,
        async fn(e) {
            var r, n;
            const {
                placement: i,
                middlewareData: s,
                rects: a,
                initialPlacement: o,
                platform: c,
                elements: l
            } = e, {
                mainAxis: u = !0,
                crossAxis: h = !0,
                fallbackPlacements: f,
                fallbackStrategy: p = "bestFit",
                fallbackAxisSideDirection: g = "none",
                flipAlignment: m = !0,
                ...y
            } = _h(t, e);
            if ((r = s.arrow) != null && r.alignmentOffset) return {};
            const w = il(i),
                x = zo(o),
                E = il(o) === o,
                _ = await (c.isRTL == null ? void 0 : c.isRTL(l.floating)),
                b = f || (E || !m ? [Lm(o)] : Ole(o)),
                A = g !== "none";
            !f && A && b.push(...Rle(o, m, g, _));
            const I = [o, ...b],
                T = await gy(e, y),
                C = [];
            let $ = ((n = s.flip) == null ? void 0 : n.overflows) || [];
            if (u && C.push(T[w]), h) {
                const D = Nle(i, a, _);
                C.push(T[D[0]], T[D[1]])
            }
            if ($ = [...$, {
                    placement: i,
                    overflows: C
                }], !C.every(D => D <= 0)) {
                var P, N;
                const D = (((P = s.flip) == null ? void 0 : P.index) || 0) + 1,
                    S = I[D];
                if (S && (!(h === "alignment" ? x !== zo(S) : !1) || $.every(U => U.overflows[0] > 0 && zo(U.placement) === x))) return {
                    data: {
                        index: D,
                        overflows: $
                    },
                    reset: {
                        placement: S
                    }
                };
                let O = (N = $.filter(M => M.overflows[0] <= 0).sort((M, U) => M.overflows[1] - U.overflows[1])[0]) == null ? void 0 : N.placement;
                if (!O) switch (p) {
                    case "bestFit":
                        {
                            var R;
                            const M = (R = $.filter(U => {
                                if (A) {
                                    const k = zo(U.placement);
                                    return k === x || k === "y"
                                }
                                return !0
                            }).map(U => [U.placement, U.overflows.filter(k => k > 0).reduce((k, F) => k + F, 0)]).sort((U, k) => U[1] - k[1])[0]) == null ? void 0 : R[0];M && (O = M);
                            break
                        }
                    case "initialPlacement":
                        O = o;
                        break
                }
                if (i !== O) return {
                    reset: {
                        placement: O
                    }
                }
            }
            return {}
        }
    }
};
async function Fle(t, e) {
    const {
        placement: r,
        platform: n,
        elements: i
    } = t, s = await (n.isRTL == null ? void 0 : n.isRTL(i.floating)), a = il(r), o = p0(r), c = zo(r) === "y", l = ["left", "top"].includes(a) ? -1 : 1, u = s && c ? -1 : 1, h = _h(e, t);
    let {
        mainAxis: f,
        crossAxis: p,
        alignmentAxis: g
    } = typeof h == "number" ? {
        mainAxis: h,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: h.mainAxis || 0,
        crossAxis: h.crossAxis || 0,
        alignmentAxis: h.alignmentAxis
    };
    return o && typeof g == "number" && (p = o === "end" ? g * -1 : g), c ? {
        x: p * u,
        y: f * l
    } : {
        x: f * l,
        y: p * u
    }
}
const Ble = function(t) {
        return t === void 0 && (t = 0), {
            name: "offset",
            options: t,
            async fn(e) {
                var r, n;
                const {
                    x: i,
                    y: s,
                    placement: a,
                    middlewareData: o
                } = e, c = await Fle(e, t);
                return a === ((r = o.offset) == null ? void 0 : r.placement) && (n = o.arrow) != null && n.alignmentOffset ? {} : {
                    x: i + c.x,
                    y: s + c.y,
                    data: { ...c,
                        placement: a
                    }
                }
            }
        }
    },
    Wle = function(t) {
        return t === void 0 && (t = {}), {
            name: "shift",
            options: t,
            async fn(e) {
                const {
                    x: r,
                    y: n,
                    placement: i
                } = e, {
                    mainAxis: s = !0,
                    crossAxis: a = !1,
                    limiter: o = {
                        fn: y => {
                            let {
                                x: w,
                                y: x
                            } = y;
                            return {
                                x: w,
                                y: x
                            }
                        }
                    },
                    ...c
                } = _h(t, e), l = {
                    x: r,
                    y: n
                }, u = await gy(e, c), h = zo(il(i)), f = qj(h);
                let p = l[f],
                    g = l[h];
                if (s) {
                    const y = f === "y" ? "top" : "left",
                        w = f === "y" ? "bottom" : "right",
                        x = p + u[y],
                        E = p - u[w];
                    p = L9(x, p, E)
                }
                if (a) {
                    const y = h === "y" ? "top" : "left",
                        w = h === "y" ? "bottom" : "right",
                        x = g + u[y],
                        E = g - u[w];
                    g = L9(x, g, E)
                }
                const m = o.fn({ ...e,
                    [f]: p,
                    [h]: g
                });
                return { ...m,
                    data: {
                        x: m.x - r,
                        y: m.y - n,
                        enabled: {
                            [f]: s,
                            [h]: a
                        }
                    }
                }
            }
        }
    },
    zle = function(t) {
        return t === void 0 && (t = {}), {
            name: "size",
            options: t,
            async fn(e) {
                var r, n;
                const {
                    placement: i,
                    rects: s,
                    platform: a,
                    elements: o
                } = e, {
                    apply: c = () => {},
                    ...l
                } = _h(t, e), u = await gy(e, l), h = il(i), f = p0(i), p = zo(i) === "y", {
                    width: g,
                    height: m
                } = s.floating;
                let y, w;
                h === "top" || h === "bottom" ? (y = h, w = f === (await (a.isRTL == null ? void 0 : a.isRTL(o.floating)) ? "start" : "end") ? "left" : "right") : (w = h, y = f === "end" ? "top" : "bottom");
                const x = m - u.top - u.bottom,
                    E = g - u.left - u.right,
                    _ = pd(m - u[y], x),
                    b = pd(g - u[w], E),
                    A = !e.middlewareData.shift;
                let I = _,
                    T = b;
                if ((r = e.middlewareData.shift) != null && r.enabled.x && (T = E), (n = e.middlewareData.shift) != null && n.enabled.y && (I = x), A && !f) {
                    const $ = Kn(u.left, 0),
                        P = Kn(u.right, 0),
                        N = Kn(u.top, 0),
                        R = Kn(u.bottom, 0);
                    p ? T = g - 2 * ($ !== 0 || P !== 0 ? $ + P : Kn(u.left, u.right)) : I = m - 2 * (N !== 0 || R !== 0 ? N + R : Kn(u.top, u.bottom))
                }
                await c({ ...e,
                    availableWidth: T,
                    availableHeight: I
                });
                const C = await a.getDimensions(o.floating);
                return g !== C.width || m !== C.height ? {
                    reset: {
                        rects: !0
                    }
                } : {}
            }
        }
    };

function Gj(t) {
    const e = ka(t);
    let r = parseFloat(e.width) || 0,
        n = parseFloat(e.height) || 0;
    const i = ho(t),
        s = i ? t.offsetWidth : r,
        a = i ? t.offsetHeight : n,
        o = Pp(r) !== s || Pp(n) !== a;
    return o && (r = s, n = a), {
        width: r,
        height: n,
        $: o
    }
}

function mx(t) {
    return ci(t) ? t : t.contextElement
}

function Bu(t) {
    const e = mx(t);
    if (!ho(e)) return io(1);
    const r = e.getBoundingClientRect(),
        {
            width: n,
            height: i,
            $: s
        } = Gj(e);
    let a = (s ? Pp(r.width) : r.width) / n,
        o = (s ? Pp(r.height) : r.height) / i;
    return (!a || !Number.isFinite(a)) && (a = 1), (!o || !Number.isFinite(o)) && (o = 1), {
        x: a,
        y: o
    }
}
const qle = io(0);

function Kj(t) {
    const e = is(t);
    return !gx() || !e.visualViewport ? qle : {
        x: e.visualViewport.offsetLeft,
        y: e.visualViewport.offsetTop
    }
}

function Hle(t, e, r) {
    return e === void 0 && (e = !1), !r || e && r !== is(t) ? !1 : e
}

function gd(t, e, r, n) {
    e === void 0 && (e = !1), r === void 0 && (r = !1);
    const i = t.getBoundingClientRect(),
        s = mx(t);
    let a = io(1);
    e && (n ? ci(n) && (a = Bu(n)) : a = Bu(t));
    const o = Hle(s, r, n) ? Kj(s) : io(0);
    let c = (i.left + o.x) / a.x,
        l = (i.top + o.y) / a.y,
        u = i.width / a.x,
        h = i.height / a.y;
    if (s) {
        const f = is(s),
            p = n && ci(n) ? is(n) : n;
        let g = f,
            m = r5(g);
        for (; m && n && p !== g;) {
            const y = Bu(m),
                w = m.getBoundingClientRect(),
                x = ka(m),
                E = w.left + (m.clientLeft + parseFloat(x.paddingLeft)) * y.x,
                _ = w.top + (m.clientTop + parseFloat(x.paddingTop)) * y.y;
            c *= y.x, l *= y.y, u *= y.x, h *= y.y, c += E, l += _, g = is(m), m = r5(g)
        }
    }
    return Um({
        width: u,
        height: h,
        x: c,
        y: l
    })
}

function yx(t, e) {
    const r = py(t).scrollLeft;
    return e ? e.left + r : gd(wo(t)).left + r
}

function Yj(t, e, r) {
    r === void 0 && (r = !1);
    const n = t.getBoundingClientRect(),
        i = n.left + e.scrollLeft - (r ? 0 : yx(t, n)),
        s = n.top + e.scrollTop;
    return {
        x: i,
        y: s
    }
}

function Vle(t) {
    let {
        elements: e,
        rect: r,
        offsetParent: n,
        strategy: i
    } = t;
    const s = i === "fixed",
        a = wo(n),
        o = e ? fy(e.floating) : !1;
    if (n === a || o && s) return r;
    let c = {
            scrollLeft: 0,
            scrollTop: 0
        },
        l = io(1);
    const u = io(0),
        h = ho(n);
    if ((h || !h && !s) && ((Eh(n) !== "body" || f0(a)) && (c = py(n)), ho(n))) {
        const p = gd(n);
        l = Bu(n), u.x = p.x + n.clientLeft, u.y = p.y + n.clientTop
    }
    const f = a && !h && !s ? Yj(a, c, !0) : io(0);
    return {
        width: r.width * l.x,
        height: r.height * l.y,
        x: r.x * l.x - c.scrollLeft * l.x + u.x + f.x,
        y: r.y * l.y - c.scrollTop * l.y + u.y + f.y
    }
}

function Gle(t) {
    return Array.from(t.getClientRects())
}

function Kle(t) {
    const e = wo(t),
        r = py(t),
        n = t.ownerDocument.body,
        i = Kn(e.scrollWidth, e.clientWidth, n.scrollWidth, n.clientWidth),
        s = Kn(e.scrollHeight, e.clientHeight, n.scrollHeight, n.clientHeight);
    let a = -r.scrollLeft + yx(t);
    const o = -r.scrollTop;
    return ka(n).direction === "rtl" && (a += Kn(e.clientWidth, n.clientWidth) - i), {
        width: i,
        height: s,
        x: a,
        y: o
    }
}

function Yle(t, e) {
    const r = is(t),
        n = wo(t),
        i = r.visualViewport;
    let s = n.clientWidth,
        a = n.clientHeight,
        o = 0,
        c = 0;
    if (i) {
        s = i.width, a = i.height;
        const l = gx();
        (!l || l && e === "fixed") && (o = i.offsetLeft, c = i.offsetTop)
    }
    return {
        width: s,
        height: a,
        x: o,
        y: c
    }
}

function Zle(t, e) {
    const r = gd(t, !0, e === "fixed"),
        n = r.top + t.clientTop,
        i = r.left + t.clientLeft,
        s = ho(t) ? Bu(t) : io(1),
        a = t.clientWidth * s.x,
        o = t.clientHeight * s.y,
        c = i * s.x,
        l = n * s.y;
    return {
        width: a,
        height: o,
        x: c,
        y: l
    }
}

function F9(t, e, r) {
    let n;
    if (e === "viewport") n = Yle(t, r);
    else if (e === "document") n = Kle(wo(t));
    else if (ci(e)) n = Zle(e, r);
    else {
        const i = Kj(t);
        n = {
            x: e.x - i.x,
            y: e.y - i.y,
            width: e.width,
            height: e.height
        }
    }
    return Um(n)
}

function Zj(t, e) {
    const r = nl(t);
    return r === e || !ci(r) || ih(r) ? !1 : ka(r).position === "fixed" || Zj(r, e)
}

function Jle(t, e) {
    const r = e.get(t);
    if (r) return r;
    let n = Tp(t, [], !1).filter(o => ci(o) && Eh(o) !== "body"),
        i = null;
    const s = ka(t).position === "fixed";
    let a = s ? nl(t) : t;
    for (; ci(a) && !ih(a);) {
        const o = ka(a),
            c = px(a);
        !c && o.position === "fixed" && (i = null), (s ? !c && !i : !c && o.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || f0(a) && !c && Zj(t, a)) ? n = n.filter(u => u !== a) : i = o, a = nl(a)
    }
    return e.set(t, n), n
}

function Qle(t) {
    let {
        element: e,
        boundary: r,
        rootBoundary: n,
        strategy: i
    } = t;
    const a = [...r === "clippingAncestors" ? fy(e) ? [] : Jle(e, this._c) : [].concat(r), n],
        o = a[0],
        c = a.reduce((l, u) => {
            const h = F9(e, u, i);
            return l.top = Kn(h.top, l.top), l.right = pd(h.right, l.right), l.bottom = pd(h.bottom, l.bottom), l.left = Kn(h.left, l.left), l
        }, F9(e, o, i));
    return {
        width: c.right - c.left,
        height: c.bottom - c.top,
        x: c.left,
        y: c.top
    }
}

function Xle(t) {
    const {
        width: e,
        height: r
    } = Gj(t);
    return {
        width: e,
        height: r
    }
}

function ede(t, e, r) {
    const n = ho(e),
        i = wo(e),
        s = r === "fixed",
        a = gd(t, !0, s, e);
    let o = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const c = io(0);

    function l() {
        c.x = yx(i)
    }
    if (n || !n && !s)
        if ((Eh(e) !== "body" || f0(i)) && (o = py(e)), n) {
            const p = gd(e, !0, s, e);
            c.x = p.x + e.clientLeft, c.y = p.y + e.clientTop
        } else i && l();
    s && !n && i && l();
    const u = i && !n && !s ? Yj(i, o) : io(0),
        h = a.left + o.scrollLeft - c.x - u.x,
        f = a.top + o.scrollTop - c.y - u.y;
    return {
        x: h,
        y: f,
        width: a.width,
        height: a.height
    }
}

function j2(t) {
    return ka(t).position === "static"
}

function B9(t, e) {
    if (!ho(t) || ka(t).position === "fixed") return null;
    if (e) return e(t);
    let r = t.offsetParent;
    return wo(t) === r && (r = r.ownerDocument.body), r
}

function Jj(t, e) {
    const r = is(t);
    if (fy(t)) return r;
    if (!ho(t)) {
        let i = nl(t);
        for (; i && !ih(i);) {
            if (ci(i) && !j2(i)) return i;
            i = nl(i)
        }
        return r
    }
    let n = B9(t, e);
    for (; n && Ile(n) && j2(n);) n = B9(n, e);
    return n && ih(n) && j2(n) && !px(n) ? r : n || $le(t) || r
}
const tde = async function(t) {
    const e = this.getOffsetParent || Jj,
        r = this.getDimensions,
        n = await r(t.floating);
    return {
        reference: ede(t.reference, await e(t.floating), t.strategy),
        floating: {
            x: 0,
            y: 0,
            width: n.width,
            height: n.height
        }
    }
};

function rde(t) {
    return ka(t).direction === "rtl"
}
const nde = {
    convertOffsetParentRelativeRectToViewportRelativeRect: Vle,
    getDocumentElement: wo,
    getClippingRect: Qle,
    getOffsetParent: Jj,
    getElementRects: tde,
    getClientRects: Gle,
    getDimensions: Xle,
    getScale: Bu,
    isElement: ci,
    isRTL: rde
};

function Qj(t, e) {
    return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
}

function ide(t, e) {
    let r = null,
        n;
    const i = wo(t);

    function s() {
        var o;
        clearTimeout(n), (o = r) == null || o.disconnect(), r = null
    }

    function a(o, c) {
        o === void 0 && (o = !1), c === void 0 && (c = 1), s();
        const l = t.getBoundingClientRect(),
            {
                left: u,
                top: h,
                width: f,
                height: p
            } = l;
        if (o || e(), !f || !p) return;
        const g = cg(h),
            m = cg(i.clientWidth - (u + f)),
            y = cg(i.clientHeight - (h + p)),
            w = cg(u),
            E = {
                rootMargin: -g + "px " + -m + "px " + -y + "px " + -w + "px",
                threshold: Kn(0, pd(1, c)) || 1
            };
        let _ = !0;

        function b(A) {
            const I = A[0].intersectionRatio;
            if (I !== c) {
                if (!_) return a();
                I ? a(!1, I) : n = setTimeout(() => {
                    a(!1, 1e-7)
                }, 1e3)
            }
            I === 1 && !Qj(l, t.getBoundingClientRect()) && a(), _ = !1
        }
        try {
            r = new IntersectionObserver(b, { ...E,
                root: i.ownerDocument
            })
        } catch {
            r = new IntersectionObserver(b, E)
        }
        r.observe(t)
    }
    return a(!0), s
}

function sde(t, e, r, n) {
    n === void 0 && (n = {});
    const {
        ancestorScroll: i = !0,
        ancestorResize: s = !0,
        elementResize: a = typeof ResizeObserver == "function",
        layoutShift: o = typeof IntersectionObserver == "function",
        animationFrame: c = !1
    } = n, l = mx(t), u = i || s ? [...l ? Tp(l) : [], ...Tp(e)] : [];
    u.forEach(w => {
        i && w.addEventListener("scroll", r, {
            passive: !0
        }), s && w.addEventListener("resize", r)
    });
    const h = l && o ? ide(l, r) : null;
    let f = -1,
        p = null;
    a && (p = new ResizeObserver(w => {
        let [x] = w;
        x && x.target === l && p && (p.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
            var E;
            (E = p) == null || E.observe(e)
        })), r()
    }), l && !c && p.observe(l), p.observe(e));
    let g, m = c ? gd(t) : null;
    c && y();

    function y() {
        const w = gd(t);
        m && !Qj(m, w) && r(), m = w, g = requestAnimationFrame(y)
    }
    return r(), () => {
        var w;
        u.forEach(x => {
            i && x.removeEventListener("scroll", r), s && x.removeEventListener("resize", r)
        }), h == null || h(), (w = p) == null || w.disconnect(), p = null, c && cancelAnimationFrame(g)
    }
}
const R2 = gy,
    ade = Ble,
    ode = Wle,
    cde = Ule,
    lde = zle,
    dde = (t, e, r) => {
        const n = new Map,
            i = {
                platform: nde,
                ...r
            },
            s = { ...i.platform,
                _c: n
            };
        return Lle(t, e, { ...i,
            platform: s
        })
    };
var ude = typeof document < "u",
    hde = function() {},
    Jg = ude ? v.useLayoutEffect : hde;

function Fm(t, e) {
    if (t === e) return !0;
    if (typeof t != typeof e) return !1;
    if (typeof t == "function" && t.toString() === e.toString()) return !0;
    let r, n, i;
    if (t && e && typeof t == "object") {
        if (Array.isArray(t)) {
            if (r = t.length, r !== e.length) return !1;
            for (n = r; n-- !== 0;)
                if (!Fm(t[n], e[n])) return !1;
            return !0
        }
        if (i = Object.keys(t), r = i.length, r !== Object.keys(e).length) return !1;
        for (n = r; n-- !== 0;)
            if (!{}.hasOwnProperty.call(e, i[n])) return !1;
        for (n = r; n-- !== 0;) {
            const s = i[n];
            if (!(s === "_owner" && t.$$typeof) && !Fm(t[s], e[s])) return !1
        }
        return !0
    }
    return t !== t && e !== e
}

function Xj(t) {
    return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1
}

function W9(t, e) {
    const r = Xj(t);
    return Math.round(e * r) / r
}

function M2(t) {
    const e = v.useRef(t);
    return Jg(() => {
        e.current = t
    }), e
}

function fde(t) {
    t === void 0 && (t = {});
    const {
        placement: e = "bottom",
        strategy: r = "absolute",
        middleware: n = [],
        platform: i,
        elements: {
            reference: s,
            floating: a
        } = {},
        transform: o = !0,
        whileElementsMounted: c,
        open: l
    } = t, [u, h] = v.useState({
        x: 0,
        y: 0,
        strategy: r,
        placement: e,
        middlewareData: {},
        isPositioned: !1
    }), [f, p] = v.useState(n);
    Fm(f, n) || p(n);
    const [g, m] = v.useState(null), [y, w] = v.useState(null), x = v.useCallback(U => {
        U !== A.current && (A.current = U, m(U))
    }, []), E = v.useCallback(U => {
        U !== I.current && (I.current = U, w(U))
    }, []), _ = s || g, b = a || y, A = v.useRef(null), I = v.useRef(null), T = v.useRef(u), C = c != null, $ = M2(c), P = M2(i), N = M2(l), R = v.useCallback(() => {
        if (!A.current || !I.current) return;
        const U = {
            placement: e,
            strategy: r,
            middleware: f
        };
        P.current && (U.platform = P.current), dde(A.current, I.current, U).then(k => {
            const F = { ...k,
                isPositioned: N.current !== !1
            };
            D.current && !Fm(T.current, F) && (T.current = F, Zo.flushSync(() => {
                h(F)
            }))
        })
    }, [f, e, r, P, N]);
    Jg(() => {
        l === !1 && T.current.isPositioned && (T.current.isPositioned = !1, h(U => ({ ...U,
            isPositioned: !1
        })))
    }, [l]);
    const D = v.useRef(!1);
    Jg(() => (D.current = !0, () => {
        D.current = !1
    }), []), Jg(() => {
        if (_ && (A.current = _), b && (I.current = b), _ && b) {
            if ($.current) return $.current(_, b, R);
            R()
        }
    }, [_, b, R, $, C]);
    const S = v.useMemo(() => ({
            reference: A,
            floating: I,
            setReference: x,
            setFloating: E
        }), [x, E]),
        O = v.useMemo(() => ({
            reference: _,
            floating: b
        }), [_, b]),
        M = v.useMemo(() => {
            const U = {
                position: r,
                left: 0,
                top: 0
            };
            if (!O.floating) return U;
            const k = W9(O.floating, u.x),
                F = W9(O.floating, u.y);
            return o ? { ...U,
                transform: "translate(" + k + "px, " + F + "px)",
                ...Xj(O.floating) >= 1.5 && {
                    willChange: "transform"
                }
            } : {
                position: r,
                left: k,
                top: F
            }
        }, [r, o, O.floating, u.x, u.y]);
    return v.useMemo(() => ({ ...u,
        update: R,
        refs: S,
        elements: O,
        floatingStyles: M
    }), [u, R, S, O, M])
}
const eR = (t, e) => ({ ...ade(t),
        options: [t, e]
    }),
    pde = (t, e) => ({ ...ode(t),
        options: [t, e]
    }),
    gde = (t, e) => ({ ...cde(t),
        options: [t, e]
    }),
    mde = (t, e) => ({ ...lde(t),
        options: [t, e]
    }),
    tR = { ...Uv
    },
    yde = tR.useInsertionEffect,
    wde = yde || (t => t());

function rR(t) {
    const e = v.useRef(() => {});
    return wde(() => {
        e.current = t
    }), v.useCallback(function() {
        for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) n[i] = arguments[i];
        return e.current == null ? void 0 : e.current(...n)
    }, [])
}
var i5 = typeof document < "u" ? v.useLayoutEffect : v.useEffect;
let z9 = !1,
    bde = 0;
const q9 = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + bde++;

function vde() {
    const [t, e] = v.useState(() => z9 ? q9() : void 0);
    return i5(() => {
        t == null && e(q9())
    }, []), v.useEffect(() => {
        z9 = !0
    }, []), t
}
const xde = tR.useId,
    Ede = xde || vde;

function _de() {
    const t = new Map;
    return {
        emit(e, r) {
            var n;
            (n = t.get(e)) == null || n.forEach(i => i(r))
        },
        on(e, r) {
            t.set(e, [...t.get(e) || [], r])
        },
        off(e, r) {
            var n;
            t.set(e, ((n = t.get(e)) == null ? void 0 : n.filter(i => i !== r)) || [])
        }
    }
}
const Cde = v.createContext(null),
    Ade = v.createContext(null),
    kde = () => {
        var t;
        return ((t = v.useContext(Cde)) == null ? void 0 : t.id) || null
    },
    Ide = () => v.useContext(Ade),
    $de = "data-floating-ui-focusable";

function Sde(t) {
    const {
        open: e = !1,
        onOpenChange: r,
        elements: n
    } = t, i = Ede(), s = v.useRef({}), [a] = v.useState(() => _de()), o = kde() != null, [c, l] = v.useState(n.reference), u = rR((p, g, m) => {
        s.current.openEvent = p ? g : void 0, a.emit("openchange", {
            open: p,
            event: g,
            reason: m,
            nested: o
        }), r == null || r(p, g, m)
    }), h = v.useMemo(() => ({
        setPositionReference: l
    }), []), f = v.useMemo(() => ({
        reference: c || n.reference || null,
        floating: n.floating || null,
        domReference: n.reference
    }), [c, n.reference, n.floating]);
    return v.useMemo(() => ({
        dataRef: s,
        open: e,
        onOpenChange: u,
        elements: f,
        events: a,
        floatingId: i,
        refs: h
    }), [e, u, f, a, i, h])
}

function Tde(t) {
    t === void 0 && (t = {});
    const {
        nodeId: e
    } = t, r = Sde({ ...t,
        elements: {
            reference: null,
            floating: null,
            ...t.elements
        }
    }), n = t.rootContext || r, i = n.elements, [s, a] = v.useState(null), [o, c] = v.useState(null), u = (i == null ? void 0 : i.domReference) || s, h = v.useRef(null), f = Ide();
    i5(() => {
        u && (h.current = u)
    }, [u]);
    const p = fde({ ...t,
            elements: { ...i,
                ...o && {
                    reference: o
                }
            }
        }),
        g = v.useCallback(E => {
            const _ = ci(E) ? {
                getBoundingClientRect: () => E.getBoundingClientRect(),
                contextElement: E
            } : E;
            c(_), p.refs.setReference(_)
        }, [p.refs]),
        m = v.useCallback(E => {
            (ci(E) || E === null) && (h.current = E, a(E)), (ci(p.refs.reference.current) || p.refs.reference.current === null || E !== null && !ci(E)) && p.refs.setReference(E)
        }, [p.refs]),
        y = v.useMemo(() => ({ ...p.refs,
            setReference: m,
            setPositionReference: g,
            domReference: h
        }), [p.refs, m, g]),
        w = v.useMemo(() => ({ ...p.elements,
            domReference: u
        }), [p.elements, u]),
        x = v.useMemo(() => ({ ...p,
            ...n,
            refs: y,
            elements: w,
            nodeId: e
        }), [p, y, w, e, n]);
    return i5(() => {
        n.dataRef.current.floatingContext = x;
        const E = f == null ? void 0 : f.nodesRef.current.find(_ => _.id === e);
        E && (E.context = x)
    }), v.useMemo(() => ({ ...p,
        context: x,
        refs: y,
        elements: w
    }), [p, y, w, x])
}
const H9 = "active",
    V9 = "selected";

function D2(t, e, r) {
    const n = new Map,
        i = r === "item";
    let s = t;
    if (i && t) {
        const {
            [H9]: a, [V9]: o, ...c
        } = t;
        s = c
    }
    return { ...r === "floating" && {
            tabIndex: -1,
            [$de]: ""
        },
        ...s,
        ...e.map(a => {
            const o = a ? a[r] : null;
            return typeof o == "function" ? t ? o(t) : null : o
        }).concat(t).reduce((a, o) => (o && Object.entries(o).forEach(c => {
            let [l, u] = c;
            if (!(i && [H9, V9].includes(l)))
                if (l.indexOf("on") === 0) {
                    if (n.has(l) || n.set(l, []), typeof u == "function") {
                        var h;
                        (h = n.get(l)) == null || h.push(u), a[l] = function() {
                            for (var f, p = arguments.length, g = new Array(p), m = 0; m < p; m++) g[m] = arguments[m];
                            return (f = n.get(l)) == null ? void 0 : f.map(y => y(...g)).find(y => y !== void 0)
                        }
                    }
                } else a[l] = u
        }), a), {})
    }
}

function Pde(t) {
    t === void 0 && (t = []);
    const e = t.map(o => o == null ? void 0 : o.reference),
        r = t.map(o => o == null ? void 0 : o.floating),
        n = t.map(o => o == null ? void 0 : o.item),
        i = v.useCallback(o => D2(o, t, "reference"), e),
        s = v.useCallback(o => D2(o, t, "floating"), r),
        a = v.useCallback(o => D2(o, t, "item"), n);
    return v.useMemo(() => ({
        getReferenceProps: i,
        getFloatingProps: s,
        getItemProps: a
    }), [i, s, a])
}

function G9(t, e) {
    return { ...t,
        rects: { ...t.rects,
            floating: { ...t.rects.floating,
                height: e
            }
        }
    }
}
const Nde = t => ({
    name: "inner",
    options: t,
    async fn(e) {
        const {
            listRef: r,
            overflowRef: n,
            onFallbackChange: i,
            offset: s = 0,
            index: a = 0,
            minItemsVisible: o = 4,
            referenceOverflowThreshold: c = 0,
            scrollRef: l,
            ...u
        } = _h(t, e), {
            rects: h,
            elements: {
                floating: f
            }
        } = e, p = r.current[a], g = (l == null ? void 0 : l.current) || f, m = f.clientTop || g.clientTop, y = f.clientTop !== 0, w = g.clientTop !== 0, x = f === g;
        if (!p) return {};
        const E = { ...e,
                ...await eR(-p.offsetTop - f.clientTop - h.reference.height / 2 - p.offsetHeight / 2 - s).fn(e)
            },
            _ = await R2(G9(E, g.scrollHeight + m + f.clientTop), u),
            b = await R2(E, { ...u,
                elementContext: "reference"
            }),
            A = Kn(0, _.top),
            I = E.y + A,
            $ = (g.scrollHeight > g.clientHeight ? P => P : Pp)(Kn(0, g.scrollHeight + (y && x || w ? m * 2 : 0) - A - Kn(0, _.bottom)));
        if (g.style.maxHeight = $ + "px", g.scrollTop = A, i) {
            const P = g.offsetHeight < p.offsetHeight * pd(o, r.current.length) - 1 || b.top >= -c || b.bottom >= -c;
            Zo.flushSync(() => i(P))
        }
        return n && (n.current = await R2(G9({ ...E,
            y: I
        }, g.offsetHeight + m + f.clientTop), u)), {
            y: I
        }
    }
});

function Ode(t, e) {
    const {
        open: r,
        elements: n
    } = t, {
        enabled: i = !0,
        overflowRef: s,
        scrollRef: a,
        onChange: o
    } = e, c = rR(o), l = v.useRef(!1), u = v.useRef(null), h = v.useRef(null);
    v.useEffect(() => {
        if (!i) return;

        function p(m) {
            if (m.ctrlKey || !g || s.current == null) return;
            const y = m.deltaY,
                w = s.current.top >= -.5,
                x = s.current.bottom >= -.5,
                E = g.scrollHeight - g.clientHeight,
                _ = y < 0 ? -1 : 1,
                b = y < 0 ? "max" : "min";
            g.scrollHeight <= g.clientHeight || (!w && y > 0 || !x && y < 0 ? (m.preventDefault(), Zo.flushSync(() => {
                c(A => A + Math[b](y, E * _))
            })) : /firefox/i.test(Sle()) && (g.scrollTop += y))
        }
        const g = (a == null ? void 0 : a.current) || n.floating;
        if (r && g) return g.addEventListener("wheel", p), requestAnimationFrame(() => {
            u.current = g.scrollTop, s.current != null && (h.current = { ...s.current
            })
        }), () => {
            u.current = null, h.current = null, g.removeEventListener("wheel", p)
        }
    }, [i, r, n.floating, s, a, c]);
    const f = v.useMemo(() => ({
        onKeyDown() {
            l.current = !0
        },
        onWheel() {
            l.current = !1
        },
        onPointerMove() {
            l.current = !1
        },
        onScroll() {
            const p = (a == null ? void 0 : a.current) || n.floating;
            if (!(!s.current || !p || !l.current)) {
                if (u.current !== null) {
                    const g = p.scrollTop - u.current;
                    (s.current.bottom < -.5 && g < -1 || s.current.top < -.5 && g > 1) && Zo.flushSync(() => c(m => m + g))
                }
                requestAnimationFrame(() => {
                    u.current = p.scrollTop
                })
            }
        }
    }), [n.floating, c, s, a]);
    return v.useMemo(() => i ? {
        floating: f
    } : {}, [i, f])
}
let Ch = v.createContext({
    styles: void 0,
    setReference: () => {},
    setFloating: () => {},
    getReferenceProps: () => ({}),
    getFloatingProps: () => ({}),
    slot: {}
});
Ch.displayName = "FloatingContext";
let wx = v.createContext(null);
wx.displayName = "PlacementContext";

function jde(t) {
    return v.useMemo(() => t ? typeof t == "string" ? {
        to: t
    } : t : null, [t])
}

function Rde() {
    return v.useContext(Ch).setReference
}

function Mde() {
    return v.useContext(Ch).getReferenceProps
}

function Dde() {
    let {
        getFloatingProps: t,
        slot: e
    } = v.useContext(Ch);
    return v.useCallback((...r) => Object.assign({}, t(...r), {
        "data-anchor": e.anchor
    }), [t, e])
}

function Lde(t = null) {
    t === !1 && (t = null), typeof t == "string" && (t = {
        to: t
    });
    let e = v.useContext(wx),
        r = v.useMemo(() => t, [JSON.stringify(t, (i, s) => {
            var a;
            return (a = s == null ? void 0 : s.outerHTML) != null ? a : s
        })]);
    lr(() => {
        e == null || e(r ? ? null)
    }, [e, r]);
    let n = v.useContext(Ch);
    return v.useMemo(() => [n.setFloating, t ? n.styles : {}], [n.setFloating, t, n.styles])
}
let K9 = 4;

function Ude({
    children: t,
    enabled: e = !0
}) {
    let [r, n] = v.useState(null), [i, s] = v.useState(0), a = v.useRef(null), [o, c] = v.useState(null);
    Fde(o);
    let l = e && r !== null && o !== null,
        {
            to: u = "bottom",
            gap: h = 0,
            offset: f = 0,
            padding: p = 0,
            inner: g
        } = Bde(r, o),
        [m, y = "center"] = u.split(" ");
    lr(() => {
        l && s(0)
    }, [l]);
    let {
        refs: w,
        floatingStyles: x,
        context: E
    } = Tde({
        open: l,
        placement: m === "selection" ? y === "center" ? "bottom" : `bottom-${y}` : y === "center" ? `${m}` : `${m}-${y}`,
        strategy: "absolute",
        transform: !1,
        middleware: [eR({
            mainAxis: m === "selection" ? 0 : h,
            crossAxis: f
        }), pde({
            padding: p
        }), m !== "selection" && gde({
            padding: p
        }), m === "selection" && g ? Nde({ ...g,
            padding: p,
            overflowRef: a,
            offset: i,
            minItemsVisible: K9,
            referenceOverflowThreshold: p,
            onFallbackChange(P) {
                var N, R;
                if (!P) return;
                let D = E.elements.floating;
                if (!D) return;
                let S = parseFloat(getComputedStyle(D).scrollPaddingBottom) || 0,
                    O = Math.min(K9, D.childElementCount),
                    M = 0,
                    U = 0;
                for (let k of (R = (N = E.elements.floating) == null ? void 0 : N.childNodes) != null ? R : [])
                    if (os(k)) {
                        let F = k.offsetTop,
                            q = F + k.clientHeight + S,
                            W = D.scrollTop,
                            K = W + D.clientHeight;
                        if (F >= W && q <= K) O--;
                        else {
                            U = Math.max(0, Math.min(q, K) - Math.max(F, W)), M = k.clientHeight;
                            break
                        }
                    }
                O >= 1 && s(k => {
                    let F = M * O - U + S;
                    return k >= F ? k : F
                })
            }
        }) : null, mde({
            padding: p,
            apply({
                availableWidth: P,
                availableHeight: N,
                elements: R
            }) {
                Object.assign(R.floating.style, {
                    overflow: "auto",
                    maxWidth: `${P}px`,
                    maxHeight: `min(var(--anchor-max-height, 100vh), ${N}px)`
                })
            }
        })].filter(Boolean),
        whileElementsMounted: sde
    }), [_ = m, b = y] = E.placement.split("-");
    m === "selection" && (_ = "selection");
    let A = v.useMemo(() => ({
            anchor: [_, b].filter(Boolean).join(" ")
        }), [_, b]),
        I = Ode(E, {
            overflowRef: a,
            onChange: s
        }),
        {
            getReferenceProps: T,
            getFloatingProps: C
        } = Pde([I]),
        $ = xt(P => {
            c(P), w.setFloating(P)
        });
    return v.createElement(wx.Provider, {
        value: n
    }, v.createElement(Ch.Provider, {
        value: {
            setFloating: $,
            setReference: w.setReference,
            styles: x,
            getReferenceProps: T,
            getFloatingProps: C,
            slot: A
        }
    }, t))
}

function Fde(t) {
    lr(() => {
        if (!t) return;
        let e = new MutationObserver(() => {
            let r = window.getComputedStyle(t).maxHeight,
                n = parseFloat(r);
            if (isNaN(n)) return;
            let i = parseInt(r);
            isNaN(i) || n !== i && (t.style.maxHeight = `${Math.ceil(n)}px`)
        });
        return e.observe(t, {
            attributes: !0,
            attributeFilter: ["style"]
        }), () => {
            e.disconnect()
        }
    }, [t])
}

function Bde(t, e) {
    var r, n, i;
    let s = L2((r = t == null ? void 0 : t.gap) != null ? r : "var(--anchor-gap, 0)", e),
        a = L2((n = t == null ? void 0 : t.offset) != null ? n : "var(--anchor-offset, 0)", e),
        o = L2((i = t == null ? void 0 : t.padding) != null ? i : "var(--anchor-padding, 0)", e);
    return { ...t,
        gap: s,
        offset: a,
        padding: o
    }
}

function L2(t, e, r = void 0) {
    let n = xh(),
        i = xt((c, l) => {
            if (c == null) return [r, null];
            if (typeof c == "number") return [c, null];
            if (typeof c == "string") {
                if (!l) return [r, null];
                let u = Y9(c, l);
                return [u, h => {
                    let f = nR(c); {
                        let p = f.map(g => window.getComputedStyle(l).getPropertyValue(g));
                        n.requestAnimationFrame(function g() {
                            n.nextFrame(g);
                            let m = !1;
                            for (let [w, x] of f.entries()) {
                                let E = window.getComputedStyle(l).getPropertyValue(x);
                                if (p[w] !== E) {
                                    p[w] = E, m = !0;
                                    break
                                }
                            }
                            if (!m) return;
                            let y = Y9(c, l);
                            u !== y && (h(y), u = y)
                        })
                    }
                    return n.dispose
                }]
            }
            return [r, null]
        }),
        s = v.useMemo(() => i(t, e)[0], [t, e]),
        [a = s, o] = v.useState();
    return lr(() => {
        let [c, l] = i(t, e);
        if (o(c), !!l) return l(o)
    }, [t, e]), a
}

function nR(t) {
    let e = /var\((.*)\)/.exec(t);
    if (e) {
        let r = e[1].indexOf(",");
        if (r === -1) return [e[1]];
        let n = e[1].slice(0, r).trim(),
            i = e[1].slice(r + 1).trim();
        return i ? [n, ...nR(i)] : [n]
    }
    return []
}

function Y9(t, e) {
    let r = document.createElement("div");
    e.appendChild(r), r.style.setProperty("margin-top", "0px", "important"), r.style.setProperty("margin-top", t, "important");
    let n = parseFloat(window.getComputedStyle(r).marginTop) || 0;
    return e.removeChild(r), n
}
let my = v.createContext(null);
my.displayName = "OpenClosedContext";
var li = (t => (t[t.Open = 1] = "Open", t[t.Closed = 2] = "Closed", t[t.Closing = 4] = "Closing", t[t.Opening = 8] = "Opening", t))(li || {});

function g0() {
    return v.useContext(my)
}

function iR({
    value: t,
    children: e
}) {
    return at.createElement(my.Provider, {
        value: t
    }, e)
}

function Wde({
    children: t
}) {
    return at.createElement(my.Provider, {
        value: null
    }, t)
}

function zde(t) {
    function e() {
        document.readyState !== "loading" && (t(), document.removeEventListener("DOMContentLoaded", e))
    }
    typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", e), e())
}
let Wc = [];
zde(() => {
    function t(e) {
        if (!ro(e.target) || e.target === document.body || Wc[0] === e.target) return;
        let r = e.target;
        r = r.closest(Dm), Wc.unshift(r ? ? e.target), Wc = Wc.filter(n => n != null && n.isConnected), Wc.splice(10)
    }
    window.addEventListener("click", t, {
        capture: !0
    }), window.addEventListener("mousedown", t, {
        capture: !0
    }), window.addEventListener("focus", t, {
        capture: !0
    }), document.body.addEventListener("click", t, {
        capture: !0
    }), document.body.addEventListener("mousedown", t, {
        capture: !0
    }), document.body.addEventListener("focus", t, {
        capture: !0
    })
});

function qde(t) {
    throw new Error("Unexpected object: " + t)
}
var Br = (t => (t[t.First = 0] = "First", t[t.Previous = 1] = "Previous", t[t.Next = 2] = "Next", t[t.Last = 3] = "Last", t[t.Specific = 4] = "Specific", t[t.Nothing = 5] = "Nothing", t))(Br || {});

function lg(t, e) {
    let r = e.resolveItems();
    if (r.length <= 0) return null;
    let n = e.resolveActiveIndex(),
        i = n ? ? -1;
    switch (t.focus) {
        case 0:
            {
                for (let s = 0; s < r.length; ++s)
                    if (!e.resolveDisabled(r[s], s, r)) return s;
                return n
            }
        case 1:
            {
                i === -1 && (i = r.length);
                for (let s = i - 1; s >= 0; --s)
                    if (!e.resolveDisabled(r[s], s, r)) return s;
                return n
            }
        case 2:
            {
                for (let s = i + 1; s < r.length; ++s)
                    if (!e.resolveDisabled(r[s], s, r)) return s;
                return n
            }
        case 3:
            {
                for (let s = r.length - 1; s >= 0; --s)
                    if (!e.resolveDisabled(r[s], s, r)) return s;
                return n
            }
        case 4:
            {
                for (let s = 0; s < r.length; ++s)
                    if (e.resolveId(r[s], s, r) === t.id) return s;
                return n
            }
        case 5:
            return null;
        default:
            qde(t)
    }
}

function bx(t) {
    let e = xt(t),
        r = v.useRef(!1);
    v.useEffect(() => (r.current = !1, () => {
        r.current = !0, ly(() => {
            r.current && e()
        })
    }), [e])
}

function Hde() {
    let t = typeof document > "u";
    return "useSyncExternalStore" in Uv ? (e => e.useSyncExternalStore)(Uv)(() => () => {}, () => !1, () => !t) : !1
}

function m0() {
    let t = Hde(),
        [e, r] = v.useState(Xl.isHandoffComplete);
    return e && Xl.isHandoffComplete === !1 && r(!1), v.useEffect(() => {
        e !== !0 && r(!0)
    }, [e]), v.useEffect(() => Xl.handoff(), []), t ? !1 : e
}
let sR = v.createContext(!1);

function Vde() {
    return v.useContext(sR)
}

function Z9(t) {
    return at.createElement(sR.Provider, {
        value: t.force
    }, t.children)
}

function Gde(t) {
    let e = Vde(),
        r = v.useContext(oR),
        [n, i] = v.useState(() => {
            var s;
            if (!e && r !== null) return (s = r.current) != null ? s : null;
            if (Xl.isServer) return null;
            let a = t == null ? void 0 : t.getElementById("headlessui-portal-root");
            if (a) return a;
            if (t === null) return null;
            let o = t.createElement("div");
            return o.setAttribute("id", "headlessui-portal-root"), t.body.appendChild(o)
        });
    return v.useEffect(() => {
        n !== null && (t != null && t.body.contains(n) || t == null || t.body.appendChild(n))
    }, [n, t]), v.useEffect(() => {
        e || r !== null && i(r.current)
    }, [r, i, e]), n
}
let aR = v.Fragment,
    Kde = Dr(function(t, e) {
        let {
            ownerDocument: r = null,
            ...n
        } = t, i = v.useRef(null), s = yi(xce(p => {
            i.current = p
        }), e), a = nh(i), o = r ? ? a, c = Gde(o), [l] = v.useState(() => {
            var p;
            return Xl.isServer ? null : (p = o == null ? void 0 : o.createElement("div")) != null ? p : null
        }), u = v.useContext(s5), h = m0();
        lr(() => {
            !c || !l || c.contains(l) || (l.setAttribute("data-headlessui-portal", ""), c.appendChild(l))
        }, [c, l]), lr(() => {
            if (l && u) return u.register(l)
        }, [u, l]), bx(() => {
            var p;
            !c || !l || (cx(l) && c.contains(l) && c.removeChild(l), c.childNodes.length <= 0 && ((p = c.parentElement) == null || p.removeChild(c)))
        });
        let f = tn();
        return h ? !c || !l ? null : Zo.createPortal(f({
            ourProps: {
                ref: s
            },
            theirProps: n,
            slot: {},
            defaultTag: aR,
            name: "Portal"
        }), l) : null
    });

function Yde(t, e) {
    let r = yi(e),
        {
            enabled: n = !0,
            ownerDocument: i,
            ...s
        } = t,
        a = tn();
    return n ? at.createElement(Kde, { ...s,
        ownerDocument: i,
        ref: r
    }) : a({
        ourProps: {
            ref: r
        },
        theirProps: s,
        slot: {},
        defaultTag: aR,
        name: "Portal"
    })
}
let Zde = v.Fragment,
    oR = v.createContext(null);

function Jde(t, e) {
    let {
        target: r,
        ...n
    } = t, i = {
        ref: yi(e)
    }, s = tn();
    return at.createElement(oR.Provider, {
        value: r
    }, s({
        ourProps: i,
        theirProps: n,
        defaultTag: Zde,
        name: "Popover.Group"
    }))
}
let s5 = v.createContext(null);

function Qde() {
    let t = v.useContext(s5),
        e = v.useRef([]),
        r = xt(s => (e.current.push(s), t && t.register(s), () => n(s))),
        n = xt(s => {
            let a = e.current.indexOf(s);
            a !== -1 && e.current.splice(a, 1), t && t.unregister(s)
        }),
        i = v.useMemo(() => ({
            register: r,
            unregister: n,
            portals: e
        }), [r, n, e]);
    return [e, v.useMemo(() => function({
        children: s
    }) {
        return at.createElement(s5.Provider, {
            value: i
        }, s)
    }, [i])]
}
let Xde = Dr(Yde),
    cR = Dr(Jde),
    lR = Object.assign(Xde, {
        Group: cR
    });

function eue(t, e = typeof document < "u" ? document.defaultView : null, r) {
    let n = h0(t, "escape");
    Lj(e, "keydown", i => {
        n && (i.defaultPrevented || i.key === pn.Escape && r(i))
    })
}

function tue() {
    var t;
    let [e] = v.useState(() => typeof window < "u" && typeof window.matchMedia == "function" ? window.matchMedia("(pointer: coarse)") : null), [r, n] = v.useState((t = e == null ? void 0 : e.matches) != null ? t : !1);
    return lr(() => {
        if (!e) return;

        function i(s) {
            n(s.matches)
        }
        return e.addEventListener("change", i), () => e.removeEventListener("change", i)
    }, [e]), r
}

function rue({
    defaultContainers: t = [],
    portals: e,
    mainTreeNode: r
} = {}) {
    let n = nh(r),
        i = xt(() => {
            var s, a;
            let o = [];
            for (let c of t) c !== null && (Go(c) ? o.push(c) : "current" in c && Go(c.current) && o.push(c.current));
            if (e != null && e.current)
                for (let c of e.current) o.push(c);
            for (let c of (s = n == null ? void 0 : n.querySelectorAll("html > *, body > *")) != null ? s : []) c !== document.body && c !== document.head && Go(c) && c.id !== "headlessui-portal-root" && (r && (c.contains(r) || c.contains((a = r == null ? void 0 : r.getRootNode()) == null ? void 0 : a.host)) || o.some(l => c.contains(l)) || o.push(c));
            return o
        });
    return {
        resolveContainers: i,
        contains: xt(s => i().some(a => a.contains(s)))
    }
}
let dR = v.createContext(null);

function J9({
    children: t,
    node: e
}) {
    let [r, n] = v.useState(null), i = uR(e ? ? r);
    return at.createElement(dR.Provider, {
        value: i
    }, t, i === null && at.createElement(X3, {
        features: Mm.Hidden,
        ref: s => {
            var a, o;
            if (s) {
                for (let c of (o = (a = Pd(s)) == null ? void 0 : a.querySelectorAll("html > *, body > *")) != null ? o : [])
                    if (c !== document.body && c !== document.head && Go(c) && c != null && c.contains(s)) {
                        n(c);
                        break
                    }
            }
        }
    }))
}

function uR(t = null) {
    var e;
    return (e = v.useContext(dR)) != null ? e : t
}

function vx() {
    let t = v.useRef(!1);
    return lr(() => (t.current = !0, () => {
        t.current = !1
    }), []), t
}
var kf = (t => (t[t.Forwards = 0] = "Forwards", t[t.Backwards = 1] = "Backwards", t))(kf || {});

function nue() {
    let t = v.useRef(0);
    return Mj(!0, "keydown", e => {
        e.key === "Tab" && (t.current = e.shiftKey ? 1 : 0)
    }, !0), t
}

function hR(t) {
    if (!t) return new Set;
    if (typeof t == "function") return new Set(t());
    let e = new Set;
    for (let r of t.current) Go(r.current) && e.add(r.current);
    return e
}
let iue = "div";
var Ol = (t => (t[t.None = 0] = "None", t[t.InitialFocus = 1] = "InitialFocus", t[t.TabLock = 2] = "TabLock", t[t.FocusLock = 4] = "FocusLock", t[t.RestoreFocus = 8] = "RestoreFocus", t[t.AutoFocus = 16] = "AutoFocus", t))(Ol || {});

function sue(t, e) {
    let r = v.useRef(null),
        n = yi(r, e),
        {
            initialFocus: i,
            initialFocusFallback: s,
            containers: a,
            features: o = 15,
            ...c
        } = t;
    m0() || (o = 0);
    let l = nh(r);
    lue(o, {
        ownerDocument: l
    });
    let u = due(o, {
        ownerDocument: l,
        container: r,
        initialFocus: i,
        initialFocusFallback: s
    });
    uue(o, {
        ownerDocument: l,
        container: r,
        containers: a,
        previousActiveElement: u
    });
    let h = nue(),
        f = xt(x => {
            if (!os(r.current)) return;
            let E = r.current;
            (_ => _())(() => {
                Aa(h.current, {
                    [kf.Forwards]: () => {
                        Fu(E, ua.First, {
                            skipElements: [x.relatedTarget, s]
                        })
                    },
                    [kf.Backwards]: () => {
                        Fu(E, ua.Last, {
                            skipElements: [x.relatedTarget, s]
                        })
                    }
                })
            })
        }),
        p = h0(!!(o & 2), "focus-trap#tab-lock"),
        g = xh(),
        m = v.useRef(!1),
        y = {
            ref: n,
            onKeyDown(x) {
                x.key == "Tab" && (m.current = !0, g.requestAnimationFrame(() => {
                    m.current = !1
                }))
            },
            onBlur(x) {
                if (!(o & 4)) return;
                let E = hR(a);
                os(r.current) && E.add(r.current);
                let _ = x.relatedTarget;
                ro(_) && _.dataset.headlessuiFocusGuard !== "true" && (fR(E, _) || (m.current ? Fu(r.current, Aa(h.current, {
                    [kf.Forwards]: () => ua.Next,
                    [kf.Backwards]: () => ua.Previous
                }) | ua.WrapAround, {
                    relativeTo: x.target
                }) : ro(x.target) && no(x.target)))
            }
        },
        w = tn();
    return at.createElement(at.Fragment, null, p && at.createElement(X3, {
        as: "button",
        type: "button",
        "data-headlessui-focus-guard": !0,
        onFocus: f,
        features: Mm.Focusable
    }), w({
        ourProps: y,
        theirProps: c,
        defaultTag: iue,
        name: "FocusTrap"
    }), p && at.createElement(X3, {
        as: "button",
        type: "button",
        "data-headlessui-focus-guard": !0,
        onFocus: f,
        features: Mm.Focusable
    }))
}
let aue = Dr(sue),
    oue = Object.assign(aue, {
        features: Ol
    });

function cue(t = !0) {
    let e = v.useRef(Wc.slice());
    return fx(([r], [n]) => {
        n === !0 && r === !1 && ly(() => {
            e.current.splice(0)
        }), n === !1 && r === !0 && (e.current = Wc.slice())
    }, [t, Wc, e]), xt(() => {
        var r;
        return (r = e.current.find(n => n != null && n.isConnected)) != null ? r : null
    })
}

function lue(t, {
    ownerDocument: e
}) {
    let r = !!(t & 8),
        n = cue(r);
    fx(() => {
        r || (e == null ? void 0 : e.activeElement) === (e == null ? void 0 : e.body) && no(n())
    }, [r]), bx(() => {
        r && no(n())
    })
}

function due(t, {
    ownerDocument: e,
    container: r,
    initialFocus: n,
    initialFocusFallback: i
}) {
    let s = v.useRef(null),
        a = h0(!!(t & 1), "focus-trap#initial-focus"),
        o = vx();
    return fx(() => {
        if (t === 0) return;
        if (!a) {
            i != null && i.current && no(i.current);
            return
        }
        let c = r.current;
        c && ly(() => {
            if (!o.current) return;
            let l = e == null ? void 0 : e.activeElement;
            if (n != null && n.current) {
                if ((n == null ? void 0 : n.current) === l) {
                    s.current = l;
                    return
                }
            } else if (c.contains(l)) {
                s.current = l;
                return
            }
            if (n != null && n.current) no(n.current);
            else {
                if (t & 16) {
                    if (Fu(c, ua.First | ua.AutoFocus) !== t5.Error) return
                } else if (Fu(c, ua.First) !== t5.Error) return;
                if (i != null && i.current && (no(i.current), (e == null ? void 0 : e.activeElement) === i.current)) return;
                console.warn("There are no focusable elements inside the <FocusTrap />")
            }
            s.current = e == null ? void 0 : e.activeElement
        })
    }, [i, a, t]), s
}

function uue(t, {
    ownerDocument: e,
    container: r,
    containers: n,
    previousActiveElement: i
}) {
    let s = vx(),
        a = !!(t & 4);
    Lj(e == null ? void 0 : e.defaultView, "focus", o => {
        if (!a || !s.current) return;
        let c = hR(n);
        os(r.current) && c.add(r.current);
        let l = i.current;
        if (!l) return;
        let u = o.target;
        os(u) ? fR(c, u) ? (i.current = u, no(u)) : (o.preventDefault(), o.stopPropagation(), no(l)) : no(i.current)
    }, !0)
}

function fR(t, e) {
    for (let r of t)
        if (r.contains(e)) return !0;
    return !1
}

function pR(t) {
    var e;
    return !!(t.enter || t.enterFrom || t.enterTo || t.leave || t.leaveFrom || t.leaveTo) || ((e = t.as) != null ? e : mR) !== v.Fragment || at.Children.count(t.children) === 1
}
let yy = v.createContext(null);
yy.displayName = "TransitionContext";
var hue = (t => (t.Visible = "visible", t.Hidden = "hidden", t))(hue || {});

function fue() {
    let t = v.useContext(yy);
    if (t === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
    return t
}

function pue() {
    let t = v.useContext(wy);
    if (t === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
    return t
}
let wy = v.createContext(null);
wy.displayName = "NestingContext";

function by(t) {
    return "children" in t ? by(t.children) : t.current.filter(({
        el: e
    }) => e.current !== null).filter(({
        state: e
    }) => e === "visible").length > 0
}

function gR(t, e) {
    let r = Nd(t),
        n = v.useRef([]),
        i = vx(),
        s = xh(),
        a = xt((p, g = Kc.Hidden) => {
            let m = n.current.findIndex(({
                el: y
            }) => y === p);
            m !== -1 && (Aa(g, {
                [Kc.Unmount]() {
                    n.current.splice(m, 1)
                },
                [Kc.Hidden]() {
                    n.current[m].state = "hidden"
                }
            }), s.microTask(() => {
                var y;
                !by(n) && i.current && ((y = r.current) == null || y.call(r))
            }))
        }),
        o = xt(p => {
            let g = n.current.find(({
                el: m
            }) => m === p);
            return g ? g.state !== "visible" && (g.state = "visible") : n.current.push({
                el: p,
                state: "visible"
            }), () => a(p, Kc.Unmount)
        }),
        c = v.useRef([]),
        l = v.useRef(Promise.resolve()),
        u = v.useRef({
            enter: [],
            leave: []
        }),
        h = xt((p, g, m) => {
            c.current.splice(0), e && (e.chains.current[g] = e.chains.current[g].filter(([y]) => y !== p)), e == null || e.chains.current[g].push([p, new Promise(y => {
                c.current.push(y)
            })]), e == null || e.chains.current[g].push([p, new Promise(y => {
                Promise.all(u.current[g].map(([w, x]) => x)).then(() => y())
            })]), g === "enter" ? l.current = l.current.then(() => e == null ? void 0 : e.wait.current).then(() => m(g)) : m(g)
        }),
        f = xt((p, g, m) => {
            Promise.all(u.current[g].splice(0).map(([y, w]) => w)).then(() => {
                var y;
                (y = c.current.shift()) == null || y()
            }).then(() => m(g))
        });
    return v.useMemo(() => ({
        children: n,
        register: o,
        unregister: a,
        onStart: h,
        onStop: f,
        wait: l,
        chains: u
    }), [o, a, n, h, f, u, l])
}
let mR = v.Fragment,
    yR = rh.RenderStrategy;

function gue(t, e) {
    var r, n;
    let {
        transition: i = !0,
        beforeEnter: s,
        afterEnter: a,
        beforeLeave: o,
        afterLeave: c,
        enter: l,
        enterFrom: u,
        enterTo: h,
        entered: f,
        leave: p,
        leaveFrom: g,
        leaveTo: m,
        ...y
    } = t, [w, x] = v.useState(null), E = v.useRef(null), _ = pR(t), b = yi(..._ ? [E, e, x] : e === null ? [] : [e]), A = (r = y.unmount) == null || r ? Kc.Unmount : Kc.Hidden, {
        show: I,
        appear: T,
        initial: C
    } = fue(), [$, P] = v.useState(I ? "visible" : "hidden"), N = pue(), {
        register: R,
        unregister: D
    } = N;
    lr(() => R(E), [R, E]), lr(() => {
        if (A === Kc.Hidden && E.current) {
            if (I && $ !== "visible") {
                P("visible");
                return
            }
            return Aa($, {
                hidden: () => D(E),
                visible: () => R(E)
            })
        }
    }, [$, E, R, D, I, A]);
    let S = m0();
    lr(() => {
        if (_ && S && $ === "visible" && E.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?")
    }, [E, $, S, _]);
    let O = C && !T,
        M = T && I && C,
        U = v.useRef(!1),
        k = gR(() => {
            U.current || (P("hidden"), D(E))
        }, N),
        F = xt(Y => {
            U.current = !0;
            let X = Y ? "enter" : "leave";
            k.onStart(E, X, ne => {
                ne === "enter" ? s == null || s() : ne === "leave" && (o == null || o())
            })
        }),
        q = xt(Y => {
            let X = Y ? "enter" : "leave";
            U.current = !1, k.onStop(E, X, ne => {
                ne === "enter" ? a == null || a() : ne === "leave" && (c == null || c())
            }), X === "leave" && !by(k) && (P("hidden"), D(E))
        });
    v.useEffect(() => {
        _ && i || (F(I), q(I))
    }, [I, _, i]);
    let W = !(!i || !_ || !S || O),
        [, K] = Bj(W, w, I, {
            start: F,
            end: q
        }),
        H = Il({
            ref: b,
            className: ((n = Q3(y.className, M && l, M && u, K.enter && l, K.enter && K.closed && u, K.enter && !K.closed && h, K.leave && p, K.leave && !K.closed && g, K.leave && K.closed && m, !K.transition && I && f)) == null ? void 0 : n.trim()) || void 0,
            ...Fj(K)
        }),
        j = 0;
    $ === "visible" && (j |= li.Open), $ === "hidden" && (j |= li.Closed), I && $ === "hidden" && (j |= li.Opening), !I && $ === "visible" && (j |= li.Closing);
    let V = tn();
    return at.createElement(wy.Provider, {
        value: k
    }, at.createElement(iR, {
        value: j
    }, V({
        ourProps: H,
        theirProps: y,
        defaultTag: mR,
        features: yR,
        visible: $ === "visible",
        name: "Transition.Child"
    })))
}

function mue(t, e) {
    let {
        show: r,
        appear: n = !1,
        unmount: i = !0,
        ...s
    } = t, a = v.useRef(null), o = pR(t), c = yi(...o ? [a, e] : e === null ? [] : [e]);
    m0();
    let l = g0();
    if (r === void 0 && l !== null && (r = (l & li.Open) === li.Open), r === void 0) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
    let [u, h] = v.useState(r ? "visible" : "hidden"), f = gR(() => {
        r || h("hidden")
    }), [p, g] = v.useState(!0), m = v.useRef([r]);
    lr(() => {
        p !== !1 && m.current[m.current.length - 1] !== r && (m.current.push(r), g(!1))
    }, [m, r]);
    let y = v.useMemo(() => ({
        show: r,
        appear: n,
        initial: p
    }), [r, n, p]);
    lr(() => {
        r ? h("visible") : !by(f) && a.current !== null && h("hidden")
    }, [r, f]);
    let w = {
            unmount: i
        },
        x = xt(() => {
            var b;
            p && g(!1), (b = t.beforeEnter) == null || b.call(t)
        }),
        E = xt(() => {
            var b;
            p && g(!1), (b = t.beforeLeave) == null || b.call(t)
        }),
        _ = tn();
    return at.createElement(wy.Provider, {
        value: f
    }, at.createElement(yy.Provider, {
        value: y
    }, _({
        ourProps: { ...w,
            as: v.Fragment,
            children: at.createElement(wR, {
                ref: c,
                ...w,
                ...s,
                beforeEnter: x,
                beforeLeave: E
            })
        },
        theirProps: {},
        defaultTag: v.Fragment,
        features: yR,
        visible: u === "visible",
        name: "Transition"
    })))
}

function yue(t, e) {
    let r = v.useContext(yy) !== null,
        n = g0() !== null;
    return at.createElement(at.Fragment, null, !r && n ? at.createElement(a5, {
        ref: e,
        ...t
    }) : at.createElement(wR, {
        ref: e,
        ...t
    }))
}
let a5 = Dr(mue),
    wR = Dr(gue),
    Np = Dr(yue),
    bR = Object.assign(a5, {
        Child: Np,
        Root: a5
    });
var wue = (t => (t[t.Open = 0] = "Open", t[t.Closed = 1] = "Closed", t))(wue || {}),
    bue = (t => (t[t.SetTitleId = 0] = "SetTitleId", t))(bue || {});
let vue = {
        0(t, e) {
            return t.titleId === e.id ? t : { ...t,
                titleId: e.id
            }
        }
    },
    xx = v.createContext(null);
xx.displayName = "DialogContext";

function vy(t) {
    let e = v.useContext(xx);
    if (e === null) {
        let r = new Error(`<${t} /> is missing a parent <Dialog /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(r, vy), r
    }
    return e
}

function xue(t, e) {
    return Aa(e.type, vue, t, e)
}
let Q9 = Dr(function(t, e) {
        let r = v.useId(),
            {
                id: n = `headlessui-dialog-${r}`,
                open: i,
                onClose: s,
                initialFocus: a,
                role: o = "dialog",
                autoFocus: c = !0,
                __demoMode: l = !1,
                unmount: u = !1,
                ...h
            } = t,
            f = v.useRef(!1);
        o = function() {
            return o === "dialog" || o === "alertdialog" ? o : (f.current || (f.current = !0, console.warn(`Invalid role [${o}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog")
        }();
        let p = g0();
        i === void 0 && p !== null && (i = (p & li.Open) === li.Open);
        let g = v.useRef(null),
            m = yi(g, e),
            y = nh(g),
            w = i ? 0 : 1,
            [x, E] = v.useReducer(xue, {
                titleId: null,
                descriptionId: null,
                panelRef: v.createRef()
            }),
            _ = xt(() => s(!1)),
            b = xt(K => E({
                type: 0,
                id: K
            })),
            A = m0() ? w === 0 : !1,
            [I, T] = Qde(),
            C = {
                get current() {
                    var K;
                    return (K = x.panelRef.current) != null ? K : g.current
                }
            },
            $ = uR(),
            {
                resolveContainers: P
            } = rue({
                mainTreeNode: $,
                portals: I,
                defaultContainers: [C]
            }),
            N = p !== null ? (p & li.Closing) === li.Closing : !1;
        Tj(l || N ? !1 : A, {
            allowed: xt(() => {
                var K, H;
                return [(H = (K = g.current) == null ? void 0 : K.closest("[data-headlessui-portal]")) != null ? H : null]
            }),
            disallowed: xt(() => {
                var K;
                return [(K = $ == null ? void 0 : $.closest("body > *:not(#headlessui-portal-root)")) != null ? K : null]
            })
        });
        let R = uy.get(null);
        lr(() => {
            if (A) return R.actions.push(n), () => R.actions.pop(n)
        }, [R, n, A]);
        let D = pa(R, v.useCallback(K => R.selectors.isTop(K, n), [R, n]));
        Dj(D, P, K => {
            K.preventDefault(), _()
        }), eue(D, y == null ? void 0 : y.defaultView, K => {
            K.preventDefault(), K.stopPropagation(), document.activeElement && "blur" in document.activeElement && typeof document.activeElement.blur == "function" && document.activeElement.blur(), _()
        }), Uj(l || N ? !1 : A, y, P), Pj(A, g, _);
        let [S, O] = xj(), M = v.useMemo(() => [{
            dialogState: w,
            close: _,
            setTitleId: b,
            unmount: u
        }, x], [w, x, _, b, u]), U = v.useMemo(() => ({
            open: w === 0
        }), [w]), k = {
            ref: m,
            id: n,
            role: o,
            tabIndex: -1,
            "aria-modal": l ? void 0 : w === 0 ? !0 : void 0,
            "aria-labelledby": x.titleId,
            "aria-describedby": S,
            unmount: u
        }, F = !tue(), q = Ol.None;
        A && !l && (q |= Ol.RestoreFocus, q |= Ol.TabLock, c && (q |= Ol.AutoFocus), F && (q |= Ol.InitialFocus));
        let W = tn();
        return at.createElement(Wde, null, at.createElement(Z9, {
            force: !0
        }, at.createElement(lR, null, at.createElement(xx.Provider, {
            value: M
        }, at.createElement(cR, {
            target: g
        }, at.createElement(Z9, {
            force: !1
        }, at.createElement(O, {
            slot: U
        }, at.createElement(T, null, at.createElement(oue, {
            initialFocus: a,
            initialFocusFallback: g,
            containers: P,
            features: q
        }, at.createElement(Pce, {
            value: _
        }, W({
            ourProps: k,
            theirProps: h,
            slot: U,
            defaultTag: Eue,
            features: _ue,
            visible: w === 0,
            name: "Dialog"
        })))))))))))
    }),
    Eue = "div",
    _ue = rh.RenderStrategy | rh.Static;

function Cue(t, e) {
    let {
        transition: r = !1,
        open: n,
        ...i
    } = t, s = g0(), a = t.hasOwnProperty("open") || s !== null, o = t.hasOwnProperty("onClose");
    if (!a && !o) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
    if (!a) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
    if (!o) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
    if (!s && typeof t.open != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${t.open}`);
    if (typeof t.onClose != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${t.onClose}`);
    return (n !== void 0 || r) && !i.static ? at.createElement(J9, null, at.createElement(bR, {
        show: n,
        transition: r,
        unmount: i.unmount
    }, at.createElement(Q9, {
        ref: e,
        ...i
    }))) : at.createElement(J9, null, at.createElement(Q9, {
        ref: e,
        open: n,
        ...i
    }))
}
let Aue = "div";

function kue(t, e) {
    let r = v.useId(),
        {
            id: n = `headlessui-dialog-panel-${r}`,
            transition: i = !1,
            ...s
        } = t,
        [{
            dialogState: a,
            unmount: o
        }, c] = vy("Dialog.Panel"),
        l = yi(e, c.panelRef),
        u = v.useMemo(() => ({
            open: a === 0
        }), [a]),
        h = xt(y => {
            y.stopPropagation()
        }),
        f = {
            ref: l,
            id: n,
            onClick: h
        },
        p = i ? Np : v.Fragment,
        g = i ? {
            unmount: o
        } : {},
        m = tn();
    return at.createElement(p, { ...g
    }, m({
        ourProps: f,
        theirProps: s,
        slot: u,
        defaultTag: Aue,
        name: "Dialog.Panel"
    }))
}
let Iue = "div";

function $ue(t, e) {
    let {
        transition: r = !1,
        ...n
    } = t, [{
        dialogState: i,
        unmount: s
    }] = vy("Dialog.Backdrop"), a = v.useMemo(() => ({
        open: i === 0
    }), [i]), o = {
        ref: e,
        "aria-hidden": !0
    }, c = r ? Np : v.Fragment, l = r ? {
        unmount: s
    } : {}, u = tn();
    return at.createElement(c, { ...l
    }, u({
        ourProps: o,
        theirProps: n,
        slot: a,
        defaultTag: Iue,
        name: "Dialog.Backdrop"
    }))
}
let Sue = "h2";

function Tue(t, e) {
    let r = v.useId(),
        {
            id: n = `headlessui-dialog-title-${r}`,
            ...i
        } = t,
        [{
            dialogState: s,
            setTitleId: a
        }] = vy("Dialog.Title"),
        o = yi(e);
    v.useEffect(() => (a(n), () => a(null)), [n, a]);
    let c = v.useMemo(() => ({
            open: s === 0
        }), [s]),
        l = {
            ref: o,
            id: n
        };
    return tn()({
        ourProps: l,
        theirProps: i,
        slot: c,
        defaultTag: Sue,
        name: "Dialog.Title"
    })
}
let Pue = Dr(Cue),
    vR = Dr(kue);
Dr($ue);
let Nue = Dr(Tue),
    Oue = Object.assign(Pue, {
        Panel: vR,
        Title: Nue,
        Description: Ace
    });

function jue(t, e) {
    let r = v.useRef({
        left: 0,
        top: 0
    });
    if (lr(() => {
            if (!e) return;
            let i = e.getBoundingClientRect();
            i && (r.current = i)
        }, [t, e]), e == null || !t || e === document.activeElement) return !1;
    let n = e.getBoundingClientRect();
    return n.top !== r.current.top || n.left !== r.current.left
}
let X9 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;

function eC(t) {
    var e, r;
    let n = (e = t.innerText) != null ? e : "",
        i = t.cloneNode(!0);
    if (!os(i)) return n;
    let s = !1;
    for (let o of i.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) o.remove(), s = !0;
    let a = s ? (r = i.innerText) != null ? r : "" : n;
    return X9.test(a) && (a = a.replace(X9, "")), a
}

function Rue(t) {
    let e = t.getAttribute("aria-label");
    if (typeof e == "string") return e.trim();
    let r = t.getAttribute("aria-labelledby");
    if (r) {
        let n = r.split(" ").map(i => {
            let s = document.getElementById(i);
            if (s) {
                let a = s.getAttribute("aria-label");
                return typeof a == "string" ? a.trim() : eC(s).trim()
            }
            return null
        }).filter(Boolean);
        if (n.length > 0) return n.join(", ")
    }
    return eC(t).trim()
}

function Mue(t) {
    let e = v.useRef(""),
        r = v.useRef("");
    return xt(() => {
        let n = t.current;
        if (!n) return "";
        let i = n.innerText;
        if (e.current === i) return r.current;
        let s = Rue(n).trim().toLowerCase();
        return e.current = i, r.current = s, s
    })
}
var Due = Object.defineProperty,
    Lue = (t, e, r) => e in t ? Due(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    tC = (t, e, r) => (Lue(t, typeof e != "symbol" ? e + "" : e, r), r),
    In = (t => (t[t.Open = 0] = "Open", t[t.Closed = 1] = "Closed", t))(In || {}),
    Bm = (t => (t[t.Pointer = 0] = "Pointer", t[t.Other = 1] = "Other", t))(Bm || {}),
    cr = (t => (t[t.OpenMenu = 0] = "OpenMenu", t[t.CloseMenu = 1] = "CloseMenu", t[t.GoToItem = 2] = "GoToItem", t[t.Search = 3] = "Search", t[t.ClearSearch = 4] = "ClearSearch", t[t.RegisterItems = 5] = "RegisterItems", t[t.UnregisterItems = 6] = "UnregisterItems", t[t.SetButtonElement = 7] = "SetButtonElement", t[t.SetItemsElement = 8] = "SetItemsElement", t[t.SortItems = 9] = "SortItems", t))(cr || {});

function rC(t, e = r => r) {
    let r = t.activeItemIndex !== null ? t.items[t.activeItemIndex] : null,
        n = jj(e(t.items.slice()), s => s.dataRef.current.domRef.current),
        i = r ? n.indexOf(r) : null;
    return i === -1 && (i = null), {
        items: n,
        activeItemIndex: i
    }
}
let Uue = {
        1(t) {
            return t.menuState === 1 ? t : { ...t,
                activeItemIndex: null,
                pendingFocus: {
                    focus: Br.Nothing
                },
                menuState: 1
            }
        },
        0(t, e) {
            return t.menuState === 0 ? t : { ...t,
                __demoMode: !1,
                pendingFocus: e.focus,
                menuState: 0
            }
        },
        2: (t, e) => {
            var r, n, i, s, a;
            if (t.menuState === 1) return t;
            let o = { ...t,
                searchQuery: "",
                activationTrigger: (r = e.trigger) != null ? r : 1,
                __demoMode: !1
            };
            if (e.focus === Br.Nothing) return { ...o,
                activeItemIndex: null
            };
            if (e.focus === Br.Specific) return { ...o,
                activeItemIndex: t.items.findIndex(u => u.id === e.id)
            };
            if (e.focus === Br.Previous) {
                let u = t.activeItemIndex;
                if (u !== null) {
                    let h = t.items[u].dataRef.current.domRef,
                        f = lg(e, {
                            resolveItems: () => t.items,
                            resolveActiveIndex: () => t.activeItemIndex,
                            resolveId: p => p.id,
                            resolveDisabled: p => p.dataRef.current.disabled
                        });
                    if (f !== null) {
                        let p = t.items[f].dataRef.current.domRef;
                        if (((n = h.current) == null ? void 0 : n.previousElementSibling) === p.current || ((i = p.current) == null ? void 0 : i.previousElementSibling) === null) return { ...o,
                            activeItemIndex: f
                        }
                    }
                }
            } else if (e.focus === Br.Next) {
                let u = t.activeItemIndex;
                if (u !== null) {
                    let h = t.items[u].dataRef.current.domRef,
                        f = lg(e, {
                            resolveItems: () => t.items,
                            resolveActiveIndex: () => t.activeItemIndex,
                            resolveId: p => p.id,
                            resolveDisabled: p => p.dataRef.current.disabled
                        });
                    if (f !== null) {
                        let p = t.items[f].dataRef.current.domRef;
                        if (((s = h.current) == null ? void 0 : s.nextElementSibling) === p.current || ((a = p.current) == null ? void 0 : a.nextElementSibling) === null) return { ...o,
                            activeItemIndex: f
                        }
                    }
                }
            }
            let c = rC(t),
                l = lg(e, {
                    resolveItems: () => c.items,
                    resolveActiveIndex: () => c.activeItemIndex,
                    resolveId: u => u.id,
                    resolveDisabled: u => u.dataRef.current.disabled
                });
            return { ...o,
                ...c,
                activeItemIndex: l
            }
        },
        3: (t, e) => {
            let r = t.searchQuery !== "" ? 0 : 1,
                n = t.searchQuery + e.value.toLowerCase(),
                i = (t.activeItemIndex !== null ? t.items.slice(t.activeItemIndex + r).concat(t.items.slice(0, t.activeItemIndex + r)) : t.items).find(a => {
                    var o;
                    return ((o = a.dataRef.current.textValue) == null ? void 0 : o.startsWith(n)) && !a.dataRef.current.disabled
                }),
                s = i ? t.items.indexOf(i) : -1;
            return s === -1 || s === t.activeItemIndex ? { ...t,
                searchQuery: n
            } : { ...t,
                searchQuery: n,
                activeItemIndex: s,
                activationTrigger: 1
            }
        },
        4(t) {
            return t.searchQuery === "" ? t : { ...t,
                searchQuery: "",
                searchActiveItemIndex: null
            }
        },
        5: (t, e) => {
            let r = t.items.concat(e.items.map(i => i)),
                n = t.activeItemIndex;
            return t.pendingFocus.focus !== Br.Nothing && (n = lg(t.pendingFocus, {
                resolveItems: () => r,
                resolveActiveIndex: () => t.activeItemIndex,
                resolveId: i => i.id,
                resolveDisabled: i => i.dataRef.current.disabled
            })), { ...t,
                items: r,
                activeItemIndex: n,
                pendingFocus: {
                    focus: Br.Nothing
                },
                pendingShouldSort: !0
            }
        },
        6: (t, e) => {
            let r = t.items,
                n = [],
                i = new Set(e.items);
            for (let [s, a] of r.entries())
                if (i.has(a.id) && (n.push(s), i.delete(a.id), i.size === 0)) break;
            if (n.length > 0) {
                r = r.slice();
                for (let s of n.reverse()) r.splice(s, 1)
            }
            return { ...t,
                items: r,
                activationTrigger: 1
            }
        },
        7: (t, e) => t.buttonElement === e.element ? t : { ...t,
            buttonElement: e.element
        },
        8: (t, e) => t.itemsElement === e.element ? t : { ...t,
            itemsElement: e.element
        },
        9: t => t.pendingShouldSort ? { ...t,
            ...rC(t),
            pendingShouldSort: !1
        } : t
    },
    Fue = class xR extends kj {
        constructor(e) {
            super(e), tC(this, "actions", {
                registerItem: $9(() => {
                    let r = [],
                        n = new Set;
                    return [(i, s) => {
                        n.has(s) || (n.add(s), r.push({
                            id: i,
                            dataRef: s
                        }))
                    }, () => (n.clear(), this.send({
                        type: 5,
                        items: r.splice(0)
                    }))]
                }),
                unregisterItem: $9(() => {
                    let r = [];
                    return [n => r.push(n), () => this.send({
                        type: 6,
                        items: r.splice(0)
                    })]
                })
            }), tC(this, "selectors", {
                activeDescendantId(r) {
                    var n;
                    let i = r.activeItemIndex,
                        s = r.items;
                    return i === null || (n = s[i]) == null ? void 0 : n.id
                },
                isActive(r, n) {
                    var i;
                    let s = r.activeItemIndex,
                        a = r.items;
                    return s !== null ? ((i = a[s]) == null ? void 0 : i.id) === n : !1
                },
                shouldScrollIntoView(r, n) {
                    return r.__demoMode || r.menuState !== 0 || r.activationTrigger === 0 ? !1 : this.isActive(r, n)
                }
            }), this.on(5, () => {
                this.disposables.requestAnimationFrame(() => {
                    this.send({
                        type: 9
                    })
                })
            }); {
                let r = this.state.id,
                    n = uy.get(null);
                this.disposables.add(n.on($j.Push, i => {
                    !n.selectors.isTop(i, r) && this.state.menuState === 0 && this.send({
                        type: 1
                    })
                })), this.on(0, () => n.actions.push(r)), this.on(1, () => n.actions.pop(r))
            }
        }
        static new({
            id: e,
            __demoMode: r = !1
        }) {
            return new xR({
                id: e,
                __demoMode: r,
                menuState: r ? 0 : 1,
                buttonElement: null,
                itemsElement: null,
                items: [],
                searchQuery: "",
                activeItemIndex: null,
                activationTrigger: 1,
                pendingShouldSort: !1,
                pendingFocus: {
                    focus: Br.Nothing
                }
            })
        }
        reduce(e, r) {
            return Aa(r.type, Uue, e, r)
        }
    };
const ER = v.createContext(null);

function Ex(t) {
    let e = v.useContext(ER);
    if (e === null) {
        let r = new Error(`<${t} /> is missing a parent <Menu /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(r, _R), r
    }
    return e
}

function _R({
    id: t,
    __demoMode: e = !1
}) {
    let r = v.useMemo(() => Fue.new({
        id: t,
        __demoMode: e
    }), []);
    return bx(() => r.dispose()), r
}
let Bue = v.Fragment;

function Wue(t, e) {
    let r = v.useId(),
        {
            __demoMode: n = !1,
            ...i
        } = t,
        s = _R({
            id: r,
            __demoMode: n
        }),
        [a, o, c] = pa(s, y => [y.menuState, y.itemsElement, y.buttonElement]),
        l = yi(e),
        u = uy.get(null),
        h = pa(u, v.useCallback(y => u.selectors.isTop(y, r), [u, r]));
    Dj(h, [c, o], (y, w) => {
        var x;
        s.send({
            type: cr.CloseMenu
        }), hx(w, ux.Loose) || (y.preventDefault(), (x = s.state.buttonElement) == null || x.focus())
    });
    let f = xt(() => {
            s.send({
                type: cr.CloseMenu
            })
        }),
        p = v.useMemo(() => ({
            open: a === In.Open,
            close: f
        }), [a, f]),
        g = {
            ref: l
        },
        m = tn();
    return at.createElement(Ude, null, at.createElement(ER.Provider, {
        value: s
    }, at.createElement(iR, {
        value: Aa(a, {
            [In.Open]: li.Open,
            [In.Closed]: li.Closed
        })
    }, m({
        ourProps: g,
        theirProps: i,
        slot: p,
        defaultTag: Bue,
        name: "Menu"
    }))))
}
let zue = "button";

function que(t, e) {
    let r = Ex("Menu.Button"),
        n = v.useId(),
        {
            id: i = `headlessui-menu-button-${n}`,
            disabled: s = !1,
            autoFocus: a = !1,
            ...o
        } = t,
        c = v.useRef(null),
        l = Mde(),
        u = yi(e, c, Rde(), xt($ => r.send({
            type: cr.SetButtonElement,
            element: $
        }))),
        h = xt($ => {
            switch ($.key) {
                case pn.Space:
                case pn.Enter:
                case pn.ArrowDown:
                    $.preventDefault(), $.stopPropagation(), r.send({
                        type: cr.OpenMenu,
                        focus: {
                            focus: Br.First
                        }
                    });
                    break;
                case pn.ArrowUp:
                    $.preventDefault(), $.stopPropagation(), r.send({
                        type: cr.OpenMenu,
                        focus: {
                            focus: Br.Last
                        }
                    });
                    break
            }
        }),
        f = xt($ => {
            switch ($.key) {
                case pn.Space:
                    $.preventDefault();
                    break
            }
        }),
        [p, g, m] = pa(r, $ => [$.menuState, $.buttonElement, $.itemsElement]),
        y = p === In.Open;
    dle(y, {
        trigger: g,
        action: v.useCallback($ => {
            if (g != null && g.contains($.target)) return og.Ignore;
            let P = $.target.closest('[role="menuitem"]:not([data-disabled])');
            return os(P) ? og.Select(P) : m != null && m.contains($.target) ? og.Ignore : og.Close
        }, [g, m]),
        close: v.useCallback(() => r.send({
            type: cr.CloseMenu
        }), []),
        select: v.useCallback($ => $.click(), [])
    });
    let w = xt($ => {
            var P;
            if ($.button === 0) {
                if (bce($.currentTarget)) return $.preventDefault();
                s || (p === In.Open ? (Zo.flushSync(() => r.send({
                    type: cr.CloseMenu
                })), (P = c.current) == null || P.focus({
                    preventScroll: !0
                })) : ($.preventDefault(), r.send({
                    type: cr.OpenMenu,
                    focus: {
                        focus: Br.Nothing
                    },
                    trigger: Bm.Pointer
                })))
            }
        }),
        {
            isFocusVisible: x,
            focusProps: E
        } = Xoe({
            autoFocus: a
        }),
        {
            isHovered: _,
            hoverProps: b
        } = Qoe({
            isDisabled: s
        }),
        {
            pressed: A,
            pressProps: I
        } = sce({
            disabled: s
        }),
        T = v.useMemo(() => ({
            open: p === In.Open,
            active: A || p === In.Open,
            disabled: s,
            hover: _,
            focus: x,
            autofocus: a
        }), [p, _, x, A, s, a]),
        C = mj(l(), {
            ref: u,
            id: i,
            type: ule(t, c.current),
            "aria-haspopup": "menu",
            "aria-controls": m == null ? void 0 : m.id,
            "aria-expanded": p === In.Open,
            disabled: s || void 0,
            autoFocus: a,
            onKeyDown: h,
            onKeyUp: f,
            onPointerDown: w
        }, E, b, I);
    return tn()({
        ourProps: C,
        theirProps: o,
        slot: T,
        defaultTag: zue,
        name: "Menu.Button"
    })
}
let Hue = "div",
    Vue = rh.RenderStrategy | rh.Static;

function Gue(t, e) {
    let r = v.useId(),
        {
            id: n = `headlessui-menu-items-${r}`,
            anchor: i,
            portal: s = !1,
            modal: a = !0,
            transition: o = !1,
            ...c
        } = t,
        l = jde(i),
        u = Ex("Menu.Items"),
        [h, f] = Lde(l),
        p = Dde(),
        [g, m] = v.useState(null),
        y = yi(e, l ? h : null, xt(k => u.send({
            type: cr.SetItemsElement,
            element: k
        })), m),
        [w, x] = pa(u, k => [k.menuState, k.buttonElement]),
        E = nh(x),
        _ = nh(g);
    l && (s = !0);
    let b = g0(),
        [A, I] = Bj(o, g, b !== null ? (b & li.Open) === li.Open : w === In.Open);
    Pj(A, x, () => {
        u.send({
            type: cr.CloseMenu
        })
    });
    let T = pa(u, k => k.__demoMode),
        C = T ? !1 : a && w === In.Open;
    Uj(C, _);
    let $ = T ? !1 : a && w === In.Open;
    Tj($, {
        allowed: v.useCallback(() => [x, g], [x, g])
    });
    let P = w !== In.Open,
        N = jue(P, x) ? !1 : A;
    v.useEffect(() => {
        let k = g;
        k && w === In.Open && k !== (_ == null ? void 0 : _.activeElement) && k.focus({
            preventScroll: !0
        })
    }, [w, g, _]), kle(w === In.Open, {
        container: g,
        accept(k) {
            return k.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : k.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT
        },
        walk(k) {
            k.setAttribute("role", "none")
        }
    });
    let R = xh(),
        D = xt(k => {
            var F, q, W;
            switch (R.dispose(), k.key) {
                case pn.Space:
                    if (u.state.searchQuery !== "") return k.preventDefault(), k.stopPropagation(), u.send({
                        type: cr.Search,
                        value: k.key
                    });
                case pn.Enter:
                    if (k.preventDefault(), k.stopPropagation(), u.state.activeItemIndex !== null) {
                        let {
                            dataRef: K
                        } = u.state.items[u.state.activeItemIndex];
                        (q = (F = K.current) == null ? void 0 : F.domRef.current) == null || q.click()
                    }
                    u.send({
                        type: cr.CloseMenu
                    }), Oj(u.state.buttonElement);
                    break;
                case pn.ArrowDown:
                    return k.preventDefault(), k.stopPropagation(), u.send({
                        type: cr.GoToItem,
                        focus: Br.Next
                    });
                case pn.ArrowUp:
                    return k.preventDefault(), k.stopPropagation(), u.send({
                        type: cr.GoToItem,
                        focus: Br.Previous
                    });
                case pn.Home:
                case pn.PageUp:
                    return k.preventDefault(), k.stopPropagation(), u.send({
                        type: cr.GoToItem,
                        focus: Br.First
                    });
                case pn.End:
                case pn.PageDown:
                    return k.preventDefault(), k.stopPropagation(), u.send({
                        type: cr.GoToItem,
                        focus: Br.Last
                    });
                case pn.Escape:
                    k.preventDefault(), k.stopPropagation(), Zo.flushSync(() => u.send({
                        type: cr.CloseMenu
                    })), (W = u.state.buttonElement) == null || W.focus({
                        preventScroll: !0
                    });
                    break;
                case pn.Tab:
                    k.preventDefault(), k.stopPropagation(), Zo.flushSync(() => u.send({
                        type: cr.CloseMenu
                    })), ale(u.state.buttonElement, k.shiftKey ? ua.Previous : ua.Next);
                    break;
                default:
                    k.key.length === 1 && (u.send({
                        type: cr.Search,
                        value: k.key
                    }), R.setTimeout(() => u.send({
                        type: cr.ClearSearch
                    }), 350));
                    break
            }
        }),
        S = xt(k => {
            switch (k.key) {
                case pn.Space:
                    k.preventDefault();
                    break
            }
        }),
        O = v.useMemo(() => ({
            open: w === In.Open
        }), [w]),
        M = mj(l ? p() : {}, {
            "aria-activedescendant": pa(u, u.selectors.activeDescendantId),
            "aria-labelledby": pa(u, k => {
                var F;
                return (F = k.buttonElement) == null ? void 0 : F.id
            }),
            id: n,
            onKeyDown: D,
            onKeyUp: S,
            role: "menu",
            tabIndex: w === In.Open ? 0 : void 0,
            ref: y,
            style: { ...c.style,
                ...f,
                "--button-width": Hce(x, !0).width
            },
            ...Fj(I)
        }),
        U = tn();
    return at.createElement(lR, {
        enabled: s ? t.static || A : !1,
        ownerDocument: E
    }, U({
        ourProps: M,
        theirProps: c,
        slot: O,
        defaultTag: Hue,
        features: Vue,
        visible: N,
        name: "Menu.Items"
    }))
}
let Kue = v.Fragment;

function Yue(t, e) {
    let r = v.useId(),
        {
            id: n = `headlessui-menu-item-${r}`,
            disabled: i = !1,
            ...s
        } = t,
        a = Ex("Menu.Item"),
        o = pa(a, P => a.selectors.isActive(P, n)),
        c = v.useRef(null),
        l = yi(e, c),
        u = pa(a, P => a.selectors.shouldScrollIntoView(P, n));
    lr(() => {
        if (u) return qs().requestAnimationFrame(() => {
            var P, N;
            (N = (P = c.current) == null ? void 0 : P.scrollIntoView) == null || N.call(P, {
                block: "nearest"
            })
        })
    }, [u, c]);
    let h = Mue(c),
        f = v.useRef({
            disabled: i,
            domRef: c,
            get textValue() {
                return h()
            }
        });
    lr(() => {
        f.current.disabled = i
    }, [f, i]), lr(() => (a.actions.registerItem(n, f), () => a.actions.unregisterItem(n)), [f, n]);
    let p = xt(() => {
            a.send({
                type: cr.CloseMenu
            })
        }),
        g = xt(P => {
            if (i) return P.preventDefault();
            a.send({
                type: cr.CloseMenu
            }), Oj(a.state.buttonElement)
        }),
        m = xt(() => {
            if (i) return a.send({
                type: cr.GoToItem,
                focus: Br.Nothing
            });
            a.send({
                type: cr.GoToItem,
                focus: Br.Specific,
                id: n
            })
        }),
        y = ble(),
        w = xt(P => {
            y.update(P), !i && (o || a.send({
                type: cr.GoToItem,
                focus: Br.Specific,
                id: n,
                trigger: Bm.Pointer
            }))
        }),
        x = xt(P => {
            y.wasMoved(P) && (i || o || a.send({
                type: cr.GoToItem,
                focus: Br.Specific,
                id: n,
                trigger: Bm.Pointer
            }))
        }),
        E = xt(P => {
            y.wasMoved(P) && (i || o && a.send({
                type: cr.GoToItem,
                focus: Br.Nothing
            }))
        }),
        [_, b] = Ej(),
        [A, I] = xj(),
        T = v.useMemo(() => ({
            active: o,
            focus: o,
            disabled: i,
            close: p
        }), [o, i, p]),
        C = {
            id: n,
            ref: l,
            role: "menuitem",
            tabIndex: i === !0 ? void 0 : -1,
            "aria-disabled": i === !0 ? !0 : void 0,
            "aria-labelledby": _,
            "aria-describedby": A,
            disabled: void 0,
            onClick: g,
            onFocus: m,
            onPointerEnter: w,
            onMouseEnter: w,
            onPointerMove: x,
            onMouseMove: x,
            onPointerLeave: E,
            onMouseLeave: E
        },
        $ = tn();
    return at.createElement(b, null, at.createElement(I, null, $({
        ourProps: C,
        theirProps: s,
        slot: T,
        defaultTag: Kue,
        name: "Menu.Item"
    })))
}
let Zue = "div";

function Jue(t, e) {
    let [r, n] = Ej(), i = t, s = {
        ref: e,
        "aria-labelledby": r,
        role: "group"
    }, a = tn();
    return at.createElement(n, null, a({
        ourProps: s,
        theirProps: i,
        slot: {},
        defaultTag: Zue,
        name: "Menu.Section"
    }))
}
let Que = "header";

function Xue(t, e) {
    let r = v.useId(),
        {
            id: n = `headlessui-menu-heading-${r}`,
            ...i
        } = t,
        s = dx();
    lr(() => s.register(n), [n, s.register]);
    let a = {
        id: n,
        ref: e,
        role: "presentation",
        ...s.props
    };
    return tn()({
        ourProps: a,
        theirProps: i,
        slot: {},
        defaultTag: Que,
        name: "Menu.Heading"
    })
}
let ehe = "div";

function the(t, e) {
    let r = t,
        n = {
            ref: e,
            role: "separator"
        };
    return tn()({
        ourProps: n,
        theirProps: r,
        slot: {},
        defaultTag: ehe,
        name: "Menu.Separator"
    })
}
let rhe = Dr(Wue),
    CR = Dr(que),
    AR = Dr(Gue),
    kR = Dr(Yue),
    nhe = Dr(Jue),
    ihe = Dr(Xue),
    she = Dr(the),
    ahe = Object.assign(rhe, {
        Button: CR,
        Items: AR,
        Item: kR,
        Section: nhe,
        Heading: ihe,
        Separator: she
    });

function ohe({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "m4.5 12.75 6 6 9-13.5"
    }))
}
const che = v.forwardRef(ohe);

function lhe({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M16.5 8.25V6a2.25 2.25 0 0 0-2.25-2.25H6A2.25 2.25 0 0 0 3.75 6v8.25A2.25 2.25 0 0 0 6 16.5h2.25m8.25-8.25H18a2.25 2.25 0 0 1 2.25 2.25V18A2.25 2.25 0 0 1 18 20.25h-7.5A2.25 2.25 0 0 1 8.25 18v-1.5m8.25-8.25h-6a2.25 2.25 0 0 0-2.25 2.25v6"
    }))
}
const IR = v.forwardRef(lhe);
var dg = {
        exports: {}
    },
    nC;

function dhe() {
    if (nC) return dg.exports;
    nC = 1;
    var t = typeof Reflect == "object" ? Reflect : null,
        e = t && typeof t.apply == "function" ? t.apply : function(b, A, I) {
            return Function.prototype.apply.call(b, A, I)
        },
        r;
    t && typeof t.ownKeys == "function" ? r = t.ownKeys : Object.getOwnPropertySymbols ? r = function(b) {
        return Object.getOwnPropertyNames(b).concat(Object.getOwnPropertySymbols(b))
    } : r = function(b) {
        return Object.getOwnPropertyNames(b)
    };

    function n(_) {
        console && console.warn && console.warn(_)
    }
    var i = Number.isNaN || function(b) {
        return b !== b
    };

    function s() {
        s.init.call(this)
    }
    dg.exports = s, dg.exports.once = w, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
    var a = 10;

    function o(_) {
        if (typeof _ != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof _)
    }
    Object.defineProperty(s, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return a
        },
        set: function(_) {
            if (typeof _ != "number" || _ < 0 || i(_)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + _ + ".");
            a = _
        }
    }), s.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
    }, s.prototype.setMaxListeners = function(b) {
        if (typeof b != "number" || b < 0 || i(b)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + b + ".");
        return this._maxListeners = b, this
    };

    function c(_) {
        return _._maxListeners === void 0 ? s.defaultMaxListeners : _._maxListeners
    }
    s.prototype.getMaxListeners = function() {
        return c(this)
    }, s.prototype.emit = function(b) {
        for (var A = [], I = 1; I < arguments.length; I++) A.push(arguments[I]);
        var T = b === "error",
            C = this._events;
        if (C !== void 0) T = T && C.error === void 0;
        else if (!T) return !1;
        if (T) {
            var $;
            if (A.length > 0 && ($ = A[0]), $ instanceof Error) throw $;
            var P = new Error("Unhandled error." + ($ ? " (" + $.message + ")" : ""));
            throw P.context = $, P
        }
        var N = C[b];
        if (N === void 0) return !1;
        if (typeof N == "function") e(N, this, A);
        else
            for (var R = N.length, D = g(N, R), I = 0; I < R; ++I) e(D[I], this, A);
        return !0
    };

    function l(_, b, A, I) {
        var T, C, $;
        if (o(A), C = _._events, C === void 0 ? (C = _._events = Object.create(null), _._eventsCount = 0) : (C.newListener !== void 0 && (_.emit("newListener", b, A.listener ? A.listener : A), C = _._events), $ = C[b]), $ === void 0) $ = C[b] = A, ++_._eventsCount;
        else if (typeof $ == "function" ? $ = C[b] = I ? [A, $] : [$, A] : I ? $.unshift(A) : $.push(A), T = c(_), T > 0 && $.length > T && !$.warned) {
            $.warned = !0;
            var P = new Error("Possible EventEmitter memory leak detected. " + $.length + " " + String(b) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            P.name = "MaxListenersExceededWarning", P.emitter = _, P.type = b, P.count = $.length, n(P)
        }
        return _
    }
    s.prototype.addListener = function(b, A) {
        return l(this, b, A, !1)
    }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(b, A) {
        return l(this, b, A, !0)
    };

    function u() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }

    function h(_, b, A) {
        var I = {
                fired: !1,
                wrapFn: void 0,
                target: _,
                type: b,
                listener: A
            },
            T = u.bind(I);
        return T.listener = A, I.wrapFn = T, T
    }
    s.prototype.once = function(b, A) {
        return o(A), this.on(b, h(this, b, A)), this
    }, s.prototype.prependOnceListener = function(b, A) {
        return o(A), this.prependListener(b, h(this, b, A)), this
    }, s.prototype.removeListener = function(b, A) {
        var I, T, C, $, P;
        if (o(A), T = this._events, T === void 0) return this;
        if (I = T[b], I === void 0) return this;
        if (I === A || I.listener === A) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete T[b], T.removeListener && this.emit("removeListener", b, I.listener || A));
        else if (typeof I != "function") {
            for (C = -1, $ = I.length - 1; $ >= 0; $--)
                if (I[$] === A || I[$].listener === A) {
                    P = I[$].listener, C = $;
                    break
                }
            if (C < 0) return this;
            C === 0 ? I.shift() : m(I, C), I.length === 1 && (T[b] = I[0]), T.removeListener !== void 0 && this.emit("removeListener", b, P || A)
        }
        return this
    }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(b) {
        var A, I, T;
        if (I = this._events, I === void 0) return this;
        if (I.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : I[b] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete I[b]), this;
        if (arguments.length === 0) {
            var C = Object.keys(I),
                $;
            for (T = 0; T < C.length; ++T) $ = C[T], $ !== "removeListener" && this.removeAllListeners($);
            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
        }
        if (A = I[b], typeof A == "function") this.removeListener(b, A);
        else if (A !== void 0)
            for (T = A.length - 1; T >= 0; T--) this.removeListener(b, A[T]);
        return this
    };

    function f(_, b, A) {
        var I = _._events;
        if (I === void 0) return [];
        var T = I[b];
        return T === void 0 ? [] : typeof T == "function" ? A ? [T.listener || T] : [T] : A ? y(T) : g(T, T.length)
    }
    s.prototype.listeners = function(b) {
        return f(this, b, !0)
    }, s.prototype.rawListeners = function(b) {
        return f(this, b, !1)
    }, s.listenerCount = function(_, b) {
        return typeof _.listenerCount == "function" ? _.listenerCount(b) : p.call(_, b)
    }, s.prototype.listenerCount = p;

    function p(_) {
        var b = this._events;
        if (b !== void 0) {
            var A = b[_];
            if (typeof A == "function") return 1;
            if (A !== void 0) return A.length
        }
        return 0
    }
    s.prototype.eventNames = function() {
        return this._eventsCount > 0 ? r(this._events) : []
    };

    function g(_, b) {
        for (var A = new Array(b), I = 0; I < b; ++I) A[I] = _[I];
        return A
    }

    function m(_, b) {
        for (; b + 1 < _.length; b++) _[b] = _[b + 1];
        _.pop()
    }

    function y(_) {
        for (var b = new Array(_.length), A = 0; A < b.length; ++A) b[A] = _[A].listener || _[A];
        return b
    }

    function w(_, b) {
        return new Promise(function(A, I) {
            function T($) {
                _.removeListener(b, C), I($)
            }

            function C() {
                typeof _.removeListener == "function" && _.removeListener("error", T), A([].slice.call(arguments))
            }
            E(_, b, C, {
                once: !0
            }), b !== "error" && x(_, T, {
                once: !0
            })
        })
    }

    function x(_, b, A) {
        typeof _.on == "function" && E(_, "error", b, A)
    }

    function E(_, b, A, I) {
        if (typeof _.on == "function") I.once ? _.once(b, A) : _.on(b, A);
        else if (typeof _.addEventListener == "function") _.addEventListener(b, function T(C) {
            I.once && _.removeEventListener(b, T), A(C)
        });
        else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof _)
    }
    return dg.exports
}
var gs = dhe();
const _x = Oa(gs);
var iC = function(t, e, r) {
        if (r || arguments.length === 2)
            for (var n = 0, i = e.length, s; n < i; n++)(s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
        return t.concat(s || Array.prototype.slice.call(e))
    },
    uhe = function() {
        function t(e, r, n) {
            this.name = e, this.version = r, this.os = n, this.type = "browser"
        }
        return t
    }(),
    hhe = function() {
        function t(e) {
            this.version = e, this.type = "node", this.name = "node", this.os = jn.platform
        }
        return t
    }(),
    fhe = function() {
        function t(e, r, n, i) {
            this.name = e, this.version = r, this.os = n, this.bot = i, this.type = "bot-device"
        }
        return t
    }(),
    phe = function() {
        function t() {
            this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null
        }
        return t
    }(),
    ghe = function() {
        function t() {
            this.type = "react-native", this.name = "react-native", this.version = null, this.os = null
        }
        return t
    }(),
    mhe = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
    yhe = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
    sC = 3,
    whe = [
        ["aol", /AOLShield\/([0-9\._]+)/],
        ["edge", /Edge\/([0-9\._]+)/],
        ["edge-ios", /EdgiOS\/([0-9\._]+)/],
        ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
        ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
        ["samsung", /SamsungBrowser\/([0-9\.]+)/],
        ["silk", /\bSilk\/([0-9._-]+)\b/],
        ["miui", /MiuiBrowser\/([0-9\.]+)$/],
        ["beaker", /BeakerBrowser\/([0-9\.]+)/],
        ["edge-chromium", /EdgA?\/([0-9\.]+)/],
        ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
        ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
        ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
        ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
        ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
        ["fxios", /FxiOS\/([0-9\.]+)/],
        ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
        ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
        ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
        ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
        ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
        ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
        ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
        ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
        ["ie", /MSIE\s(7\.0)/],
        ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
        ["android", /Android\s([0-9\.]+)/],
        ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
        ["safari", /Version\/([0-9\._]+).*Safari/],
        ["facebook", /FB[AS]V\/([0-9\.]+)/],
        ["instagram", /Instagram\s([0-9\.]+)/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
        ["curl", /^curl\/([0-9\.]+)$/],
        ["searchbot", mhe]
    ],
    aC = [
        ["iOS", /iP(hone|od|ad)/],
        ["Android OS", /Android/],
        ["BlackBerry OS", /BlackBerry|BB10/],
        ["Windows Mobile", /IEMobile/],
        ["Amazon OS", /Kindle/],
        ["Windows 3.11", /Win16/],
        ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
        ["Windows 98", /(Windows 98)|(Win98)/],
        ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
        ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
        ["Windows Server 2003", /(Windows NT 5.2)/],
        ["Windows Vista", /(Windows NT 6.0)/],
        ["Windows 7", /(Windows NT 6.1)/],
        ["Windows 8", /(Windows NT 6.2)/],
        ["Windows 8.1", /(Windows NT 6.3)/],
        ["Windows 10", /(Windows NT 10.0)/],
        ["Windows ME", /Windows ME/],
        ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
        ["Open BSD", /OpenBSD/],
        ["Sun OS", /SunOS/],
        ["Chrome OS", /CrOS/],
        ["Linux", /(Linux)|(X11)/],
        ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
        ["QNX", /QNX/],
        ["BeOS", /BeOS/],
        ["OS/2", /OS\/2/]
    ];

function bhe(t) {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new ghe : typeof navigator < "u" ? xhe(navigator.userAgent) : _he()
}

function vhe(t) {
    return t !== "" && whe.reduce(function(e, r) {
        var n = r[0],
            i = r[1];
        if (e) return e;
        var s = i.exec(t);
        return !!s && [n, s]
    }, !1)
}

function xhe(t) {
    var e = vhe(t);
    if (!e) return null;
    var r = e[0],
        n = e[1];
    if (r === "searchbot") return new phe;
    var i = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
    i ? i.length < sC && (i = iC(iC([], i, !0), Che(sC - i.length), !0)) : i = [];
    var s = i.join("."),
        a = Ehe(t),
        o = yhe.exec(t);
    return o && o[1] ? new fhe(r, s, a, o[1]) : new uhe(r, s, a)
}

function Ehe(t) {
    for (var e = 0, r = aC.length; e < r; e++) {
        var n = aC[e],
            i = n[0],
            s = n[1],
            a = s.exec(t);
        if (a) return i
    }
    return null
}

function _he() {
    var t = typeof jn < "u" && jn.version;
    return t ? new hhe(jn.version.slice(1)) : null
}

function Che(t) {
    for (var e = [], r = 0; r < t; r++) e.push("0");
    return e
}
var U2 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var o5 = function(t, e) {
    return o5 = Object.setPrototypeOf || {
        __proto__: []
    }
    instanceof Array && function(r, n) {
        r.__proto__ = n
    } || function(r, n) {
        for (var i in n) n.hasOwnProperty(i) && (r[i] = n[i])
    }, o5(t, e)
};

function Ahe(t, e) {
    o5(t, e);

    function r() {
        this.constructor = t
    }
    t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r)
}
var c5 = function() {
    return c5 = Object.assign || function(e) {
        for (var r, n = 1, i = arguments.length; n < i; n++) {
            r = arguments[n];
            for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s])
        }
        return e
    }, c5.apply(this, arguments)
};

function khe(t, e) {
    var r = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++) e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
    return r
}

function Ihe(t, e, r, n) {
    var i = arguments.length,
        s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n,
        a;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, r, n);
    else
        for (var o = t.length - 1; o >= 0; o--)(a = t[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, r, s) : a(e, r)) || s);
    return i > 3 && s && Object.defineProperty(e, r, s), s
}

function $he(t, e) {
    return function(r, n) {
        e(r, n, t)
    }
}

function She(t, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e)
}

function The(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(a) {
            a(s)
        })
    }
    return new(r || (r = Promise))(function(s, a) {
        function o(u) {
            try {
                l(n.next(u))
            } catch (h) {
                a(h)
            }
        }

        function c(u) {
            try {
                l(n.throw(u))
            } catch (h) {
                a(h)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(o, c)
        }
        l((n = n.apply(t, e || [])).next())
    })
}

function Phe(t, e) {
    var r = {
            label: 0,
            sent: function() {
                if (s[0] & 1) throw s[1];
                return s[1]
            },
            trys: [],
            ops: []
        },
        n, i, s, a;
    return a = {
        next: o(0),
        throw: o(1),
        return: o(2)
    }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
        return this
    }), a;

    function o(l) {
        return function(u) {
            return c([l, u])
        }
    }

    function c(l) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; r;) try {
            if (n = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done) return s;
            switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
                case 0:
                case 1:
                    s = l;
                    break;
                case 4:
                    return r.label++, {
                        value: l[1],
                        done: !1
                    };
                case 5:
                    r.label++, i = l[1], l = [0];
                    continue;
                case 7:
                    l = r.ops.pop(), r.trys.pop();
                    continue;
                default:
                    if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
                        r = 0;
                        continue
                    }
                    if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
                        r.label = l[1];
                        break
                    }
                    if (l[0] === 6 && r.label < s[1]) {
                        r.label = s[1], s = l;
                        break
                    }
                    if (s && r.label < s[2]) {
                        r.label = s[2], r.ops.push(l);
                        break
                    }
                    s[2] && r.ops.pop(), r.trys.pop();
                    continue
            }
            l = e.call(t, r)
        } catch (u) {
            l = [6, u], i = 0
        } finally {
            n = s = 0
        }
        if (l[0] & 5) throw l[1];
        return {
            value: l[0] ? l[1] : void 0,
            done: !0
        }
    }
}

function Nhe(t, e, r, n) {
    n === void 0 && (n = r), t[n] = e[r]
}

function Ohe(t, e) {
    for (var r in t) r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r])
}

function l5(t) {
    var e = typeof Symbol == "function" && Symbol.iterator,
        r = e && t[e],
        n = 0;
    if (r) return r.call(t);
    if (t && typeof t.length == "number") return {
        next: function() {
            return t && n >= t.length && (t = void 0), {
                value: t && t[n++],
                done: !t
            }
        }
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}

function $R(t, e) {
    var r = typeof Symbol == "function" && t[Symbol.iterator];
    if (!r) return t;
    var n = r.call(t),
        i, s = [],
        a;
    try {
        for (;
            (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
    } catch (o) {
        a = {
            error: o
        }
    } finally {
        try {
            i && !i.done && (r = n.return) && r.call(n)
        } finally {
            if (a) throw a.error
        }
    }
    return s
}

function jhe() {
    for (var t = [], e = 0; e < arguments.length; e++) t = t.concat($R(arguments[e]));
    return t
}

function Rhe() {
    for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length;
    for (var n = Array(t), i = 0, e = 0; e < r; e++)
        for (var s = arguments[e], a = 0, o = s.length; a < o; a++, i++) n[i] = s[a];
    return n
}

function Op(t) {
    return this instanceof Op ? (this.v = t, this) : new Op(t)
}

function Mhe(t, e, r) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var n = r.apply(t, e || []),
        i, s = [];
    return i = {}, a("next"), a("throw"), a("return"), i[Symbol.asyncIterator] = function() {
        return this
    }, i;

    function a(f) {
        n[f] && (i[f] = function(p) {
            return new Promise(function(g, m) {
                s.push([f, p, g, m]) > 1 || o(f, p)
            })
        })
    }

    function o(f, p) {
        try {
            c(n[f](p))
        } catch (g) {
            h(s[0][3], g)
        }
    }

    function c(f) {
        f.value instanceof Op ? Promise.resolve(f.value.v).then(l, u) : h(s[0][2], f)
    }

    function l(f) {
        o("next", f)
    }

    function u(f) {
        o("throw", f)
    }

    function h(f, p) {
        f(p), s.shift(), s.length && o(s[0][0], s[0][1])
    }
}

function Dhe(t) {
    var e, r;
    return e = {}, n("next"), n("throw", function(i) {
        throw i
    }), n("return"), e[Symbol.iterator] = function() {
        return this
    }, e;

    function n(i, s) {
        e[i] = t[i] ? function(a) {
            return (r = !r) ? {
                value: Op(t[i](a)),
                done: i === "return"
            } : s ? s(a) : a
        } : s
    }
}

function Lhe(t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = t[Symbol.asyncIterator],
        r;
    return e ? e.call(t) : (t = typeof l5 == "function" ? l5(t) : t[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
        return this
    }, r);

    function n(s) {
        r[s] = t[s] && function(a) {
            return new Promise(function(o, c) {
                a = t[s](a), i(o, c, a.done, a.value)
            })
        }
    }

    function i(s, a, o, c) {
        Promise.resolve(c).then(function(l) {
            s({
                value: l,
                done: o
            })
        }, a)
    }
}

function Uhe(t, e) {
    return Object.defineProperty ? Object.defineProperty(t, "raw", {
        value: e
    }) : t.raw = e, t
}

function Fhe(t) {
    if (t && t.__esModule) return t;
    var e = {};
    if (t != null)
        for (var r in t) Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
    return e.default = t, e
}

function Bhe(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}

function Whe(t, e) {
    if (!e.has(t)) throw new TypeError("attempted to get private field on non-instance");
    return e.get(t)
}

function zhe(t, e, r) {
    if (!e.has(t)) throw new TypeError("attempted to set private field on non-instance");
    return e.set(t, r), r
}
const qhe = Object.freeze(Object.defineProperty({
        __proto__: null,
        get __assign() {
            return c5
        },
        __asyncDelegator: Dhe,
        __asyncGenerator: Mhe,
        __asyncValues: Lhe,
        __await: Op,
        __awaiter: The,
        __classPrivateFieldGet: Whe,
        __classPrivateFieldSet: zhe,
        __createBinding: Nhe,
        __decorate: Ihe,
        __exportStar: Ohe,
        __extends: Ahe,
        __generator: Phe,
        __importDefault: Bhe,
        __importStar: Fhe,
        __makeTemplateObject: Uhe,
        __metadata: She,
        __param: $he,
        __read: $R,
        __rest: khe,
        __spread: jhe,
        __spreadArrays: Rhe,
        __values: l5
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    xy = xS(qhe);
var F2 = {},
    Kh = {},
    oC;

function Hhe() {
    if (oC) return Kh;
    oC = 1, Object.defineProperty(Kh, "__esModule", {
        value: !0
    }), Kh.delay = void 0;

    function t(e) {
        return new Promise(r => {
            setTimeout(() => {
                r(!0)
            }, e)
        })
    }
    return Kh.delay = t, Kh
}
var El = {},
    B2 = {},
    _l = {},
    cC;

function Vhe() {
    return cC || (cC = 1, Object.defineProperty(_l, "__esModule", {
        value: !0
    }), _l.ONE_THOUSAND = _l.ONE_HUNDRED = void 0, _l.ONE_HUNDRED = 100, _l.ONE_THOUSAND = 1e3), _l
}
var W2 = {},
    lC;

function Ghe() {
    return lC || (lC = 1, function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.ONE_YEAR = t.FOUR_WEEKS = t.THREE_WEEKS = t.TWO_WEEKS = t.ONE_WEEK = t.THIRTY_DAYS = t.SEVEN_DAYS = t.FIVE_DAYS = t.THREE_DAYS = t.ONE_DAY = t.TWENTY_FOUR_HOURS = t.TWELVE_HOURS = t.SIX_HOURS = t.THREE_HOURS = t.ONE_HOUR = t.SIXTY_MINUTES = t.THIRTY_MINUTES = t.TEN_MINUTES = t.FIVE_MINUTES = t.ONE_MINUTE = t.SIXTY_SECONDS = t.THIRTY_SECONDS = t.TEN_SECONDS = t.FIVE_SECONDS = t.ONE_SECOND = void 0, t.ONE_SECOND = 1, t.FIVE_SECONDS = 5, t.TEN_SECONDS = 10, t.THIRTY_SECONDS = 30, t.SIXTY_SECONDS = 60, t.ONE_MINUTE = t.SIXTY_SECONDS, t.FIVE_MINUTES = t.ONE_MINUTE * 5, t.TEN_MINUTES = t.ONE_MINUTE * 10, t.THIRTY_MINUTES = t.ONE_MINUTE * 30, t.SIXTY_MINUTES = t.ONE_MINUTE * 60, t.ONE_HOUR = t.SIXTY_MINUTES, t.THREE_HOURS = t.ONE_HOUR * 3, t.SIX_HOURS = t.ONE_HOUR * 6, t.TWELVE_HOURS = t.ONE_HOUR * 12, t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24, t.ONE_DAY = t.TWENTY_FOUR_HOURS, t.THREE_DAYS = t.ONE_DAY * 3, t.FIVE_DAYS = t.ONE_DAY * 5, t.SEVEN_DAYS = t.ONE_DAY * 7, t.THIRTY_DAYS = t.ONE_DAY * 30, t.ONE_WEEK = t.SEVEN_DAYS, t.TWO_WEEKS = t.ONE_WEEK * 2, t.THREE_WEEKS = t.ONE_WEEK * 3, t.FOUR_WEEKS = t.ONE_WEEK * 4, t.ONE_YEAR = t.ONE_DAY * 365
    }(W2)), W2
}
var dC;

function SR() {
    return dC || (dC = 1, function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const e = xy;
        e.__exportStar(Vhe(), t), e.__exportStar(Ghe(), t)
    }(B2)), B2
}
var uC;

function Khe() {
    if (uC) return El;
    uC = 1, Object.defineProperty(El, "__esModule", {
        value: !0
    }), El.fromMiliseconds = El.toMiliseconds = void 0;
    const t = SR();

    function e(n) {
        return n * t.ONE_THOUSAND
    }
    El.toMiliseconds = e;

    function r(n) {
        return Math.floor(n / t.ONE_THOUSAND)
    }
    return El.fromMiliseconds = r, El
}
var hC;

function Yhe() {
    return hC || (hC = 1, function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const e = xy;
        e.__exportStar(Hhe(), t), e.__exportStar(Khe(), t)
    }(F2)), F2
}
var ru = {},
    fC;

function Zhe() {
    if (fC) return ru;
    fC = 1, Object.defineProperty(ru, "__esModule", {
        value: !0
    }), ru.Watch = void 0;
    class t {
        constructor() {
            this.timestamps = new Map
        }
        start(r) {
            if (this.timestamps.has(r)) throw new Error(`Watch already started for label: ${r}`);
            this.timestamps.set(r, {
                started: Date.now()
            })
        }
        stop(r) {
            const n = this.get(r);
            if (typeof n.elapsed < "u") throw new Error(`Watch already stopped for label: ${r}`);
            const i = Date.now() - n.started;
            this.timestamps.set(r, {
                started: n.started,
                elapsed: i
            })
        }
        get(r) {
            const n = this.timestamps.get(r);
            if (typeof n > "u") throw new Error(`No timestamp found for label: ${r}`);
            return n
        }
        elapsed(r) {
            const n = this.get(r);
            return n.elapsed || Date.now() - n.started
        }
    }
    return ru.Watch = t, ru.default = t, ru
}
var z2 = {},
    Yh = {},
    pC;

function Jhe() {
    if (pC) return Yh;
    pC = 1, Object.defineProperty(Yh, "__esModule", {
        value: !0
    }), Yh.IWatch = void 0;
    class t {}
    return Yh.IWatch = t, Yh
}
var gC;

function Qhe() {
    return gC || (gC = 1, function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), xy.__exportStar(Jhe(), t)
    }(z2)), z2
}
var mC;

function Xhe() {
    return mC || (mC = 1, function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const e = xy;
        e.__exportStar(Yhe(), t), e.__exportStar(Zhe(), t), e.__exportStar(Qhe(), t), e.__exportStar(SR(), t)
    }(U2)), U2
}
var Me = Xhe(),
    hr = {},
    yC;

function TR() {
    if (yC) return hr;
    yC = 1, Object.defineProperty(hr, "__esModule", {
        value: !0
    }), hr.getLocalStorage = hr.getLocalStorageOrThrow = hr.getCrypto = hr.getCryptoOrThrow = hr.getLocation = hr.getLocationOrThrow = hr.getNavigator = hr.getNavigatorOrThrow = hr.getDocument = hr.getDocumentOrThrow = hr.getFromWindowOrThrow = hr.getFromWindow = void 0;

    function t(f) {
        let p;
        return typeof window < "u" && typeof window[f] < "u" && (p = window[f]), p
    }
    hr.getFromWindow = t;

    function e(f) {
        const p = t(f);
        if (!p) throw new Error(`${f} is not defined in Window`);
        return p
    }
    hr.getFromWindowOrThrow = e;

    function r() {
        return e("document")
    }
    hr.getDocumentOrThrow = r;

    function n() {
        return t("document")
    }
    hr.getDocument = n;

    function i() {
        return e("navigator")
    }
    hr.getNavigatorOrThrow = i;

    function s() {
        return t("navigator")
    }
    hr.getNavigator = s;

    function a() {
        return e("location")
    }
    hr.getLocationOrThrow = a;

    function o() {
        return t("location")
    }
    hr.getLocation = o;

    function c() {
        return e("crypto")
    }
    hr.getCryptoOrThrow = c;

    function l() {
        return t("crypto")
    }
    hr.getCrypto = l;

    function u() {
        return e("localStorage")
    }
    hr.getLocalStorageOrThrow = u;

    function h() {
        return t("localStorage")
    }
    return hr.getLocalStorage = h, hr
}
var sc = TR(),
    Zh = {},
    wC;

function efe() {
    if (wC) return Zh;
    wC = 1, Object.defineProperty(Zh, "__esModule", {
        value: !0
    }), Zh.getWindowMetadata = void 0;
    const t = TR();

    function e() {
        let r, n;
        try {
            r = t.getDocumentOrThrow(), n = t.getLocationOrThrow()
        } catch {
            return null
        }

        function i() {
            const p = r.getElementsByTagName("link"),
                g = [];
            for (let m = 0; m < p.length; m++) {
                const y = p[m],
                    w = y.getAttribute("rel");
                if (w && w.toLowerCase().indexOf("icon") > -1) {
                    const x = y.getAttribute("href");
                    if (x)
                        if (x.toLowerCase().indexOf("https:") === -1 && x.toLowerCase().indexOf("http:") === -1 && x.indexOf("//") !== 0) {
                            let E = n.protocol + "//" + n.host;
                            if (x.indexOf("/") === 0) E += x;
                            else {
                                const _ = n.pathname.split("/");
                                _.pop();
                                const b = _.join("/");
                                E += b + "/" + x
                            }
                            g.push(E)
                        } else if (x.indexOf("//") === 0) {
                        const E = n.protocol + x;
                        g.push(E)
                    } else g.push(x)
                }
            }
            return g
        }

        function s(...p) {
            const g = r.getElementsByTagName("meta");
            for (let m = 0; m < g.length; m++) {
                const y = g[m],
                    w = ["itemprop", "property", "name"].map(x => y.getAttribute(x)).filter(x => x ? p.includes(x) : !1);
                if (w.length && w) {
                    const x = y.getAttribute("content");
                    if (x) return x
                }
            }
            return ""
        }

        function a() {
            let p = s("name", "og:site_name", "og:title", "twitter:title");
            return p || (p = r.title), p
        }

        function o() {
            return s("description", "og:description", "twitter:description", "keywords")
        }
        const c = a(),
            l = o(),
            u = n.origin,
            h = i();
        return {
            description: l,
            url: u,
            icons: h,
            name: c
        }
    }
    return Zh.getWindowMetadata = e, Zh
}
var tfe = efe();

function jp(t, {
    strict: e = !0
} = {}) {
    return !t || typeof t != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith("0x")
}

function d5(t) {
    return jp(t, {
        strict: !1
    }) ? Math.ceil((t.length - 2) / 2) : t.length
}
const PR = "2.31.0";
let Jh = {
    getDocsUrl: ({
        docsBaseUrl: t,
        docsPath: e = "",
        docsSlug: r
    }) => e ? `${t??"https://viem.sh"}${e}${r?`#${r}`:""}` : void 0,
    version: `viem@${PR}`
};
class md extends Error {
    constructor(e, r = {}) {
        var o;
        const n = (() => {
                var c;
                return r.cause instanceof md ? r.cause.details : (c = r.cause) != null && c.message ? r.cause.message : r.details
            })(),
            i = r.cause instanceof md && r.cause.docsPath || r.docsPath,
            s = (o = Jh.getDocsUrl) == null ? void 0 : o.call(Jh, { ...r,
                docsPath: i
            }),
            a = [e || "An error occurred.", "", ...r.metaMessages ? [...r.metaMessages, ""] : [], ...s ? [`Docs: ${s}`] : [], ...n ? [`Details: ${n}`] : [], ...Jh.version ? [`Version: ${Jh.version}`] : []].join(`
`);
        super(a, r.cause ? {
            cause: r.cause
        } : void 0), Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseError"
        }), this.details = n, this.docsPath = i, this.metaMessages = r.metaMessages, this.name = r.name ? ? this.name, this.shortMessage = e, this.version = PR
    }
    walk(e) {
        return NR(this, e)
    }
}

function NR(t, e) {
    return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause !== void 0 ? NR(t.cause, e) : e ? null : t
}
class OR extends md {
    constructor({
        size: e,
        targetSize: r,
        type: n
    }) {
        super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${r}).`, {
            name: "SizeExceedsPaddingSizeError"
        })
    }
}

function Ah(t, {
    dir: e,
    size: r = 32
} = {}) {
    return typeof t == "string" ? rfe(t, {
        dir: e,
        size: r
    }) : nfe(t, {
        dir: e,
        size: r
    })
}

function rfe(t, {
    dir: e,
    size: r = 32
} = {}) {
    if (r === null) return t;
    const n = t.replace("0x", "");
    if (n.length > r * 2) throw new OR({
        size: Math.ceil(n.length / 2),
        targetSize: r,
        type: "hex"
    });
    return `0x${n[e==="right"?"padEnd":"padStart"](r*2,"0")}`
}

function nfe(t, {
    dir: e,
    size: r = 32
} = {}) {
    if (r === null) return t;
    if (t.length > r) throw new OR({
        size: t.length,
        targetSize: r,
        type: "bytes"
    });
    const n = new Uint8Array(r);
    for (let i = 0; i < r; i++) {
        const s = e === "right";
        n[s ? i : r - i - 1] = t[s ? i : t.length - i - 1]
    }
    return n
}
class ife extends md {
    constructor({
        max: e,
        min: r,
        signed: n,
        size: i,
        value: s
    }) {
        super(`Number "${s}" is not in safe ${i?`${i*8}-bit ${n?"signed":"unsigned"} `:""}integer range ${e?`(${r} to ${e})`:`(above ${r})`}`, {
            name: "IntegerOutOfRangeError"
        })
    }
}
class sfe extends md {
    constructor({
        givenSize: e,
        maxSize: r
    }) {
        super(`Size cannot exceed ${r} bytes. Given size: ${e} bytes.`, {
            name: "SizeOverflowError"
        })
    }
}

function kh(t, {
    size: e
}) {
    if (d5(t) > e) throw new sfe({
        givenSize: d5(t),
        maxSize: e
    })
}

function u5(t, e = {}) {
    const {
        signed: r
    } = e;
    e.size && kh(t, {
        size: e.size
    });
    const n = BigInt(t);
    if (!r) return n;
    const i = (t.length - 2) / 2,
        s = (1 n << BigInt(i) * 8 n - 1 n) - 1 n;
    return n <= s ? n : n - BigInt(`0x${"f".padStart(i*2,"f")}`) - 1 n
}

function afe(t, e = {}) {
    return Number(u5(t, e))
}
const ofe = Array.from({
    length: 256
}, (t, e) => e.toString(16).padStart(2, "0"));

function h5(t, e = {}) {
    return typeof t == "number" || typeof t == "bigint" ? RR(t, e) : typeof t == "string" ? dfe(t, e) : typeof t == "boolean" ? cfe(t, e) : jR(t, e)
}

function cfe(t, e = {}) {
    const r = `0x${Number(t)}`;
    return typeof e.size == "number" ? (kh(r, {
        size: e.size
    }), Ah(r, {
        size: e.size
    })) : r
}

function jR(t, e = {}) {
    let r = "";
    for (let i = 0; i < t.length; i++) r += ofe[t[i]];
    const n = `0x${r}`;
    return typeof e.size == "number" ? (kh(n, {
        size: e.size
    }), Ah(n, {
        dir: "right",
        size: e.size
    })) : n
}

function RR(t, e = {}) {
    const {
        signed: r,
        size: n
    } = e, i = BigInt(t);
    let s;
    n ? r ? s = (1 n << BigInt(n) * 8 n - 1 n) - 1 n : s = 2 n ** (BigInt(n) * 8 n) - 1 n : typeof t == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
    const a = typeof s == "bigint" && r ? -s - 1 n : 0;
    if (s && i > s || i < a) {
        const c = typeof t == "bigint" ? "n" : "";
        throw new ife({
            max: s ? `${s}${c}` : void 0,
            min: `${a}${c}`,
            signed: r,
            size: n,
            value: `${t}${c}`
        })
    }
    const o = `0x${(r&&i<0?(1n<<BigInt(n*8))+BigInt(i):i).toString(16)}`;
    return n ? Ah(o, {
        size: n
    }) : o
}
const lfe = new TextEncoder;

function dfe(t, e = {}) {
    const r = lfe.encode(t);
    return jR(r, e)
}
const ufe = new TextEncoder;

function hfe(t, e = {}) {
    return typeof t == "number" || typeof t == "bigint" ? pfe(t, e) : typeof t == "boolean" ? ffe(t, e) : jp(t) ? MR(t, e) : DR(t, e)
}

function ffe(t, e = {}) {
    const r = new Uint8Array(1);
    return r[0] = Number(t), typeof e.size == "number" ? (kh(r, {
        size: e.size
    }), Ah(r, {
        size: e.size
    })) : r
}
const Eo = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};

function bC(t) {
    if (t >= Eo.zero && t <= Eo.nine) return t - Eo.zero;
    if (t >= Eo.A && t <= Eo.F) return t - (Eo.A - 10);
    if (t >= Eo.a && t <= Eo.f) return t - (Eo.a - 10)
}

function MR(t, e = {}) {
    let r = t;
    e.size && (kh(r, {
        size: e.size
    }), r = Ah(r, {
        dir: "right",
        size: e.size
    }));
    let n = r.slice(2);
    n.length % 2 && (n = `0${n}`);
    const i = n.length / 2,
        s = new Uint8Array(i);
    for (let a = 0, o = 0; a < i; a++) {
        const c = bC(n.charCodeAt(o++)),
            l = bC(n.charCodeAt(o++));
        if (c === void 0 || l === void 0) throw new md(`Invalid byte sequence ("${n[o-2]}${n[o-1]}" in "${n}").`);
        s[a] = c * 16 + l
    }
    return s
}

function pfe(t, e) {
    const r = RR(t, e);
    return MR(r)
}

function DR(t, e = {}) {
    const r = ufe.encode(t);
    return typeof e.size == "number" ? (kh(r, {
        size: e.size
    }), Ah(r, {
        dir: "right",
        size: e.size
    })) : r
}

function LR(t, e) {
    const r = e || "hex",
        n = q4(jp(t, {
            strict: !1
        }) ? hfe(t) : t);
    return r === "bytes" ? n : h5(n)
}
class gfe extends Map {
    constructor(e) {
        super(), Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.maxSize = e
    }
    get(e) {
        const r = super.get(e);
        return super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r
    }
    set(e, r) {
        if (super.set(e, r), this.maxSize && this.size > this.maxSize) {
            const n = this.keys().next().value;
            n && this.delete(n)
        }
        return this
    }
}
const q2 = new gfe(8192);

function mfe(t, e) {
    if (q2.has(`${t}.${e}`)) return q2.get(`${t}.${e}`);
    const r = t.substring(2).toLowerCase(),
        n = LR(DR(r), "bytes"),
        i = r.split("");
    for (let a = 0; a < 40; a += 2) n[a >> 1] >> 4 >= 8 && i[a] && (i[a] = i[a].toUpperCase()), (n[a >> 1] & 15) >= 8 && i[a + 1] && (i[a + 1] = i[a + 1].toUpperCase());
    const s = `0x${i.join("")}`;
    return q2.set(`${t}.${e}`, s), s
}

function yfe(t) {
    const e = LR(`0x${t.substring(4)}`).substring(26);
    return mfe(`0x${e}`)
}
async function wfe({
    hash: t,
    signature: e
}) {
    const r = jp(t) ? t : h5(t),
        {
            secp256k1: n
        } = await ma(async () => {
            const {
                secp256k1: a
            } = await Promise.resolve().then(() => Kfe);
            return {
                secp256k1: a
            }
        }, void 0);
    return `0x${(()=>{if(typeof e=="object"&&"r"in e&&"s"in e){const{r:l,s:u,v:h,yParity:f}=e,p=Number(f??h),g=vC(p);return new n.Signature(u5(l),u5(u)).addRecoveryBit(g)}const a=jp(e)?e:h5(e);if(d5(a)!==65)throw new Error("invalid signature length");const o=afe(`
    0x $ {
        a.slice(130)
    }
    `),c=vC(o);return n.Signature.fromCompact(a.substring(2,130)).addRecoveryBit(c)})().recoverPublicKey(r.substring(2)).toHex(!1)}`
}

function vC(t) {
    if (t === 0 || t === 1) return t;
    if (t === 27) return 0;
    if (t === 28) return 1;
    throw new Error("Invalid yParityOrV value")
}
async function bfe({
    hash: t,
    signature: e
}) {
    return yfe(await wfe({
        hash: t,
        signature: e
    }))
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Cx = BigInt(0),
    f5 = BigInt(1);

function y0(t) {
    return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array"
}

function Ax(t) {
    if (!y0(t)) throw new Error("Uint8Array expected")
}

function Rp(t, e) {
    if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e)
}

function ug(t) {
    const e = t.toString(16);
    return e.length & 1 ? "0" + e : e
}

function UR(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    return t === "" ? Cx : BigInt("0x" + t)
}
const FR = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function",
    vfe = Array.from({
        length: 256
    }, (t, e) => e.toString(16).padStart(2, "0"));

function Mp(t) {
    if (Ax(t), FR) return t.toHex();
    let e = "";
    for (let r = 0; r < t.length; r++) e += vfe[t[r]];
    return e
}
const _o = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};

function xC(t) {
    if (t >= _o._0 && t <= _o._9) return t - _o._0;
    if (t >= _o.A && t <= _o.F) return t - (_o.A - 10);
    if (t >= _o.a && t <= _o.f) return t - (_o.a - 10)
}

function Wm(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    if (FR) return Uint8Array.fromHex(t);
    const e = t.length,
        r = e / 2;
    if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
    const n = new Uint8Array(r);
    for (let i = 0, s = 0; i < r; i++, s += 2) {
        const a = xC(t.charCodeAt(s)),
            o = xC(t.charCodeAt(s + 1));
        if (a === void 0 || o === void 0) {
            const c = t[s] + t[s + 1];
            throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + s)
        }
        n[i] = a * 16 + o
    }
    return n
}

function ed(t) {
    return UR(Mp(t))
}

function BR(t) {
    return Ax(t), UR(Mp(Uint8Array.from(t).reverse()))
}

function w0(t, e) {
    return Wm(t.toString(16).padStart(e * 2, "0"))
}

function WR(t, e) {
    return w0(t, e).reverse()
}

function ks(t, e, r) {
    let n;
    if (typeof e == "string") try {
            n = Wm(e)
        } catch (s) {
            throw new Error(t + " must be hex string or Uint8Array, cause: " + s)
        } else if (y0(e)) n = Uint8Array.from(e);
        else throw new Error(t + " must be hex string or Uint8Array");
    const i = n.length;
    if (typeof r == "number" && i !== r) throw new Error(t + " of length " + r + " expected, got " + i);
    return n
}

function zm(...t) {
    let e = 0;
    for (let n = 0; n < t.length; n++) {
        const i = t[n];
        Ax(i), e += i.length
    }
    const r = new Uint8Array(e);
    for (let n = 0, i = 0; n < t.length; n++) {
        const s = t[n];
        r.set(s, i), i += s.length
    }
    return r
}
const H2 = t => typeof t == "bigint" && Cx <= t;

function kx(t, e, r) {
    return H2(t) && H2(e) && H2(r) && e <= t && t < r
}

function Wu(t, e, r, n) {
    if (!kx(e, r, n)) throw new Error("expected valid " + t + ": " + r + " <= n < " + n + ", got " + e)
}

function xfe(t) {
    let e;
    for (e = 0; t > Cx; t >>= f5, e += 1);
    return e
}
const Ey = t => (f5 << BigInt(t)) - f5,
    V2 = t => new Uint8Array(t),
    EC = t => Uint8Array.from(t);

function Efe(t, e, r) {
    if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
    if (typeof r != "function") throw new Error("hmacFn must be a function");
    let n = V2(t),
        i = V2(t),
        s = 0;
    const a = () => {
            n.fill(1), i.fill(0), s = 0
        },
        o = (...h) => r(i, n, ...h),
        c = (h = V2(0)) => {
            i = o(EC([0]), h), n = o(), h.length !== 0 && (i = o(EC([1]), h), n = o())
        },
        l = () => {
            if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
            let h = 0;
            const f = [];
            for (; h < e;) {
                n = o();
                const p = n.slice();
                f.push(p), h += n.length
            }
            return zm(...f)
        };
    return (h, f) => {
        a(), c(h);
        let p;
        for (; !(p = f(l()));) c();
        return a(), p
    }
}
const _fe = {
    bigint: t => typeof t == "bigint",
    function: t => typeof t == "function",
    boolean: t => typeof t == "boolean",
    string: t => typeof t == "string",
    stringOrUint8Array: t => typeof t == "string" || y0(t),
    isSafeInteger: t => Number.isSafeInteger(t),
    array: t => Array.isArray(t),
    field: (t, e) => e.Fp.isValid(t),
    hash: t => typeof t == "function" && Number.isSafeInteger(t.outputLen)
};

function _y(t, e, r = {}) {
    const n = (i, s, a) => {
        const o = _fe[s];
        if (typeof o != "function") throw new Error("invalid validator function");
        const c = t[i];
        if (!(a && c === void 0) && !o(c, t)) throw new Error("param " + String(i) + " is invalid. Expected " + s + ", got " + c)
    };
    for (const [i, s] of Object.entries(e)) n(i, s, !1);
    for (const [i, s] of Object.entries(r)) n(i, s, !0);
    return t
}

function _C(t) {
    const e = new WeakMap;
    return (r, ...n) => {
        const i = e.get(r);
        if (i !== void 0) return i;
        const s = t(r, ...n);
        return e.set(r, s), s
    }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ri = BigInt(0),
    ui = BigInt(1),
    Wl = BigInt(2),
    Cfe = BigInt(3),
    zR = BigInt(4),
    qR = BigInt(5),
    HR = BigInt(8);

function Ti(t, e) {
    const r = t % e;
    return r >= Ri ? r : e + r
}

function bs(t, e, r) {
    let n = t;
    for (; e-- > Ri;) n *= n, n %= r;
    return n
}

function p5(t, e) {
    if (t === Ri) throw new Error("invert: expected non-zero number");
    if (e <= Ri) throw new Error("invert: expected positive modulus, got " + e);
    let r = Ti(t, e),
        n = e,
        i = Ri,
        s = ui;
    for (; r !== Ri;) {
        const o = n / r,
            c = n % r,
            l = i - s * o;
        n = r, r = c, i = s, s = l
    }
    if (n !== ui) throw new Error("invert: does not exist");
    return Ti(i, e)
}

function VR(t, e) {
    const r = (t.ORDER + ui) / zR,
        n = t.pow(e, r);
    if (!t.eql(t.sqr(n), e)) throw new Error("Cannot find square root");
    return n
}

function Afe(t, e) {
    const r = (t.ORDER - qR) / HR,
        n = t.mul(e, Wl),
        i = t.pow(n, r),
        s = t.mul(e, i),
        a = t.mul(t.mul(s, Wl), i),
        o = t.mul(s, t.sub(a, t.ONE));
    if (!t.eql(t.sqr(o), e)) throw new Error("Cannot find square root");
    return o
}

function kfe(t) {
    if (t < BigInt(3)) throw new Error("sqrt is not defined for small field");
    let e = t - ui,
        r = 0;
    for (; e % Wl === Ri;) e /= Wl, r++;
    let n = Wl;
    const i = Ix(t);
    for (; CC(i, n) === 1;)
        if (n++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (r === 1) return VR;
    let s = i.pow(n, e);
    const a = (e + ui) / Wl;
    return function(c, l) {
        if (c.is0(l)) return l;
        if (CC(c, l) !== 1) throw new Error("Cannot find square root");
        let u = r,
            h = c.mul(c.ONE, s),
            f = c.pow(l, e),
            p = c.pow(l, a);
        for (; !c.eql(f, c.ONE);) {
            if (c.is0(f)) return c.ZERO;
            let g = 1,
                m = c.sqr(f);
            for (; !c.eql(m, c.ONE);)
                if (g++, m = c.sqr(m), g === u) throw new Error("Cannot find square root");
            const y = ui << BigInt(u - g - 1),
                w = c.pow(h, y);
            u = g, h = c.sqr(w), f = c.mul(f, h), p = c.mul(p, w)
        }
        return p
    }
}

function Ife(t) {
    return t % zR === Cfe ? VR : t % HR === qR ? Afe : kfe(t)
}
const $fe = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

function Sfe(t) {
    const e = {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger"
        },
        r = $fe.reduce((n, i) => (n[i] = "function", n), e);
    return _y(t, r)
}

function Tfe(t, e, r) {
    if (r < Ri) throw new Error("invalid exponent, negatives unsupported");
    if (r === Ri) return t.ONE;
    if (r === ui) return e;
    let n = t.ONE,
        i = e;
    for (; r > Ri;) r & ui && (n = t.mul(n, i)), i = t.sqr(i), r >>= ui;
    return n
}

function GR(t, e, r = !1) {
    const n = new Array(e.length).fill(r ? t.ZERO : void 0),
        i = e.reduce((a, o, c) => t.is0(o) ? a : (n[c] = a, t.mul(a, o)), t.ONE),
        s = t.inv(i);
    return e.reduceRight((a, o, c) => t.is0(o) ? a : (n[c] = t.mul(a, n[c]), t.mul(a, o)), s), n
}

function CC(t, e) {
    const r = (t.ORDER - ui) / Wl,
        n = t.pow(e, r),
        i = t.eql(n, t.ONE),
        s = t.eql(n, t.ZERO),
        a = t.eql(n, t.neg(t.ONE));
    if (!i && !s && !a) throw new Error("invalid Legendre symbol result");
    return i ? 1 : s ? 0 : -1
}

function KR(t, e) {
    e !== void 0 && RW(e);
    const r = e !== void 0 ? e : t.toString(2).length,
        n = Math.ceil(r / 8);
    return {
        nBitLength: r,
        nByteLength: n
    }
}

function Ix(t, e, r = !1, n = {}) {
    if (t <= Ri) throw new Error("invalid field: expected ORDER > 0, got " + t);
    const {
        nBitLength: i,
        nByteLength: s
    } = KR(t, e);
    if (s > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let a;
    const o = Object.freeze({
        ORDER: t,
        isLE: r,
        BITS: i,
        BYTES: s,
        MASK: Ey(i),
        ZERO: Ri,
        ONE: ui,
        create: c => Ti(c, t),
        isValid: c => {
            if (typeof c != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c);
            return Ri <= c && c < t
        },
        is0: c => c === Ri,
        isOdd: c => (c & ui) === ui,
        neg: c => Ti(-c, t),
        eql: (c, l) => c === l,
        sqr: c => Ti(c * c, t),
        add: (c, l) => Ti(c + l, t),
        sub: (c, l) => Ti(c - l, t),
        mul: (c, l) => Ti(c * l, t),
        pow: (c, l) => Tfe(o, c, l),
        div: (c, l) => Ti(c * p5(l, t), t),
        sqrN: c => c * c,
        addN: (c, l) => c + l,
        subN: (c, l) => c - l,
        mulN: (c, l) => c * l,
        inv: c => p5(c, t),
        sqrt: n.sqrt || (c => (a || (a = Ife(t)), a(o, c))),
        toBytes: c => r ? WR(c, s) : w0(c, s),
        fromBytes: c => {
            if (c.length !== s) throw new Error("Field.fromBytes: expected " + s + " bytes, got " + c.length);
            return r ? BR(c) : ed(c)
        },
        invertBatch: c => GR(o, c),
        cmov: (c, l, u) => u ? l : c
    });
    return Object.freeze(o)
}

function YR(t) {
    if (typeof t != "bigint") throw new Error("field order must be bigint");
    const e = t.toString(2).length;
    return Math.ceil(e / 8)
}

function ZR(t) {
    const e = YR(t);
    return e + Math.ceil(e / 2)
}

function Pfe(t, e, r = !1) {
    const n = t.length,
        i = YR(e),
        s = ZR(e);
    if (n < 16 || n < s || n > 1024) throw new Error("expected " + s + "-1024 bytes of input, got " + n);
    const a = r ? BR(t) : ed(t),
        o = Ti(a, e - ui) + ui;
    return r ? WR(o, i) : w0(o, i)
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const AC = BigInt(0),
    g5 = BigInt(1);

function G2(t, e) {
    const r = e.negate();
    return t ? r : e
}

function JR(t, e) {
    if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t)
}

function K2(t, e) {
    JR(t, e);
    const r = Math.ceil(e / t) + 1,
        n = 2 ** (t - 1),
        i = 2 ** t,
        s = Ey(t),
        a = BigInt(t);
    return {
        windows: r,
        windowSize: n,
        mask: s,
        maxNumber: i,
        shiftBy: a
    }
}

function kC(t, e, r) {
    const {
        windowSize: n,
        mask: i,
        maxNumber: s,
        shiftBy: a
    } = r;
    let o = Number(t & i),
        c = t >> a;
    o > n && (o -= s, c += g5);
    const l = e * n,
        u = l + Math.abs(o) - 1,
        h = o === 0,
        f = o < 0,
        p = e % 2 !== 0;
    return {
        nextN: c,
        offset: u,
        isZero: h,
        isNeg: f,
        isNegF: p,
        offsetF: l
    }
}

function Nfe(t, e) {
    if (!Array.isArray(t)) throw new Error("array expected");
    t.forEach((r, n) => {
        if (!(r instanceof e)) throw new Error("invalid point at index " + n)
    })
}

function Ofe(t, e) {
    if (!Array.isArray(t)) throw new Error("array of scalars expected");
    t.forEach((r, n) => {
        if (!e.isValid(r)) throw new Error("invalid scalar at index " + n)
    })
}
const Y2 = new WeakMap,
    QR = new WeakMap;

function Z2(t) {
    return QR.get(t) || 1
}

function jfe(t, e) {
    return {
        constTimeNegate: G2,
        hasPrecomputes(r) {
            return Z2(r) !== 1
        },
        unsafeLadder(r, n, i = t.ZERO) {
            let s = r;
            for (; n > AC;) n & g5 && (i = i.add(s)), s = s.double(), n >>= g5;
            return i
        },
        precomputeWindow(r, n) {
            const {
                windows: i,
                windowSize: s
            } = K2(n, e), a = [];
            let o = r,
                c = o;
            for (let l = 0; l < i; l++) {
                c = o, a.push(c);
                for (let u = 1; u < s; u++) c = c.add(o), a.push(c);
                o = c.double()
            }
            return a
        },
        wNAF(r, n, i) {
            let s = t.ZERO,
                a = t.BASE;
            const o = K2(r, e);
            for (let c = 0; c < o.windows; c++) {
                const {
                    nextN: l,
                    offset: u,
                    isZero: h,
                    isNeg: f,
                    isNegF: p,
                    offsetF: g
                } = kC(i, c, o);
                i = l, h ? a = a.add(G2(p, n[g])) : s = s.add(G2(f, n[u]))
            }
            return {
                p: s,
                f: a
            }
        },
        wNAFUnsafe(r, n, i, s = t.ZERO) {
            const a = K2(r, e);
            for (let o = 0; o < a.windows && i !== AC; o++) {
                const {
                    nextN: c,
                    offset: l,
                    isZero: u,
                    isNeg: h
                } = kC(i, o, a);
                if (i = c, !u) {
                    const f = n[l];
                    s = s.add(h ? f.negate() : f)
                }
            }
            return s
        },
        getPrecomputes(r, n, i) {
            let s = Y2.get(n);
            return s || (s = this.precomputeWindow(n, r), r !== 1 && Y2.set(n, i(s))), s
        },
        wNAFCached(r, n, i) {
            const s = Z2(r);
            return this.wNAF(s, this.getPrecomputes(s, r, i), n)
        },
        wNAFCachedUnsafe(r, n, i, s) {
            const a = Z2(r);
            return a === 1 ? this.unsafeLadder(r, n, s) : this.wNAFUnsafe(a, this.getPrecomputes(a, r, i), n, s)
        },
        setWindowSize(r, n) {
            JR(n, e), QR.set(r, n), Y2.delete(r)
        }
    }
}

function Rfe(t, e, r, n) {
    Nfe(r, t), Ofe(n, e);
    const i = r.length,
        s = n.length;
    if (i !== s) throw new Error("arrays of points and scalars must have equal length");
    const a = t.ZERO,
        o = xfe(BigInt(i));
    let c = 1;
    o > 12 ? c = o - 3 : o > 4 ? c = o - 2 : o > 0 && (c = 2);
    const l = Ey(c),
        u = new Array(Number(l) + 1).fill(a),
        h = Math.floor((e.BITS - 1) / c) * c;
    let f = a;
    for (let p = h; p >= 0; p -= c) {
        u.fill(a);
        for (let m = 0; m < s; m++) {
            const y = n[m],
                w = Number(y >> BigInt(p) & l);
            u[w] = u[w].add(r[m])
        }
        let g = a;
        for (let m = u.length - 1, y = a; m > 0; m--) y = y.add(u[m]), g = g.add(y);
        if (f = f.add(g), p !== 0)
            for (let m = 0; m < c; m++) f = f.double()
    }
    return f
}

function XR(t) {
    return Sfe(t.Fp), _y(t, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({ ...KR(t.n, t.nBitLength),
        ...t,
        p: t.Fp.ORDER
    })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function IC(t) {
    t.lowS !== void 0 && Rp("lowS", t.lowS), t.prehash !== void 0 && Rp("prehash", t.prehash)
}

function Mfe(t) {
    const e = XR(t);
    _y(e, {
        a: "field",
        b: "field"
    }, {
        allowInfinityPoint: "boolean",
        allowedPrivateKeyLengths: "array",
        clearCofactor: "function",
        fromBytes: "function",
        isTorsionFree: "function",
        toBytes: "function",
        wrapPrivateKey: "boolean"
    });
    const {
        endo: r,
        Fp: n,
        a: i
    } = e;
    if (r) {
        if (!n.eql(i, n.ZERO)) throw new Error("invalid endo: CURVE.a must be 0");
        if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function") throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')
    }
    return Object.freeze({ ...e
    })
}
class Dfe extends Error {
    constructor(e = "") {
        super(e)
    }
}
const Do = {
    Err: Dfe,
    _tlv: {
        encode: (t, e) => {
            const {
                Err: r
            } = Do;
            if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
            if (e.length & 1) throw new r("tlv.encode: unpadded data");
            const n = e.length / 2,
                i = ug(n);
            if (i.length / 2 & 128) throw new r("tlv.encode: long form length too big");
            const s = n > 127 ? ug(i.length / 2 | 128) : "";
            return ug(t) + s + i + e
        },
        decode(t, e) {
            const {
                Err: r
            } = Do;
            let n = 0;
            if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
            if (e.length < 2 || e[n++] !== t) throw new r("tlv.decode: wrong tlv");
            const i = e[n++],
                s = !!(i & 128);
            let a = 0;
            if (!s) a = i;
            else {
                const c = i & 127;
                if (!c) throw new r("tlv.decode(long): indefinite length not supported");
                if (c > 4) throw new r("tlv.decode(long): byte length is too big");
                const l = e.subarray(n, n + c);
                if (l.length !== c) throw new r("tlv.decode: length bytes not complete");
                if (l[0] === 0) throw new r("tlv.decode(long): zero leftmost byte");
                for (const u of l) a = a << 8 | u;
                if (n += c, a < 128) throw new r("tlv.decode(long): not minimal encoding")
            }
            const o = e.subarray(n, n + a);
            if (o.length !== a) throw new r("tlv.decode: wrong value length");
            return {
                v: o,
                l: e.subarray(n + a)
            }
        }
    },
    _int: {
        encode(t) {
            const {
                Err: e
            } = Do;
            if (t < Fo) throw new e("integer: negative integers are not allowed");
            let r = ug(t);
            if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
            return r
        },
        decode(t) {
            const {
                Err: e
            } = Do;
            if (t[0] & 128) throw new e("invalid signature integer: negative");
            if (t[0] === 0 && !(t[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
            return ed(t)
        }
    },
    toSig(t) {
        const {
            Err: e,
            _int: r,
            _tlv: n
        } = Do, i = ks("signature", t), {
            v: s,
            l: a
        } = n.decode(48, i);
        if (a.length) throw new e("invalid signature: left bytes after parsing");
        const {
            v: o,
            l: c
        } = n.decode(2, s), {
            v: l,
            l: u
        } = n.decode(2, c);
        if (u.length) throw new e("invalid signature: left bytes after parsing");
        return {
            r: r.decode(o),
            s: r.decode(l)
        }
    },
    hexFromSig(t) {
        const {
            _tlv: e,
            _int: r
        } = Do, n = e.encode(2, r.encode(t.r)), i = e.encode(2, r.encode(t.s)), s = n + i;
        return e.encode(48, s)
    }
};

function J2(t, e) {
    return Mp(w0(t, e))
}
const Fo = BigInt(0),
    gn = BigInt(1);
BigInt(2);
const Q2 = BigInt(3),
    Lfe = BigInt(4);

function Ufe(t) {
    const e = Mfe(t),
        {
            Fp: r
        } = e,
        n = Ix(e.n, e.nBitLength),
        i = e.toBytes || ((E, _, b) => {
            const A = _.toAffine();
            return zm(Uint8Array.from([4]), r.toBytes(A.x), r.toBytes(A.y))
        }),
        s = e.fromBytes || (E => {
            const _ = E.subarray(1),
                b = r.fromBytes(_.subarray(0, r.BYTES)),
                A = r.fromBytes(_.subarray(r.BYTES, 2 * r.BYTES));
            return {
                x: b,
                y: A
            }
        });

    function a(E) {
        const {
            a: _,
            b
        } = e, A = r.sqr(E), I = r.mul(A, E);
        return r.add(r.add(I, r.mul(E, _)), b)
    }

    function o(E, _) {
        const b = r.sqr(_),
            A = a(E);
        return r.eql(b, A)
    }
    if (!o(e.Gx, e.Gy)) throw new Error("bad curve params: generator point");
    const c = r.mul(r.pow(e.a, Q2), Lfe),
        l = r.mul(r.sqr(e.b), BigInt(27));
    if (r.is0(r.add(c, l))) throw new Error("bad curve params: a or b");

    function u(E) {
        return kx(E, gn, e.n)
    }

    function h(E) {
        const {
            allowedPrivateKeyLengths: _,
            nByteLength: b,
            wrapPrivateKey: A,
            n: I
        } = e;
        if (_ && typeof E != "bigint") {
            if (y0(E) && (E = Mp(E)), typeof E != "string" || !_.includes(E.length)) throw new Error("invalid private key");
            E = E.padStart(b * 2, "0")
        }
        let T;
        try {
            T = typeof E == "bigint" ? E : ed(ks("private key", E, b))
        } catch {
            throw new Error("invalid private key, expected hex or " + b + " bytes, got " + typeof E)
        }
        return A && (T = Ti(T, I)), Wu("private key", T, gn, I), T
    }

    function f(E) {
        if (!(E instanceof m)) throw new Error("ProjectivePoint expected")
    }
    const p = _C((E, _) => {
            const {
                px: b,
                py: A,
                pz: I
            } = E;
            if (r.eql(I, r.ONE)) return {
                x: b,
                y: A
            };
            const T = E.is0();
            _ == null && (_ = T ? r.ONE : r.inv(I));
            const C = r.mul(b, _),
                $ = r.mul(A, _),
                P = r.mul(I, _);
            if (T) return {
                x: r.ZERO,
                y: r.ZERO
            };
            if (!r.eql(P, r.ONE)) throw new Error("invZ was invalid");
            return {
                x: C,
                y: $
            }
        }),
        g = _C(E => {
            if (E.is0()) {
                if (e.allowInfinityPoint && !r.is0(E.py)) return;
                throw new Error("bad point: ZERO")
            }
            const {
                x: _,
                y: b
            } = E.toAffine();
            if (!r.isValid(_) || !r.isValid(b)) throw new Error("bad point: x or y not FE");
            if (!o(_, b)) throw new Error("bad point: equation left != right");
            if (!E.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
            return !0
        });
    class m {
        constructor(_, b, A) {
            if (_ == null || !r.isValid(_)) throw new Error("x required");
            if (b == null || !r.isValid(b) || r.is0(b)) throw new Error("y required");
            if (A == null || !r.isValid(A)) throw new Error("z required");
            this.px = _, this.py = b, this.pz = A, Object.freeze(this)
        }
        static fromAffine(_) {
            const {
                x: b,
                y: A
            } = _ || {};
            if (!_ || !r.isValid(b) || !r.isValid(A)) throw new Error("invalid affine point");
            if (_ instanceof m) throw new Error("projective point not allowed");
            const I = T => r.eql(T, r.ZERO);
            return I(b) && I(A) ? m.ZERO : new m(b, A, r.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(_) {
            const b = GR(r, _.map(A => A.pz));
            return _.map((A, I) => A.toAffine(b[I])).map(m.fromAffine)
        }
        static fromHex(_) {
            const b = m.fromAffine(s(ks("pointHex", _)));
            return b.assertValidity(), b
        }
        static fromPrivateKey(_) {
            return m.BASE.multiply(h(_))
        }
        static msm(_, b) {
            return Rfe(m, n, _, b)
        }
        _setWindowSize(_) {
            x.setWindowSize(this, _)
        }
        assertValidity() {
            g(this)
        }
        hasEvenY() {
            const {
                y: _
            } = this.toAffine();
            if (r.isOdd) return !r.isOdd(_);
            throw new Error("Field doesn't support isOdd")
        }
        equals(_) {
            f(_);
            const {
                px: b,
                py: A,
                pz: I
            } = this, {
                px: T,
                py: C,
                pz: $
            } = _, P = r.eql(r.mul(b, $), r.mul(T, I)), N = r.eql(r.mul(A, $), r.mul(C, I));
            return P && N
        }
        negate() {
            return new m(this.px, r.neg(this.py), this.pz)
        }
        double() {
            const {
                a: _,
                b
            } = e, A = r.mul(b, Q2), {
                px: I,
                py: T,
                pz: C
            } = this;
            let $ = r.ZERO,
                P = r.ZERO,
                N = r.ZERO,
                R = r.mul(I, I),
                D = r.mul(T, T),
                S = r.mul(C, C),
                O = r.mul(I, T);
            return O = r.add(O, O), N = r.mul(I, C), N = r.add(N, N), $ = r.mul(_, N), P = r.mul(A, S), P = r.add($, P), $ = r.sub(D, P), P = r.add(D, P), P = r.mul($, P), $ = r.mul(O, $), N = r.mul(A, N), S = r.mul(_, S), O = r.sub(R, S), O = r.mul(_, O), O = r.add(O, N), N = r.add(R, R), R = r.add(N, R), R = r.add(R, S), R = r.mul(R, O), P = r.add(P, R), S = r.mul(T, C), S = r.add(S, S), R = r.mul(S, O), $ = r.sub($, R), N = r.mul(S, D), N = r.add(N, N), N = r.add(N, N), new m($, P, N)
        }
        add(_) {
            f(_);
            const {
                px: b,
                py: A,
                pz: I
            } = this, {
                px: T,
                py: C,
                pz: $
            } = _;
            let P = r.ZERO,
                N = r.ZERO,
                R = r.ZERO;
            const D = e.a,
                S = r.mul(e.b, Q2);
            let O = r.mul(b, T),
                M = r.mul(A, C),
                U = r.mul(I, $),
                k = r.add(b, A),
                F = r.add(T, C);
            k = r.mul(k, F), F = r.add(O, M), k = r.sub(k, F), F = r.add(b, I);
            let q = r.add(T, $);
            return F = r.mul(F, q), q = r.add(O, U), F = r.sub(F, q), q = r.add(A, I), P = r.add(C, $), q = r.mul(q, P), P = r.add(M, U), q = r.sub(q, P), R = r.mul(D, F), P = r.mul(S, U), R = r.add(P, R), P = r.sub(M, R), R = r.add(M, R), N = r.mul(P, R), M = r.add(O, O), M = r.add(M, O), U = r.mul(D, U), F = r.mul(S, F), M = r.add(M, U), U = r.sub(O, U), U = r.mul(D, U), F = r.add(F, U), O = r.mul(M, F), N = r.add(N, O), O = r.mul(q, F), P = r.mul(k, P), P = r.sub(P, O), O = r.mul(k, M), R = r.mul(q, R), R = r.add(R, O), new m(P, N, R)
        }
        subtract(_) {
            return this.add(_.negate())
        }
        is0() {
            return this.equals(m.ZERO)
        }
        wNAF(_) {
            return x.wNAFCached(this, _, m.normalizeZ)
        }
        multiplyUnsafe(_) {
            const {
                endo: b,
                n: A
            } = e;
            Wu("scalar", _, Fo, A);
            const I = m.ZERO;
            if (_ === Fo) return I;
            if (this.is0() || _ === gn) return this;
            if (!b || x.hasPrecomputes(this)) return x.wNAFCachedUnsafe(this, _, m.normalizeZ);
            let {
                k1neg: T,
                k1: C,
                k2neg: $,
                k2: P
            } = b.splitScalar(_), N = I, R = I, D = this;
            for (; C > Fo || P > Fo;) C & gn && (N = N.add(D)), P & gn && (R = R.add(D)), D = D.double(), C >>= gn, P >>= gn;
            return T && (N = N.negate()), $ && (R = R.negate()), R = new m(r.mul(R.px, b.beta), R.py, R.pz), N.add(R)
        }
        multiply(_) {
            const {
                endo: b,
                n: A
            } = e;
            Wu("scalar", _, gn, A);
            let I, T;
            if (b) {
                const {
                    k1neg: C,
                    k1: $,
                    k2neg: P,
                    k2: N
                } = b.splitScalar(_);
                let {
                    p: R,
                    f: D
                } = this.wNAF($), {
                    p: S,
                    f: O
                } = this.wNAF(N);
                R = x.constTimeNegate(C, R), S = x.constTimeNegate(P, S), S = new m(r.mul(S.px, b.beta), S.py, S.pz), I = R.add(S), T = D.add(O)
            } else {
                const {
                    p: C,
                    f: $
                } = this.wNAF(_);
                I = C, T = $
            }
            return m.normalizeZ([I, T])[0]
        }
        multiplyAndAddUnsafe(_, b, A) {
            const I = m.BASE,
                T = ($, P) => P === Fo || P === gn || !$.equals(I) ? $.multiplyUnsafe(P) : $.multiply(P),
                C = T(this, b).add(T(_, A));
            return C.is0() ? void 0 : C
        }
        toAffine(_) {
            return p(this, _)
        }
        isTorsionFree() {
            const {
                h: _,
                isTorsionFree: b
            } = e;
            if (_ === gn) return !0;
            if (b) return b(m, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            const {
                h: _,
                clearCofactor: b
            } = e;
            return _ === gn ? this : b ? b(m, this) : this.multiplyUnsafe(e.h)
        }
        toRawBytes(_ = !0) {
            return Rp("isCompressed", _), this.assertValidity(), i(m, this, _)
        }
        toHex(_ = !0) {
            return Rp("isCompressed", _), Mp(this.toRawBytes(_))
        }
    }
    m.BASE = new m(e.Gx, e.Gy, r.ONE), m.ZERO = new m(r.ZERO, r.ONE, r.ZERO);
    const {
        endo: y,
        nBitLength: w
    } = e, x = jfe(m, y ? Math.ceil(w / 2) : w);
    return {
        CURVE: e,
        ProjectivePoint: m,
        normPrivateKeyToScalar: h,
        weierstrassEquation: a,
        isWithinCurveOrder: u
    }
}

function Ffe(t) {
    const e = XR(t);
    return _y(e, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }), Object.freeze({
        lowS: !0,
        ...e
    })
}

function Bfe(t) {
    const e = Ffe(t),
        {
            Fp: r,
            n,
            nByteLength: i,
            nBitLength: s
        } = e,
        a = r.BYTES + 1,
        o = 2 * r.BYTES + 1;

    function c(S) {
        return Ti(S, n)
    }

    function l(S) {
        return p5(S, n)
    }
    const {
        ProjectivePoint: u,
        normPrivateKeyToScalar: h,
        weierstrassEquation: f,
        isWithinCurveOrder: p
    } = Ufe({ ...e,
        toBytes(S, O, M) {
            const U = O.toAffine(),
                k = r.toBytes(U.x),
                F = zm;
            return Rp("isCompressed", M), M ? F(Uint8Array.from([O.hasEvenY() ? 2 : 3]), k) : F(Uint8Array.from([4]), k, r.toBytes(U.y))
        },
        fromBytes(S) {
            const O = S.length,
                M = S[0],
                U = S.subarray(1);
            if (O === a && (M === 2 || M === 3)) {
                const k = ed(U);
                if (!kx(k, gn, r.ORDER)) throw new Error("Point is not on curve");
                const F = f(k);
                let q;
                try {
                    q = r.sqrt(F)
                } catch (H) {
                    const j = H instanceof Error ? ": " + H.message : "";
                    throw new Error("Point is not on curve" + j)
                }
                const W = (q & gn) === gn;
                return (M & 1) === 1 !== W && (q = r.neg(q)), {
                    x: k,
                    y: q
                }
            } else if (O === o && M === 4) {
                const k = r.fromBytes(U.subarray(0, r.BYTES)),
                    F = r.fromBytes(U.subarray(r.BYTES, 2 * r.BYTES));
                return {
                    x: k,
                    y: F
                }
            } else {
                const k = a,
                    F = o;
                throw new Error("invalid Point, expected length of " + k + ", or uncompressed " + F + ", got " + O)
            }
        }
    });

    function g(S) {
        const O = n >> gn;
        return S > O
    }

    function m(S) {
        return g(S) ? c(-S) : S
    }
    const y = (S, O, M) => ed(S.slice(O, M));
    class w {
        constructor(O, M, U) {
            Wu("r", O, gn, n), Wu("s", M, gn, n), this.r = O, this.s = M, U != null && (this.recovery = U), Object.freeze(this)
        }
        static fromCompact(O) {
            const M = i;
            return O = ks("compactSignature", O, M * 2), new w(y(O, 0, M), y(O, M, 2 * M))
        }
        static fromDER(O) {
            const {
                r: M,
                s: U
            } = Do.toSig(ks("DER", O));
            return new w(M, U)
        }
        assertValidity() {}
        addRecoveryBit(O) {
            return new w(this.r, this.s, O)
        }
        recoverPublicKey(O) {
            const {
                r: M,
                s: U,
                recovery: k
            } = this, F = I(ks("msgHash", O));
            if (k == null || ![0, 1, 2, 3].includes(k)) throw new Error("recovery id invalid");
            const q = k === 2 || k === 3 ? M + e.n : M;
            if (q >= r.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const W = (k & 1) === 0 ? "02" : "03",
                K = u.fromHex(W + J2(q, r.BYTES)),
                H = l(q),
                j = c(-F * H),
                V = c(U * H),
                Y = u.BASE.multiplyAndAddUnsafe(K, j, V);
            if (!Y) throw new Error("point at infinify");
            return Y.assertValidity(), Y
        }
        hasHighS() {
            return g(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new w(this.r, c(-this.s), this.recovery) : this
        }
        toDERRawBytes() {
            return Wm(this.toDERHex())
        }
        toDERHex() {
            return Do.hexFromSig(this)
        }
        toCompactRawBytes() {
            return Wm(this.toCompactHex())
        }
        toCompactHex() {
            const O = i;
            return J2(this.r, O) + J2(this.s, O)
        }
    }
    const x = {
        isValidPrivateKey(S) {
            try {
                return h(S), !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: h,
        randomPrivateKey: () => {
            const S = ZR(e.n);
            return Pfe(e.randomBytes(S), e.n)
        },
        precompute(S = 8, O = u.BASE) {
            return O._setWindowSize(S), O.multiply(BigInt(3)), O
        }
    };

    function E(S, O = !0) {
        return u.fromPrivateKey(S).toRawBytes(O)
    }

    function _(S) {
        if (typeof S == "bigint") return !1;
        if (S instanceof u) return !0;
        const M = ks("key", S).length,
            U = r.BYTES,
            k = U + 1,
            F = 2 * U + 1;
        if (!(e.allowedPrivateKeyLengths || i === k)) return M === k || M === F
    }

    function b(S, O, M = !0) {
        if (_(S) === !0) throw new Error("first arg must be private key");
        if (_(O) === !1) throw new Error("second arg must be public key");
        return u.fromHex(O).multiply(h(S)).toRawBytes(M)
    }
    const A = e.bits2int || function(S) {
            if (S.length > 8192) throw new Error("input is too large");
            const O = ed(S),
                M = S.length * 8 - s;
            return M > 0 ? O >> BigInt(M) : O
        },
        I = e.bits2int_modN || function(S) {
            return c(A(S))
        },
        T = Ey(s);

    function C(S) {
        return Wu("num < 2^" + s, S, Fo, T), w0(S, i)
    }

    function $(S, O, M = P) {
        if (["recovered", "canonical"].some(ne => ne in M)) throw new Error("sign() legacy options not supported");
        const {
            hash: U,
            randomBytes: k
        } = e;
        let {
            lowS: F,
            prehash: q,
            extraEntropy: W
        } = M;
        F == null && (F = !0), S = ks("msgHash", S), IC(M), q && (S = ks("prehashed msgHash", U(S)));
        const K = I(S),
            H = h(O),
            j = [C(H), C(K)];
        if (W != null && W !== !1) {
            const ne = W === !0 ? k(r.BYTES) : W;
            j.push(ks("extraEntropy", ne))
        }
        const V = zm(...j),
            Y = K;

        function X(ne) {
            const ae = A(ne);
            if (!p(ae)) return;
            const ue = l(ae),
                he = u.BASE.multiply(ae).toAffine(),
                fe = c(he.x);
            if (fe === Fo) return;
            const de = c(ue * c(Y + fe * H));
            if (de === Fo) return;
            let ye = (he.x === fe ? 0 : 2) | Number(he.y & gn),
                Be = de;
            return F && g(de) && (Be = m(de), ye ^= 1), new w(fe, Be, ye)
        }
        return {
            seed: V,
            k2sig: X
        }
    }
    const P = {
            lowS: e.lowS,
            prehash: !1
        },
        N = {
            lowS: e.lowS,
            prehash: !1
        };

    function R(S, O, M = P) {
        const {
            seed: U,
            k2sig: k
        } = $(S, O, M), F = e;
        return Efe(F.hash.outputLen, F.nByteLength, F.hmac)(U, k)
    }
    u.BASE._setWindowSize(8);

    function D(S, O, M, U = N) {
        var ye;
        const k = S;
        O = ks("msgHash", O), M = ks("publicKey", M);
        const {
            lowS: F,
            prehash: q,
            format: W
        } = U;
        if (IC(U), "strict" in U) throw new Error("options.strict was renamed to lowS");
        if (W !== void 0 && W !== "compact" && W !== "der") throw new Error("format must be compact or der");
        const K = typeof k == "string" || y0(k),
            H = !K && !W && typeof k == "object" && k !== null && typeof k.r == "bigint" && typeof k.s == "bigint";
        if (!K && !H) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        let j, V;
        try {
            if (H && (j = new w(k.r, k.s)), K) {
                try {
                    W !== "compact" && (j = w.fromDER(k))
                } catch (Be) {
                    if (!(Be instanceof Do.Err)) throw Be
                }!j && W !== "der" && (j = w.fromCompact(k))
            }
            V = u.fromHex(M)
        } catch {
            return !1
        }
        if (!j || F && j.hasHighS()) return !1;
        q && (O = e.hash(O));
        const {
            r: Y,
            s: X
        } = j, ne = I(O), ae = l(X), ue = c(ne * ae), he = c(Y * ae), fe = (ye = u.BASE.multiplyAndAddUnsafe(V, ue, he)) == null ? void 0 : ye.toAffine();
        return fe ? c(fe.x) === Y : !1
    }
    return {
        CURVE: e,
        getPublicKey: E,
        getSharedSecret: b,
        sign: R,
        verify: D,
        ProjectivePoint: u,
        Signature: w,
        utils: x
    }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Wfe(t) {
    return {
        hash: t,
        hmac: (e, ...r) => DW(t, e, LW(...r)),
        randomBytes: MW
    }
}

function zfe(t, e) {
    const r = n => Bfe({ ...t,
        ...Wfe(n)
    });
    return { ...r(e),
        create: r
    }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const eM = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    $C = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    qfe = BigInt(0),
    Hfe = BigInt(1),
    m5 = BigInt(2),
    SC = (t, e) => (t + e / m5) / e;

function Vfe(t) {
    const e = eM,
        r = BigInt(3),
        n = BigInt(6),
        i = BigInt(11),
        s = BigInt(22),
        a = BigInt(23),
        o = BigInt(44),
        c = BigInt(88),
        l = t * t * t % e,
        u = l * l * t % e,
        h = bs(u, r, e) * u % e,
        f = bs(h, r, e) * u % e,
        p = bs(f, m5, e) * l % e,
        g = bs(p, i, e) * p % e,
        m = bs(g, s, e) * g % e,
        y = bs(m, o, e) * m % e,
        w = bs(y, c, e) * y % e,
        x = bs(w, o, e) * m % e,
        E = bs(x, r, e) * u % e,
        _ = bs(E, a, e) * g % e,
        b = bs(_, n, e) * l % e,
        A = bs(b, m5, e);
    if (!y5.eql(y5.sqr(A), t)) throw new Error("Cannot find square root");
    return A
}
const y5 = Ix(eM, void 0, void 0, {
        sqrt: Vfe
    }),
    Gfe = zfe({
        a: qfe,
        b: BigInt(7),
        Fp: y5,
        n: $C,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: !0,
        endo: {
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
            splitScalar: t => {
                const e = $C,
                    r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                    n = -Hfe * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                    i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                    s = r,
                    a = BigInt("0x100000000000000000000000000000000"),
                    o = SC(s * t, e),
                    c = SC(-n * t, e);
                let l = Ti(t - o * r - c * i, e),
                    u = Ti(-o * n - c * s, e);
                const h = l > a,
                    f = u > a;
                if (h && (l = e - l), f && (u = e - u), l > a || u > a) throw new Error("splitScalar: Endomorphism failed, k=" + t);
                return {
                    k1neg: h,
                    k1: l,
                    k2neg: f,
                    k2: u
                }
            }
        }
    }, UW),
    Kfe = Object.freeze(Object.defineProperty({
        __proto__: null,
        secp256k1: Gfe
    }, Symbol.toStringTag, {
        value: "Module"
    }));

function Yfe(t) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    const e = new Uint8Array(256);
    for (let l = 0; l < e.length; l++) e[l] = 255;
    for (let l = 0; l < t.length; l++) {
        const u = t.charAt(l),
            h = u.charCodeAt(0);
        if (e[h] !== 255) throw new TypeError(u + " is ambiguous");
        e[h] = l
    }
    const r = t.length,
        n = t.charAt(0),
        i = Math.log(r) / Math.log(256),
        s = Math.log(256) / Math.log(r);

    function a(l) {
        if (l instanceof Uint8Array || (ArrayBuffer.isView(l) ? l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength) : Array.isArray(l) && (l = Uint8Array.from(l))), !(l instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (l.length === 0) return "";
        let u = 0,
            h = 0,
            f = 0;
        const p = l.length;
        for (; f !== p && l[f] === 0;) f++, u++;
        const g = (p - f) * s + 1 >>> 0,
            m = new Uint8Array(g);
        for (; f !== p;) {
            let x = l[f],
                E = 0;
            for (let _ = g - 1;
                (x !== 0 || E < h) && _ !== -1; _--, E++) x += 256 * m[_] >>> 0, m[_] = x % r >>> 0, x = x / r >>> 0;
            if (x !== 0) throw new Error("Non-zero carry");
            h = E, f++
        }
        let y = g - h;
        for (; y !== g && m[y] === 0;) y++;
        let w = n.repeat(u);
        for (; y < g; ++y) w += t.charAt(m[y]);
        return w
    }

    function o(l) {
        if (typeof l != "string") throw new TypeError("Expected String");
        if (l.length === 0) return new Uint8Array;
        let u = 0,
            h = 0,
            f = 0;
        for (; l[u] === n;) h++, u++;
        const p = (l.length - u) * i + 1 >>> 0,
            g = new Uint8Array(p);
        for (; u < l.length;) {
            const x = l.charCodeAt(u);
            if (x > 255) return;
            let E = e[x];
            if (E === 255) return;
            let _ = 0;
            for (let b = p - 1;
                (E !== 0 || _ < f) && b !== -1; b--, _++) E += r * g[b] >>> 0, g[b] = E % 256 >>> 0, E = E / 256 >>> 0;
            if (E !== 0) throw new Error("Non-zero carry");
            f = _, u++
        }
        let m = p - f;
        for (; m !== p && g[m] === 0;) m++;
        const y = new Uint8Array(h + (p - m));
        let w = h;
        for (; m !== p;) y[w++] = g[m++];
        return y
    }

    function c(l) {
        const u = o(l);
        if (u) return u;
        throw new Error("Non-base" + r + " character")
    }
    return {
        encode: a,
        decodeUnsafe: o,
        decode: c
    }
}
var Zfe = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const b0 = Yfe(Zfe);

function Jfe(t) {
    const e = t.length;
    let r = 0,
        n = 0;
    for (; n < e;) {
        let i = t.charCodeAt(n++);
        if ((i & 4294967168) === 0) {
            r++;
            continue
        } else if ((i & 4294965248) === 0) r += 2;
        else {
            if (i >= 55296 && i <= 56319 && n < e) {
                const s = t.charCodeAt(n);
                (s & 64512) === 56320 && (++n, i = ((i & 1023) << 10) + (s & 1023) + 65536)
            }(i & 4294901760) === 0 ? r += 3 : r += 4
        }
    }
    return r
}

function Qfe(t, e, r) {
    const n = t.length;
    let i = r,
        s = 0;
    for (; s < n;) {
        let a = t.charCodeAt(s++);
        if ((a & 4294967168) === 0) {
            e[i++] = a;
            continue
        } else if ((a & 4294965248) === 0) e[i++] = a >> 6 & 31 | 192;
        else {
            if (a >= 55296 && a <= 56319 && s < n) {
                const o = t.charCodeAt(s);
                (o & 64512) === 56320 && (++s, a = ((a & 1023) << 10) + (o & 1023) + 65536)
            }(a & 4294901760) === 0 ? (e[i++] = a >> 12 & 15 | 224, e[i++] = a >> 6 & 63 | 128) : (e[i++] = a >> 18 & 7 | 240, e[i++] = a >> 12 & 63 | 128, e[i++] = a >> 6 & 63 | 128)
        }
        e[i++] = a & 63 | 128
    }
}
const Xfe = new TextEncoder,
    epe = 50;

function tpe(t, e, r) {
    Xfe.encodeInto(t, e.subarray(r))
}

function rpe(t, e, r) {
    t.length > epe ? tpe(t, e, r) : Qfe(t, e, r)
}
const npe = 4096;

function tM(t, e, r) {
    let n = e;
    const i = n + r,
        s = [];
    let a = "";
    for (; n < i;) {
        const o = t[n++];
        if ((o & 128) === 0) s.push(o);
        else if ((o & 224) === 192) {
            const c = t[n++] & 63;
            s.push((o & 31) << 6 | c)
        } else if ((o & 240) === 224) {
            const c = t[n++] & 63,
                l = t[n++] & 63;
            s.push((o & 31) << 12 | c << 6 | l)
        } else if ((o & 248) === 240) {
            const c = t[n++] & 63,
                l = t[n++] & 63,
                u = t[n++] & 63;
            let h = (o & 7) << 18 | c << 12 | l << 6 | u;
            h > 65535 && (h -= 65536, s.push(h >>> 10 & 1023 | 55296), h = 56320 | h & 1023), s.push(h)
        } else s.push(o);
        s.length >= npe && (a += String.fromCharCode(...s), s.length = 0)
    }
    return s.length > 0 && (a += String.fromCharCode(...s)), a
}
const ipe = new TextDecoder,
    spe = 200;

function ape(t, e, r) {
    const n = t.subarray(e, e + r);
    return ipe.decode(n)
}

function ope(t, e, r) {
    return r > spe ? ape(t, e, r) : tM(t, e, r)
}
class hg {
    constructor(e, r) {
        this.type = e, this.data = r
    }
}
class Ji extends Error {
    constructor(e) {
        super(e);
        const r = Object.create(Ji.prototype);
        Object.setPrototypeOf(this, r), Object.defineProperty(this, "name", {
            configurable: !0,
            enumerable: !1,
            value: Ji.name
        })
    }
}
const Qh = 4294967295;

function cpe(t, e, r) {
    const n = r / 4294967296,
        i = r;
    t.setUint32(e, n), t.setUint32(e + 4, i)
}

function rM(t, e, r) {
    const n = Math.floor(r / 4294967296),
        i = r;
    t.setUint32(e, n), t.setUint32(e + 4, i)
}

function nM(t, e) {
    const r = t.getInt32(e),
        n = t.getUint32(e + 4);
    return r * 4294967296 + n
}

function lpe(t, e) {
    const r = t.getUint32(e),
        n = t.getUint32(e + 4);
    return r * 4294967296 + n
}
const dpe = -1,
    upe = 4294967296 - 1,
    hpe = 17179869184 - 1;

function fpe({
    sec: t,
    nsec: e
}) {
    if (t >= 0 && e >= 0 && t <= hpe)
        if (e === 0 && t <= upe) {
            const r = new Uint8Array(4);
            return new DataView(r.buffer).setUint32(0, t), r
        } else {
            const r = t / 4294967296,
                n = t & 4294967295,
                i = new Uint8Array(8),
                s = new DataView(i.buffer);
            return s.setUint32(0, e << 2 | r & 3), s.setUint32(4, n), i
        }
    else {
        const r = new Uint8Array(12),
            n = new DataView(r.buffer);
        return n.setUint32(0, e), rM(n, 4, t), r
    }
}

function ppe(t) {
    const e = t.getTime(),
        r = Math.floor(e / 1e3),
        n = (e - r * 1e3) * 1e6,
        i = Math.floor(n / 1e9);
    return {
        sec: r + i,
        nsec: n - i * 1e9
    }
}

function gpe(t) {
    if (t instanceof Date) {
        const e = ppe(t);
        return fpe(e)
    } else return null
}

function mpe(t) {
    const e = new DataView(t.buffer, t.byteOffset, t.byteLength);
    switch (t.byteLength) {
        case 4:
            return {
                sec: e.getUint32(0),
                nsec: 0
            };
        case 8:
            {
                const r = e.getUint32(0),
                    n = e.getUint32(4),
                    i = (r & 3) * 4294967296 + n,
                    s = r >>> 2;
                return {
                    sec: i,
                    nsec: s
                }
            }
        case 12:
            {
                const r = nM(e, 4),
                    n = e.getUint32(0);
                return {
                    sec: r,
                    nsec: n
                }
            }
        default:
            throw new Ji(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${t.length}`)
    }
}

function ype(t) {
    const e = mpe(t);
    return new Date(e.sec * 1e3 + e.nsec / 1e6)
}
const wpe = {
    type: dpe,
    encode: gpe,
    decode: ype
};
class qm {
    constructor() {
        this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(wpe)
    }
    register({
        type: e,
        encode: r,
        decode: n
    }) {
        if (e >= 0) this.encoders[e] = r, this.decoders[e] = n;
        else {
            const i = -1 - e;
            this.builtInEncoders[i] = r, this.builtInDecoders[i] = n
        }
    }
    tryToEncode(e, r) {
        for (let n = 0; n < this.builtInEncoders.length; n++) {
            const i = this.builtInEncoders[n];
            if (i != null) {
                const s = i(e, r);
                if (s != null) {
                    const a = -1 - n;
                    return new hg(a, s)
                }
            }
        }
        for (let n = 0; n < this.encoders.length; n++) {
            const i = this.encoders[n];
            if (i != null) {
                const s = i(e, r);
                if (s != null) {
                    const a = n;
                    return new hg(a, s)
                }
            }
        }
        return e instanceof hg ? e : null
    }
    decode(e, r, n) {
        const i = r < 0 ? this.builtInDecoders[-1 - r] : this.decoders[r];
        return i ? i(e, r, n) : new hg(r, e)
    }
}
qm.defaultCodec = new qm;

function bpe(t) {
    return t instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer
}

function w5(t) {
    return t instanceof Uint8Array ? t : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : bpe(t) ? new Uint8Array(t) : Uint8Array.from(t)
}
const vpe = 100,
    xpe = 2048;
let Epe = class iM {
    constructor(e) {
        this.entered = !1, this.extensionCodec = (e == null ? void 0 : e.extensionCodec) ? ? qm.defaultCodec, this.context = e == null ? void 0 : e.context, this.useBigInt64 = (e == null ? void 0 : e.useBigInt64) ? ? !1, this.maxDepth = (e == null ? void 0 : e.maxDepth) ? ? vpe, this.initialBufferSize = (e == null ? void 0 : e.initialBufferSize) ? ? xpe, this.sortKeys = (e == null ? void 0 : e.sortKeys) ? ? !1, this.forceFloat32 = (e == null ? void 0 : e.forceFloat32) ? ? !1, this.ignoreUndefined = (e == null ? void 0 : e.ignoreUndefined) ? ? !1, this.forceIntegerToFloat = (e == null ? void 0 : e.forceIntegerToFloat) ? ? !1, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer)
    }
    clone() {
        return new iM({
            extensionCodec: this.extensionCodec,
            context: this.context,
            useBigInt64: this.useBigInt64,
            maxDepth: this.maxDepth,
            initialBufferSize: this.initialBufferSize,
            sortKeys: this.sortKeys,
            forceFloat32: this.forceFloat32,
            ignoreUndefined: this.ignoreUndefined,
            forceIntegerToFloat: this.forceIntegerToFloat
        })
    }
    reinitializeState() {
        this.pos = 0
    }
    encodeSharedRef(e) {
        if (this.entered) return this.clone().encodeSharedRef(e);
        try {
            return this.entered = !0, this.reinitializeState(), this.doEncode(e, 1), this.bytes.subarray(0, this.pos)
        } finally {
            this.entered = !1
        }
    }
    encode(e) {
        if (this.entered) return this.clone().encode(e);
        try {
            return this.entered = !0, this.reinitializeState(), this.doEncode(e, 1), this.bytes.slice(0, this.pos)
        } finally {
            this.entered = !1
        }
    }
    doEncode(e, r) {
        if (r > this.maxDepth) throw new Error(`Too deep objects in depth ${r}`);
        e == null ? this.encodeNil() : typeof e == "boolean" ? this.encodeBoolean(e) : typeof e == "number" ? this.forceIntegerToFloat ? this.encodeNumberAsFloat(e) : this.encodeNumber(e) : typeof e == "string" ? this.encodeString(e) : this.useBigInt64 && typeof e == "bigint" ? this.encodeBigInt64(e) : this.encodeObject(e, r)
    }
    ensureBufferSizeToWrite(e) {
        const r = this.pos + e;
        this.view.byteLength < r && this.resizeBuffer(r * 2)
    }
    resizeBuffer(e) {
        const r = new ArrayBuffer(e),
            n = new Uint8Array(r),
            i = new DataView(r);
        n.set(this.bytes), this.view = i, this.bytes = n
    }
    encodeNil() {
        this.writeU8(192)
    }
    encodeBoolean(e) {
        e === !1 ? this.writeU8(194) : this.writeU8(195)
    }
    encodeNumber(e) {
        !this.forceIntegerToFloat && Number.isSafeInteger(e) ? e >= 0 ? e < 128 ? this.writeU8(e) : e < 256 ? (this.writeU8(204), this.writeU8(e)) : e < 65536 ? (this.writeU8(205), this.writeU16(e)) : e < 4294967296 ? (this.writeU8(206), this.writeU32(e)) : this.useBigInt64 ? this.encodeNumberAsFloat(e) : (this.writeU8(207), this.writeU64(e)) : e >= -32 ? this.writeU8(224 | e + 32) : e >= -128 ? (this.writeU8(208), this.writeI8(e)) : e >= -32768 ? (this.writeU8(209), this.writeI16(e)) : e >= -2147483648 ? (this.writeU8(210), this.writeI32(e)) : this.useBigInt64 ? this.encodeNumberAsFloat(e) : (this.writeU8(211), this.writeI64(e)) : this.encodeNumberAsFloat(e)
    }
    encodeNumberAsFloat(e) {
        this.forceFloat32 ? (this.writeU8(202), this.writeF32(e)) : (this.writeU8(203), this.writeF64(e))
    }
    encodeBigInt64(e) {
        e >= BigInt(0) ? (this.writeU8(207), this.writeBigUint64(e)) : (this.writeU8(211), this.writeBigInt64(e))
    }
    writeStringHeader(e) {
        if (e < 32) this.writeU8(160 + e);
        else if (e < 256) this.writeU8(217), this.writeU8(e);
        else if (e < 65536) this.writeU8(218), this.writeU16(e);
        else if (e < 4294967296) this.writeU8(219), this.writeU32(e);
        else throw new Error(`Too long string: ${e} bytes in UTF-8`)
    }
    encodeString(e) {
        const n = Jfe(e);
        this.ensureBufferSizeToWrite(5 + n), this.writeStringHeader(n), rpe(e, this.bytes, this.pos), this.pos += n
    }
    encodeObject(e, r) {
        const n = this.extensionCodec.tryToEncode(e, this.context);
        if (n != null) this.encodeExtension(n);
        else if (Array.isArray(e)) this.encodeArray(e, r);
        else if (ArrayBuffer.isView(e)) this.encodeBinary(e);
        else if (typeof e == "object") this.encodeMap(e, r);
        else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(e)}`)
    }
    encodeBinary(e) {
        const r = e.byteLength;
        if (r < 256) this.writeU8(196), this.writeU8(r);
        else if (r < 65536) this.writeU8(197), this.writeU16(r);
        else if (r < 4294967296) this.writeU8(198), this.writeU32(r);
        else throw new Error(`Too large binary: ${r}`);
        const n = w5(e);
        this.writeU8a(n)
    }
    encodeArray(e, r) {
        const n = e.length;
        if (n < 16) this.writeU8(144 + n);
        else if (n < 65536) this.writeU8(220), this.writeU16(n);
        else if (n < 4294967296) this.writeU8(221), this.writeU32(n);
        else throw new Error(`Too large array: ${n}`);
        for (const i of e) this.doEncode(i, r + 1)
    }
    countWithoutUndefined(e, r) {
        let n = 0;
        for (const i of r) e[i] !== void 0 && n++;
        return n
    }
    encodeMap(e, r) {
        const n = Object.keys(e);
        this.sortKeys && n.sort();
        const i = this.ignoreUndefined ? this.countWithoutUndefined(e, n) : n.length;
        if (i < 16) this.writeU8(128 + i);
        else if (i < 65536) this.writeU8(222), this.writeU16(i);
        else if (i < 4294967296) this.writeU8(223), this.writeU32(i);
        else throw new Error(`Too large map object: ${i}`);
        for (const s of n) {
            const a = e[s];
            this.ignoreUndefined && a === void 0 || (this.encodeString(s), this.doEncode(a, r + 1))
        }
    }
    encodeExtension(e) {
        if (typeof e.data == "function") {
            const n = e.data(this.pos + 6),
                i = n.length;
            if (i >= 4294967296) throw new Error(`Too large extension object: ${i}`);
            this.writeU8(201), this.writeU32(i), this.writeI8(e.type), this.writeU8a(n);
            return
        }
        const r = e.data.length;
        if (r === 1) this.writeU8(212);
        else if (r === 2) this.writeU8(213);
        else if (r === 4) this.writeU8(214);
        else if (r === 8) this.writeU8(215);
        else if (r === 16) this.writeU8(216);
        else if (r < 256) this.writeU8(199), this.writeU8(r);
        else if (r < 65536) this.writeU8(200), this.writeU16(r);
        else if (r < 4294967296) this.writeU8(201), this.writeU32(r);
        else throw new Error(`Too large extension object: ${r}`);
        this.writeI8(e.type), this.writeU8a(e.data)
    }
    writeU8(e) {
        this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, e), this.pos++
    }
    writeU8a(e) {
        const r = e.length;
        this.ensureBufferSizeToWrite(r), this.bytes.set(e, this.pos), this.pos += r
    }
    writeI8(e) {
        this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, e), this.pos++
    }
    writeU16(e) {
        this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, e), this.pos += 2
    }
    writeI16(e) {
        this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, e), this.pos += 2
    }
    writeU32(e) {
        this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, e), this.pos += 4
    }
    writeI32(e) {
        this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, e), this.pos += 4
    }
    writeF32(e) {
        this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, e), this.pos += 4
    }
    writeF64(e) {
        this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, e), this.pos += 8
    }
    writeU64(e) {
        this.ensureBufferSizeToWrite(8), cpe(this.view, this.pos, e), this.pos += 8
    }
    writeI64(e) {
        this.ensureBufferSizeToWrite(8), rM(this.view, this.pos, e), this.pos += 8
    }
    writeBigUint64(e) {
        this.ensureBufferSizeToWrite(8), this.view.setBigUint64(this.pos, e), this.pos += 8
    }
    writeBigInt64(e) {
        this.ensureBufferSizeToWrite(8), this.view.setBigInt64(this.pos, e), this.pos += 8
    }
};

function _pe(t, e) {
    return new Epe(e).encodeSharedRef(t)
}

function X2(t) {
    return `${t<0?"-":""}0x${Math.abs(t).toString(16).padStart(2,"0")}`
}
const Cpe = 16,
    Ape = 16;
class kpe {
    constructor(e = Cpe, r = Ape) {
        this.hit = 0, this.miss = 0, this.maxKeyLength = e, this.maxLengthPerKey = r, this.caches = [];
        for (let n = 0; n < this.maxKeyLength; n++) this.caches.push([])
    }
    canBeCached(e) {
        return e > 0 && e <= this.maxKeyLength
    }
    find(e, r, n) {
        const i = this.caches[n - 1];
        e: for (const s of i) {
            const a = s.bytes;
            for (let o = 0; o < n; o++)
                if (a[o] !== e[r + o]) continue e;
            return s.str
        }
        return null
    }
    store(e, r) {
        const n = this.caches[e.length - 1],
            i = {
                bytes: e,
                str: r
            };
        n.length >= this.maxLengthPerKey ? n[Math.random() * n.length | 0] = i : n.push(i)
    }
    decode(e, r, n) {
        const i = this.find(e, r, n);
        if (i != null) return this.hit++, i;
        this.miss++;
        const s = tM(e, r, n),
            a = Uint8Array.prototype.slice.call(e, r, r + n);
        return this.store(a, s), s
    }
}
const b5 = "array",
    Bf = "map_key",
    sM = "map_value",
    Ipe = t => {
        if (typeof t == "string" || typeof t == "number") return t;
        throw new Ji("The type of key must be string or number but " + typeof t)
    };
class $pe {
    constructor() {
        this.stack = [], this.stackHeadPosition = -1
    }
    get length() {
        return this.stackHeadPosition + 1
    }
    top() {
        return this.stack[this.stackHeadPosition]
    }
    pushArrayState(e) {
        const r = this.getUninitializedStateFromPool();
        r.type = b5, r.position = 0, r.size = e, r.array = new Array(e)
    }
    pushMapState(e) {
        const r = this.getUninitializedStateFromPool();
        r.type = Bf, r.readCount = 0, r.size = e, r.map = {}
    }
    getUninitializedStateFromPool() {
        if (this.stackHeadPosition++, this.stackHeadPosition === this.stack.length) {
            const e = {
                type: void 0,
                size: 0,
                array: void 0,
                position: 0,
                readCount: 0,
                map: void 0,
                key: null
            };
            this.stack.push(e)
        }
        return this.stack[this.stackHeadPosition]
    }
    release(e) {
        if (this.stack[this.stackHeadPosition] !== e) throw new Error("Invalid stack state. Released state is not on top of the stack.");
        if (e.type === b5) {
            const n = e;
            n.size = 0, n.array = void 0, n.position = 0, n.type = void 0
        }
        if (e.type === Bf || e.type === sM) {
            const n = e;
            n.size = 0, n.map = void 0, n.readCount = 0, n.type = void 0
        }
        this.stackHeadPosition--
    }
    reset() {
        this.stack.length = 0, this.stackHeadPosition = -1
    }
}
const Xh = -1,
    $x = new DataView(new ArrayBuffer(0)),
    Spe = new Uint8Array($x.buffer);
try {
    $x.getInt8(0)
} catch (t) {
    if (!(t instanceof RangeError)) throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")
}
const TC = new RangeError("Insufficient data"),
    Tpe = new kpe;
let Ppe = class aM {
    constructor(e) {
        this.totalPos = 0, this.pos = 0, this.view = $x, this.bytes = Spe, this.headByte = Xh, this.stack = new $pe, this.entered = !1, this.extensionCodec = (e == null ? void 0 : e.extensionCodec) ? ? qm.defaultCodec, this.context = e == null ? void 0 : e.context, this.useBigInt64 = (e == null ? void 0 : e.useBigInt64) ? ? !1, this.rawStrings = (e == null ? void 0 : e.rawStrings) ? ? !1, this.maxStrLength = (e == null ? void 0 : e.maxStrLength) ? ? Qh, this.maxBinLength = (e == null ? void 0 : e.maxBinLength) ? ? Qh, this.maxArrayLength = (e == null ? void 0 : e.maxArrayLength) ? ? Qh, this.maxMapLength = (e == null ? void 0 : e.maxMapLength) ? ? Qh, this.maxExtLength = (e == null ? void 0 : e.maxExtLength) ? ? Qh, this.keyDecoder = (e == null ? void 0 : e.keyDecoder) !== void 0 ? e.keyDecoder : Tpe, this.mapKeyConverter = (e == null ? void 0 : e.mapKeyConverter) ? ? Ipe
    }
    clone() {
        return new aM({
            extensionCodec: this.extensionCodec,
            context: this.context,
            useBigInt64: this.useBigInt64,
            rawStrings: this.rawStrings,
            maxStrLength: this.maxStrLength,
            maxBinLength: this.maxBinLength,
            maxArrayLength: this.maxArrayLength,
            maxMapLength: this.maxMapLength,
            maxExtLength: this.maxExtLength,
            keyDecoder: this.keyDecoder
        })
    }
    reinitializeState() {
        this.totalPos = 0, this.headByte = Xh, this.stack.reset()
    }
    setBuffer(e) {
        const r = w5(e);
        this.bytes = r, this.view = new DataView(r.buffer, r.byteOffset, r.byteLength), this.pos = 0
    }
    appendBuffer(e) {
        if (this.headByte === Xh && !this.hasRemaining(1)) this.setBuffer(e);
        else {
            const r = this.bytes.subarray(this.pos),
                n = w5(e),
                i = new Uint8Array(r.length + n.length);
            i.set(r), i.set(n, r.length), this.setBuffer(i)
        }
    }
    hasRemaining(e) {
        return this.view.byteLength - this.pos >= e
    }
    createExtraByteError(e) {
        const {
            view: r,
            pos: n
        } = this;
        return new RangeError(`Extra ${r.byteLength-n} of ${r.byteLength} byte(s) found at buffer[${e}]`)
    }
    decode(e) {
        if (this.entered) return this.clone().decode(e);
        try {
            this.entered = !0, this.reinitializeState(), this.setBuffer(e);
            const r = this.doDecodeSync();
            if (this.hasRemaining(1)) throw this.createExtraByteError(this.pos);
            return r
        } finally {
            this.entered = !1
        }
    }* decodeMulti(e) {
        if (this.entered) {
            yield* this.clone().decodeMulti(e);
            return
        }
        try {
            for (this.entered = !0, this.reinitializeState(), this.setBuffer(e); this.hasRemaining(1);) yield this.doDecodeSync()
        } finally {
            this.entered = !1
        }
    }
    async decodeAsync(e) {
        if (this.entered) return this.clone().decodeAsync(e);
        try {
            this.entered = !0;
            let r = !1,
                n;
            for await (const o of e) {
                if (r) throw this.entered = !1, this.createExtraByteError(this.totalPos);
                this.appendBuffer(o);
                try {
                    n = this.doDecodeSync(), r = !0
                } catch (c) {
                    if (!(c instanceof RangeError)) throw c
                }
                this.totalPos += this.pos
            }
            if (r) {
                if (this.hasRemaining(1)) throw this.createExtraByteError(this.totalPos);
                return n
            }
            const {
                headByte: i,
                pos: s,
                totalPos: a
            } = this;
            throw new RangeError(`Insufficient data in parsing ${X2(i)} at ${a} (${s} in the current buffer)`)
        } finally {
            this.entered = !1
        }
    }
    decodeArrayStream(e) {
        return this.decodeMultiAsync(e, !0)
    }
    decodeStream(e) {
        return this.decodeMultiAsync(e, !1)
    }
    async * decodeMultiAsync(e, r) {
        if (this.entered) {
            yield* this.clone().decodeMultiAsync(e, r);
            return
        }
        try {
            this.entered = !0;
            let n = r,
                i = -1;
            for await (const s of e) {
                if (r && i === 0) throw this.createExtraByteError(this.totalPos);
                this.appendBuffer(s), n && (i = this.readArraySize(), n = !1, this.complete());
                try {
                    for (; yield this.doDecodeSync(), --i !== 0;);
                } catch (a) {
                    if (!(a instanceof RangeError)) throw a
                }
                this.totalPos += this.pos
            }
        } finally {
            this.entered = !1
        }
    }
    doDecodeSync() {
        e: for (;;) {
            const e = this.readHeadByte();
            let r;
            if (e >= 224) r = e - 256;
            else if (e < 192)
                if (e < 128) r = e;
                else if (e < 144) {
                const i = e - 128;
                if (i !== 0) {
                    this.pushMapState(i), this.complete();
                    continue e
                } else r = {}
            } else if (e < 160) {
                const i = e - 144;
                if (i !== 0) {
                    this.pushArrayState(i), this.complete();
                    continue e
                } else r = []
            } else {
                const i = e - 160;
                r = this.decodeString(i, 0)
            } else if (e === 192) r = null;
            else if (e === 194) r = !1;
            else if (e === 195) r = !0;
            else if (e === 202) r = this.readF32();
            else if (e === 203) r = this.readF64();
            else if (e === 204) r = this.readU8();
            else if (e === 205) r = this.readU16();
            else if (e === 206) r = this.readU32();
            else if (e === 207) this.useBigInt64 ? r = this.readU64AsBigInt() : r = this.readU64();
            else if (e === 208) r = this.readI8();
            else if (e === 209) r = this.readI16();
            else if (e === 210) r = this.readI32();
            else if (e === 211) this.useBigInt64 ? r = this.readI64AsBigInt() : r = this.readI64();
            else if (e === 217) {
                const i = this.lookU8();
                r = this.decodeString(i, 1)
            } else if (e === 218) {
                const i = this.lookU16();
                r = this.decodeString(i, 2)
            } else if (e === 219) {
                const i = this.lookU32();
                r = this.decodeString(i, 4)
            } else if (e === 220) {
                const i = this.readU16();
                if (i !== 0) {
                    this.pushArrayState(i), this.complete();
                    continue e
                } else r = []
            } else if (e === 221) {
                const i = this.readU32();
                if (i !== 0) {
                    this.pushArrayState(i), this.complete();
                    continue e
                } else r = []
            } else if (e === 222) {
                const i = this.readU16();
                if (i !== 0) {
                    this.pushMapState(i), this.complete();
                    continue e
                } else r = {}
            } else if (e === 223) {
                const i = this.readU32();
                if (i !== 0) {
                    this.pushMapState(i), this.complete();
                    continue e
                } else r = {}
            } else if (e === 196) {
                const i = this.lookU8();
                r = this.decodeBinary(i, 1)
            } else if (e === 197) {
                const i = this.lookU16();
                r = this.decodeBinary(i, 2)
            } else if (e === 198) {
                const i = this.lookU32();
                r = this.decodeBinary(i, 4)
            } else if (e === 212) r = this.decodeExtension(1, 0);
            else if (e === 213) r = this.decodeExtension(2, 0);
            else if (e === 214) r = this.decodeExtension(4, 0);
            else if (e === 215) r = this.decodeExtension(8, 0);
            else if (e === 216) r = this.decodeExtension(16, 0);
            else if (e === 199) {
                const i = this.lookU8();
                r = this.decodeExtension(i, 1)
            } else if (e === 200) {
                const i = this.lookU16();
                r = this.decodeExtension(i, 2)
            } else if (e === 201) {
                const i = this.lookU32();
                r = this.decodeExtension(i, 4)
            } else throw new Ji(`Unrecognized type byte: ${X2(e)}`);
            this.complete();
            const n = this.stack;
            for (; n.length > 0;) {
                const i = n.top();
                if (i.type === b5)
                    if (i.array[i.position] = r, i.position++, i.position === i.size) r = i.array, n.release(i);
                    else continue e;
                else if (i.type === Bf) {
                    if (r === "__proto__") throw new Ji("The key __proto__ is not allowed");
                    i.key = this.mapKeyConverter(r), i.type = sM;
                    continue e
                } else if (i.map[i.key] = r, i.readCount++, i.readCount === i.size) r = i.map, n.release(i);
                else {
                    i.key = null, i.type = Bf;
                    continue e
                }
            }
            return r
        }
    }
    readHeadByte() {
        return this.headByte === Xh && (this.headByte = this.readU8()), this.headByte
    }
    complete() {
        this.headByte = Xh
    }
    readArraySize() {
        const e = this.readHeadByte();
        switch (e) {
            case 220:
                return this.readU16();
            case 221:
                return this.readU32();
            default:
                {
                    if (e < 160) return e - 144;
                    throw new Ji(`Unrecognized array type byte: ${X2(e)}`)
                }
        }
    }
    pushMapState(e) {
        if (e > this.maxMapLength) throw new Ji(`Max length exceeded: map length (${e}) > maxMapLengthLength (${this.maxMapLength})`);
        this.stack.pushMapState(e)
    }
    pushArrayState(e) {
        if (e > this.maxArrayLength) throw new Ji(`Max length exceeded: array length (${e}) > maxArrayLength (${this.maxArrayLength})`);
        this.stack.pushArrayState(e)
    }
    decodeString(e, r) {
        return !this.rawStrings || this.stateIsMapKey() ? this.decodeUtf8String(e, r) : this.decodeBinary(e, r)
    }
    decodeUtf8String(e, r) {
        var s;
        if (e > this.maxStrLength) throw new Ji(`Max length exceeded: UTF-8 byte length (${e}) > maxStrLength (${this.maxStrLength})`);
        if (this.bytes.byteLength < this.pos + r + e) throw TC;
        const n = this.pos + r;
        let i;
        return this.stateIsMapKey() && ((s = this.keyDecoder) != null && s.canBeCached(e)) ? i = this.keyDecoder.decode(this.bytes, n, e) : i = ope(this.bytes, n, e), this.pos += r + e, i
    }
    stateIsMapKey() {
        return this.stack.length > 0 ? this.stack.top().type === Bf : !1
    }
    decodeBinary(e, r) {
        if (e > this.maxBinLength) throw new Ji(`Max length exceeded: bin length (${e}) > maxBinLength (${this.maxBinLength})`);
        if (!this.hasRemaining(e + r)) throw TC;
        const n = this.pos + r,
            i = this.bytes.subarray(n, n + e);
        return this.pos += r + e, i
    }
    decodeExtension(e, r) {
        if (e > this.maxExtLength) throw new Ji(`Max length exceeded: ext length (${e}) > maxExtLength (${this.maxExtLength})`);
        const n = this.view.getInt8(this.pos + r),
            i = this.decodeBinary(e, r + 1);
        return this.extensionCodec.decode(i, n, this.context)
    }
    lookU8() {
        return this.view.getUint8(this.pos)
    }
    lookU16() {
        return this.view.getUint16(this.pos)
    }
    lookU32() {
        return this.view.getUint32(this.pos)
    }
    readU8() {
        const e = this.view.getUint8(this.pos);
        return this.pos++, e
    }
    readI8() {
        const e = this.view.getInt8(this.pos);
        return this.pos++, e
    }
    readU16() {
        const e = this.view.getUint16(this.pos);
        return this.pos += 2, e
    }
    readI16() {
        const e = this.view.getInt16(this.pos);
        return this.pos += 2, e
    }
    readU32() {
        const e = this.view.getUint32(this.pos);
        return this.pos += 4, e
    }
    readI32() {
        const e = this.view.getInt32(this.pos);
        return this.pos += 4, e
    }
    readU64() {
        const e = lpe(this.view, this.pos);
        return this.pos += 8, e
    }
    readI64() {
        const e = nM(this.view, this.pos);
        return this.pos += 8, e
    }
    readU64AsBigInt() {
        const e = this.view.getBigUint64(this.pos);
        return this.pos += 8, e
    }
    readI64AsBigInt() {
        const e = this.view.getBigInt64(this.pos);
        return this.pos += 8, e
    }
    readF32() {
        const e = this.view.getFloat32(this.pos);
        return this.pos += 4, e
    }
    readF64() {
        const e = this.view.getFloat64(this.pos);
        return this.pos += 8, e
    }
};

function Npe(t, e) {
    return new Ppe(e).decode(t)
} /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function oM(t) {
    return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array"
}

function cM(t, e) {
    return Array.isArray(e) ? e.length === 0 ? !0 : t ? e.every(r => typeof r == "string") : e.every(r => Number.isSafeInteger(r)) : !1
}

function Hm(t, e) {
    if (typeof e != "string") throw new Error(`${t}: string expected`);
    return !0
}

function v0(t) {
    if (!Number.isSafeInteger(t)) throw new Error(`invalid integer: ${t}`)
}

function Vm(t) {
    if (!Array.isArray(t)) throw new Error("array expected")
}

function Gm(t, e) {
    if (!cM(!0, e)) throw new Error(`${t}: array of strings expected`)
}

function lM(t, e) {
    if (!cM(!1, e)) throw new Error(`${t}: array of numbers expected`)
}

function dM(...t) {
    const e = s => s,
        r = (s, a) => o => s(a(o)),
        n = t.map(s => s.encode).reduceRight(r, e),
        i = t.map(s => s.decode).reduce(r, e);
    return {
        encode: n,
        decode: i
    }
}

function uM(t) {
    const e = typeof t == "string" ? t.split("") : t,
        r = e.length;
    Gm("alphabet", e);
    const n = new Map(e.map((i, s) => [i, s]));
    return {
        encode: i => (Vm(i), i.map(s => {
            if (!Number.isSafeInteger(s) || s < 0 || s >= r) throw new Error(`alphabet.encode: digit index outside alphabet "${s}". Allowed: ${t}`);
            return e[s]
        })),
        decode: i => (Vm(i), i.map(s => {
            Hm("alphabet.decode", s);
            const a = n.get(s);
            if (a === void 0) throw new Error(`Unknown letter: "${s}". Allowed: ${t}`);
            return a
        }))
    }
}

function hM(t = "") {
    return Hm("join", t), {
        encode: e => (Gm("join.decode", e), e.join(t)),
        decode: e => (Hm("join.decode", e), e.split(t))
    }
}

function Ope(t, e = "=") {
    return v0(t), Hm("padding", e), {
        encode(r) {
            for (Gm("padding.encode", r); r.length * t % 8;) r.push(e);
            return r
        },
        decode(r) {
            Gm("padding.decode", r);
            let n = r.length;
            if (n * t % 8) throw new Error("padding: invalid, string should have whole number of bytes");
            for (; n > 0 && r[n - 1] === e; n--)
                if ((n - 1) * t % 8 === 0) throw new Error("padding: invalid, string has too much padding");
            return r.slice(0, n)
        }
    }
}

function PC(t, e, r) {
    if (e < 2) throw new Error(`convertRadix: invalid from=${e}, base cannot be less than 2`);
    if (r < 2) throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);
    if (Vm(t), !t.length) return [];
    let n = 0;
    const i = [],
        s = Array.from(t, o => {
            if (v0(o), o < 0 || o >= e) throw new Error(`invalid integer: ${o}`);
            return o
        }),
        a = s.length;
    for (;;) {
        let o = 0,
            c = !0;
        for (let l = n; l < a; l++) {
            const u = s[l],
                h = e * o,
                f = h + u;
            if (!Number.isSafeInteger(f) || h / e !== o || f - u !== h) throw new Error("convertRadix: carry overflow");
            const p = f / r;
            o = f % r;
            const g = Math.floor(p);
            if (s[l] = g, !Number.isSafeInteger(g) || g * r + o !== f) throw new Error("convertRadix: carry overflow");
            if (c) g ? c = !1 : n = l;
            else continue
        }
        if (i.push(o), c) break
    }
    for (let o = 0; o < t.length - 1 && t[o] === 0; o++) i.push(0);
    return i.reverse()
}
const fM = (t, e) => e === 0 ? t : fM(e, t % e),
    Km = (t, e) => t + (e - fM(t, e)),
    eb = (() => {
        let t = [];
        for (let e = 0; e < 40; e++) t.push(2 ** e);
        return t
    })();

function NC(t, e, r, n) {
    if (Vm(t), e <= 0 || e > 32) throw new Error(`convertRadix2: wrong from=${e}`);
    if (r <= 0 || r > 32) throw new Error(`convertRadix2: wrong to=${r}`);
    if (Km(e, r) > 32) throw new Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${Km(e,r)}`);
    let i = 0,
        s = 0;
    const a = eb[e],
        o = eb[r] - 1,
        c = [];
    for (const l of t) {
        if (v0(l), l >= a) throw new Error(`convertRadix2: invalid data word=${l} from=${e}`);
        if (i = i << e | l, s + e > 32) throw new Error(`convertRadix2: carry overflow pos=${s} from=${e}`);
        for (s += e; s >= r; s -= r) c.push((i >> s - r & o) >>> 0);
        const u = eb[s];
        if (u === void 0) throw new Error("invalid carry");
        i &= u - 1
    }
    if (i = i << r - s & o, !n && s >= e) throw new Error("Excess padding");
    if (!n && i > 0) throw new Error(`Non-zero padding: ${i}`);
    return n && s > 0 && c.push(i >>> 0), c
}

function jpe(t) {
    v0(t);
    const e = 2 ** 8;
    return {
        encode: r => {
            if (!oM(r)) throw new Error("radix.encode input should be Uint8Array");
            return PC(Array.from(r), e, t)
        },
        decode: r => (lM("radix.decode", r), Uint8Array.from(PC(r, t, e)))
    }
}

function Rpe(t, e = !1) {
    if (v0(t), t <= 0 || t > 32) throw new Error("radix2: bits should be in (0..32]");
    if (Km(8, t) > 32 || Km(t, 8) > 32) throw new Error("radix2: carry overflow");
    return {
        encode: r => {
            if (!oM(r)) throw new Error("radix2.encode input should be Uint8Array");
            return NC(Array.from(r), 8, t, !e)
        },
        decode: r => (lM("radix2.decode", r), Uint8Array.from(NC(r, t, 8, e)))
    }
}
const Mpe = dM(Rpe(5), uM("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), Ope(5), hM("")),
    Dpe = t => dM(jpe(58), uM(t), hM("")),
    cOe = Dpe("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),
    Lpe = t => JSON.stringify(t, (e, r) => typeof r == "bigint" ? r.toString() + "n" : r),
    Upe = t => {
        const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
            r = t.replace(e, '$1"$2n"$3');
        return JSON.parse(r, (n, i) => typeof i == "string" && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i)
    };

function yd(t) {
    if (typeof t != "string") throw new Error(`Cannot safe json parse value of type ${typeof t}`);
    try {
        return Upe(t)
    } catch {
        return t
    }
}

function ac(t) {
    return typeof t == "string" ? t : Lpe(t) || ""
}

function Fpe(t) {
    return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array"
}

function pM(t, ...e) {
    if (!Fpe(t)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length)
}

function OC(t, e = !0) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished) throw new Error("Hash#digest() has already been called")
}

function Bpe(t, e) {
    pM(t);
    const r = e.outputLen;
    if (t.length < r) throw new Error("digestInto() expects output buffer of length at least " + r)
}
const nu = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0; /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const tb = t => new DataView(t.buffer, t.byteOffset, t.byteLength);

function Wpe(t) {
    if (typeof t != "string") throw new Error("utf8ToBytes expected string, got " + typeof t);
    return new Uint8Array(new TextEncoder().encode(t))
}

function gM(t) {
    return typeof t == "string" && (t = Wpe(t)), pM(t), t
}
let zpe = class {
    clone() {
        return this._cloneInto()
    }
};

function qpe(t) {
    const e = n => t().update(gM(n)).digest(),
        r = t();
    return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e
}

function mM(t = 32) {
    if (nu && typeof nu.getRandomValues == "function") return nu.getRandomValues(new Uint8Array(t));
    if (nu && typeof nu.randomBytes == "function") return nu.randomBytes(t);
    throw new Error("crypto.getRandomValues must be defined")
}

function Hpe(t, e, r, n) {
    if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, r, n);
    const i = BigInt(32),
        s = BigInt(4294967295),
        a = Number(r >> i & s),
        o = Number(r & s),
        c = n ? 4 : 0,
        l = n ? 0 : 4;
    t.setUint32(e + c, a, n), t.setUint32(e + l, o, n)
}
let Vpe = class extends zpe {
    constructor(e, r, n, i) {
        super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = tb(this.buffer)
    }
    update(e) {
        OC(this);
        const {
            view: r,
            buffer: n,
            blockLen: i
        } = this;
        e = gM(e);
        const s = e.length;
        for (let a = 0; a < s;) {
            const o = Math.min(i - this.pos, s - a);
            if (o === i) {
                const c = tb(e);
                for (; i <= s - a; a += i) this.process(c, a);
                continue
            }
            n.set(e.subarray(a, a + o), this.pos), this.pos += o, a += o, this.pos === i && (this.process(r, 0), this.pos = 0)
        }
        return this.length += e.length, this.roundClean(), this
    }
    digestInto(e) {
        OC(this), Bpe(e, this), this.finished = !0;
        const {
            buffer: r,
            view: n,
            blockLen: i,
            isLE: s
        } = this;
        let {
            pos: a
        } = this;
        r[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > i - a && (this.process(n, 0), a = 0);
        for (let h = a; h < i; h++) r[h] = 0;
        Hpe(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);
        const o = tb(e),
            c = this.outputLen;
        if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const l = c / 4,
            u = this.get();
        if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
        for (let h = 0; h < l; h++) o.setUint32(4 * h, u[h], s)
    }
    digest() {
        const {
            buffer: e,
            outputLen: r
        } = this;
        this.digestInto(e);
        const n = e.slice(0, r);
        return this.destroy(), n
    }
    _cloneInto(e) {
        e || (e = new this.constructor), e.set(...this.get());
        const {
            blockLen: r,
            buffer: n,
            length: i,
            finished: s,
            destroyed: a,
            pos: o
        } = this;
        return e.length = i, e.pos = o, e.finished = s, e.destroyed = a, i % r && e.buffer.set(n), e
    }
};
const fg = BigInt(2 ** 32 - 1),
    v5 = BigInt(32);

function yM(t, e = !1) {
    return e ? {
        h: Number(t & fg),
        l: Number(t >> v5 & fg)
    } : {
        h: Number(t >> v5 & fg) | 0,
        l: Number(t & fg) | 0
    }
}

function Gpe(t, e = !1) {
    let r = new Uint32Array(t.length),
        n = new Uint32Array(t.length);
    for (let i = 0; i < t.length; i++) {
        const {
            h: s,
            l: a
        } = yM(t[i], e);
        [r[i], n[i]] = [s, a]
    }
    return [r, n]
}
const Kpe = (t, e) => BigInt(t >>> 0) << v5 | BigInt(e >>> 0),
    Ype = (t, e, r) => t >>> r,
    Zpe = (t, e, r) => t << 32 - r | e >>> r,
    Jpe = (t, e, r) => t >>> r | e << 32 - r,
    Qpe = (t, e, r) => t << 32 - r | e >>> r,
    Xpe = (t, e, r) => t << 64 - r | e >>> r - 32,
    e0e = (t, e, r) => t >>> r - 32 | e << 64 - r,
    t0e = (t, e) => e,
    r0e = (t, e) => t,
    n0e = (t, e, r) => t << r | e >>> 32 - r,
    i0e = (t, e, r) => e << r | t >>> 32 - r,
    s0e = (t, e, r) => e << r - 32 | t >>> 64 - r,
    a0e = (t, e, r) => t << r - 32 | e >>> 64 - r;

function o0e(t, e, r, n) {
    const i = (e >>> 0) + (n >>> 0);
    return {
        h: t + r + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    }
}
const c0e = (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0),
    l0e = (t, e, r, n) => e + r + n + (t / 2 ** 32 | 0) | 0,
    d0e = (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0),
    u0e = (t, e, r, n, i) => e + r + n + i + (t / 2 ** 32 | 0) | 0,
    h0e = (t, e, r, n, i) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0),
    f0e = (t, e, r, n, i, s) => e + r + n + i + s + (t / 2 ** 32 | 0) | 0,
    Nt = {
        fromBig: yM,
        split: Gpe,
        toBig: Kpe,
        shrSH: Ype,
        shrSL: Zpe,
        rotrSH: Jpe,
        rotrSL: Qpe,
        rotrBH: Xpe,
        rotrBL: e0e,
        rotr32H: t0e,
        rotr32L: r0e,
        rotlSH: n0e,
        rotlSL: i0e,
        rotlBH: s0e,
        rotlBL: a0e,
        add: o0e,
        add3L: c0e,
        add3H: l0e,
        add4L: d0e,
        add4H: u0e,
        add5H: f0e,
        add5L: h0e
    },
    [p0e, g0e] = Nt.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(t => BigInt(t))),
    Cc = new Uint32Array(80),
    Ac = new Uint32Array(80);
let m0e = class extends Vpe {
    constructor() {
        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
    }
    get() {
        const {
            Ah: e,
            Al: r,
            Bh: n,
            Bl: i,
            Ch: s,
            Cl: a,
            Dh: o,
            Dl: c,
            Eh: l,
            El: u,
            Fh: h,
            Fl: f,
            Gh: p,
            Gl: g,
            Hh: m,
            Hl: y
        } = this;
        return [e, r, n, i, s, a, o, c, l, u, h, f, p, g, m, y]
    }
    set(e, r, n, i, s, a, o, c, l, u, h, f, p, g, m, y) {
        this.Ah = e | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = s | 0, this.Cl = a | 0, this.Dh = o | 0, this.Dl = c | 0, this.Eh = l | 0, this.El = u | 0, this.Fh = h | 0, this.Fl = f | 0, this.Gh = p | 0, this.Gl = g | 0, this.Hh = m | 0, this.Hl = y | 0
    }
    process(e, r) {
        for (let E = 0; E < 16; E++, r += 4) Cc[E] = e.getUint32(r), Ac[E] = e.getUint32(r += 4);
        for (let E = 16; E < 80; E++) {
            const _ = Cc[E - 15] | 0,
                b = Ac[E - 15] | 0,
                A = Nt.rotrSH(_, b, 1) ^ Nt.rotrSH(_, b, 8) ^ Nt.shrSH(_, b, 7),
                I = Nt.rotrSL(_, b, 1) ^ Nt.rotrSL(_, b, 8) ^ Nt.shrSL(_, b, 7),
                T = Cc[E - 2] | 0,
                C = Ac[E - 2] | 0,
                $ = Nt.rotrSH(T, C, 19) ^ Nt.rotrBH(T, C, 61) ^ Nt.shrSH(T, C, 6),
                P = Nt.rotrSL(T, C, 19) ^ Nt.rotrBL(T, C, 61) ^ Nt.shrSL(T, C, 6),
                N = Nt.add4L(I, P, Ac[E - 7], Ac[E - 16]),
                R = Nt.add4H(N, A, $, Cc[E - 7], Cc[E - 16]);
            Cc[E] = R | 0, Ac[E] = N | 0
        }
        let {
            Ah: n,
            Al: i,
            Bh: s,
            Bl: a,
            Ch: o,
            Cl: c,
            Dh: l,
            Dl: u,
            Eh: h,
            El: f,
            Fh: p,
            Fl: g,
            Gh: m,
            Gl: y,
            Hh: w,
            Hl: x
        } = this;
        for (let E = 0; E < 80; E++) {
            const _ = Nt.rotrSH(h, f, 14) ^ Nt.rotrSH(h, f, 18) ^ Nt.rotrBH(h, f, 41),
                b = Nt.rotrSL(h, f, 14) ^ Nt.rotrSL(h, f, 18) ^ Nt.rotrBL(h, f, 41),
                A = h & p ^ ~h & m,
                I = f & g ^ ~f & y,
                T = Nt.add5L(x, b, I, g0e[E], Ac[E]),
                C = Nt.add5H(T, w, _, A, p0e[E], Cc[E]),
                $ = T | 0,
                P = Nt.rotrSH(n, i, 28) ^ Nt.rotrBH(n, i, 34) ^ Nt.rotrBH(n, i, 39),
                N = Nt.rotrSL(n, i, 28) ^ Nt.rotrBL(n, i, 34) ^ Nt.rotrBL(n, i, 39),
                R = n & s ^ n & o ^ s & o,
                D = i & a ^ i & c ^ a & c;
            w = m | 0, x = y | 0, m = p | 0, y = g | 0, p = h | 0, g = f | 0, {
                h,
                l: f
            } = Nt.add(l | 0, u | 0, C | 0, $ | 0), l = o | 0, u = c | 0, o = s | 0, c = a | 0, s = n | 0, a = i | 0;
            const S = Nt.add3L($, N, D);
            n = Nt.add3H(S, C, P, R), i = S | 0
        }({
            h: n,
            l: i
        } = Nt.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), {
            h: s,
            l: a
        } = Nt.add(this.Bh | 0, this.Bl | 0, s | 0, a | 0), {
            h: o,
            l: c
        } = Nt.add(this.Ch | 0, this.Cl | 0, o | 0, c | 0), {
            h: l,
            l: u
        } = Nt.add(this.Dh | 0, this.Dl | 0, l | 0, u | 0), {
            h,
            l: f
        } = Nt.add(this.Eh | 0, this.El | 0, h | 0, f | 0), {
            h: p,
            l: g
        } = Nt.add(this.Fh | 0, this.Fl | 0, p | 0, g | 0), {
            h: m,
            l: y
        } = Nt.add(this.Gh | 0, this.Gl | 0, m | 0, y | 0), {
            h: w,
            l: x
        } = Nt.add(this.Hh | 0, this.Hl | 0, w | 0, x | 0), this.set(n, i, s, a, o, c, l, u, h, f, p, g, m, y, w, x)
    }
    roundClean() {
        Cc.fill(0), Ac.fill(0)
    }
    destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
};
const y0e = qpe(() => new m0e); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Sx = BigInt(0),
    wM = BigInt(1),
    w0e = BigInt(2);

function Tx(t) {
    return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array"
}

function Px(t) {
    if (!Tx(t)) throw new Error("Uint8Array expected")
}

function rb(t, e) {
    if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e)
}
const b0e = Array.from({
    length: 256
}, (t, e) => e.toString(16).padStart(2, "0"));

function Nx(t) {
    Px(t);
    let e = "";
    for (let r = 0; r < t.length; r++) e += b0e[t[r]];
    return e
}

function bM(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    return t === "" ? Sx : BigInt("0x" + t)
}
const Co = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};

function jC(t) {
    if (t >= Co._0 && t <= Co._9) return t - Co._0;
    if (t >= Co.A && t <= Co.F) return t - (Co.A - 10);
    if (t >= Co.a && t <= Co.f) return t - (Co.a - 10)
}

function vM(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    const e = t.length,
        r = e / 2;
    if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
    const n = new Uint8Array(r);
    for (let i = 0, s = 0; i < r; i++, s += 2) {
        const a = jC(t.charCodeAt(s)),
            o = jC(t.charCodeAt(s + 1));
        if (a === void 0 || o === void 0) {
            const c = t[s] + t[s + 1];
            throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + s)
        }
        n[i] = a * 16 + o
    }
    return n
}

function v0e(t) {
    return bM(Nx(t))
}

function Qg(t) {
    return Px(t), bM(Nx(Uint8Array.from(t).reverse()))
}

function xM(t, e) {
    return vM(t.toString(16).padStart(e * 2, "0"))
}

function x5(t, e) {
    return xM(t, e).reverse()
}

function Ao(t, e, r) {
    let n;
    if (typeof e == "string") try {
            n = vM(e)
        } catch (s) {
            throw new Error(t + " must be hex string or Uint8Array, cause: " + s)
        } else if (Tx(e)) n = Uint8Array.from(e);
        else throw new Error(t + " must be hex string or Uint8Array");
    const i = n.length;
    if (typeof r == "number" && i !== r) throw new Error(t + " of length " + r + " expected, got " + i);
    return n
}

function RC(...t) {
    let e = 0;
    for (let n = 0; n < t.length; n++) {
        const i = t[n];
        Px(i), e += i.length
    }
    const r = new Uint8Array(e);
    for (let n = 0, i = 0; n < t.length; n++) {
        const s = t[n];
        r.set(s, i), i += s.length
    }
    return r
}
const nb = t => typeof t == "bigint" && Sx <= t;

function x0e(t, e, r) {
    return nb(t) && nb(e) && nb(r) && e <= t && t < r
}

function ef(t, e, r, n) {
    if (!x0e(e, r, n)) throw new Error("expected valid " + t + ": " + r + " <= n < " + n + ", got " + e)
}

function E0e(t) {
    let e;
    for (e = 0; t > Sx; t >>= wM, e += 1);
    return e
}
const _0e = t => (w0e << BigInt(t - 1)) - wM,
    C0e = {
        bigint: t => typeof t == "bigint",
        function: t => typeof t == "function",
        boolean: t => typeof t == "boolean",
        string: t => typeof t == "string",
        stringOrUint8Array: t => typeof t == "string" || Tx(t),
        isSafeInteger: t => Number.isSafeInteger(t),
        array: t => Array.isArray(t),
        field: (t, e) => e.Fp.isValid(t),
        hash: t => typeof t == "function" && Number.isSafeInteger(t.outputLen)
    };

function Ox(t, e, r = {}) {
    const n = (i, s, a) => {
        const o = C0e[s];
        if (typeof o != "function") throw new Error("invalid validator function");
        const c = t[i];
        if (!(a && c === void 0) && !o(c, t)) throw new Error("param " + String(i) + " is invalid. Expected " + s + ", got " + c)
    };
    for (const [i, s] of Object.entries(e)) n(i, s, !1);
    for (const [i, s] of Object.entries(r)) n(i, s, !0);
    return t
}

function MC(t) {
    const e = new WeakMap;
    return (r, ...n) => {
        const i = e.get(r);
        if (i !== void 0) return i;
        const s = t(r, ...n);
        return e.set(r, s), s
    }
}
const yn = BigInt(0),
    Wr = BigInt(1),
    jl = BigInt(2),
    A0e = BigInt(3),
    E5 = BigInt(4),
    DC = BigInt(5),
    LC = BigInt(8);

function on(t, e) {
    const r = t % e;
    return r >= yn ? r : e + r
}

function k0e(t, e, r) {
    if (e < yn) throw new Error("invalid exponent, negatives unsupported");
    if (r <= yn) throw new Error("invalid modulus");
    if (r === Wr) return yn;
    let n = Wr;
    for (; e > yn;) e & Wr && (n = n * t % r), t = t * t % r, e >>= Wr;
    return n
}

function Fa(t, e, r) {
    let n = t;
    for (; e-- > yn;) n *= n, n %= r;
    return n
}

function UC(t, e) {
    if (t === yn) throw new Error("invert: expected non-zero number");
    if (e <= yn) throw new Error("invert: expected positive modulus, got " + e);
    let r = on(t, e),
        n = e,
        i = yn,
        s = Wr;
    for (; r !== yn;) {
        const a = n / r,
            o = n % r,
            c = i - s * a;
        n = r, r = o, i = s, s = c
    }
    if (n !== Wr) throw new Error("invert: does not exist");
    return on(i, e)
}

function I0e(t) {
    const e = (t - Wr) / jl;
    let r, n, i;
    for (r = t - Wr, n = 0; r % jl === yn; r /= jl, n++);
    for (i = jl; i < t && k0e(i, e, t) !== t - Wr; i++)
        if (i > 1e3) throw new Error("Cannot find square root: likely non-prime P");
    if (n === 1) {
        const a = (t + Wr) / E5;
        return function(o, c) {
            const l = o.pow(c, a);
            if (!o.eql(o.sqr(l), c)) throw new Error("Cannot find square root");
            return l
        }
    }
    const s = (r + Wr) / jl;
    return function(a, o) {
        if (a.pow(o, e) === a.neg(a.ONE)) throw new Error("Cannot find square root");
        let c = n,
            l = a.pow(a.mul(a.ONE, i), r),
            u = a.pow(o, s),
            h = a.pow(o, r);
        for (; !a.eql(h, a.ONE);) {
            if (a.eql(h, a.ZERO)) return a.ZERO;
            let f = 1;
            for (let g = a.sqr(h); f < c && !a.eql(g, a.ONE); f++) g = a.sqr(g);
            const p = a.pow(l, Wr << BigInt(c - f - 1));
            l = a.sqr(p), u = a.mul(u, p), h = a.mul(h, l), c = f
        }
        return u
    }
}

function $0e(t) {
    if (t % E5 === A0e) {
        const e = (t + Wr) / E5;
        return function(r, n) {
            const i = r.pow(n, e);
            if (!r.eql(r.sqr(i), n)) throw new Error("Cannot find square root");
            return i
        }
    }
    if (t % LC === DC) {
        const e = (t - DC) / LC;
        return function(r, n) {
            const i = r.mul(n, jl),
                s = r.pow(i, e),
                a = r.mul(n, s),
                o = r.mul(r.mul(a, jl), s),
                c = r.mul(a, r.sub(o, r.ONE));
            if (!r.eql(r.sqr(c), n)) throw new Error("Cannot find square root");
            return c
        }
    }
    return I0e(t)
}
const S0e = (t, e) => (on(t, e) & Wr) === Wr,
    T0e = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

function P0e(t) {
    const e = {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger"
        },
        r = T0e.reduce((n, i) => (n[i] = "function", n), e);
    return Ox(t, r)
}

function N0e(t, e, r) {
    if (r < yn) throw new Error("invalid exponent, negatives unsupported");
    if (r === yn) return t.ONE;
    if (r === Wr) return e;
    let n = t.ONE,
        i = e;
    for (; r > yn;) r & Wr && (n = t.mul(n, i)), i = t.sqr(i), r >>= Wr;
    return n
}

function O0e(t, e) {
    const r = new Array(e.length),
        n = e.reduce((s, a, o) => t.is0(a) ? s : (r[o] = s, t.mul(s, a)), t.ONE),
        i = t.inv(n);
    return e.reduceRight((s, a, o) => t.is0(a) ? s : (r[o] = t.mul(s, r[o]), t.mul(s, a)), i), r
}

function EM(t, e) {
    const r = e !== void 0 ? e : t.toString(2).length,
        n = Math.ceil(r / 8);
    return {
        nBitLength: r,
        nByteLength: n
    }
}

function _M(t, e, r = !1, n = {}) {
    if (t <= yn) throw new Error("invalid field: expected ORDER > 0, got " + t);
    const {
        nBitLength: i,
        nByteLength: s
    } = EM(t, e);
    if (s > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let a;
    const o = Object.freeze({
        ORDER: t,
        isLE: r,
        BITS: i,
        BYTES: s,
        MASK: _0e(i),
        ZERO: yn,
        ONE: Wr,
        create: c => on(c, t),
        isValid: c => {
            if (typeof c != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c);
            return yn <= c && c < t
        },
        is0: c => c === yn,
        isOdd: c => (c & Wr) === Wr,
        neg: c => on(-c, t),
        eql: (c, l) => c === l,
        sqr: c => on(c * c, t),
        add: (c, l) => on(c + l, t),
        sub: (c, l) => on(c - l, t),
        mul: (c, l) => on(c * l, t),
        pow: (c, l) => N0e(o, c, l),
        div: (c, l) => on(c * UC(l, t), t),
        sqrN: c => c * c,
        addN: (c, l) => c + l,
        subN: (c, l) => c - l,
        mulN: (c, l) => c * l,
        inv: c => UC(c, t),
        sqrt: n.sqrt || (c => (a || (a = $0e(t)), a(o, c))),
        invertBatch: c => O0e(o, c),
        cmov: (c, l, u) => u ? l : c,
        toBytes: c => r ? x5(c, s) : xM(c, s),
        fromBytes: c => {
            if (c.length !== s) throw new Error("Field.fromBytes: expected " + s + " bytes, got " + c.length);
            return r ? Qg(c) : v0e(c)
        }
    });
    return Object.freeze(o)
}
const FC = BigInt(0),
    pg = BigInt(1);

function ib(t, e) {
    const r = e.negate();
    return t ? r : e
}

function CM(t, e) {
    if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t)
}

function sb(t, e) {
    CM(t, e);
    const r = Math.ceil(e / t) + 1,
        n = 2 ** (t - 1);
    return {
        windows: r,
        windowSize: n
    }
}

function j0e(t, e) {
    if (!Array.isArray(t)) throw new Error("array expected");
    t.forEach((r, n) => {
        if (!(r instanceof e)) throw new Error("invalid point at index " + n)
    })
}

function R0e(t, e) {
    if (!Array.isArray(t)) throw new Error("array of scalars expected");
    t.forEach((r, n) => {
        if (!e.isValid(r)) throw new Error("invalid scalar at index " + n)
    })
}
const ab = new WeakMap,
    AM = new WeakMap;

function ob(t) {
    return AM.get(t) || 1
}

function M0e(t, e) {
    return {
        constTimeNegate: ib,
        hasPrecomputes(r) {
            return ob(r) !== 1
        },
        unsafeLadder(r, n, i = t.ZERO) {
            let s = r;
            for (; n > FC;) n & pg && (i = i.add(s)), s = s.double(), n >>= pg;
            return i
        },
        precomputeWindow(r, n) {
            const {
                windows: i,
                windowSize: s
            } = sb(n, e), a = [];
            let o = r,
                c = o;
            for (let l = 0; l < i; l++) {
                c = o, a.push(c);
                for (let u = 1; u < s; u++) c = c.add(o), a.push(c);
                o = c.double()
            }
            return a
        },
        wNAF(r, n, i) {
            const {
                windows: s,
                windowSize: a
            } = sb(r, e);
            let o = t.ZERO,
                c = t.BASE;
            const l = BigInt(2 ** r - 1),
                u = 2 ** r,
                h = BigInt(r);
            for (let f = 0; f < s; f++) {
                const p = f * a;
                let g = Number(i & l);
                i >>= h, g > a && (g -= u, i += pg);
                const m = p,
                    y = p + Math.abs(g) - 1,
                    w = f % 2 !== 0,
                    x = g < 0;
                g === 0 ? c = c.add(ib(w, n[m])) : o = o.add(ib(x, n[y]))
            }
            return {
                p: o,
                f: c
            }
        },
        wNAFUnsafe(r, n, i, s = t.ZERO) {
            const {
                windows: a,
                windowSize: o
            } = sb(r, e), c = BigInt(2 ** r - 1), l = 2 ** r, u = BigInt(r);
            for (let h = 0; h < a; h++) {
                const f = h * o;
                if (i === FC) break;
                let p = Number(i & c);
                if (i >>= u, p > o && (p -= l, i += pg), p === 0) continue;
                let g = n[f + Math.abs(p) - 1];
                p < 0 && (g = g.negate()), s = s.add(g)
            }
            return s
        },
        getPrecomputes(r, n, i) {
            let s = ab.get(n);
            return s || (s = this.precomputeWindow(n, r), r !== 1 && ab.set(n, i(s))), s
        },
        wNAFCached(r, n, i) {
            const s = ob(r);
            return this.wNAF(s, this.getPrecomputes(s, r, i), n)
        },
        wNAFCachedUnsafe(r, n, i, s) {
            const a = ob(r);
            return a === 1 ? this.unsafeLadder(r, n, s) : this.wNAFUnsafe(a, this.getPrecomputes(a, r, i), n, s)
        },
        setWindowSize(r, n) {
            CM(n, e), AM.set(r, n), ab.delete(r)
        }
    }
}

function D0e(t, e, r, n) {
    if (j0e(r, t), R0e(n, e), r.length !== n.length) throw new Error("arrays of points and scalars must have equal length");
    const i = t.ZERO,
        s = E0e(BigInt(r.length)),
        a = s > 12 ? s - 3 : s > 4 ? s - 2 : s ? 2 : 1,
        o = (1 << a) - 1,
        c = new Array(o + 1).fill(i),
        l = Math.floor((e.BITS - 1) / a) * a;
    let u = i;
    for (let h = l; h >= 0; h -= a) {
        c.fill(i);
        for (let p = 0; p < n.length; p++) {
            const g = n[p],
                m = Number(g >> BigInt(h) & BigInt(o));
            c[m] = c[m].add(r[p])
        }
        let f = i;
        for (let p = c.length - 1, g = i; p > 0; p--) g = g.add(c[p]), f = f.add(g);
        if (u = u.add(f), h !== 0)
            for (let p = 0; p < a; p++) u = u.double()
    }
    return u
}

function L0e(t) {
    return P0e(t.Fp), Ox(t, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({ ...EM(t.n, t.nBitLength),
        ...t,
        p: t.Fp.ORDER
    })
}
const Ys = BigInt(0),
    _i = BigInt(1),
    gg = BigInt(2),
    U0e = BigInt(8),
    F0e = {
        zip215: !0
    };

function B0e(t) {
    const e = L0e(t);
    return Ox(t, {
        hash: "function",
        a: "bigint",
        d: "bigint",
        randomBytes: "function"
    }, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
    }), Object.freeze({ ...e
    })
}

function W0e(t) {
    const e = B0e(t),
        {
            Fp: r,
            n,
            prehash: i,
            hash: s,
            randomBytes: a,
            nByteLength: o,
            h: c
        } = e,
        l = gg << BigInt(o * 8) - _i,
        u = r.create,
        h = _M(e.n, e.nBitLength),
        f = e.uvRatio || ((S, O) => {
            try {
                return {
                    isValid: !0,
                    value: r.sqrt(S * r.inv(O))
                }
            } catch {
                return {
                    isValid: !1,
                    value: Ys
                }
            }
        }),
        p = e.adjustScalarBytes || (S => S),
        g = e.domain || ((S, O, M) => {
            if (rb("phflag", M), O.length || M) throw new Error("Contexts/pre-hash are not supported");
            return S
        });

    function m(S, O) {
        ef("coordinate " + S, O, Ys, l)
    }

    function y(S) {
        if (!(S instanceof E)) throw new Error("ExtendedPoint expected")
    }
    const w = MC((S, O) => {
            const {
                ex: M,
                ey: U,
                ez: k
            } = S, F = S.is0();
            O == null && (O = F ? U0e : r.inv(k));
            const q = u(M * O),
                W = u(U * O),
                K = u(k * O);
            if (F) return {
                x: Ys,
                y: _i
            };
            if (K !== _i) throw new Error("invZ was invalid");
            return {
                x: q,
                y: W
            }
        }),
        x = MC(S => {
            const {
                a: O,
                d: M
            } = e;
            if (S.is0()) throw new Error("bad point: ZERO");
            const {
                ex: U,
                ey: k,
                ez: F,
                et: q
            } = S, W = u(U * U), K = u(k * k), H = u(F * F), j = u(H * H), V = u(W * O), Y = u(H * u(V + K)), X = u(j + u(M * u(W * K)));
            if (Y !== X) throw new Error("bad point: equation left != right (1)");
            const ne = u(U * k),
                ae = u(F * q);
            if (ne !== ae) throw new Error("bad point: equation left != right (2)");
            return !0
        });
    class E {
        constructor(O, M, U, k) {
            this.ex = O, this.ey = M, this.ez = U, this.et = k, m("x", O), m("y", M), m("z", U), m("t", k), Object.freeze(this)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static fromAffine(O) {
            if (O instanceof E) throw new Error("extended point not allowed");
            const {
                x: M,
                y: U
            } = O || {};
            return m("x", M), m("y", U), new E(M, U, _i, u(M * U))
        }
        static normalizeZ(O) {
            const M = r.invertBatch(O.map(U => U.ez));
            return O.map((U, k) => U.toAffine(M[k])).map(E.fromAffine)
        }
        static msm(O, M) {
            return D0e(E, h, O, M)
        }
        _setWindowSize(O) {
            A.setWindowSize(this, O)
        }
        assertValidity() {
            x(this)
        }
        equals(O) {
            y(O);
            const {
                ex: M,
                ey: U,
                ez: k
            } = this, {
                ex: F,
                ey: q,
                ez: W
            } = O, K = u(M * W), H = u(F * k), j = u(U * W), V = u(q * k);
            return K === H && j === V
        }
        is0() {
            return this.equals(E.ZERO)
        }
        negate() {
            return new E(u(-this.ex), this.ey, this.ez, u(-this.et))
        }
        double() {
            const {
                a: O
            } = e, {
                ex: M,
                ey: U,
                ez: k
            } = this, F = u(M * M), q = u(U * U), W = u(gg * u(k * k)), K = u(O * F), H = M + U, j = u(u(H * H) - F - q), V = K + q, Y = V - W, X = K - q, ne = u(j * Y), ae = u(V * X), ue = u(j * X), he = u(Y * V);
            return new E(ne, ae, he, ue)
        }
        add(O) {
            y(O);
            const {
                a: M,
                d: U
            } = e, {
                ex: k,
                ey: F,
                ez: q,
                et: W
            } = this, {
                ex: K,
                ey: H,
                ez: j,
                et: V
            } = O;
            if (M === BigInt(-1)) {
                const xe = u((F - k) * (H + K)),
                    ie = u((F + k) * (H - K)),
                    Ee = u(ie - xe);
                if (Ee === Ys) return this.double();
                const ft = u(q * gg * V),
                    Ae = u(W * gg * j),
                    Le = Ae + ft,
                    Te = ie + xe,
                    Ue = Ae - ft,
                    De = u(Le * Ee),
                    We = u(Te * Ue),
                    dt = u(Le * Ue),
                    He = u(Ee * Te);
                return new E(De, We, He, dt)
            }
            const Y = u(k * K),
                X = u(F * H),
                ne = u(W * U * V),
                ae = u(q * j),
                ue = u((k + F) * (K + H) - Y - X),
                he = ae - ne,
                fe = ae + ne,
                de = u(X - M * Y),
                ye = u(ue * he),
                Be = u(fe * de),
                ce = u(ue * de),
                Ie = u(he * fe);
            return new E(ye, Be, Ie, ce)
        }
        subtract(O) {
            return this.add(O.negate())
        }
        wNAF(O) {
            return A.wNAFCached(this, O, E.normalizeZ)
        }
        multiply(O) {
            const M = O;
            ef("scalar", M, _i, n);
            const {
                p: U,
                f: k
            } = this.wNAF(M);
            return E.normalizeZ([U, k])[0]
        }
        multiplyUnsafe(O, M = E.ZERO) {
            const U = O;
            return ef("scalar", U, Ys, n), U === Ys ? b : this.is0() || U === _i ? this : A.wNAFCachedUnsafe(this, U, E.normalizeZ, M)
        }
        isSmallOrder() {
            return this.multiplyUnsafe(c).is0()
        }
        isTorsionFree() {
            return A.unsafeLadder(this, n).is0()
        }
        toAffine(O) {
            return w(this, O)
        }
        clearCofactor() {
            const {
                h: O
            } = e;
            return O === _i ? this : this.multiplyUnsafe(O)
        }
        static fromHex(O, M = !1) {
            const {
                d: U,
                a: k
            } = e, F = r.BYTES;
            O = Ao("pointHex", O, F), rb("zip215", M);
            const q = O.slice(),
                W = O[F - 1];
            q[F - 1] = W & -129;
            const K = Qg(q),
                H = M ? l : r.ORDER;
            ef("pointHex.y", K, Ys, H);
            const j = u(K * K),
                V = u(j - _i),
                Y = u(U * j - k);
            let {
                isValid: X,
                value: ne
            } = f(V, Y);
            if (!X) throw new Error("Point.fromHex: invalid y coordinate");
            const ae = (ne & _i) === _i,
                ue = (W & 128) !== 0;
            if (!M && ne === Ys && ue) throw new Error("Point.fromHex: x=0 and x_0=1");
            return ue !== ae && (ne = u(-ne)), E.fromAffine({
                x: ne,
                y: K
            })
        }
        static fromPrivateKey(O) {
            return C(O).point
        }
        toRawBytes() {
            const {
                x: O,
                y: M
            } = this.toAffine(), U = x5(M, r.BYTES);
            return U[U.length - 1] |= O & _i ? 128 : 0, U
        }
        toHex() {
            return Nx(this.toRawBytes())
        }
    }
    E.BASE = new E(e.Gx, e.Gy, _i, u(e.Gx * e.Gy)), E.ZERO = new E(Ys, _i, _i, Ys);
    const {
        BASE: _,
        ZERO: b
    } = E, A = M0e(E, o * 8);

    function I(S) {
        return on(S, n)
    }

    function T(S) {
        return I(Qg(S))
    }

    function C(S) {
        const O = r.BYTES;
        S = Ao("private key", S, O);
        const M = Ao("hashed private key", s(S), 2 * O),
            U = p(M.slice(0, O)),
            k = M.slice(O, 2 * O),
            F = T(U),
            q = _.multiply(F),
            W = q.toRawBytes();
        return {
            head: U,
            prefix: k,
            scalar: F,
            point: q,
            pointBytes: W
        }
    }

    function $(S) {
        return C(S).pointBytes
    }

    function P(S = new Uint8Array, ...O) {
        const M = RC(...O);
        return T(s(g(M, Ao("context", S), !!i)))
    }

    function N(S, O, M = {}) {
        S = Ao("message", S), i && (S = i(S));
        const {
            prefix: U,
            scalar: k,
            pointBytes: F
        } = C(O), q = P(M.context, U, S), W = _.multiply(q).toRawBytes(), K = P(M.context, W, F, S), H = I(q + K * k);
        ef("signature.s", H, Ys, n);
        const j = RC(W, x5(H, r.BYTES));
        return Ao("result", j, r.BYTES * 2)
    }
    const R = F0e;

    function D(S, O, M, U = R) {
        const {
            context: k,
            zip215: F
        } = U, q = r.BYTES;
        S = Ao("signature", S, 2 * q), O = Ao("message", O), M = Ao("publicKey", M, q), F !== void 0 && rb("zip215", F), i && (O = i(O));
        const W = Qg(S.slice(q, 2 * q));
        let K, H, j;
        try {
            K = E.fromHex(M, F), H = E.fromHex(S.slice(0, q), F), j = _.multiplyUnsafe(W)
        } catch {
            return !1
        }
        if (!F && K.isSmallOrder()) return !1;
        const V = P(k, H.toRawBytes(), K.toRawBytes(), O);
        return H.add(K.multiplyUnsafe(V)).subtract(j).clearCofactor().equals(E.ZERO)
    }
    return _._setWindowSize(8), {
        CURVE: e,
        getPublicKey: $,
        sign: N,
        verify: D,
        ExtendedPoint: E,
        utils: {
            getExtendedPublicKey: C,
            randomPrivateKey: () => a(r.BYTES),
            precompute(S = 8, O = E.BASE) {
                return O._setWindowSize(S), O.multiply(BigInt(3)), O
            }
        }
    }
}
BigInt(0), BigInt(1);
const jx = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
    BC = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const z0e = BigInt(1),
    WC = BigInt(2);
BigInt(3);
const q0e = BigInt(5),
    H0e = BigInt(8);

function V0e(t) {
    const e = BigInt(10),
        r = BigInt(20),
        n = BigInt(40),
        i = BigInt(80),
        s = jx,
        a = t * t % s * t % s,
        o = Fa(a, WC, s) * a % s,
        c = Fa(o, z0e, s) * t % s,
        l = Fa(c, q0e, s) * c % s,
        u = Fa(l, e, s) * l % s,
        h = Fa(u, r, s) * u % s,
        f = Fa(h, n, s) * h % s,
        p = Fa(f, i, s) * f % s,
        g = Fa(p, i, s) * f % s,
        m = Fa(g, e, s) * l % s;
    return {
        pow_p_5_8: Fa(m, WC, s) * t % s,
        b2: a
    }
}

function G0e(t) {
    return t[0] &= 248, t[31] &= 127, t[31] |= 64, t
}

function K0e(t, e) {
    const r = jx,
        n = on(e * e * e, r),
        i = on(n * n * e, r),
        s = V0e(t * i).pow_p_5_8;
    let a = on(t * n * s, r);
    const o = on(e * a * a, r),
        c = a,
        l = on(a * BC, r),
        u = o === t,
        h = o === on(-t, r),
        f = o === on(-t * BC, r);
    return u && (a = c), (h || f) && (a = l), S0e(a, r) && (a = on(-a, r)), {
        isValid: u || h,
        value: a
    }
}
const Y0e = _M(jx, void 0, !0),
    Z0e = {
        a: BigInt(-1),
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        Fp: Y0e,
        n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
        h: H0e,
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
        hash: y0e,
        randomBytes: mM,
        adjustScalarBytes: G0e,
        uvRatio: K0e
    },
    kM = W0e(Z0e),
    J0e = "EdDSA",
    Q0e = "JWT",
    Ym = ".",
    Cy = "base64url",
    IM = "utf8",
    $M = "utf8",
    X0e = ":",
    ege = "did",
    tge = "key",
    zC = "base58btc",
    rge = "z",
    nge = "K36",
    ige = 32;

function Rx(t) {
    return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t
}

function SM(t = 0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Rx(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t)
}

function TM(t, e) {
    e || (e = t.reduce((i, s) => i + s.length, 0));
    const r = SM(e);
    let n = 0;
    for (const i of t) r.set(i, n), n += i.length;
    return Rx(r)
}

function sge(t, e) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    for (var r = new Uint8Array(256), n = 0; n < r.length; n++) r[n] = 255;
    for (var i = 0; i < t.length; i++) {
        var s = t.charAt(i),
            a = s.charCodeAt(0);
        if (r[a] !== 255) throw new TypeError(s + " is ambiguous");
        r[a] = i
    }
    var o = t.length,
        c = t.charAt(0),
        l = Math.log(o) / Math.log(256),
        u = Math.log(256) / Math.log(o);

    function h(g) {
        if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))), !(g instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (g.length === 0) return "";
        for (var m = 0, y = 0, w = 0, x = g.length; w !== x && g[w] === 0;) w++, m++;
        for (var E = (x - w) * u + 1 >>> 0, _ = new Uint8Array(E); w !== x;) {
            for (var b = g[w], A = 0, I = E - 1;
                (b !== 0 || A < y) && I !== -1; I--, A++) b += 256 * _[I] >>> 0, _[I] = b % o >>> 0, b = b / o >>> 0;
            if (b !== 0) throw new Error("Non-zero carry");
            y = A, w++
        }
        for (var T = E - y; T !== E && _[T] === 0;) T++;
        for (var C = c.repeat(m); T < E; ++T) C += t.charAt(_[T]);
        return C
    }

    function f(g) {
        if (typeof g != "string") throw new TypeError("Expected String");
        if (g.length === 0) return new Uint8Array;
        var m = 0;
        if (g[m] !== " ") {
            for (var y = 0, w = 0; g[m] === c;) y++, m++;
            for (var x = (g.length - m) * l + 1 >>> 0, E = new Uint8Array(x); g[m];) {
                var _ = r[g.charCodeAt(m)];
                if (_ === 255) return;
                for (var b = 0, A = x - 1;
                    (_ !== 0 || b < w) && A !== -1; A--, b++) _ += o * E[A] >>> 0, E[A] = _ % 256 >>> 0, _ = _ / 256 >>> 0;
                if (_ !== 0) throw new Error("Non-zero carry");
                w = b, m++
            }
            if (g[m] !== " ") {
                for (var I = x - w; I !== x && E[I] === 0;) I++;
                for (var T = new Uint8Array(y + (x - I)), C = y; I !== x;) T[C++] = E[I++];
                return T
            }
        }
    }

    function p(g) {
        var m = f(g);
        if (m) return m;
        throw new Error(`Non-${e} character`)
    }
    return {
        encode: h,
        decodeUnsafe: f,
        decode: p
    }
}
var age = sge,
    oge = age;
const PM = t => {
        if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t;
        if (t instanceof ArrayBuffer) return new Uint8Array(t);
        if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
        throw new Error("Unknown type, must be binary type")
    },
    cge = t => new TextEncoder().encode(t),
    lge = t => new TextDecoder().decode(t);
let dge = class {
        constructor(e, r, n) {
            this.name = e, this.prefix = r, this.baseEncode = n
        }
        encode(e) {
            if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
            throw Error("Unknown type, must be binary type")
        }
    },
    uge = class {
        constructor(e, r, n) {
            if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
            this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n
        }
        decode(e) {
            if (typeof e == "string") {
                if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
                return this.baseDecode(e.slice(this.prefix.length))
            } else throw Error("Can only multibase decode strings")
        }
        or(e) {
            return NM(this, e)
        }
    },
    hge = class {
        constructor(e) {
            this.decoders = e
        }
        or(e) {
            return NM(this, e)
        }
        decode(e) {
            const r = e[0],
                n = this.decoders[r];
            if (n) return n.decode(e);
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
        }
    };
const NM = (t, e) => new hge({ ...t.decoders || {
        [t.prefix]: t
    },
    ...e.decoders || {
        [e.prefix]: e
    }
});
let fge = class {
    constructor(e, r, n, i) {
        this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new dge(e, r, n), this.decoder = new uge(e, r, i)
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
};
const Ay = ({
        name: t,
        prefix: e,
        encode: r,
        decode: n
    }) => new fge(t, e, r, n),
    x0 = ({
        prefix: t,
        name: e,
        alphabet: r
    }) => {
        const {
            encode: n,
            decode: i
        } = oge(r, e);
        return Ay({
            prefix: t,
            name: e,
            encode: n,
            decode: s => PM(i(s))
        })
    },
    pge = (t, e, r, n) => {
        const i = {};
        for (let u = 0; u < e.length; ++u) i[e[u]] = u;
        let s = t.length;
        for (; t[s - 1] === "=";) --s;
        const a = new Uint8Array(s * r / 8 | 0);
        let o = 0,
            c = 0,
            l = 0;
        for (let u = 0; u < s; ++u) {
            const h = i[t[u]];
            if (h === void 0) throw new SyntaxError(`Non-${n} character`);
            c = c << r | h, o += r, o >= 8 && (o -= 8, a[l++] = 255 & c >> o)
        }
        if (o >= r || 255 & c << 8 - o) throw new SyntaxError("Unexpected end of data");
        return a
    },
    gge = (t, e, r) => {
        const n = e[e.length - 1] === "=",
            i = (1 << r) - 1;
        let s = "",
            a = 0,
            o = 0;
        for (let c = 0; c < t.length; ++c)
            for (o = o << 8 | t[c], a += 8; a > r;) a -= r, s += e[i & o >> a];
        if (a && (s += e[i & o << r - a]), n)
            for (; s.length * r & 7;) s += "=";
        return s
    },
    Mn = ({
        name: t,
        prefix: e,
        bitsPerChar: r,
        alphabet: n
    }) => Ay({
        prefix: e,
        name: t,
        encode(i) {
            return gge(i, n, r)
        },
        decode(i) {
            return pge(i, n, r, t)
        }
    }),
    mge = Ay({
        prefix: "\0",
        name: "identity",
        encode: t => lge(t),
        decode: t => cge(t)
    });
var yge = Object.freeze({
    __proto__: null,
    identity: mge
});
const wge = Mn({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
});
var bge = Object.freeze({
    __proto__: null,
    base2: wge
});
const vge = Mn({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
});
var xge = Object.freeze({
    __proto__: null,
    base8: vge
});
const Ege = x0({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
});
var _ge = Object.freeze({
    __proto__: null,
    base10: Ege
});
const Cge = Mn({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
    }),
    Age = Mn({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
    });
var kge = Object.freeze({
    __proto__: null,
    base16: Cge,
    base16upper: Age
});
const Ige = Mn({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
    }),
    $ge = Mn({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
    }),
    Sge = Mn({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
    }),
    Tge = Mn({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
    }),
    Pge = Mn({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
    }),
    Nge = Mn({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
    }),
    Oge = Mn({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
    }),
    jge = Mn({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
    }),
    Rge = Mn({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
    });
var Mge = Object.freeze({
    __proto__: null,
    base32: Ige,
    base32upper: $ge,
    base32pad: Sge,
    base32padupper: Tge,
    base32hex: Pge,
    base32hexupper: Nge,
    base32hexpad: Oge,
    base32hexpadupper: jge,
    base32z: Rge
});
const Dge = x0({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    }),
    Lge = x0({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
var Uge = Object.freeze({
    __proto__: null,
    base36: Dge,
    base36upper: Lge
});
const Fge = x0({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }),
    Bge = x0({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
var Wge = Object.freeze({
    __proto__: null,
    base58btc: Fge,
    base58flickr: Bge
});
const zge = Mn({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
    }),
    qge = Mn({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
    }),
    Hge = Mn({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
    }),
    Vge = Mn({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
    });
var Gge = Object.freeze({
    __proto__: null,
    base64: zge,
    base64pad: qge,
    base64url: Hge,
    base64urlpad: Vge
});
const OM = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),
    Kge = OM.reduce((t, e, r) => (t[r] = e, t), []),
    Yge = OM.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);

function Zge(t) {
    return t.reduce((e, r) => (e += Kge[r], e), "")
}

function Jge(t) {
    const e = [];
    for (const r of t) {
        const n = Yge[r.codePointAt(0)];
        if (n === void 0) throw new Error(`Non-base256emoji character: ${r}`);
        e.push(n)
    }
    return new Uint8Array(e)
}
const Qge = Ay({
    prefix: "🚀",
    name: "base256emoji",
    encode: Zge,
    decode: Jge
});
var Xge = Object.freeze({
        __proto__: null,
        base256emoji: Qge
    }),
    eme = jM,
    qC = 128,
    tme = -128,
    rme = Math.pow(2, 31);

function jM(t, e, r) {
    e = e || [], r = r || 0;
    for (var n = r; t >= rme;) e[r++] = t & 255 | qC, t /= 128;
    for (; t & tme;) e[r++] = t & 255 | qC, t >>>= 7;
    return e[r] = t | 0, jM.bytes = r - n + 1, e
}
var nme = _5,
    ime = 128,
    HC = 127;

function _5(t, n) {
    var r = 0,
        n = n || 0,
        i = 0,
        s = n,
        a, o = t.length;
    do {
        if (s >= o) throw _5.bytes = 0, new RangeError("Could not decode varint");
        a = t[s++], r += i < 28 ? (a & HC) << i : (a & HC) * Math.pow(2, i), i += 7
    } while (a >= ime);
    return _5.bytes = s - n, r
}
var sme = Math.pow(2, 7),
    ame = Math.pow(2, 14),
    ome = Math.pow(2, 21),
    cme = Math.pow(2, 28),
    lme = Math.pow(2, 35),
    dme = Math.pow(2, 42),
    ume = Math.pow(2, 49),
    hme = Math.pow(2, 56),
    fme = Math.pow(2, 63),
    pme = function(t) {
        return t < sme ? 1 : t < ame ? 2 : t < ome ? 3 : t < cme ? 4 : t < lme ? 5 : t < dme ? 6 : t < ume ? 7 : t < hme ? 8 : t < fme ? 9 : 10
    },
    gme = {
        encode: eme,
        decode: nme,
        encodingLength: pme
    },
    RM = gme;
const VC = (t, e, r = 0) => (RM.encode(t, e, r), e),
    GC = t => RM.encodingLength(t),
    C5 = (t, e) => {
        const r = e.byteLength,
            n = GC(t),
            i = n + GC(r),
            s = new Uint8Array(i + r);
        return VC(t, s, 0), VC(r, s, n), s.set(e, i), new mme(t, r, e, s)
    };
let mme = class {
    constructor(e, r, n, i) {
        this.code = e, this.size = r, this.digest = n, this.bytes = i
    }
};
const MM = ({
    name: t,
    code: e,
    encode: r
}) => new yme(t, e, r);
let yme = class {
    constructor(e, r, n) {
        this.name = e, this.code = r, this.encode = n
    }
    digest(e) {
        if (e instanceof Uint8Array) {
            const r = this.encode(e);
            return r instanceof Uint8Array ? C5(this.code, r) : r.then(n => C5(this.code, n))
        } else throw Error("Unknown type, must be binary type")
    }
};
const DM = t => async e => new Uint8Array(await crypto.subtle.digest(t, e)),
    wme = MM({
        name: "sha2-256",
        code: 18,
        encode: DM("SHA-256")
    }),
    bme = MM({
        name: "sha2-512",
        code: 19,
        encode: DM("SHA-512")
    });
var vme = Object.freeze({
    __proto__: null,
    sha256: wme,
    sha512: bme
});
const LM = 0,
    xme = "identity",
    UM = PM,
    Eme = t => C5(LM, UM(t)),
    _me = {
        code: LM,
        name: xme,
        encode: UM,
        digest: Eme
    };
var Cme = Object.freeze({
    __proto__: null,
    identity: _me
});
new TextEncoder, new TextDecoder;
const KC = { ...yge,
    ...bge,
    ...xge,
    ..._ge,
    ...kge,
    ...Mge,
    ...Uge,
    ...Wge,
    ...Gge,
    ...Xge
};
({ ...vme,
    ...Cme
});

function FM(t, e, r, n) {
    return {
        name: t,
        prefix: e,
        encoder: {
            name: t,
            prefix: e,
            encode: r
        },
        decoder: {
            decode: n
        }
    }
}
const YC = FM("utf8", "u", t => "u" + new TextDecoder("utf8").decode(t), t => new TextEncoder().encode(t.substring(1))),
    cb = FM("ascii", "a", t => {
        let e = "a";
        for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
        return e
    }, t => {
        t = t.substring(1);
        const e = SM(t.length);
        for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
        return e
    }),
    BM = {
        utf8: YC,
        "utf-8": YC,
        hex: KC.base16,
        latin1: cb,
        ascii: cb,
        binary: cb,
        ...KC
    };

function ky(t, e = "utf8") {
    const r = BM[e];
    if (!r) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : r.encoder.encode(t).substring(1)
}

function Ih(t, e = "utf8") {
    const r = BM[e];
    if (!r) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Rx(globalThis.Buffer.from(t, "utf-8")) : r.decoder.decode(`${r.prefix}${t}`)
}

function ZC(t) {
    return yd(ky(Ih(t, Cy), IM))
}

function Zm(t) {
    return ky(Ih(ac(t), IM), Cy)
}

function WM(t) {
    const e = Ih(nge, zC),
        r = rge + ky(TM([e, t]), zC);
    return [ege, tge, r].join(X0e)
}

function Ame(t) {
    return ky(t, Cy)
}

function kme(t) {
    return Ih(t, Cy)
}

function Ime(t) {
    return Ih([Zm(t.header), Zm(t.payload)].join(Ym), $M)
}

function $me(t) {
    return [Zm(t.header), Zm(t.payload), Ame(t.signature)].join(Ym)
}

function A5(t) {
    const e = t.split(Ym),
        r = ZC(e[0]),
        n = ZC(e[1]),
        i = kme(e[2]),
        s = Ih(e.slice(0, 2).join(Ym), $M);
    return {
        header: r,
        payload: n,
        signature: i,
        data: s
    }
}

function JC(t = mM(ige)) {
    const e = kM.getPublicKey(t);
    return {
        secretKey: TM([t, e]),
        publicKey: e
    }
}
async function Sme(t, e, r, n, i = Me.fromMiliseconds(Date.now())) {
    const s = {
            alg: J0e,
            typ: Q0e
        },
        a = WM(n.publicKey),
        o = i + r,
        c = {
            iss: a,
            sub: t,
            aud: e,
            iat: i,
            exp: o
        },
        l = Ime({
            header: s,
            payload: c
        }),
        u = kM.sign(l, n.secretKey.slice(0, 32));
    return $me({
        header: s,
        payload: c,
        signature: u
    })
}

function Mx(t) {
    return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t
}

function zM(t = 0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Mx(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t)
}

function Wf(t, e) {
    e || (e = t.reduce((i, s) => i + s.length, 0));
    const r = zM(e);
    let n = 0;
    for (const i of t) r.set(i, n), n += i.length;
    return Mx(r)
}

function Tme(t, e) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    for (var r = new Uint8Array(256), n = 0; n < r.length; n++) r[n] = 255;
    for (var i = 0; i < t.length; i++) {
        var s = t.charAt(i),
            a = s.charCodeAt(0);
        if (r[a] !== 255) throw new TypeError(s + " is ambiguous");
        r[a] = i
    }
    var o = t.length,
        c = t.charAt(0),
        l = Math.log(o) / Math.log(256),
        u = Math.log(256) / Math.log(o);

    function h(g) {
        if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))), !(g instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (g.length === 0) return "";
        for (var m = 0, y = 0, w = 0, x = g.length; w !== x && g[w] === 0;) w++, m++;
        for (var E = (x - w) * u + 1 >>> 0, _ = new Uint8Array(E); w !== x;) {
            for (var b = g[w], A = 0, I = E - 1;
                (b !== 0 || A < y) && I !== -1; I--, A++) b += 256 * _[I] >>> 0, _[I] = b % o >>> 0, b = b / o >>> 0;
            if (b !== 0) throw new Error("Non-zero carry");
            y = A, w++
        }
        for (var T = E - y; T !== E && _[T] === 0;) T++;
        for (var C = c.repeat(m); T < E; ++T) C += t.charAt(_[T]);
        return C
    }

    function f(g) {
        if (typeof g != "string") throw new TypeError("Expected String");
        if (g.length === 0) return new Uint8Array;
        var m = 0;
        if (g[m] !== " ") {
            for (var y = 0, w = 0; g[m] === c;) y++, m++;
            for (var x = (g.length - m) * l + 1 >>> 0, E = new Uint8Array(x); g[m];) {
                var _ = r[g.charCodeAt(m)];
                if (_ === 255) return;
                for (var b = 0, A = x - 1;
                    (_ !== 0 || b < w) && A !== -1; A--, b++) _ += o * E[A] >>> 0, E[A] = _ % 256 >>> 0, _ = _ / 256 >>> 0;
                if (_ !== 0) throw new Error("Non-zero carry");
                w = b, m++
            }
            if (g[m] !== " ") {
                for (var I = x - w; I !== x && E[I] === 0;) I++;
                for (var T = new Uint8Array(y + (x - I)), C = y; I !== x;) T[C++] = E[I++];
                return T
            }
        }
    }

    function p(g) {
        var m = f(g);
        if (m) return m;
        throw new Error(`Non-${e} character`)
    }
    return {
        encode: h,
        decodeUnsafe: f,
        decode: p
    }
}
var Pme = Tme,
    Nme = Pme;
const Ome = t => {
        if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t;
        if (t instanceof ArrayBuffer) return new Uint8Array(t);
        if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
        throw new Error("Unknown type, must be binary type")
    },
    jme = t => new TextEncoder().encode(t),
    Rme = t => new TextDecoder().decode(t);
class Mme {
    constructor(e, r, n) {
        this.name = e, this.prefix = r, this.baseEncode = n
    }
    encode(e) {
        if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type")
    }
}
class Dme {
    constructor(e, r, n) {
        if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
        this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length))
        } else throw Error("Can only multibase decode strings")
    }
    or(e) {
        return qM(this, e)
    }
}
class Lme {
    constructor(e) {
        this.decoders = e
    }
    or(e) {
        return qM(this, e)
    }
    decode(e) {
        const r = e[0],
            n = this.decoders[r];
        if (n) return n.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
}
const qM = (t, e) => new Lme({ ...t.decoders || {
        [t.prefix]: t
    },
    ...e.decoders || {
        [e.prefix]: e
    }
});
class Ume {
    constructor(e, r, n, i) {
        this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new Mme(e, r, n), this.decoder = new Dme(e, r, i)
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
}
const Iy = ({
        name: t,
        prefix: e,
        encode: r,
        decode: n
    }) => new Ume(t, e, r, n),
    E0 = ({
        prefix: t,
        name: e,
        alphabet: r
    }) => {
        const {
            encode: n,
            decode: i
        } = Nme(r, e);
        return Iy({
            prefix: t,
            name: e,
            encode: n,
            decode: s => Ome(i(s))
        })
    },
    Fme = (t, e, r, n) => {
        const i = {};
        for (let u = 0; u < e.length; ++u) i[e[u]] = u;
        let s = t.length;
        for (; t[s - 1] === "=";) --s;
        const a = new Uint8Array(s * r / 8 | 0);
        let o = 0,
            c = 0,
            l = 0;
        for (let u = 0; u < s; ++u) {
            const h = i[t[u]];
            if (h === void 0) throw new SyntaxError(`Non-${n} character`);
            c = c << r | h, o += r, o >= 8 && (o -= 8, a[l++] = 255 & c >> o)
        }
        if (o >= r || 255 & c << 8 - o) throw new SyntaxError("Unexpected end of data");
        return a
    },
    Bme = (t, e, r) => {
        const n = e[e.length - 1] === "=",
            i = (1 << r) - 1;
        let s = "",
            a = 0,
            o = 0;
        for (let c = 0; c < t.length; ++c)
            for (o = o << 8 | t[c], a += 8; a > r;) a -= r, s += e[i & o >> a];
        if (a && (s += e[i & o << r - a]), n)
            for (; s.length * r & 7;) s += "=";
        return s
    },
    Dn = ({
        name: t,
        prefix: e,
        bitsPerChar: r,
        alphabet: n
    }) => Iy({
        prefix: e,
        name: t,
        encode(i) {
            return Bme(i, n, r)
        },
        decode(i) {
            return Fme(i, n, r, t)
        }
    }),
    Wme = Iy({
        prefix: "\0",
        name: "identity",
        encode: t => Rme(t),
        decode: t => jme(t)
    }),
    zme = Object.freeze(Object.defineProperty({
        __proto__: null,
        identity: Wme
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    qme = Dn({
        prefix: "0",
        name: "base2",
        alphabet: "01",
        bitsPerChar: 1
    }),
    Hme = Object.freeze(Object.defineProperty({
        __proto__: null,
        base2: qme
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Vme = Dn({
        prefix: "7",
        name: "base8",
        alphabet: "01234567",
        bitsPerChar: 3
    }),
    Gme = Object.freeze(Object.defineProperty({
        __proto__: null,
        base8: Vme
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Kme = E0({
        prefix: "9",
        name: "base10",
        alphabet: "0123456789"
    }),
    Yme = Object.freeze(Object.defineProperty({
        __proto__: null,
        base10: Kme
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Zme = Dn({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
    }),
    Jme = Dn({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
    }),
    Qme = Object.freeze(Object.defineProperty({
        __proto__: null,
        base16: Zme,
        base16upper: Jme
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Xme = Dn({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
    }),
    e1e = Dn({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
    }),
    t1e = Dn({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
    }),
    r1e = Dn({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
    }),
    n1e = Dn({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
    }),
    i1e = Dn({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
    }),
    s1e = Dn({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
    }),
    a1e = Dn({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
    }),
    o1e = Dn({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
    }),
    c1e = Object.freeze(Object.defineProperty({
        __proto__: null,
        base32: Xme,
        base32hex: n1e,
        base32hexpad: s1e,
        base32hexpadupper: a1e,
        base32hexupper: i1e,
        base32pad: t1e,
        base32padupper: r1e,
        base32upper: e1e,
        base32z: o1e
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    l1e = E0({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    }),
    d1e = E0({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    }),
    u1e = Object.freeze(Object.defineProperty({
        __proto__: null,
        base36: l1e,
        base36upper: d1e
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    h1e = E0({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }),
    f1e = E0({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    }),
    p1e = Object.freeze(Object.defineProperty({
        __proto__: null,
        base58btc: h1e,
        base58flickr: f1e
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    g1e = Dn({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
    }),
    m1e = Dn({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
    }),
    y1e = Dn({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
    }),
    w1e = Dn({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
    }),
    b1e = Object.freeze(Object.defineProperty({
        __proto__: null,
        base64: g1e,
        base64pad: m1e,
        base64url: y1e,
        base64urlpad: w1e
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    HM = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),
    v1e = HM.reduce((t, e, r) => (t[r] = e, t), []),
    x1e = HM.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);

function E1e(t) {
    return t.reduce((e, r) => (e += v1e[r], e), "")
}

function _1e(t) {
    const e = [];
    for (const r of t) {
        const n = x1e[r.codePointAt(0)];
        if (n === void 0) throw new Error(`Non-base256emoji character: ${r}`);
        e.push(n)
    }
    return new Uint8Array(e)
}
const C1e = Iy({
        prefix: "🚀",
        name: "base256emoji",
        encode: E1e,
        decode: _1e
    }),
    A1e = Object.freeze(Object.defineProperty({
        __proto__: null,
        base256emoji: C1e
    }, Symbol.toStringTag, {
        value: "Module"
    }));
new TextEncoder;
new TextDecoder;
const QC = { ...zme,
    ...Hme,
    ...Gme,
    ...Yme,
    ...Qme,
    ...c1e,
    ...u1e,
    ...p1e,
    ...b1e,
    ...A1e
};

function VM(t, e, r, n) {
    return {
        name: t,
        prefix: e,
        encoder: {
            name: t,
            prefix: e,
            encode: r
        },
        decoder: {
            decode: n
        }
    }
}
const XC = VM("utf8", "u", t => "u" + new TextDecoder("utf8").decode(t), t => new TextEncoder().encode(t.substring(1))),
    lb = VM("ascii", "a", t => {
        let e = "a";
        for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
        return e
    }, t => {
        t = t.substring(1);
        const e = zM(t.length);
        for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
        return e
    }),
    GM = {
        utf8: XC,
        "utf-8": XC,
        hex: QC.base16,
        latin1: lb,
        ascii: lb,
        binary: lb,
        ...QC
    };

function Ts(t, e = "utf8") {
    const r = GM[e];
    if (!r) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Mx(globalThis.Buffer.from(t, "utf-8")) : r.decoder.decode(`${r.prefix}${t}`)
}

function Li(t, e = "utf8") {
    const r = GM[e];
    if (!r) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : r.encoder.encode(t).substring(1)
}
const k1e = {
    waku: {
        publish: "waku_publish",
        batchPublish: "waku_batchPublish",
        subscribe: "waku_subscribe",
        batchSubscribe: "waku_batchSubscribe",
        subscription: "waku_subscription",
        unsubscribe: "waku_unsubscribe",
        batchUnsubscribe: "waku_batchUnsubscribe",
        batchFetchMessages: "waku_batchFetchMessages"
    },
    irn: {
        publish: "irn_publish",
        batchPublish: "irn_batchPublish",
        subscribe: "irn_subscribe",
        batchSubscribe: "irn_batchSubscribe",
        subscription: "irn_subscription",
        unsubscribe: "irn_unsubscribe",
        batchUnsubscribe: "irn_batchUnsubscribe",
        batchFetchMessages: "irn_batchFetchMessages"
    },
    iridium: {
        publish: "iridium_publish",
        batchPublish: "iridium_batchPublish",
        subscribe: "iridium_subscribe",
        batchSubscribe: "iridium_batchSubscribe",
        subscription: "iridium_subscription",
        unsubscribe: "iridium_unsubscribe",
        batchUnsubscribe: "iridium_batchUnsubscribe",
        batchFetchMessages: "iridium_batchFetchMessages"
    }
};
var db, eA;

function KM() {
    if (eA) return db;
    eA = 1;
    const t = "Input must be an string, Buffer or Uint8Array";

    function e(a) {
        let o;
        if (a instanceof Uint8Array) o = a;
        else if (typeof a == "string") o = new TextEncoder().encode(a);
        else throw new Error(t);
        return o
    }

    function r(a) {
        return Array.prototype.map.call(a, function(o) {
            return (o < 16 ? "0" : "") + o.toString(16)
        }).join("")
    }

    function n(a) {
        return (4294967296 + a).toString(16).substring(1)
    }

    function i(a, o, c) {
        let l = `
` + a + " = ";
        for (let u = 0; u < o.length; u += 2) {
            if (c === 32) l += n(o[u]).toUpperCase(), l += " ", l += n(o[u + 1]).toUpperCase();
            else if (c === 64) l += n(o[u + 1]).toUpperCase(), l += n(o[u]).toUpperCase();
            else throw new Error("Invalid size " + c);
            u % 6 === 4 ? l += `
` + new Array(a.length + 4).join(" ") : u < o.length - 2 && (l += " ")
        }
        console.log(l)
    }

    function s(a, o, c) {
        let l = new Date().getTime();
        const u = new Uint8Array(o);
        for (let f = 0; f < o; f++) u[f] = f % 256;
        const h = new Date().getTime();
        console.log("Generated random input in " + (h - l) + "ms"), l = h;
        for (let f = 0; f < c; f++) {
            const p = a(u),
                g = new Date().getTime(),
                m = g - l;
            l = g, console.log("Hashed in " + m + "ms: " + p.substring(0, 20) + "..."), console.log(Math.round(o / (1 << 20) / (m / 1e3) * 100) / 100 + " MB PER SECOND")
        }
    }
    return db = {
        normalizeInput: e,
        toHex: r,
        debugPrint: i,
        testSpeed: s
    }, db
}
var ub, tA;

function I1e() {
    if (tA) return ub;
    tA = 1;
    const t = KM();

    function e(w, x, E) {
        const _ = w[x] + w[E];
        let b = w[x + 1] + w[E + 1];
        _ >= 4294967296 && b++, w[x] = _, w[x + 1] = b
    }

    function r(w, x, E, _) {
        let b = w[x] + E;
        E < 0 && (b += 4294967296);
        let A = w[x + 1] + _;
        b >= 4294967296 && A++, w[x] = b, w[x + 1] = A
    }

    function n(w, x) {
        return w[x] ^ w[x + 1] << 8 ^ w[x + 2] << 16 ^ w[x + 3] << 24
    }

    function i(w, x, E, _, b, A) {
        const I = l[b],
            T = l[b + 1],
            C = l[A],
            $ = l[A + 1];
        e(c, w, x), r(c, w, I, T);
        let P = c[_] ^ c[w],
            N = c[_ + 1] ^ c[w + 1];
        c[_] = N, c[_ + 1] = P, e(c, E, _), P = c[x] ^ c[E], N = c[x + 1] ^ c[E + 1], c[x] = P >>> 24 ^ N << 8, c[x + 1] = N >>> 24 ^ P << 8, e(c, w, x), r(c, w, C, $), P = c[_] ^ c[w], N = c[_ + 1] ^ c[w + 1], c[_] = P >>> 16 ^ N << 16, c[_ + 1] = N >>> 16 ^ P << 16, e(c, E, _), P = c[x] ^ c[E], N = c[x + 1] ^ c[E + 1], c[x] = N >>> 31 ^ P << 1, c[x + 1] = P >>> 31 ^ N << 1
    }
    const s = new Uint32Array([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]),
        a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],
        o = new Uint8Array(a.map(function(w) {
            return w * 2
        })),
        c = new Uint32Array(32),
        l = new Uint32Array(32);

    function u(w, x) {
        let E = 0;
        for (E = 0; E < 16; E++) c[E] = w.h[E], c[E + 16] = s[E];
        for (c[24] = c[24] ^ w.t, c[25] = c[25] ^ w.t / 4294967296, x && (c[28] = ~c[28], c[29] = ~c[29]), E = 0; E < 32; E++) l[E] = n(w.b, 4 * E);
        for (E = 0; E < 12; E++) i(0, 8, 16, 24, o[E * 16 + 0], o[E * 16 + 1]), i(2, 10, 18, 26, o[E * 16 + 2], o[E * 16 + 3]), i(4, 12, 20, 28, o[E * 16 + 4], o[E * 16 + 5]), i(6, 14, 22, 30, o[E * 16 + 6], o[E * 16 + 7]), i(0, 10, 20, 30, o[E * 16 + 8], o[E * 16 + 9]), i(2, 12, 22, 24, o[E * 16 + 10], o[E * 16 + 11]), i(4, 14, 16, 26, o[E * 16 + 12], o[E * 16 + 13]), i(6, 8, 18, 28, o[E * 16 + 14], o[E * 16 + 15]);
        for (E = 0; E < 16; E++) w.h[E] = w.h[E] ^ c[E] ^ c[E + 16]
    }
    const h = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);

    function f(w, x, E, _) {
        if (w === 0 || w > 64) throw new Error("Illegal output length, expected 0 < length <= 64");
        if (x && x.length > 64) throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
        if (E && E.length !== 16) throw new Error("Illegal salt, expected Uint8Array with length is 16");
        if (_ && _.length !== 16) throw new Error("Illegal personal, expected Uint8Array with length is 16");
        const b = {
            b: new Uint8Array(128),
            h: new Uint32Array(16),
            t: 0,
            c: 0,
            outlen: w
        };
        h.fill(0), h[0] = w, x && (h[1] = x.length), h[2] = 1, h[3] = 1, E && h.set(E, 32), _ && h.set(_, 48);
        for (let A = 0; A < 16; A++) b.h[A] = s[A] ^ n(h, A * 4);
        return x && (p(b, x), b.c = 128), b
    }

    function p(w, x) {
        for (let E = 0; E < x.length; E++) w.c === 128 && (w.t += w.c, u(w, !1), w.c = 0), w.b[w.c++] = x[E]
    }

    function g(w) {
        for (w.t += w.c; w.c < 128;) w.b[w.c++] = 0;
        u(w, !0);
        const x = new Uint8Array(w.outlen);
        for (let E = 0; E < w.outlen; E++) x[E] = w.h[E >> 2] >> 8 * (E & 3);
        return x
    }

    function m(w, x, E, _, b) {
        E = E || 64, w = t.normalizeInput(w), _ && (_ = t.normalizeInput(_)), b && (b = t.normalizeInput(b));
        const A = f(E, x, _, b);
        return p(A, w), g(A)
    }

    function y(w, x, E, _, b) {
        const A = m(w, x, E, _, b);
        return t.toHex(A)
    }
    return ub = {
        blake2b: m,
        blake2bHex: y,
        blake2bInit: f,
        blake2bUpdate: p,
        blake2bFinal: g
    }, ub
}
var hb, rA;

function $1e() {
    if (rA) return hb;
    rA = 1;
    const t = KM();

    function e(g, m) {
        return g[m] ^ g[m + 1] << 8 ^ g[m + 2] << 16 ^ g[m + 3] << 24
    }

    function r(g, m, y, w, x, E) {
        a[g] = a[g] + a[m] + x, a[w] = n(a[w] ^ a[g], 16), a[y] = a[y] + a[w], a[m] = n(a[m] ^ a[y], 12), a[g] = a[g] + a[m] + E, a[w] = n(a[w] ^ a[g], 8), a[y] = a[y] + a[w], a[m] = n(a[m] ^ a[y], 7)
    }

    function n(g, m) {
        return g >>> m ^ g << 32 - m
    }
    const i = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
        s = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0]),
        a = new Uint32Array(16),
        o = new Uint32Array(16);

    function c(g, m) {
        let y = 0;
        for (y = 0; y < 8; y++) a[y] = g.h[y], a[y + 8] = i[y];
        for (a[12] ^= g.t, a[13] ^= g.t / 4294967296, m && (a[14] = ~a[14]), y = 0; y < 16; y++) o[y] = e(g.b, 4 * y);
        for (y = 0; y < 10; y++) r(0, 4, 8, 12, o[s[y * 16 + 0]], o[s[y * 16 + 1]]), r(1, 5, 9, 13, o[s[y * 16 + 2]], o[s[y * 16 + 3]]), r(2, 6, 10, 14, o[s[y * 16 + 4]], o[s[y * 16 + 5]]), r(3, 7, 11, 15, o[s[y * 16 + 6]], o[s[y * 16 + 7]]), r(0, 5, 10, 15, o[s[y * 16 + 8]], o[s[y * 16 + 9]]), r(1, 6, 11, 12, o[s[y * 16 + 10]], o[s[y * 16 + 11]]), r(2, 7, 8, 13, o[s[y * 16 + 12]], o[s[y * 16 + 13]]), r(3, 4, 9, 14, o[s[y * 16 + 14]], o[s[y * 16 + 15]]);
        for (y = 0; y < 8; y++) g.h[y] ^= a[y] ^ a[y + 8]
    }

    function l(g, m) {
        if (!(g > 0 && g <= 32)) throw new Error("Incorrect output length, should be in [1, 32]");
        const y = m ? m.length : 0;
        if (m && !(y > 0 && y <= 32)) throw new Error("Incorrect key length, should be in [1, 32]");
        const w = {
            h: new Uint32Array(i),
            b: new Uint8Array(64),
            c: 0,
            t: 0,
            outlen: g
        };
        return w.h[0] ^= 16842752 ^ y << 8 ^ g, y > 0 && (u(w, m), w.c = 64), w
    }

    function u(g, m) {
        for (let y = 0; y < m.length; y++) g.c === 64 && (g.t += g.c, c(g, !1), g.c = 0), g.b[g.c++] = m[y]
    }

    function h(g) {
        for (g.t += g.c; g.c < 64;) g.b[g.c++] = 0;
        c(g, !0);
        const m = new Uint8Array(g.outlen);
        for (let y = 0; y < g.outlen; y++) m[y] = g.h[y >> 2] >> 8 * (y & 3) & 255;
        return m
    }

    function f(g, m, y) {
        y = y || 32, g = t.normalizeInput(g);
        const w = l(y, m);
        return u(w, g), h(w)
    }

    function p(g, m, y) {
        const w = f(g, m, y);
        return t.toHex(w)
    }
    return hb = {
        blake2s: f,
        blake2sHex: p,
        blake2sInit: l,
        blake2sUpdate: u,
        blake2sFinal: h
    }, hb
}
var fb, nA;

function S1e() {
    if (nA) return fb;
    nA = 1;
    const t = I1e(),
        e = $1e();
    return fb = {
        blake2b: t.blake2b,
        blake2bHex: t.blake2bHex,
        blake2bInit: t.blake2bInit,
        blake2bUpdate: t.blake2bUpdate,
        blake2bFinal: t.blake2bFinal,
        blake2s: e.blake2s,
        blake2sHex: e.blake2sHex,
        blake2sInit: e.blake2sInit,
        blake2sUpdate: e.blake2sUpdate,
        blake2sFinal: e.blake2sFinal
    }, fb
}
var T1e = S1e(),
    P1e = {};
const N1e = ":";

function zu(t) {
    const [e, r] = t.split(N1e);
    return {
        namespace: e,
        reference: r
    }
}

function iA(t, e = []) {
    const r = [];
    return Object.keys(t).forEach(n => {
        if (e.length && !e.includes(n)) return;
        const i = t[n];
        r.push(...i.accounts)
    }), r
}

function YM(t, e) {
    return t.includes(":") ? [t] : e.chains || []
}
var O1e = Object.defineProperty,
    j1e = Object.defineProperties,
    R1e = Object.getOwnPropertyDescriptors,
    sA = Object.getOwnPropertySymbols,
    M1e = Object.prototype.hasOwnProperty,
    D1e = Object.prototype.propertyIsEnumerable,
    k5 = (t, e, r) => e in t ? O1e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    aA = (t, e) => {
        for (var r in e || (e = {})) M1e.call(e, r) && k5(t, r, e[r]);
        if (sA)
            for (var r of sA(e)) D1e.call(e, r) && k5(t, r, e[r]);
        return t
    },
    L1e = (t, e) => j1e(t, R1e(e)),
    oA = (t, e, r) => k5(t, typeof e != "symbol" ? e + "" : e, r);
const U1e = "ReactNative",
    ns = {
        reactNative: "react-native",
        node: "node",
        browser: "browser",
        unknown: "unknown"
    },
    F1e = "js";

function Jm() {
    return typeof jn < "u" && typeof jn.versions < "u" && typeof jn.versions.node < "u"
}

function ul() {
    return !sc.getDocument() && !!sc.getNavigator() && navigator.product === U1e
}

function B1e() {
    return ul() && typeof globalThis < "u" && typeof(globalThis == null ? void 0 : globalThis.Platform) < "u" && (globalThis == null ? void 0 : globalThis.Platform.OS) === "android"
}

function W1e() {
    return ul() && typeof globalThis < "u" && typeof(globalThis == null ? void 0 : globalThis.Platform) < "u" && (globalThis == null ? void 0 : globalThis.Platform.OS) === "ios"
}

function $h() {
    return !Jm() && !!sc.getNavigator() && !!sc.getDocument()
}

function _0() {
    return ul() ? ns.reactNative : Jm() ? ns.node : $h() ? ns.browser : ns.unknown
}

function cA() {
    var t;
    try {
        return ul() && typeof globalThis < "u" && typeof(globalThis == null ? void 0 : globalThis.Application) < "u" ? (t = globalThis.Application) == null ? void 0 : t.applicationId : void 0
    } catch {
        return
    }
}

function z1e(t, e) {
    const r = new URLSearchParams(t);
    for (const n of Object.keys(e).sort())
        if (e.hasOwnProperty(n)) {
            const i = e[n];
            i !== void 0 && r.set(n, i)
        }
    return r.toString()
}

function q1e(t) {
    var e, r;
    const n = ZM();
    try {
        return t != null && t.url && n.url && new URL(t.url).host !== new URL(n.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${n.url}. This is probably unintended and can lead to issues.`), t.url = n.url), (e = t == null ? void 0 : t.icons) != null && e.length && t.icons.length > 0 && (t.icons = t.icons.filter(i => i !== "")), L1e(aA(aA({}, n), t), {
            url: (t == null ? void 0 : t.url) || n.url,
            name: (t == null ? void 0 : t.name) || n.name,
            description: (t == null ? void 0 : t.description) || n.description,
            icons: (r = t == null ? void 0 : t.icons) != null && r.length && t.icons.length > 0 ? t.icons : n.icons
        })
    } catch (i) {
        return console.warn("Error populating app metadata", i), t || n
    }
}

function ZM() {
    return tfe.getWindowMetadata() || {
        name: "",
        description: "",
        url: "",
        icons: [""]
    }
}

function H1e() {
    if (_0() === ns.reactNative && typeof globalThis < "u" && typeof(globalThis == null ? void 0 : globalThis.Platform) < "u") {
        const {
            OS: r,
            Version: n
        } = globalThis.Platform;
        return [r, n].join("-")
    }
    const t = bhe();
    if (t === null) return "unknown";
    const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
    return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-")
}

function V1e() {
    var t;
    const e = _0();
    return e === ns.browser ? [e, ((t = sc.getLocation()) == null ? void 0 : t.host) || "unknown"].join(":") : e
}

function JM(t, e, r) {
    const n = H1e(),
        i = V1e();
    return [
        [t, e].join("-"), [F1e, r].join("-"), n, i
    ].join("/")
}

function G1e({
    protocol: t,
    version: e,
    relayUrl: r,
    sdkVersion: n,
    auth: i,
    projectId: s,
    useOnCloseEvent: a,
    bundleId: o,
    packageName: c
}) {
    const l = r.split("?"),
        u = JM(t, e, n),
        h = {
            auth: i,
            ua: u,
            projectId: s,
            useOnCloseEvent: a,
            packageName: c || void 0,
            bundleId: o || void 0
        },
        f = z1e(l[1] || "", h);
    return l[0] + "?" + f
}

function zl(t, e) {
    return t.filter(r => e.includes(r)).length === t.length
}

function I5(t) {
    return Object.fromEntries(t.entries())
}

function $5(t) {
    return new Map(Object.entries(t))
}

function $l(t = Me.FIVE_MINUTES, e) {
    const r = Me.toMiliseconds(t || Me.FIVE_MINUTES);
    let n, i, s, a;
    return {
        resolve: o => {
            s && n && (clearTimeout(s), n(o), a = Promise.resolve(o))
        },
        reject: o => {
            s && i && (clearTimeout(s), i(o))
        },
        done: () => new Promise((o, c) => {
            if (a) return o(a);
            s = setTimeout(() => {
                const l = new Error(e);
                a = Promise.reject(l), c(l)
            }, r), n = o, i = c
        })
    }
}

function Yc(t, e, r) {
    return new Promise(async (n, i) => {
        const s = setTimeout(() => i(new Error(r)), e);
        try {
            const a = await t;
            n(a)
        } catch (a) {
            i(a)
        }
        clearTimeout(s)
    })
}

function QM(t, e) {
    if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
    if (t.toLowerCase() === "topic") {
        if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
        return `topic:${e}`
    } else if (t.toLowerCase() === "id") {
        if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
        return `id:${e}`
    }
    throw new Error(`Unknown expirer target type: ${t}`)
}

function K1e(t) {
    return QM("topic", t)
}

function Y1e(t) {
    return QM("id", t)
}

function XM(t) {
    const [e, r] = t.split(":"), n = {
        id: void 0,
        topic: void 0
    };
    if (e === "topic" && typeof r == "string") n.topic = r;
    else if (e === "id" && Number.isInteger(Number(r))) n.id = Number(r);
    else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${r}`);
    return n
}

function an(t, e) {
    return Me.fromMiliseconds(Date.now() + Me.toMiliseconds(t))
}

function jc(t) {
    return Date.now() >= Me.toMiliseconds(t)
}

function rr(t, e) {
    return `${t}${e?`:${e}`:""}`
}

function so(t = [], e = []) {
    return [...new Set([...t, ...e])]
}
async function Z1e({
    id: t,
    topic: e,
    wcDeepLink: r
}) {
    var n;
    try {
        if (!r) return;
        const i = typeof r == "string" ? JSON.parse(r) : r,
            s = i == null ? void 0 : i.href;
        if (typeof s != "string") return;
        const a = J1e(s, t, e),
            o = _0();
        if (o === ns.browser) {
            if (!((n = sc.getDocument()) != null && n.hasFocus())) {
                console.warn("Document does not have focus, skipping deeplink.");
                return
            }
            Q1e(a)
        } else o === ns.reactNative && typeof(globalThis == null ? void 0 : globalThis.Linking) < "u" && await globalThis.Linking.openURL(a)
    } catch (i) {
        console.error(i)
    }
}

function J1e(t, e, r) {
    const n = `requestId=${e}&sessionTopic=${r}`;
    t.endsWith("/") && (t = t.slice(0, -1));
    let i = `${t}`;
    if (t.startsWith("https://t.me")) {
        const s = t.includes("?") ? "&startapp=" : "?startapp=";
        i = `${i}${s}${rye(n,!0)}`
    } else i = `${i}/wc?${n}`;
    return i
}

function Q1e(t) {
    let e = "_self";
    tye() ? e = "_top" : (eye() || t.startsWith("https://") || t.startsWith("http://")) && (e = "_blank"), window.open(t, e, "noreferrer noopener")
}
async function X1e(t, e) {
    let r = "";
    try {
        if ($h() && (r = localStorage.getItem(e), r)) return r;
        r = await t.getItem(e)
    } catch (n) {
        console.error(n)
    }
    return r
}

function lA(t, e) {
    if (!t.includes(e)) return null;
    const r = t.split(/([&,?,=])/),
        n = r.indexOf(e);
    return r[n + 2]
}

function dA() {
    return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, t => {
        const e = Math.random() * 16 | 0;
        return (t === "x" ? e : e & 3 | 8).toString(16)
    })
}

function Dx() {
    return typeof jn < "u" && P1e.IS_VITEST === "true"
}

function eye() {
    return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto)
}

function tye() {
    try {
        return window.self !== window.top
    } catch {
        return !1
    }
}

function rye(t, e = !1) {
    const r = Ve.from(t).toString("base64");
    return e ? r.replace(/[=]/g, "") : r
}

function eD(t) {
    return Ve.from(t, "base64").toString("utf-8")
}

function nye(t) {
    return new Promise(e => setTimeout(e, t))
}
let iye = class {
    constructor({
        limit: e
    }) {
        oA(this, "limit"), oA(this, "set"), this.limit = e, this.set = new Set
    }
    add(e) {
        if (!this.set.has(e)) {
            if (this.set.size >= this.limit) {
                const r = this.set.values().next().value;
                r && this.set.delete(r)
            }
            this.set.add(e)
        }
    }
    has(e) {
        return this.set.has(e)
    }
};
const mg = BigInt(2 ** 32 - 1),
    uA = BigInt(32);

function tD(t, e = !1) {
    return e ? {
        h: Number(t & mg),
        l: Number(t >> uA & mg)
    } : {
        h: Number(t >> uA & mg) | 0,
        l: Number(t & mg) | 0
    }
}

function rD(t, e = !1) {
    const r = t.length;
    let n = new Uint32Array(r),
        i = new Uint32Array(r);
    for (let s = 0; s < r; s++) {
        const {
            h: a,
            l: o
        } = tD(t[s], e);
        [n[s], i[s]] = [a, o]
    }
    return [n, i]
}
const hA = (t, e, r) => t >>> r,
    fA = (t, e, r) => t << 32 - r | e >>> r,
    Rc = (t, e, r) => t >>> r | e << 32 - r,
    Mc = (t, e, r) => t << 32 - r | e >>> r,
    If = (t, e, r) => t << 64 - r | e >>> r - 32,
    $f = (t, e, r) => t >>> r - 32 | e << 64 - r,
    sye = (t, e) => e,
    aye = (t, e) => t,
    oye = (t, e, r) => t << r | e >>> 32 - r,
    cye = (t, e, r) => e << r | t >>> 32 - r,
    lye = (t, e, r) => e << r - 32 | t >>> 64 - r,
    dye = (t, e, r) => t << r - 32 | e >>> 64 - r;

function sa(t, e, r, n) {
    const i = (e >>> 0) + (n >>> 0);
    return {
        h: t + r + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    }
}
const Lx = (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0),
    Ux = (t, e, r, n) => e + r + n + (t / 2 ** 32 | 0) | 0,
    uye = (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0),
    hye = (t, e, r, n, i) => e + r + n + i + (t / 2 ** 32 | 0) | 0,
    fye = (t, e, r, n, i) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0),
    pye = (t, e, r, n, i, s) => e + r + n + i + s + (t / 2 ** 32 | 0) | 0,
    iu = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

function Fx(t) {
    return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array"
}

function oc(t) {
    if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t)
}

function Ms(t, ...e) {
    if (!Fx(t)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length)
}

function Bx(t) {
    if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
    oc(t.outputLen), oc(t.blockLen)
}

function sl(t, e = !0) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished) throw new Error("Hash#digest() has already been called")
}

function Wx(t, e) {
    Ms(t);
    const r = e.outputLen;
    if (t.length < r) throw new Error("digestInto() expects output buffer of length at least " + r)
}

function Dp(t) {
    return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4))
}

function Ds(...t) {
    for (let e = 0; e < t.length; e++) t[e].fill(0)
}

function pb(t) {
    return new DataView(t.buffer, t.byteOffset, t.byteLength)
}

function Ba(t, e) {
    return t << 32 - e | t >>> e
}
const nD = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;

function iD(t) {
    return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255
}
const To = nD ? t => t : t => iD(t);

function gye(t) {
    for (let e = 0; e < t.length; e++) t[e] = iD(t[e]);
    return t
}
const Dc = nD ? t => t : gye,
    sD = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function",
    mye = Array.from({
        length: 256
    }, (t, e) => e.toString(16).padStart(2, "0"));

function Lp(t) {
    if (Ms(t), sD) return t.toHex();
    let e = "";
    for (let r = 0; r < t.length; r++) e += mye[t[r]];
    return e
}
const ko = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};

function pA(t) {
    if (t >= ko._0 && t <= ko._9) return t - ko._0;
    if (t >= ko.A && t <= ko.F) return t - (ko.A - 10);
    if (t >= ko.a && t <= ko.f) return t - (ko.a - 10)
}

function zx(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    if (sD) return Uint8Array.fromHex(t);
    const e = t.length,
        r = e / 2;
    if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
    const n = new Uint8Array(r);
    for (let i = 0, s = 0; i < r; i++, s += 2) {
        const a = pA(t.charCodeAt(s)),
            o = pA(t.charCodeAt(s + 1));
        if (a === void 0 || o === void 0) {
            const c = t[s] + t[s + 1];
            throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + s)
        }
        n[i] = a * 16 + o
    }
    return n
}

function yye(t) {
    if (typeof t != "string") throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(t))
}

function wa(t) {
    return typeof t == "string" && (t = yye(t)), Ms(t), t
}

function ql(...t) {
    let e = 0;
    for (let n = 0; n < t.length; n++) {
        const i = t[n];
        Ms(i), e += i.length
    }
    const r = new Uint8Array(e);
    for (let n = 0, i = 0; n < t.length; n++) {
        const s = t[n];
        r.set(s, i), i += s.length
    }
    return r
}
let $y = class {};

function C0(t) {
    const e = n => t().update(wa(n)).digest(),
        r = t();
    return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e
}

function wye(t) {
    const e = (n, i) => t(i).update(wa(n)).digest(),
        r = t({});
    return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = n => t(n), e
}

function Sh(t = 32) {
    if (iu && typeof iu.getRandomValues == "function") return iu.getRandomValues(new Uint8Array(t));
    if (iu && typeof iu.randomBytes == "function") return Uint8Array.from(iu.randomBytes(t));
    throw new Error("crypto.getRandomValues must be defined")
}
const bye = BigInt(0),
    tf = BigInt(1),
    vye = BigInt(2),
    xye = BigInt(7),
    Eye = BigInt(256),
    _ye = BigInt(113),
    aD = [],
    oD = [],
    cD = [];
for (let t = 0, e = tf, r = 1, n = 0; t < 24; t++) {
    [r, n] = [n, (2 * r + 3 * n) % 5], aD.push(2 * (5 * n + r)), oD.push((t + 1) * (t + 2) / 2 % 64);
    let i = bye;
    for (let s = 0; s < 7; s++) e = (e << tf ^ (e >> xye) * _ye) % Eye, e & vye && (i ^= tf << (tf << BigInt(s)) - tf);
    cD.push(i)
}
const lD = rD(cD, !0),
    Cye = lD[0],
    Aye = lD[1],
    gA = (t, e, r) => r > 32 ? lye(t, e, r) : oye(t, e, r),
    mA = (t, e, r) => r > 32 ? dye(t, e, r) : cye(t, e, r);

function kye(t, e = 24) {
    const r = new Uint32Array(10);
    for (let n = 24 - e; n < 24; n++) {
        for (let a = 0; a < 10; a++) r[a] = t[a] ^ t[a + 10] ^ t[a + 20] ^ t[a + 30] ^ t[a + 40];
        for (let a = 0; a < 10; a += 2) {
            const o = (a + 8) % 10,
                c = (a + 2) % 10,
                l = r[c],
                u = r[c + 1],
                h = gA(l, u, 1) ^ r[o],
                f = mA(l, u, 1) ^ r[o + 1];
            for (let p = 0; p < 50; p += 10) t[a + p] ^= h, t[a + p + 1] ^= f
        }
        let i = t[2],
            s = t[3];
        for (let a = 0; a < 24; a++) {
            const o = oD[a],
                c = gA(i, s, o),
                l = mA(i, s, o),
                u = aD[a];
            i = t[u], s = t[u + 1], t[u] = c, t[u + 1] = l
        }
        for (let a = 0; a < 50; a += 10) {
            for (let o = 0; o < 10; o++) r[o] = t[a + o];
            for (let o = 0; o < 10; o++) t[a + o] ^= ~r[(o + 2) % 10] & r[(o + 4) % 10]
        }
        t[0] ^= Cye[n], t[1] ^= Aye[n]
    }
    Ds(r)
}
let Iye = class dD extends $y {
    constructor(e, r, n, i = !1, s = 24) {
        if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = r, this.outputLen = n, this.enableXOF = i, this.rounds = s, oc(n), !(0 < e && e < 200)) throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200), this.state32 = Dp(this.state)
    }
    clone() {
        return this._cloneInto()
    }
    keccak() {
        Dc(this.state32), kye(this.state32, this.rounds), Dc(this.state32), this.posOut = 0, this.pos = 0
    }
    update(e) {
        sl(this), e = wa(e), Ms(e);
        const {
            blockLen: r,
            state: n
        } = this, i = e.length;
        for (let s = 0; s < i;) {
            const a = Math.min(r - this.pos, i - s);
            for (let o = 0; o < a; o++) n[this.pos++] ^= e[s++];
            this.pos === r && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished) return;
        this.finished = !0;
        const {
            state: e,
            suffix: r,
            pos: n,
            blockLen: i
        } = this;
        e[n] ^= r, (r & 128) !== 0 && n === i - 1 && this.keccak(), e[i - 1] ^= 128, this.keccak()
    }
    writeInto(e) {
        sl(this, !1), Ms(e), this.finish();
        const r = this.state,
            {
                blockLen: n
            } = this;
        for (let i = 0, s = e.length; i < s;) {
            this.posOut >= n && this.keccak();
            const a = Math.min(n - this.posOut, s - i);
            e.set(r.subarray(this.posOut, this.posOut + a), i), this.posOut += a, i += a
        }
        return e
    }
    xofInto(e) {
        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
        return this.writeInto(e)
    }
    xof(e) {
        return oc(e), this.xofInto(new Uint8Array(e))
    }
    digestInto(e) {
        if (Wx(e, this), this.finished) throw new Error("digest() was already called");
        return this.writeInto(e), this.destroy(), e
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0, Ds(this.state)
    }
    _cloneInto(e) {
        const {
            blockLen: r,
            suffix: n,
            outputLen: i,
            rounds: s,
            enableXOF: a
        } = this;
        return e || (e = new dD(r, n, i, a, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = n, e.outputLen = i, e.enableXOF = a, e.destroyed = this.destroyed, e
    }
};
const $ye = (t, e, r) => C0(() => new Iye(e, t, r)),
    Sye = $ye(1, 136, 256 / 8);

function Tye(t, e, r, n) {
    if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, r, n);
    const i = BigInt(32),
        s = BigInt(4294967295),
        a = Number(r >> i & s),
        o = Number(r & s),
        c = n ? 4 : 0,
        l = n ? 0 : 4;
    t.setUint32(e + c, a, n), t.setUint32(e + l, o, n)
}

function Pye(t, e, r) {
    return t & e ^ ~t & r
}

function Nye(t, e, r) {
    return t & e ^ t & r ^ e & r
}
let uD = class extends $y {
    constructor(e, r, n, i) {
        super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(e), this.view = pb(this.buffer)
    }
    update(e) {
        sl(this), e = wa(e), Ms(e);
        const {
            view: r,
            buffer: n,
            blockLen: i
        } = this, s = e.length;
        for (let a = 0; a < s;) {
            const o = Math.min(i - this.pos, s - a);
            if (o === i) {
                const c = pb(e);
                for (; i <= s - a; a += i) this.process(c, a);
                continue
            }
            n.set(e.subarray(a, a + o), this.pos), this.pos += o, a += o, this.pos === i && (this.process(r, 0), this.pos = 0)
        }
        return this.length += e.length, this.roundClean(), this
    }
    digestInto(e) {
        sl(this), Wx(e, this), this.finished = !0;
        const {
            buffer: r,
            view: n,
            blockLen: i,
            isLE: s
        } = this;
        let {
            pos: a
        } = this;
        r[a++] = 128, Ds(this.buffer.subarray(a)), this.padOffset > i - a && (this.process(n, 0), a = 0);
        for (let h = a; h < i; h++) r[h] = 0;
        Tye(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);
        const o = pb(e),
            c = this.outputLen;
        if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const l = c / 4,
            u = this.get();
        if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
        for (let h = 0; h < l; h++) o.setUint32(4 * h, u[h], s)
    }
    digest() {
        const {
            buffer: e,
            outputLen: r
        } = this;
        this.digestInto(e);
        const n = e.slice(0, r);
        return this.destroy(), n
    }
    _cloneInto(e) {
        e || (e = new this.constructor), e.set(...this.get());
        const {
            blockLen: r,
            buffer: n,
            length: i,
            finished: s,
            destroyed: a,
            pos: o
        } = this;
        return e.destroyed = a, e.finished = s, e.length = i, e.pos = o, i % r && e.buffer.set(n), e
    }
    clone() {
        return this._cloneInto()
    }
};
const kc = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
    Wn = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]),
    zn = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]),
    Oye = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
    Ic = new Uint32Array(64);
let jye = class extends uD {
    constructor(e = 32) {
        super(64, e, 8, !1), this.A = kc[0] | 0, this.B = kc[1] | 0, this.C = kc[2] | 0, this.D = kc[3] | 0, this.E = kc[4] | 0, this.F = kc[5] | 0, this.G = kc[6] | 0, this.H = kc[7] | 0
    }
    get() {
        const {
            A: e,
            B: r,
            C: n,
            D: i,
            E: s,
            F: a,
            G: o,
            H: c
        } = this;
        return [e, r, n, i, s, a, o, c]
    }
    set(e, r, n, i, s, a, o, c) {
        this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = a | 0, this.G = o | 0, this.H = c | 0
    }
    process(e, r) {
        for (let h = 0; h < 16; h++, r += 4) Ic[h] = e.getUint32(r, !1);
        for (let h = 16; h < 64; h++) {
            const f = Ic[h - 15],
                p = Ic[h - 2],
                g = Ba(f, 7) ^ Ba(f, 18) ^ f >>> 3,
                m = Ba(p, 17) ^ Ba(p, 19) ^ p >>> 10;
            Ic[h] = m + Ic[h - 7] + g + Ic[h - 16] | 0
        }
        let {
            A: n,
            B: i,
            C: s,
            D: a,
            E: o,
            F: c,
            G: l,
            H: u
        } = this;
        for (let h = 0; h < 64; h++) {
            const f = Ba(o, 6) ^ Ba(o, 11) ^ Ba(o, 25),
                p = u + f + Pye(o, c, l) + Oye[h] + Ic[h] | 0,
                g = (Ba(n, 2) ^ Ba(n, 13) ^ Ba(n, 22)) + Nye(n, i, s) | 0;
            u = l, l = c, c = o, o = a + p | 0, a = s, s = i, i = n, n = p + g | 0
        }
        n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, a = a + this.D | 0, o = o + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, u = u + this.H | 0, this.set(n, i, s, a, o, c, l, u)
    }
    roundClean() {
        Ds(Ic)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), Ds(this.buffer)
    }
};
const hD = rD(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(t => BigInt(t))),
    Rye = hD[0],
    Mye = hD[1],
    $c = new Uint32Array(80),
    Sc = new Uint32Array(80);
let qx = class extends uD {
        constructor(e = 64) {
            super(128, e, 16, !1), this.Ah = zn[0] | 0, this.Al = zn[1] | 0, this.Bh = zn[2] | 0, this.Bl = zn[3] | 0, this.Ch = zn[4] | 0, this.Cl = zn[5] | 0, this.Dh = zn[6] | 0, this.Dl = zn[7] | 0, this.Eh = zn[8] | 0, this.El = zn[9] | 0, this.Fh = zn[10] | 0, this.Fl = zn[11] | 0, this.Gh = zn[12] | 0, this.Gl = zn[13] | 0, this.Hh = zn[14] | 0, this.Hl = zn[15] | 0
        }
        get() {
            const {
                Ah: e,
                Al: r,
                Bh: n,
                Bl: i,
                Ch: s,
                Cl: a,
                Dh: o,
                Dl: c,
                Eh: l,
                El: u,
                Fh: h,
                Fl: f,
                Gh: p,
                Gl: g,
                Hh: m,
                Hl: y
            } = this;
            return [e, r, n, i, s, a, o, c, l, u, h, f, p, g, m, y]
        }
        set(e, r, n, i, s, a, o, c, l, u, h, f, p, g, m, y) {
            this.Ah = e | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = s | 0, this.Cl = a | 0, this.Dh = o | 0, this.Dl = c | 0, this.Eh = l | 0, this.El = u | 0, this.Fh = h | 0, this.Fl = f | 0, this.Gh = p | 0, this.Gl = g | 0, this.Hh = m | 0, this.Hl = y | 0
        }
        process(e, r) {
            for (let E = 0; E < 16; E++, r += 4) $c[E] = e.getUint32(r), Sc[E] = e.getUint32(r += 4);
            for (let E = 16; E < 80; E++) {
                const _ = $c[E - 15] | 0,
                    b = Sc[E - 15] | 0,
                    A = Rc(_, b, 1) ^ Rc(_, b, 8) ^ hA(_, b, 7),
                    I = Mc(_, b, 1) ^ Mc(_, b, 8) ^ fA(_, b, 7),
                    T = $c[E - 2] | 0,
                    C = Sc[E - 2] | 0,
                    $ = Rc(T, C, 19) ^ If(T, C, 61) ^ hA(T, C, 6),
                    P = Mc(T, C, 19) ^ $f(T, C, 61) ^ fA(T, C, 6),
                    N = uye(I, P, Sc[E - 7], Sc[E - 16]),
                    R = hye(N, A, $, $c[E - 7], $c[E - 16]);
                $c[E] = R | 0, Sc[E] = N | 0
            }
            let {
                Ah: n,
                Al: i,
                Bh: s,
                Bl: a,
                Ch: o,
                Cl: c,
                Dh: l,
                Dl: u,
                Eh: h,
                El: f,
                Fh: p,
                Fl: g,
                Gh: m,
                Gl: y,
                Hh: w,
                Hl: x
            } = this;
            for (let E = 0; E < 80; E++) {
                const _ = Rc(h, f, 14) ^ Rc(h, f, 18) ^ If(h, f, 41),
                    b = Mc(h, f, 14) ^ Mc(h, f, 18) ^ $f(h, f, 41),
                    A = h & p ^ ~h & m,
                    I = f & g ^ ~f & y,
                    T = fye(x, b, I, Mye[E], Sc[E]),
                    C = pye(T, w, _, A, Rye[E], $c[E]),
                    $ = T | 0,
                    P = Rc(n, i, 28) ^ If(n, i, 34) ^ If(n, i, 39),
                    N = Mc(n, i, 28) ^ $f(n, i, 34) ^ $f(n, i, 39),
                    R = n & s ^ n & o ^ s & o,
                    D = i & a ^ i & c ^ a & c;
                w = m | 0, x = y | 0, m = p | 0, y = g | 0, p = h | 0, g = f | 0, {
                    h,
                    l: f
                } = sa(l | 0, u | 0, C | 0, $ | 0), l = o | 0, u = c | 0, o = s | 0, c = a | 0, s = n | 0, a = i | 0;
                const S = Lx($, N, D);
                n = Ux(S, C, P, R), i = S | 0
            }({
                h: n,
                l: i
            } = sa(this.Ah | 0, this.Al | 0, n | 0, i | 0)), {
                h: s,
                l: a
            } = sa(this.Bh | 0, this.Bl | 0, s | 0, a | 0), {
                h: o,
                l: c
            } = sa(this.Ch | 0, this.Cl | 0, o | 0, c | 0), {
                h: l,
                l: u
            } = sa(this.Dh | 0, this.Dl | 0, l | 0, u | 0), {
                h,
                l: f
            } = sa(this.Eh | 0, this.El | 0, h | 0, f | 0), {
                h: p,
                l: g
            } = sa(this.Fh | 0, this.Fl | 0, p | 0, g | 0), {
                h: m,
                l: y
            } = sa(this.Gh | 0, this.Gl | 0, m | 0, y | 0), {
                h: w,
                l: x
            } = sa(this.Hh | 0, this.Hl | 0, w | 0, x | 0), this.set(n, i, s, a, o, c, l, u, h, f, p, g, m, y, w, x)
        }
        roundClean() {
            Ds($c, Sc)
        }
        destroy() {
            Ds(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
        }
    },
    Dye = class extends qx {
        constructor() {
            super(48), this.Ah = Wn[0] | 0, this.Al = Wn[1] | 0, this.Bh = Wn[2] | 0, this.Bl = Wn[3] | 0, this.Ch = Wn[4] | 0, this.Cl = Wn[5] | 0, this.Dh = Wn[6] | 0, this.Dl = Wn[7] | 0, this.Eh = Wn[8] | 0, this.El = Wn[9] | 0, this.Fh = Wn[10] | 0, this.Fl = Wn[11] | 0, this.Gh = Wn[12] | 0, this.Gl = Wn[13] | 0, this.Hh = Wn[14] | 0, this.Hl = Wn[15] | 0
        }
    };
const qn = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
let Lye = class extends qx {
    constructor() {
        super(32), this.Ah = qn[0] | 0, this.Al = qn[1] | 0, this.Bh = qn[2] | 0, this.Bl = qn[3] | 0, this.Ch = qn[4] | 0, this.Cl = qn[5] | 0, this.Dh = qn[6] | 0, this.Dl = qn[7] | 0, this.Eh = qn[8] | 0, this.El = qn[9] | 0, this.Fh = qn[10] | 0, this.Fl = qn[11] | 0, this.Gh = qn[12] | 0, this.Gl = qn[13] | 0, this.Hh = qn[14] | 0, this.Hl = qn[15] | 0
    }
};
const Sy = C0(() => new jye),
    Uye = C0(() => new qx),
    Fye = C0(() => new Dye),
    Bye = C0(() => new Lye),
    Wye = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]),
    rn = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]),
    ze = new Uint32Array(32);

function Tc(t, e, r, n, i, s) {
    const a = i[s],
        o = i[s + 1];
    let c = ze[2 * t],
        l = ze[2 * t + 1],
        u = ze[2 * e],
        h = ze[2 * e + 1],
        f = ze[2 * r],
        p = ze[2 * r + 1],
        g = ze[2 * n],
        m = ze[2 * n + 1],
        y = Lx(c, u, a);
    l = Ux(y, l, h, o), c = y | 0, {
        Dh: m,
        Dl: g
    } = {
        Dh: m ^ l,
        Dl: g ^ c
    }, {
        Dh: m,
        Dl: g
    } = {
        Dh: sye(m, g),
        Dl: aye(m)
    }, {
        h: p,
        l: f
    } = sa(p, f, m, g), {
        Bh: h,
        Bl: u
    } = {
        Bh: h ^ p,
        Bl: u ^ f
    }, {
        Bh: h,
        Bl: u
    } = {
        Bh: Rc(h, u, 24),
        Bl: Mc(h, u, 24)
    }, ze[2 * t] = c, ze[2 * t + 1] = l, ze[2 * e] = u, ze[2 * e + 1] = h, ze[2 * r] = f, ze[2 * r + 1] = p, ze[2 * n] = g, ze[2 * n + 1] = m
}

function Pc(t, e, r, n, i, s) {
    const a = i[s],
        o = i[s + 1];
    let c = ze[2 * t],
        l = ze[2 * t + 1],
        u = ze[2 * e],
        h = ze[2 * e + 1],
        f = ze[2 * r],
        p = ze[2 * r + 1],
        g = ze[2 * n],
        m = ze[2 * n + 1],
        y = Lx(c, u, a);
    l = Ux(y, l, h, o), c = y | 0, {
        Dh: m,
        Dl: g
    } = {
        Dh: m ^ l,
        Dl: g ^ c
    }, {
        Dh: m,
        Dl: g
    } = {
        Dh: Rc(m, g, 16),
        Dl: Mc(m, g, 16)
    }, {
        h: p,
        l: f
    } = sa(p, f, m, g), {
        Bh: h,
        Bl: u
    } = {
        Bh: h ^ p,
        Bl: u ^ f
    }, {
        Bh: h,
        Bl: u
    } = {
        Bh: If(h, u, 63),
        Bl: $f(h, u, 63)
    }, ze[2 * t] = c, ze[2 * t + 1] = l, ze[2 * e] = u, ze[2 * e + 1] = h, ze[2 * r] = f, ze[2 * r + 1] = p, ze[2 * n] = g, ze[2 * n + 1] = m
}

function zye(t, e = {}, r, n, i) {
    if (oc(r), t < 0 || t > r) throw new Error("outputLen bigger than keyLen");
    const {
        key: s,
        salt: a,
        personalization: o
    } = e;
    if (s !== void 0 && (s.length < 1 || s.length > r)) throw new Error("key length must be undefined or 1.." + r);
    if (a !== void 0 && a.length !== n) throw new Error("salt must be undefined or " + n);
    if (o !== void 0 && o.length !== i) throw new Error("personalization must be undefined or " + i)
}
let qye = class extends $y {
        constructor(e, r) {
            super(), this.finished = !1, this.destroyed = !1, this.length = 0, this.pos = 0, oc(e), oc(r), this.blockLen = e, this.outputLen = r, this.buffer = new Uint8Array(e), this.buffer32 = Dp(this.buffer)
        }
        update(e) {
            sl(this), e = wa(e), Ms(e);
            const {
                blockLen: r,
                buffer: n,
                buffer32: i
            } = this, s = e.length, a = e.byteOffset, o = e.buffer;
            for (let c = 0; c < s;) {
                this.pos === r && (Dc(i), this.compress(i, 0, !1), Dc(i), this.pos = 0);
                const l = Math.min(r - this.pos, s - c),
                    u = a + c;
                if (l === r && !(u % 4) && c + l < s) {
                    const h = new Uint32Array(o, u, Math.floor((s - c) / 4));
                    Dc(h);
                    for (let f = 0; c + r < s; f += i.length, c += r) this.length += r, this.compress(h, f, !1);
                    Dc(h);
                    continue
                }
                n.set(e.subarray(c, c + l), this.pos), this.pos += l, this.length += l, c += l
            }
            return this
        }
        digestInto(e) {
            sl(this), Wx(e, this);
            const {
                pos: r,
                buffer32: n
            } = this;
            this.finished = !0, Ds(this.buffer.subarray(r)), Dc(n), this.compress(n, 0, !0), Dc(n);
            const i = Dp(e);
            this.get().forEach((s, a) => i[a] = To(s))
        }
        digest() {
            const {
                buffer: e,
                outputLen: r
            } = this;
            this.digestInto(e);
            const n = e.slice(0, r);
            return this.destroy(), n
        }
        _cloneInto(e) {
            const {
                buffer: r,
                length: n,
                finished: i,
                destroyed: s,
                outputLen: a,
                pos: o
            } = this;
            return e || (e = new this.constructor({
                dkLen: a
            })), e.set(...this.get()), e.buffer.set(r), e.destroyed = s, e.finished = i, e.length = n, e.pos = o, e.outputLen = a, e
        }
        clone() {
            return this._cloneInto()
        }
    },
    Hye = class extends qye {
        constructor(e = {}) {
            const r = e.dkLen === void 0 ? 64 : e.dkLen;
            super(128, r), this.v0l = rn[0] | 0, this.v0h = rn[1] | 0, this.v1l = rn[2] | 0, this.v1h = rn[3] | 0, this.v2l = rn[4] | 0, this.v2h = rn[5] | 0, this.v3l = rn[6] | 0, this.v3h = rn[7] | 0, this.v4l = rn[8] | 0, this.v4h = rn[9] | 0, this.v5l = rn[10] | 0, this.v5h = rn[11] | 0, this.v6l = rn[12] | 0, this.v6h = rn[13] | 0, this.v7l = rn[14] | 0, this.v7h = rn[15] | 0, zye(r, e, 64, 16, 16);
            let {
                key: n,
                personalization: i,
                salt: s
            } = e, a = 0;
            if (n !== void 0 && (n = wa(n), a = n.length), this.v0l ^= this.outputLen | a << 8 | 65536 | 1 << 24, s !== void 0) {
                s = wa(s);
                const o = Dp(s);
                this.v4l ^= To(o[0]), this.v4h ^= To(o[1]), this.v5l ^= To(o[2]), this.v5h ^= To(o[3])
            }
            if (i !== void 0) {
                i = wa(i);
                const o = Dp(i);
                this.v6l ^= To(o[0]), this.v6h ^= To(o[1]), this.v7l ^= To(o[2]), this.v7h ^= To(o[3])
            }
            if (n !== void 0) {
                const o = new Uint8Array(this.blockLen);
                o.set(n), this.update(o)
            }
        }
        get() {
            let {
                v0l: e,
                v0h: r,
                v1l: n,
                v1h: i,
                v2l: s,
                v2h: a,
                v3l: o,
                v3h: c,
                v4l: l,
                v4h: u,
                v5l: h,
                v5h: f,
                v6l: p,
                v6h: g,
                v7l: m,
                v7h: y
            } = this;
            return [e, r, n, i, s, a, o, c, l, u, h, f, p, g, m, y]
        }
        set(e, r, n, i, s, a, o, c, l, u, h, f, p, g, m, y) {
            this.v0l = e | 0, this.v0h = r | 0, this.v1l = n | 0, this.v1h = i | 0, this.v2l = s | 0, this.v2h = a | 0, this.v3l = o | 0, this.v3h = c | 0, this.v4l = l | 0, this.v4h = u | 0, this.v5l = h | 0, this.v5h = f | 0, this.v6l = p | 0, this.v6h = g | 0, this.v7l = m | 0, this.v7h = y | 0
        }
        compress(e, r, n) {
            this.get().forEach((c, l) => ze[l] = c), ze.set(rn, 16);
            let {
                h: i,
                l: s
            } = tD(BigInt(this.length));
            ze[24] = rn[8] ^ s, ze[25] = rn[9] ^ i, n && (ze[28] = ~ze[28], ze[29] = ~ze[29]);
            let a = 0;
            const o = Wye;
            for (let c = 0; c < 12; c++) Tc(0, 4, 8, 12, e, r + 2 * o[a++]), Pc(0, 4, 8, 12, e, r + 2 * o[a++]), Tc(1, 5, 9, 13, e, r + 2 * o[a++]), Pc(1, 5, 9, 13, e, r + 2 * o[a++]), Tc(2, 6, 10, 14, e, r + 2 * o[a++]), Pc(2, 6, 10, 14, e, r + 2 * o[a++]), Tc(3, 7, 11, 15, e, r + 2 * o[a++]), Pc(3, 7, 11, 15, e, r + 2 * o[a++]), Tc(0, 5, 10, 15, e, r + 2 * o[a++]), Pc(0, 5, 10, 15, e, r + 2 * o[a++]), Tc(1, 6, 11, 12, e, r + 2 * o[a++]), Pc(1, 6, 11, 12, e, r + 2 * o[a++]), Tc(2, 7, 8, 13, e, r + 2 * o[a++]), Pc(2, 7, 8, 13, e, r + 2 * o[a++]), Tc(3, 4, 9, 14, e, r + 2 * o[a++]), Pc(3, 4, 9, 14, e, r + 2 * o[a++]);
            this.v0l ^= ze[0] ^ ze[16], this.v0h ^= ze[1] ^ ze[17], this.v1l ^= ze[2] ^ ze[18], this.v1h ^= ze[3] ^ ze[19], this.v2l ^= ze[4] ^ ze[20], this.v2h ^= ze[5] ^ ze[21], this.v3l ^= ze[6] ^ ze[22], this.v3h ^= ze[7] ^ ze[23], this.v4l ^= ze[8] ^ ze[24], this.v4h ^= ze[9] ^ ze[25], this.v5l ^= ze[10] ^ ze[26], this.v5h ^= ze[11] ^ ze[27], this.v6l ^= ze[12] ^ ze[28], this.v6h ^= ze[13] ^ ze[29], this.v7l ^= ze[14] ^ ze[30], this.v7h ^= ze[15] ^ ze[31], Ds(ze)
        }
        destroy() {
            this.destroyed = !0, Ds(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
        }
    };
const Vye = wye(t => new Hye(t)),
    Gye = "https://rpc.walletconnect.org/v1";

function fD(t) {
    const e = `Ethereum Signed Message:
${t.length}`,
        r = new TextEncoder().encode(e + t);
    return "0x" + Ve.from(Sye(r)).toString("hex")
}
async function Kye(t, e, r, n, i, s) {
    switch (r.t) {
        case "eip191":
            return await Yye(t, e, r.s);
        case "eip1271":
            return await Zye(t, e, r.s, n, i, s);
        default:
            throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${r.t}`)
    }
}
async function Yye(t, e, r) {
    return (await bfe({
        hash: fD(e),
        signature: r
    })).toLowerCase() === t.toLowerCase()
}
async function Zye(t, e, r, n, i, s) {
    const a = zu(n);
    if (!a.namespace || !a.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${n}`);
    try {
        const o = "0x1626ba7e",
            c = "0000000000000000000000000000000000000000000000000000000000000040",
            l = r.substring(2),
            u = (l.length / 2).toString(16).padStart(64, "0"),
            h = (e.startsWith("0x") ? e : fD(e)).substring(2),
            f = o + h + c + u + l,
            p = await fetch(`${s||Gye}/?chainId=${n}&projectId=${i}`, {
                headers: {
                    "Content-Type": "application/json"
                },
                method: "POST",
                body: JSON.stringify({
                    id: Jye(),
                    jsonrpc: "2.0",
                    method: "eth_call",
                    params: [{
                        to: t,
                        data: f
                    }, "latest"]
                })
            }),
            {
                result: g
            } = await p.json();
        return g ? g.slice(0, o.length).toLowerCase() === o.toLowerCase() : !1
    } catch (o) {
        return console.error("isValidEip1271Signature: ", o), !1
    }
}

function Jye() {
    return Date.now() + Math.floor(Math.random() * 1e3)
}

function Qye(t) {
    const e = atob(t),
        r = new Uint8Array(e.length);
    for (let a = 0; a < e.length; a++) r[a] = e.charCodeAt(a);
    const n = r[0];
    if (n === 0) throw new Error("No signatures found");
    const i = 1 + n * 64;
    if (r.length < i) throw new Error("Transaction data too short for claimed signature count");
    if (r.length < 100) throw new Error("Transaction too short");
    const s = Ve.from(t, "base64").slice(1, 65);
    return b0.encode(s)
}

function Xye(t) {
    const e = new Uint8Array(Ve.from(t, "base64")),
        r = Array.from("TransactionData::").map(s => s.charCodeAt(0)),
        n = new Uint8Array(r.length + e.length);
    n.set(r), n.set(e, r.length);
    const i = Vye(n, {
        dkLen: 32
    });
    return b0.encode(i)
}

function yA(t) {
    const e = new Uint8Array(Sy(ewe(t)));
    return b0.encode(e)
}

function ewe(t) {
    if (t instanceof Uint8Array) return t;
    if (Array.isArray(t)) return new Uint8Array(t);
    if (typeof t == "object" && t != null && t.data) return new Uint8Array(Object.values(t.data));
    if (typeof t == "object" && t) return new Uint8Array(Object.values(t));
    throw new Error("getNearUint8ArrayFromBytes: Unexpected result type from bytes array")
}

function wA(t) {
    const e = Ve.from(t, "base64"),
        r = Npe(e).txn;
    if (!r) throw new Error("Invalid signed transaction: missing 'txn' field");
    const n = _pe(r),
        i = Ve.from("TX"),
        s = Ve.concat([i, Ve.from(n)]),
        a = Bye(s);
    return Mpe.encode(a).replace(/=+$/, "")
}

function gb(t) {
    const e = [];
    let r = BigInt(t);
    for (; r >= BigInt(128);) e.push(Number(r & BigInt(127) | BigInt(128))), r >>= BigInt(7);
    return e.push(Number(r)), Ve.from(e)
}

function twe(t) {
    const e = Ve.from(t.signed.bodyBytes, "base64"),
        r = Ve.from(t.signed.authInfoBytes, "base64"),
        n = Ve.from(t.signature.signature, "base64"),
        i = [];
    i.push(Ve.from([10])), i.push(gb(e.length)), i.push(e), i.push(Ve.from([18])), i.push(gb(r.length)), i.push(r), i.push(Ve.from([26])), i.push(gb(n.length)), i.push(n);
    const s = Ve.concat(i),
        a = Sy(s);
    return Ve.from(a).toString("hex").toUpperCase()
}
var rwe = Object.defineProperty,
    nwe = Object.defineProperties,
    iwe = Object.getOwnPropertyDescriptors,
    bA = Object.getOwnPropertySymbols,
    swe = Object.prototype.hasOwnProperty,
    awe = Object.prototype.propertyIsEnumerable,
    vA = (t, e, r) => e in t ? rwe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    owe = (t, e) => {
        for (var r in e || (e = {})) swe.call(e, r) && vA(t, r, e[r]);
        if (bA)
            for (var r of bA(e)) awe.call(e, r) && vA(t, r, e[r]);
        return t
    },
    cwe = (t, e) => nwe(t, iwe(e));
const lwe = "did:pkh:",
    Hx = t => t == null ? void 0 : t.split(":"),
    dwe = t => {
        const e = t && Hx(t);
        if (e) return t.includes(lwe) ? e[3] : e[1]
    },
    S5 = t => {
        const e = t && Hx(t);
        if (e) return e[2] + ":" + e[3]
    },
    Qm = t => {
        const e = t && Hx(t);
        if (e) return e.pop()
    };
async function xA(t) {
    const {
        cacao: e,
        projectId: r
    } = t, {
        s: n,
        p: i
    } = e, s = pD(i, i.iss), a = Qm(i.iss);
    return await Kye(a, s, n, S5(i.iss), r)
}
const pD = (t, e) => {
    const r = `${t.domain} wants you to sign in with your Ethereum account:`,
        n = Qm(e);
    if (!t.aud && !t.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
    let i = t.statement || void 0;
    const s = `URI: ${t.aud||t.uri}`,
        a = `Version: ${t.version}`,
        o = `Chain ID: ${dwe(e)}`,
        c = `Nonce: ${t.nonce}`,
        l = `Issued At: ${t.iat}`,
        u = t.exp ? `Expiration Time: ${t.exp}` : void 0,
        h = t.nbf ? `Not Before: ${t.nbf}` : void 0,
        f = t.requestId ? `Request ID: ${t.requestId}` : void 0,
        p = t.resources ? `Resources:${t.resources.map(m=>`
- ${m}`).join("")}` : void 0,
        g = Xg(t.resources);
    if (g) {
        const m = Up(g);
        i = bwe(i, m)
    }
    return [r, n, "", i, "", s, a, o, c, l, u, h, f, p].filter(m => m != null).join(`
`)
};

function uwe(t) {
    return Ve.from(JSON.stringify(t)).toString("base64")
}

function hwe(t) {
    return JSON.parse(Ve.from(t, "base64").toString("utf-8"))
}

function wd(t) {
    if (!t) throw new Error("No recap provided, value is undefined");
    if (!t.att) throw new Error("No `att` property found");
    const e = Object.keys(t.att);
    if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
    e.forEach(r => {
        const n = t.att[r];
        if (Array.isArray(n)) throw new Error(`Resource must be an object: ${r}`);
        if (typeof n != "object") throw new Error(`Resource must be an object: ${r}`);
        if (!Object.keys(n).length) throw new Error(`Resource object is empty: ${r}`);
        Object.keys(n).forEach(i => {
            const s = n[i];
            if (!Array.isArray(s)) throw new Error(`Ability limits ${i} must be an array of objects, found: ${s}`);
            if (!s.length) throw new Error(`Value of ${i} is empty array, must be an array with objects`);
            s.forEach(a => {
                if (typeof a != "object") throw new Error(`Ability limits (${i}) must be an array of objects, found: ${a}`)
            })
        })
    })
}

function fwe(t, e, r, n = {}) {
    return r == null || r.sort((i, s) => i.localeCompare(s)), {
        att: {
            [t]: pwe(e, r, n)
        }
    }
}

function pwe(t, e, r = {}) {
    e = e == null ? void 0 : e.sort((i, s) => i.localeCompare(s));
    const n = e.map(i => ({
        [`${t}/${i}`]: [r]
    }));
    return Object.assign({}, ...n)
}

function gD(t) {
    return wd(t), `urn:recap:${uwe(t).replace(/=/g,"")}`
}

function Up(t) {
    const e = hwe(t.replace("urn:recap:", ""));
    return wd(e), e
}

function gwe(t, e, r) {
    const n = fwe(t, e, r);
    return gD(n)
}

function mwe(t) {
    return t && t.includes("urn:recap:")
}

function ywe(t, e) {
    const r = Up(t),
        n = Up(e),
        i = wwe(r, n);
    return gD(i)
}

function wwe(t, e) {
    wd(t), wd(e);
    const r = Object.keys(t.att).concat(Object.keys(e.att)).sort((i, s) => i.localeCompare(s)),
        n = {
            att: {}
        };
    return r.forEach(i => {
        var s, a;
        Object.keys(((s = t.att) == null ? void 0 : s[i]) || {}).concat(Object.keys(((a = e.att) == null ? void 0 : a[i]) || {})).sort((o, c) => o.localeCompare(c)).forEach(o => {
            var c, l;
            n.att[i] = cwe(owe({}, n.att[i]), {
                [o]: ((c = t.att[i]) == null ? void 0 : c[o]) || ((l = e.att[i]) == null ? void 0 : l[o])
            })
        })
    }), n
}

function bwe(t = "", e) {
    wd(e);
    const r = "I further authorize the stated URI to perform the following actions on my behalf: ";
    if (t.includes(r)) return t;
    const n = [];
    let i = 0;
    Object.keys(e.att).forEach(o => {
        const c = Object.keys(e.att[o]).map(h => ({
            ability: h.split("/")[0],
            action: h.split("/")[1]
        }));
        c.sort((h, f) => h.action.localeCompare(f.action));
        const l = {};
        c.forEach(h => {
            l[h.ability] || (l[h.ability] = []), l[h.ability].push(h.action)
        });
        const u = Object.keys(l).map(h => (i++, `(${i}) '${h}': '${l[h].join("', '")}' for '${o}'.`));
        n.push(u.join(", ").replace(".,", "."))
    });
    const s = n.join(" "),
        a = `${r}${s}`;
    return `${t?t+" ":""}${a}`
}

function EA(t) {
    var e;
    const r = Up(t);
    wd(r);
    const n = (e = r.att) == null ? void 0 : e.eip155;
    return n ? Object.keys(n).map(i => i.split("/")[1]) : []
}

function _A(t) {
    const e = Up(t);
    wd(e);
    const r = [];
    return Object.values(e.att).forEach(n => {
        Object.values(n).forEach(i => {
            var s;
            (s = i == null ? void 0 : i[0]) != null && s.chains && r.push(i[0].chains)
        })
    }), [...new Set(r.flat())]
}

function Xg(t) {
    if (!t) return;
    const e = t == null ? void 0 : t[t.length - 1];
    return mwe(e) ? e : void 0
} /*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */
function mD(t) {
    return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array"
}

function T5(t) {
    if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`)
}

function mb(t) {
    if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t)
}

function Pi(t, ...e) {
    if (!mD(t)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length)
}

function CA(t, e = !0) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished) throw new Error("Hash#digest() has already been called")
}

function vwe(t, e) {
    Pi(t);
    const r = e.outputLen;
    if (t.length < r) throw new Error("digestInto() expects output buffer of length at least " + r)
}

function el(t) {
    return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4))
}

function sh(...t) {
    for (let e = 0; e < t.length; e++) t[e].fill(0)
}

function xwe(t) {
    return new DataView(t.buffer, t.byteOffset, t.byteLength)
}
const Ewe = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;

function _we(t) {
    if (typeof t != "string") throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(t))
}

function P5(t) {
    if (typeof t == "string") t = _we(t);
    else if (mD(t)) t = N5(t);
    else throw new Error("Uint8Array expected, got " + typeof t);
    return t
}

function Cwe(t, e) {
    if (e == null || typeof e != "object") throw new Error("options must be defined");
    return Object.assign(t, e)
}

function Awe(t, e) {
    if (t.length !== e.length) return !1;
    let r = 0;
    for (let n = 0; n < t.length; n++) r |= t[n] ^ e[n];
    return r === 0
}
const kwe = (t, e) => {
    function r(n, ...i) {
        if (Pi(n), !Ewe) throw new Error("Non little-endian hardware is not yet supported");
        if (t.nonceLength !== void 0) {
            const l = i[0];
            if (!l) throw new Error("nonce / iv required");
            t.varSizeNonce ? Pi(l) : Pi(l, t.nonceLength)
        }
        const s = t.tagLength;
        s && i[1] !== void 0 && Pi(i[1]);
        const a = e(n, ...i),
            o = (l, u) => {
                if (u !== void 0) {
                    if (l !== 2) throw new Error("cipher output not supported");
                    Pi(u)
                }
            };
        let c = !1;
        return {
            encrypt(l, u) {
                if (c) throw new Error("cannot encrypt() twice with same key + nonce");
                return c = !0, Pi(l), o(a.encrypt.length, u), a.encrypt(l, u)
            },
            decrypt(l, u) {
                if (Pi(l), s && l.length < s) throw new Error("invalid ciphertext length: smaller than tagLength=" + s);
                return o(a.decrypt.length, u), a.decrypt(l, u)
            }
        }
    }
    return Object.assign(r, t), r
};

function AA(t, e, r = !0) {
    if (e === void 0) return new Uint8Array(t);
    if (e.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e.length);
    if (r && !$we(e)) throw new Error("invalid output, must be aligned");
    return e
}

function kA(t, e, r, n) {
    if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, r, n);
    const i = BigInt(32),
        s = BigInt(4294967295),
        a = Number(r >> i & s),
        o = Number(r & s);
    t.setUint32(e + 4, a, n), t.setUint32(e + 0, o, n)
}

function Iwe(t, e, r) {
    T5(r);
    const n = new Uint8Array(16),
        i = xwe(n);
    return kA(i, 0, BigInt(e), r), kA(i, 8, BigInt(t), r), n
}

function $we(t) {
    return t.byteOffset % 4 === 0
}

function N5(t) {
    return Uint8Array.from(t)
}
const yD = t => Uint8Array.from(t.split("").map(e => e.charCodeAt(0))),
    Swe = yD("expand 16-byte k"),
    Twe = yD("expand 32-byte k"),
    Pwe = el(Swe),
    Nwe = el(Twe);

function Zt(t, e) {
    return t << e | t >>> 32 - e
}

function O5(t) {
    return t.byteOffset % 4 === 0
}
const yg = 64,
    Owe = 16,
    wD = 2 ** 32 - 1,
    IA = new Uint32Array;

function jwe(t, e, r, n, i, s, a, o) {
    const c = i.length,
        l = new Uint8Array(yg),
        u = el(l),
        h = O5(i) && O5(s),
        f = h ? el(i) : IA,
        p = h ? el(s) : IA;
    for (let g = 0; g < c; a++) {
        if (t(e, r, n, u, a, o), a >= wD) throw new Error("arx: counter overflow");
        const m = Math.min(yg, c - g);
        if (h && m === yg) {
            const y = g / 4;
            if (g % 4 !== 0) throw new Error("arx: invalid block position");
            for (let w = 0, x; w < Owe; w++) x = y + w, p[x] = f[x] ^ u[w];
            g += yg;
            continue
        }
        for (let y = 0, w; y < m; y++) w = g + y, s[w] = i[w] ^ l[y];
        g += m
    }
}

function Rwe(t, e) {
    const {
        allowShortKeys: r,
        extendNonceFn: n,
        counterLength: i,
        counterRight: s,
        rounds: a
    } = Cwe({
        allowShortKeys: !1,
        counterLength: 8,
        counterRight: !1,
        rounds: 20
    }, e);
    if (typeof t != "function") throw new Error("core must be a function");
    return mb(i), mb(a), T5(s), T5(r), (o, c, l, u, h = 0) => {
        Pi(o), Pi(c), Pi(l);
        const f = l.length;
        if (u === void 0 && (u = new Uint8Array(f)), Pi(u), mb(h), h < 0 || h >= wD) throw new Error("arx: counter overflow");
        if (u.length < f) throw new Error(`arx: output (${u.length}) is shorter than data (${f})`);
        const p = [];
        let g = o.length,
            m, y;
        if (g === 32) p.push(m = N5(o)), y = Nwe;
        else if (g === 16 && r) m = new Uint8Array(32), m.set(o), m.set(o, 16), y = Pwe, p.push(m);
        else throw new Error(`arx: invalid 32-byte key, got length=${g}`);
        O5(c) || p.push(c = N5(c));
        const w = el(m);
        if (n) {
            if (c.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
            n(y, w, el(c.subarray(0, 16)), w), c = c.subarray(16)
        }
        const x = 16 - i;
        if (x !== c.length) throw new Error(`arx: nonce must be ${x} or 16 bytes`);
        if (x !== 12) {
            const _ = new Uint8Array(12);
            _.set(c, s ? 0 : 12 - c.length), c = _, p.push(c)
        }
        const E = el(c);
        return jwe(t, y, w, E, l, u, h, a), sh(...p), u
    }
}
const vn = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;
let Mwe = class {
    constructor(e) {
        this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, e = P5(e), Pi(e, 32);
        const r = vn(e, 0),
            n = vn(e, 2),
            i = vn(e, 4),
            s = vn(e, 6),
            a = vn(e, 8),
            o = vn(e, 10),
            c = vn(e, 12),
            l = vn(e, 14);
        this.r[0] = r & 8191, this.r[1] = (r >>> 13 | n << 3) & 8191, this.r[2] = (n >>> 10 | i << 6) & 7939, this.r[3] = (i >>> 7 | s << 9) & 8191, this.r[4] = (s >>> 4 | a << 12) & 255, this.r[5] = a >>> 1 & 8190, this.r[6] = (a >>> 14 | o << 2) & 8191, this.r[7] = (o >>> 11 | c << 5) & 8065, this.r[8] = (c >>> 8 | l << 8) & 8191, this.r[9] = l >>> 5 & 127;
        for (let u = 0; u < 8; u++) this.pad[u] = vn(e, 16 + 2 * u)
    }
    process(e, r, n = !1) {
        const i = n ? 0 : 2048,
            {
                h: s,
                r: a
            } = this,
            o = a[0],
            c = a[1],
            l = a[2],
            u = a[3],
            h = a[4],
            f = a[5],
            p = a[6],
            g = a[7],
            m = a[8],
            y = a[9],
            w = vn(e, r + 0),
            x = vn(e, r + 2),
            E = vn(e, r + 4),
            _ = vn(e, r + 6),
            b = vn(e, r + 8),
            A = vn(e, r + 10),
            I = vn(e, r + 12),
            T = vn(e, r + 14);
        let C = s[0] + (w & 8191),
            $ = s[1] + ((w >>> 13 | x << 3) & 8191),
            P = s[2] + ((x >>> 10 | E << 6) & 8191),
            N = s[3] + ((E >>> 7 | _ << 9) & 8191),
            R = s[4] + ((_ >>> 4 | b << 12) & 8191),
            D = s[5] + (b >>> 1 & 8191),
            S = s[6] + ((b >>> 14 | A << 2) & 8191),
            O = s[7] + ((A >>> 11 | I << 5) & 8191),
            M = s[8] + ((I >>> 8 | T << 8) & 8191),
            U = s[9] + (T >>> 5 | i),
            k = 0,
            F = k + C * o + $ * (5 * y) + P * (5 * m) + N * (5 * g) + R * (5 * p);
        k = F >>> 13, F &= 8191, F += D * (5 * f) + S * (5 * h) + O * (5 * u) + M * (5 * l) + U * (5 * c), k += F >>> 13, F &= 8191;
        let q = k + C * c + $ * o + P * (5 * y) + N * (5 * m) + R * (5 * g);
        k = q >>> 13, q &= 8191, q += D * (5 * p) + S * (5 * f) + O * (5 * h) + M * (5 * u) + U * (5 * l), k += q >>> 13, q &= 8191;
        let W = k + C * l + $ * c + P * o + N * (5 * y) + R * (5 * m);
        k = W >>> 13, W &= 8191, W += D * (5 * g) + S * (5 * p) + O * (5 * f) + M * (5 * h) + U * (5 * u), k += W >>> 13, W &= 8191;
        let K = k + C * u + $ * l + P * c + N * o + R * (5 * y);
        k = K >>> 13, K &= 8191, K += D * (5 * m) + S * (5 * g) + O * (5 * p) + M * (5 * f) + U * (5 * h), k += K >>> 13, K &= 8191;
        let H = k + C * h + $ * u + P * l + N * c + R * o;
        k = H >>> 13, H &= 8191, H += D * (5 * y) + S * (5 * m) + O * (5 * g) + M * (5 * p) + U * (5 * f), k += H >>> 13, H &= 8191;
        let j = k + C * f + $ * h + P * u + N * l + R * c;
        k = j >>> 13, j &= 8191, j += D * o + S * (5 * y) + O * (5 * m) + M * (5 * g) + U * (5 * p), k += j >>> 13, j &= 8191;
        let V = k + C * p + $ * f + P * h + N * u + R * l;
        k = V >>> 13, V &= 8191, V += D * c + S * o + O * (5 * y) + M * (5 * m) + U * (5 * g), k += V >>> 13, V &= 8191;
        let Y = k + C * g + $ * p + P * f + N * h + R * u;
        k = Y >>> 13, Y &= 8191, Y += D * l + S * c + O * o + M * (5 * y) + U * (5 * m), k += Y >>> 13, Y &= 8191;
        let X = k + C * m + $ * g + P * p + N * f + R * h;
        k = X >>> 13, X &= 8191, X += D * u + S * l + O * c + M * o + U * (5 * y), k += X >>> 13, X &= 8191;
        let ne = k + C * y + $ * m + P * g + N * p + R * f;
        k = ne >>> 13, ne &= 8191, ne += D * h + S * u + O * l + M * c + U * o, k += ne >>> 13, ne &= 8191, k = (k << 2) + k | 0, k = k + F | 0, F = k & 8191, k = k >>> 13, q += k, s[0] = F, s[1] = q, s[2] = W, s[3] = K, s[4] = H, s[5] = j, s[6] = V, s[7] = Y, s[8] = X, s[9] = ne
    }
    finalize() {
        const {
            h: e,
            pad: r
        } = this, n = new Uint16Array(10);
        let i = e[1] >>> 13;
        e[1] &= 8191;
        for (let o = 2; o < 10; o++) e[o] += i, i = e[o] >>> 13, e[o] &= 8191;
        e[0] += i * 5, i = e[0] >>> 13, e[0] &= 8191, e[1] += i, i = e[1] >>> 13, e[1] &= 8191, e[2] += i, n[0] = e[0] + 5, i = n[0] >>> 13, n[0] &= 8191;
        for (let o = 1; o < 10; o++) n[o] = e[o] + i, i = n[o] >>> 13, n[o] &= 8191;
        n[9] -= 8192;
        let s = (i ^ 1) - 1;
        for (let o = 0; o < 10; o++) n[o] &= s;
        s = ~s;
        for (let o = 0; o < 10; o++) e[o] = e[o] & s | n[o];
        e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
        let a = e[0] + r[0];
        e[0] = a & 65535;
        for (let o = 1; o < 8; o++) a = (e[o] + r[o] | 0) + (a >>> 16) | 0, e[o] = a & 65535;
        sh(n)
    }
    update(e) {
        CA(this), e = P5(e), Pi(e);
        const {
            buffer: r,
            blockLen: n
        } = this, i = e.length;
        for (let s = 0; s < i;) {
            const a = Math.min(n - this.pos, i - s);
            if (a === n) {
                for (; n <= i - s; s += n) this.process(e, s);
                continue
            }
            r.set(e.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === n && (this.process(r, 0, !1), this.pos = 0)
        }
        return this
    }
    destroy() {
        sh(this.h, this.r, this.buffer, this.pad)
    }
    digestInto(e) {
        CA(this), vwe(e, this), this.finished = !0;
        const {
            buffer: r,
            h: n
        } = this;
        let {
            pos: i
        } = this;
        if (i) {
            for (r[i++] = 1; i < 16; i++) r[i] = 0;
            this.process(r, 0, !0)
        }
        this.finalize();
        let s = 0;
        for (let a = 0; a < 8; a++) e[s++] = n[a] >>> 0, e[s++] = n[a] >>> 8;
        return e
    }
    digest() {
        const {
            buffer: e,
            outputLen: r
        } = this;
        this.digestInto(e);
        const n = e.slice(0, r);
        return this.destroy(), n
    }
};

function Dwe(t) {
    const e = (n, i) => t(i).update(P5(n)).digest(),
        r = t(new Uint8Array(32));
    return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = n => t(n), e
}
const Lwe = Dwe(t => new Mwe(t));

function Uwe(t, e, r, n, i, s = 20) {
    let a = t[0],
        o = t[1],
        c = t[2],
        l = t[3],
        u = e[0],
        h = e[1],
        f = e[2],
        p = e[3],
        g = e[4],
        m = e[5],
        y = e[6],
        w = e[7],
        x = i,
        E = r[0],
        _ = r[1],
        b = r[2],
        A = a,
        I = o,
        T = c,
        C = l,
        $ = u,
        P = h,
        N = f,
        R = p,
        D = g,
        S = m,
        O = y,
        M = w,
        U = x,
        k = E,
        F = _,
        q = b;
    for (let K = 0; K < s; K += 2) A = A + $ | 0, U = Zt(U ^ A, 16), D = D + U | 0, $ = Zt($ ^ D, 12), A = A + $ | 0, U = Zt(U ^ A, 8), D = D + U | 0, $ = Zt($ ^ D, 7), I = I + P | 0, k = Zt(k ^ I, 16), S = S + k | 0, P = Zt(P ^ S, 12), I = I + P | 0, k = Zt(k ^ I, 8), S = S + k | 0, P = Zt(P ^ S, 7), T = T + N | 0, F = Zt(F ^ T, 16), O = O + F | 0, N = Zt(N ^ O, 12), T = T + N | 0, F = Zt(F ^ T, 8), O = O + F | 0, N = Zt(N ^ O, 7), C = C + R | 0, q = Zt(q ^ C, 16), M = M + q | 0, R = Zt(R ^ M, 12), C = C + R | 0, q = Zt(q ^ C, 8), M = M + q | 0, R = Zt(R ^ M, 7), A = A + P | 0, q = Zt(q ^ A, 16), O = O + q | 0, P = Zt(P ^ O, 12), A = A + P | 0, q = Zt(q ^ A, 8), O = O + q | 0, P = Zt(P ^ O, 7), I = I + N | 0, U = Zt(U ^ I, 16), M = M + U | 0, N = Zt(N ^ M, 12), I = I + N | 0, U = Zt(U ^ I, 8), M = M + U | 0, N = Zt(N ^ M, 7), T = T + R | 0, k = Zt(k ^ T, 16), D = D + k | 0, R = Zt(R ^ D, 12), T = T + R | 0, k = Zt(k ^ T, 8), D = D + k | 0, R = Zt(R ^ D, 7), C = C + $ | 0, F = Zt(F ^ C, 16), S = S + F | 0, $ = Zt($ ^ S, 12), C = C + $ | 0, F = Zt(F ^ C, 8), S = S + F | 0, $ = Zt($ ^ S, 7);
    let W = 0;
    n[W++] = a + A | 0, n[W++] = o + I | 0, n[W++] = c + T | 0, n[W++] = l + C | 0, n[W++] = u + $ | 0, n[W++] = h + P | 0, n[W++] = f + N | 0, n[W++] = p + R | 0, n[W++] = g + D | 0, n[W++] = m + S | 0, n[W++] = y + O | 0, n[W++] = w + M | 0, n[W++] = x + U | 0, n[W++] = E + k | 0, n[W++] = _ + F | 0, n[W++] = b + q | 0
}
const Fwe = Rwe(Uwe, {
        counterRight: !1,
        counterLength: 4,
        allowShortKeys: !1
    }),
    Bwe = new Uint8Array(16),
    $A = (t, e) => {
        t.update(e);
        const r = e.length % 16;
        r && t.update(Bwe.subarray(r))
    },
    Wwe = new Uint8Array(32);

function SA(t, e, r, n, i) {
    const s = t(e, r, Wwe),
        a = Lwe.create(s);
    i && $A(a, i), $A(a, n);
    const o = Iwe(n.length, i ? i.length : 0, !0);
    a.update(o);
    const c = a.digest();
    return sh(s, o), c
}
const zwe = t => (e, r, n) => ({
        encrypt(i, s) {
            const a = i.length;
            s = AA(a + 16, s, !1), s.set(i);
            const o = s.subarray(0, -16);
            t(e, r, o, o, 1);
            const c = SA(t, e, r, o, n);
            return s.set(c, a), sh(c), s
        },
        decrypt(i, s) {
            s = AA(i.length - 16, s, !1);
            const a = i.subarray(0, -16),
                o = i.subarray(-16),
                c = SA(t, e, r, a, n);
            if (!Awe(o, c)) throw new Error("invalid tag");
            return s.set(i.subarray(0, -16)), t(e, r, s, s, 1), sh(c), s
        }
    }),
    bD = kwe({
        blockSize: 64,
        nonceLength: 12,
        tagLength: 16
    }, zwe(Fwe));
let vD = class extends $y {
    constructor(e, r) {
        super(), this.finished = !1, this.destroyed = !1, Bx(e);
        const n = wa(r);
        if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const i = this.blockLen,
            s = new Uint8Array(i);
        s.set(n.length > i ? e.create().update(n).digest() : n);
        for (let a = 0; a < s.length; a++) s[a] ^= 54;
        this.iHash.update(s), this.oHash = e.create();
        for (let a = 0; a < s.length; a++) s[a] ^= 106;
        this.oHash.update(s), Ds(s)
    }
    update(e) {
        return sl(this), this.iHash.update(e), this
    }
    digestInto(e) {
        sl(this), Ms(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy()
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {
            oHash: r,
            iHash: n,
            finished: i,
            destroyed: s,
            blockLen: a,
            outputLen: o
        } = this;
        return e = e, e.finished = i, e.destroyed = s, e.blockLen = a, e.outputLen = o, e.oHash = r._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e
    }
    clone() {
        return this._cloneInto()
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
    }
};
const Ty = (t, e, r) => new vD(t, e).update(r).digest();
Ty.create = (t, e) => new vD(t, e);

function qwe(t, e, r) {
    return Bx(t), r === void 0 && (r = new Uint8Array(t.outputLen)), Ty(t, wa(r), wa(e))
}
const yb = Uint8Array.from([0]),
    TA = Uint8Array.of();

function Hwe(t, e, r, n = 32) {
    Bx(t), oc(n);
    const i = t.outputLen;
    if (n > 255 * i) throw new Error("Length should be <= 255*HashLen");
    const s = Math.ceil(n / i);
    r === void 0 && (r = TA);
    const a = new Uint8Array(s * i),
        o = Ty.create(t, e),
        c = o._cloneInto(),
        l = new Uint8Array(o.outputLen);
    for (let u = 0; u < s; u++) yb[0] = u + 1, c.update(u === 0 ? TA : l).update(r).update(yb).digestInto(l), a.set(l, i * u), o._cloneInto(c);
    return o.destroy(), c.destroy(), Ds(l, yb), a.slice(0, n)
}
const Vwe = (t, e, r, n, i) => Hwe(t, qwe(t, e, r), n, i),
    Py = Sy,
    Vx = BigInt(0),
    j5 = BigInt(1);

function Xm(t, e) {
    if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e)
}

function wg(t) {
    const e = t.toString(16);
    return e.length & 1 ? "0" + e : e
}

function xD(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    return t === "" ? Vx : BigInt("0x" + t)
}

function Ny(t) {
    return xD(Lp(t))
}

function e1(t) {
    return Ms(t), xD(Lp(Uint8Array.from(t).reverse()))
}

function Gx(t, e) {
    return zx(t.toString(16).padStart(e * 2, "0"))
}

function Kx(t, e) {
    return Gx(t, e).reverse()
}

function Si(t, e, r) {
    let n;
    if (typeof e == "string") try {
            n = zx(e)
        } catch (s) {
            throw new Error(t + " must be hex string or Uint8Array, cause: " + s)
        } else if (Fx(e)) n = Uint8Array.from(e);
        else throw new Error(t + " must be hex string or Uint8Array");
    const i = n.length;
    if (typeof r == "number" && i !== r) throw new Error(t + " of length " + r + " expected, got " + i);
    return n
}
const wb = t => typeof t == "bigint" && Vx <= t;

function Gwe(t, e, r) {
    return wb(t) && wb(e) && wb(r) && e <= t && t < r
}

function R5(t, e, r, n) {
    if (!Gwe(e, r, n)) throw new Error("expected valid " + t + ": " + r + " <= n < " + n + ", got " + e)
}

function Kwe(t) {
    let e;
    for (e = 0; t > Vx; t >>= j5, e += 1);
    return e
}
const Oy = t => (j5 << BigInt(t)) - j5;

function Ywe(t, e, r) {
    if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
    if (typeof r != "function") throw new Error("hmacFn must be a function");
    const n = f => new Uint8Array(f),
        i = f => Uint8Array.of(f);
    let s = n(t),
        a = n(t),
        o = 0;
    const c = () => {
            s.fill(1), a.fill(0), o = 0
        },
        l = (...f) => r(a, s, ...f),
        u = (f = n(0)) => {
            a = l(i(0), f), s = l(), f.length !== 0 && (a = l(i(1), f), s = l())
        },
        h = () => {
            if (o++ >= 1e3) throw new Error("drbg: tried 1000 values");
            let f = 0;
            const p = [];
            for (; f < e;) {
                s = l();
                const g = s.slice();
                p.push(g), f += s.length
            }
            return ql(...p)
        };
    return (f, p) => {
        c(), u(f);
        let g;
        for (; !(g = p(h()));) u();
        return c(), g
    }
}

function jy(t, e, r = {}) {
    if (!t || typeof t != "object") throw new Error("expected valid options object");

    function n(i, s, a) {
        const o = t[i];
        if (a && o === void 0) return;
        const c = typeof o;
        if (c !== s || o === null) throw new Error(`param "${i}" is invalid: expected ${s}, got ${c}`)
    }
    Object.entries(e).forEach(([i, s]) => n(i, s, !1)), Object.entries(r).forEach(([i, s]) => n(i, s, !0))
}

function PA(t) {
    const e = new WeakMap;
    return (r, ...n) => {
        const i = e.get(r);
        if (i !== void 0) return i;
        const s = t(r, ...n);
        return e.set(r, s), s
    }
}
const Mi = BigInt(0),
    hi = BigInt(1),
    Hl = BigInt(2),
    Zwe = BigInt(3),
    ED = BigInt(4),
    _D = BigInt(5),
    CD = BigInt(8);

function Ss(t, e) {
    const r = t % e;
    return r >= Mi ? r : e + r
}

function na(t, e, r) {
    let n = t;
    for (; e-- > Mi;) n *= n, n %= r;
    return n
}

function NA(t, e) {
    if (t === Mi) throw new Error("invert: expected non-zero number");
    if (e <= Mi) throw new Error("invert: expected positive modulus, got " + e);
    let r = Ss(t, e),
        n = e,
        i = Mi,
        s = hi;
    for (; r !== Mi;) {
        const a = n / r,
            o = n % r,
            c = i - s * a;
        n = r, r = o, i = s, s = c
    }
    if (n !== hi) throw new Error("invert: does not exist");
    return Ss(i, e)
}

function AD(t, e) {
    const r = (t.ORDER + hi) / ED,
        n = t.pow(e, r);
    if (!t.eql(t.sqr(n), e)) throw new Error("Cannot find square root");
    return n
}

function Jwe(t, e) {
    const r = (t.ORDER - _D) / CD,
        n = t.mul(e, Hl),
        i = t.pow(n, r),
        s = t.mul(e, i),
        a = t.mul(t.mul(s, Hl), i),
        o = t.mul(s, t.sub(a, t.ONE));
    if (!t.eql(t.sqr(o), e)) throw new Error("Cannot find square root");
    return o
}

function Qwe(t) {
    if (t < BigInt(3)) throw new Error("sqrt is not defined for small field");
    let e = t - hi,
        r = 0;
    for (; e % Hl === Mi;) e /= Hl, r++;
    let n = Hl;
    const i = Th(t);
    for (; OA(i, n) === 1;)
        if (n++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (r === 1) return AD;
    let s = i.pow(n, e);
    const a = (e + hi) / Hl;
    return function(o, c) {
        if (o.is0(c)) return c;
        if (OA(o, c) !== 1) throw new Error("Cannot find square root");
        let l = r,
            u = o.mul(o.ONE, s),
            h = o.pow(c, e),
            f = o.pow(c, a);
        for (; !o.eql(h, o.ONE);) {
            if (o.is0(h)) return o.ZERO;
            let p = 1,
                g = o.sqr(h);
            for (; !o.eql(g, o.ONE);)
                if (p++, g = o.sqr(g), p === l) throw new Error("Cannot find square root");
            const m = hi << BigInt(l - p - 1),
                y = o.pow(u, m);
            l = p, u = o.sqr(y), h = o.mul(h, u), f = o.mul(f, y)
        }
        return f
    }
}

function Xwe(t) {
    return t % ED === Zwe ? AD : t % CD === _D ? Jwe : Qwe(t)
}
const e2e = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

function t2e(t) {
    const e = {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "number",
            BITS: "number"
        },
        r = e2e.reduce((n, i) => (n[i] = "function", n), e);
    return jy(t, r), t
}

function r2e(t, e, r) {
    if (r < Mi) throw new Error("invalid exponent, negatives unsupported");
    if (r === Mi) return t.ONE;
    if (r === hi) return e;
    let n = t.ONE,
        i = e;
    for (; r > Mi;) r & hi && (n = t.mul(n, i)), i = t.sqr(i), r >>= hi;
    return n
}

function kD(t, e, r = !1) {
    const n = new Array(e.length).fill(r ? t.ZERO : void 0),
        i = e.reduce((a, o, c) => t.is0(o) ? a : (n[c] = a, t.mul(a, o)), t.ONE),
        s = t.inv(i);
    return e.reduceRight((a, o, c) => t.is0(o) ? a : (n[c] = t.mul(a, n[c]), t.mul(a, o)), s), n
}

function OA(t, e) {
    const r = (t.ORDER - hi) / Hl,
        n = t.pow(e, r),
        i = t.eql(n, t.ONE),
        s = t.eql(n, t.ZERO),
        a = t.eql(n, t.neg(t.ONE));
    if (!i && !s && !a) throw new Error("invalid Legendre symbol result");
    return i ? 1 : s ? 0 : -1
}

function n2e(t, e) {
    e !== void 0 && oc(e);
    const r = e !== void 0 ? e : t.toString(2).length,
        n = Math.ceil(r / 8);
    return {
        nBitLength: r,
        nByteLength: n
    }
}

function Th(t, e, r = !1, n = {}) {
    if (t <= Mi) throw new Error("invalid field: expected ORDER > 0, got " + t);
    let i, s;
    if (typeof e == "object" && e != null) {
        if (n.sqrt || r) throw new Error("cannot specify opts in two arguments");
        const u = e;
        u.BITS && (i = u.BITS), u.sqrt && (s = u.sqrt), typeof u.isLE == "boolean" && (r = u.isLE)
    } else typeof e == "number" && (i = e), n.sqrt && (s = n.sqrt);
    const {
        nBitLength: a,
        nByteLength: o
    } = n2e(t, i);
    if (o > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let c;
    const l = Object.freeze({
        ORDER: t,
        isLE: r,
        BITS: a,
        BYTES: o,
        MASK: Oy(a),
        ZERO: Mi,
        ONE: hi,
        create: u => Ss(u, t),
        isValid: u => {
            if (typeof u != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof u);
            return Mi <= u && u < t
        },
        is0: u => u === Mi,
        isValidNot0: u => !l.is0(u) && l.isValid(u),
        isOdd: u => (u & hi) === hi,
        neg: u => Ss(-u, t),
        eql: (u, h) => u === h,
        sqr: u => Ss(u * u, t),
        add: (u, h) => Ss(u + h, t),
        sub: (u, h) => Ss(u - h, t),
        mul: (u, h) => Ss(u * h, t),
        pow: (u, h) => r2e(l, u, h),
        div: (u, h) => Ss(u * NA(h, t), t),
        sqrN: u => u * u,
        addN: (u, h) => u + h,
        subN: (u, h) => u - h,
        mulN: (u, h) => u * h,
        inv: u => NA(u, t),
        sqrt: s || (u => (c || (c = Xwe(t)), c(l, u))),
        toBytes: u => r ? Kx(u, o) : Gx(u, o),
        fromBytes: u => {
            if (u.length !== o) throw new Error("Field.fromBytes: expected " + o + " bytes, got " + u.length);
            return r ? e1(u) : Ny(u)
        },
        invertBatch: u => kD(l, u),
        cmov: (u, h, f) => f ? h : u
    });
    return Object.freeze(l)
}

function ID(t) {
    if (typeof t != "bigint") throw new Error("field order must be bigint");
    const e = t.toString(2).length;
    return Math.ceil(e / 8)
}

function $D(t) {
    const e = ID(t);
    return e + Math.ceil(e / 2)
}

function i2e(t, e, r = !1) {
    const n = t.length,
        i = ID(e),
        s = $D(e);
    if (n < 16 || n < s || n > 1024) throw new Error("expected " + s + "-1024 bytes of input, got " + n);
    const a = r ? e1(t) : Ny(t),
        o = Ss(a, e - hi) + hi;
    return r ? Kx(o, i) : Gx(o, i)
}
const ah = BigInt(0),
    Vl = BigInt(1);

function zf(t, e) {
    const r = e.negate();
    return t ? r : e
}

function s2e(t, e, r) {
    const n = s => s.pz,
        i = kD(t.Fp, r.map(n));
    return r.map((s, a) => s.toAffine(i[a])).map(t.fromAffine)
}

function SD(t, e) {
    if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t)
}

function bb(t, e) {
    SD(t, e);
    const r = Math.ceil(e / t) + 1,
        n = 2 ** (t - 1),
        i = 2 ** t,
        s = Oy(t),
        a = BigInt(t);
    return {
        windows: r,
        windowSize: n,
        mask: s,
        maxNumber: i,
        shiftBy: a
    }
}

function jA(t, e, r) {
    const {
        windowSize: n,
        mask: i,
        maxNumber: s,
        shiftBy: a
    } = r;
    let o = Number(t & i),
        c = t >> a;
    o > n && (o -= s, c += Vl);
    const l = e * n,
        u = l + Math.abs(o) - 1,
        h = o === 0,
        f = o < 0,
        p = e % 2 !== 0;
    return {
        nextN: c,
        offset: u,
        isZero: h,
        isNeg: f,
        isNegF: p,
        offsetF: l
    }
}

function a2e(t, e) {
    if (!Array.isArray(t)) throw new Error("array expected");
    t.forEach((r, n) => {
        if (!(r instanceof e)) throw new Error("invalid point at index " + n)
    })
}

function o2e(t, e) {
    if (!Array.isArray(t)) throw new Error("array of scalars expected");
    t.forEach((r, n) => {
        if (!e.isValid(r)) throw new Error("invalid scalar at index " + n)
    })
}
const vb = new WeakMap,
    TD = new WeakMap;

function xb(t) {
    return TD.get(t) || 1
}

function RA(t) {
    if (t !== ah) throw new Error("invalid wNAF")
}

function c2e(t, e) {
    return {
        constTimeNegate: zf,
        hasPrecomputes(r) {
            return xb(r) !== 1
        },
        unsafeLadder(r, n, i = t.ZERO) {
            let s = r;
            for (; n > ah;) n & Vl && (i = i.add(s)), s = s.double(), n >>= Vl;
            return i
        },
        precomputeWindow(r, n) {
            const {
                windows: i,
                windowSize: s
            } = bb(n, e), a = [];
            let o = r,
                c = o;
            for (let l = 0; l < i; l++) {
                c = o, a.push(c);
                for (let u = 1; u < s; u++) c = c.add(o), a.push(c);
                o = c.double()
            }
            return a
        },
        wNAF(r, n, i) {
            let s = t.ZERO,
                a = t.BASE;
            const o = bb(r, e);
            for (let c = 0; c < o.windows; c++) {
                const {
                    nextN: l,
                    offset: u,
                    isZero: h,
                    isNeg: f,
                    isNegF: p,
                    offsetF: g
                } = jA(i, c, o);
                i = l, h ? a = a.add(zf(p, n[g])) : s = s.add(zf(f, n[u]))
            }
            return RA(i), {
                p: s,
                f: a
            }
        },
        wNAFUnsafe(r, n, i, s = t.ZERO) {
            const a = bb(r, e);
            for (let o = 0; o < a.windows && i !== ah; o++) {
                const {
                    nextN: c,
                    offset: l,
                    isZero: u,
                    isNeg: h
                } = jA(i, o, a);
                if (i = c, !u) {
                    const f = n[l];
                    s = s.add(h ? f.negate() : f)
                }
            }
            return RA(i), s
        },
        getPrecomputes(r, n, i) {
            let s = vb.get(n);
            return s || (s = this.precomputeWindow(n, r), r !== 1 && (typeof i == "function" && (s = i(s)), vb.set(n, s))), s
        },
        wNAFCached(r, n, i) {
            const s = xb(r);
            return this.wNAF(s, this.getPrecomputes(s, r, i), n)
        },
        wNAFCachedUnsafe(r, n, i, s) {
            const a = xb(r);
            return a === 1 ? this.unsafeLadder(r, n, s) : this.wNAFUnsafe(a, this.getPrecomputes(a, r, i), n, s)
        },
        setWindowSize(r, n) {
            SD(n, e), TD.set(r, n), vb.delete(r)
        }
    }
}

function l2e(t, e, r, n) {
    let i = e,
        s = t.ZERO,
        a = t.ZERO;
    for (; r > ah || n > ah;) r & Vl && (s = s.add(i)), n & Vl && (a = a.add(i)), i = i.double(), r >>= Vl, n >>= Vl;
    return {
        p1: s,
        p2: a
    }
}

function d2e(t, e, r, n) {
    a2e(r, t), o2e(n, e);
    const i = r.length,
        s = n.length;
    if (i !== s) throw new Error("arrays of points and scalars must have equal length");
    const a = t.ZERO,
        o = Kwe(BigInt(i));
    let c = 1;
    o > 12 ? c = o - 3 : o > 4 ? c = o - 2 : o > 0 && (c = 2);
    const l = Oy(c),
        u = new Array(Number(l) + 1).fill(a),
        h = Math.floor((e.BITS - 1) / c) * c;
    let f = a;
    for (let p = h; p >= 0; p -= c) {
        u.fill(a);
        for (let m = 0; m < s; m++) {
            const y = n[m],
                w = Number(y >> BigInt(p) & l);
            u[w] = u[w].add(r[m])
        }
        let g = a;
        for (let m = u.length - 1, y = a; m > 0; m--) y = y.add(u[m]), g = g.add(y);
        if (f = f.add(g), p !== 0)
            for (let m = 0; m < c; m++) f = f.double()
    }
    return f
}

function MA(t, e) {
    if (e) {
        if (e.ORDER !== t) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        return t2e(e), e
    } else return Th(t)
}

function u2e(t, e, r = {}) {
    if (!e || typeof e != "object") throw new Error(`expected valid ${t} CURVE object`);
    for (const a of ["p", "n", "h"]) {
        const o = e[a];
        if (!(typeof o == "bigint" && o > ah)) throw new Error(`CURVE.${a} must be positive bigint`)
    }
    const n = MA(e.p, r.Fp),
        i = MA(e.n, r.Fn),
        s = ["Gx", "Gy", "a", "b"];
    for (const a of s)
        if (!n.isValid(e[a])) throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);
    return {
        Fp: n,
        Fn: i
    }
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
const rf = BigInt(0),
    su = BigInt(1),
    bg = BigInt(2);

function h2e(t) {
    return jy(t, {
        adjustScalarBytes: "function",
        powPminus2: "function"
    }), Object.freeze({ ...t
    })
}

function f2e(t) {
    const e = h2e(t),
        {
            P: r,
            type: n,
            adjustScalarBytes: i,
            powPminus2: s,
            randomBytes: a
        } = e,
        o = n === "x25519";
    if (!o && n !== "x448") throw new Error("invalid type");
    const c = a || Sh,
        l = o ? 255 : 448,
        u = o ? 32 : 56,
        h = BigInt(o ? 9 : 5),
        f = BigInt(o ? 121665 : 39081),
        p = o ? bg ** BigInt(254) : bg ** BigInt(447),
        g = o ? BigInt(8) * bg ** BigInt(251) - su : BigInt(4) * bg ** BigInt(445) - su,
        m = p + g + su,
        y = C => Ss(C, r),
        w = x(h);

    function x(C) {
        return Kx(y(C), u)
    }

    function E(C) {
        const $ = Si("u coordinate", C, u);
        return o && ($[31] &= 127), y(e1($))
    }

    function _(C) {
        return e1(i(Si("scalar", C, u)))
    }

    function b(C, $) {
        const P = T(E($), _(C));
        if (P === rf) throw new Error("invalid private or public key received");
        return x(P)
    }

    function A(C) {
        return b(C, w)
    }

    function I(C, $, P) {
        const N = y(C * ($ - P));
        return $ = y($ - N), P = y(P + N), {
            x_2: $,
            x_3: P
        }
    }

    function T(C, $) {
        R5("u", C, rf, r), R5("scalar", $, p, m);
        const P = $,
            N = C;
        let R = su,
            D = rf,
            S = C,
            O = su,
            M = rf;
        for (let k = BigInt(l - 1); k >= rf; k--) {
            const F = P >> k & su;
            M ^= F, {
                x_2: R,
                x_3: S
            } = I(M, R, S), {
                x_2: D,
                x_3: O
            } = I(M, D, O), M = F;
            const q = R + D,
                W = y(q * q),
                K = R - D,
                H = y(K * K),
                j = W - H,
                V = S + O,
                Y = S - O,
                X = y(Y * q),
                ne = y(V * K),
                ae = X + ne,
                ue = X - ne;
            S = y(ae * ae), O = y(N * y(ue * ue)), R = y(W * H), D = y(j * (W + y(f * j)))
        }({
            x_2: R,
            x_3: S
        } = I(M, R, S)), {
            x_2: D,
            x_3: O
        } = I(M, D, O);
        const U = s(D);
        return y(R * U)
    }
    return {
        scalarMult: b,
        scalarMultBase: A,
        getSharedSecret: (C, $) => b(C, $),
        getPublicKey: C => A(C),
        utils: {
            randomPrivateKey: () => c(u)
        },
        GuBytes: w.slice()
    }
}
BigInt(0);
const p2e = BigInt(1),
    DA = BigInt(2),
    g2e = BigInt(3),
    m2e = BigInt(5);
BigInt(8);
const PD = {
    p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};

function y2e(t) {
    const e = BigInt(10),
        r = BigInt(20),
        n = BigInt(40),
        i = BigInt(80),
        s = PD.p,
        a = t * t % s * t % s,
        o = na(a, DA, s) * a % s,
        c = na(o, p2e, s) * t % s,
        l = na(c, m2e, s) * c % s,
        u = na(l, e, s) * l % s,
        h = na(u, r, s) * u % s,
        f = na(h, n, s) * h % s,
        p = na(f, i, s) * f % s,
        g = na(p, i, s) * f % s,
        m = na(g, e, s) * l % s;
    return {
        pow_p_5_8: na(m, DA, s) * t % s,
        b2: a
    }
}

function w2e(t) {
    return t[0] &= 248, t[31] &= 127, t[31] |= 64, t
}
const M5 = (() => {
    const t = PD.p;
    return f2e({
        P: t,
        type: "x25519",
        powPminus2: e => {
            const {
                pow_p_5_8: r,
                b2: n
            } = y2e(e);
            return Ss(na(r, g2e, t) * n, t)
        },
        adjustScalarBytes: w2e
    })
})();

function LA(t) {
    t.lowS !== void 0 && Xm("lowS", t.lowS), t.prehash !== void 0 && Xm("prehash", t.prehash)
}
let b2e = class extends Error {
    constructor(e = "") {
        super(e)
    }
};
const Lo = {
        Err: b2e,
        _tlv: {
            encode: (t, e) => {
                const {
                    Err: r
                } = Lo;
                if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
                if (e.length & 1) throw new r("tlv.encode: unpadded data");
                const n = e.length / 2,
                    i = wg(n);
                if (i.length / 2 & 128) throw new r("tlv.encode: long form length too big");
                const s = n > 127 ? wg(i.length / 2 | 128) : "";
                return wg(t) + s + i + e
            },
            decode(t, e) {
                const {
                    Err: r
                } = Lo;
                let n = 0;
                if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
                if (e.length < 2 || e[n++] !== t) throw new r("tlv.decode: wrong tlv");
                const i = e[n++],
                    s = !!(i & 128);
                let a = 0;
                if (!s) a = i;
                else {
                    const c = i & 127;
                    if (!c) throw new r("tlv.decode(long): indefinite length not supported");
                    if (c > 4) throw new r("tlv.decode(long): byte length is too big");
                    const l = e.subarray(n, n + c);
                    if (l.length !== c) throw new r("tlv.decode: length bytes not complete");
                    if (l[0] === 0) throw new r("tlv.decode(long): zero leftmost byte");
                    for (const u of l) a = a << 8 | u;
                    if (n += c, a < 128) throw new r("tlv.decode(long): not minimal encoding")
                }
                const o = e.subarray(n, n + a);
                if (o.length !== a) throw new r("tlv.decode: wrong value length");
                return {
                    v: o,
                    l: e.subarray(n + a)
                }
            }
        },
        _int: {
            encode(t) {
                const {
                    Err: e
                } = Lo;
                if (t < qf) throw new e("integer: negative integers are not allowed");
                let r = wg(t);
                if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
                return r
            },
            decode(t) {
                const {
                    Err: e
                } = Lo;
                if (t[0] & 128) throw new e("invalid signature integer: negative");
                if (t[0] === 0 && !(t[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
                return Ny(t)
            }
        },
        toSig(t) {
            const {
                Err: e,
                _int: r,
                _tlv: n
            } = Lo, i = Si("signature", t), {
                v: s,
                l: a
            } = n.decode(48, i);
            if (a.length) throw new e("invalid signature: left bytes after parsing");
            const {
                v: o,
                l: c
            } = n.decode(2, s), {
                v: l,
                l: u
            } = n.decode(2, c);
            if (u.length) throw new e("invalid signature: left bytes after parsing");
            return {
                r: r.decode(o),
                s: r.decode(l)
            }
        },
        hexFromSig(t) {
            const {
                _tlv: e,
                _int: r
            } = Lo, n = e.encode(2, r.encode(t.r)), i = e.encode(2, r.encode(t.s)), s = n + i;
            return e.encode(48, s)
        }
    },
    qf = BigInt(0),
    Hf = BigInt(1),
    v2e = BigInt(2),
    vg = BigInt(3),
    x2e = BigInt(4);

function E2e(t, e, r) {
    function n(i) {
        const s = t.sqr(i),
            a = t.mul(s, i);
        return t.add(t.add(a, t.mul(i, e)), r)
    }
    return n
}

function ND(t, e, r) {
    const {
        BYTES: n
    } = t;

    function i(s) {
        let a;
        if (typeof s == "bigint") a = s;
        else {
            let o = Si("private key", s);
            if (e) {
                if (!e.includes(o.length * 2)) throw new Error("invalid private key");
                const c = new Uint8Array(n);
                c.set(o, c.length - o.length), o = c
            }
            try {
                a = t.fromBytes(o)
            } catch {
                throw new Error(`invalid private key: expected ui8a of size ${n}, got ${typeof s}`)
            }
        }
        if (r && (a = t.create(a)), !t.isValidNot0(a)) throw new Error("invalid private key: out of range [1..N-1]");
        return a
    }
    return i
}

function _2e(t, e = {}) {
    const {
        Fp: r,
        Fn: n
    } = u2e("weierstrass", t, e), {
        h: i,
        n: s
    } = t;
    jy(e, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
    });
    const {
        endo: a
    } = e;
    if (a && (!r.is0(t.a) || typeof a.beta != "bigint" || typeof a.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');

    function o() {
        if (!r.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()")
    }

    function c(T, C, $) {
        const {
            x: P,
            y: N
        } = C.toAffine(), R = r.toBytes(P);
        if (Xm("isCompressed", $), $) {
            o();
            const D = !r.isOdd(N);
            return ql(OD(D), R)
        } else return ql(Uint8Array.of(4), R, r.toBytes(N))
    }

    function l(T) {
        Ms(T);
        const C = r.BYTES,
            $ = C + 1,
            P = 2 * C + 1,
            N = T.length,
            R = T[0],
            D = T.subarray(1);
        if (N === $ && (R === 2 || R === 3)) {
            const S = r.fromBytes(D);
            if (!r.isValid(S)) throw new Error("bad point: is not on curve, wrong x");
            const O = f(S);
            let M;
            try {
                M = r.sqrt(O)
            } catch (k) {
                const F = k instanceof Error ? ": " + k.message : "";
                throw new Error("bad point: is not on curve, sqrt error" + F)
            }
            o();
            const U = r.isOdd(M);
            return (R & 1) === 1 !== U && (M = r.neg(M)), {
                x: S,
                y: M
            }
        } else if (N === P && R === 4) {
            const S = r.fromBytes(D.subarray(C * 0, C * 1)),
                O = r.fromBytes(D.subarray(C * 1, C * 2));
            if (!p(S, O)) throw new Error("bad point: is not on curve");
            return {
                x: S,
                y: O
            }
        } else throw new Error(`bad point: got length ${N}, expected compressed=${$} or uncompressed=${P}`)
    }
    const u = e.toBytes || c,
        h = e.fromBytes || l,
        f = E2e(r, t.a, t.b);

    function p(T, C) {
        const $ = r.sqr(C),
            P = f(T);
        return r.eql($, P)
    }
    if (!p(t.Gx, t.Gy)) throw new Error("bad curve params: generator point");
    const g = r.mul(r.pow(t.a, vg), x2e),
        m = r.mul(r.sqr(t.b), BigInt(27));
    if (r.is0(r.add(g, m))) throw new Error("bad curve params: a or b");

    function y(T, C, $ = !1) {
        if (!r.isValid(C) || $ && r.is0(C)) throw new Error(`bad point coordinate ${T}`);
        return C
    }

    function w(T) {
        if (!(T instanceof b)) throw new Error("ProjectivePoint expected")
    }
    const x = PA((T, C) => {
            const {
                px: $,
                py: P,
                pz: N
            } = T;
            if (r.eql(N, r.ONE)) return {
                x: $,
                y: P
            };
            const R = T.is0();
            C == null && (C = R ? r.ONE : r.inv(N));
            const D = r.mul($, C),
                S = r.mul(P, C),
                O = r.mul(N, C);
            if (R) return {
                x: r.ZERO,
                y: r.ZERO
            };
            if (!r.eql(O, r.ONE)) throw new Error("invZ was invalid");
            return {
                x: D,
                y: S
            }
        }),
        E = PA(T => {
            if (T.is0()) {
                if (e.allowInfinityPoint && !r.is0(T.py)) return;
                throw new Error("bad point: ZERO")
            }
            const {
                x: C,
                y: $
            } = T.toAffine();
            if (!r.isValid(C) || !r.isValid($)) throw new Error("bad point: x or y not field elements");
            if (!p(C, $)) throw new Error("bad point: equation left != right");
            if (!T.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
            return !0
        });

    function _(T, C, $, P, N) {
        return $ = new b(r.mul($.px, T), $.py, $.pz), C = zf(P, C), $ = zf(N, $), C.add($)
    }
    class b {
        constructor(C, $, P) {
            this.px = y("x", C), this.py = y("y", $, !0), this.pz = y("z", P), Object.freeze(this)
        }
        static fromAffine(C) {
            const {
                x: $,
                y: P
            } = C || {};
            if (!C || !r.isValid($) || !r.isValid(P)) throw new Error("invalid affine point");
            if (C instanceof b) throw new Error("projective point not allowed");
            return r.is0($) && r.is0(P) ? b.ZERO : new b($, P, r.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(C) {
            return s2e(b, "pz", C)
        }
        static fromBytes(C) {
            return Ms(C), b.fromHex(C)
        }
        static fromHex(C) {
            const $ = b.fromAffine(h(Si("pointHex", C)));
            return $.assertValidity(), $
        }
        static fromPrivateKey(C) {
            const $ = ND(n, e.allowedPrivateKeyLengths, e.wrapPrivateKey);
            return b.BASE.multiply($(C))
        }
        static msm(C, $) {
            return d2e(b, n, C, $)
        }
        precompute(C = 8, $ = !0) {
            return I.setWindowSize(this, C), $ || this.multiply(vg), this
        }
        _setWindowSize(C) {
            this.precompute(C)
        }
        assertValidity() {
            E(this)
        }
        hasEvenY() {
            const {
                y: C
            } = this.toAffine();
            if (!r.isOdd) throw new Error("Field doesn't support isOdd");
            return !r.isOdd(C)
        }
        equals(C) {
            w(C);
            const {
                px: $,
                py: P,
                pz: N
            } = this, {
                px: R,
                py: D,
                pz: S
            } = C, O = r.eql(r.mul($, S), r.mul(R, N)), M = r.eql(r.mul(P, S), r.mul(D, N));
            return O && M
        }
        negate() {
            return new b(this.px, r.neg(this.py), this.pz)
        }
        double() {
            const {
                a: C,
                b: $
            } = t, P = r.mul($, vg), {
                px: N,
                py: R,
                pz: D
            } = this;
            let S = r.ZERO,
                O = r.ZERO,
                M = r.ZERO,
                U = r.mul(N, N),
                k = r.mul(R, R),
                F = r.mul(D, D),
                q = r.mul(N, R);
            return q = r.add(q, q), M = r.mul(N, D), M = r.add(M, M), S = r.mul(C, M), O = r.mul(P, F), O = r.add(S, O), S = r.sub(k, O), O = r.add(k, O), O = r.mul(S, O), S = r.mul(q, S), M = r.mul(P, M), F = r.mul(C, F), q = r.sub(U, F), q = r.mul(C, q), q = r.add(q, M), M = r.add(U, U), U = r.add(M, U), U = r.add(U, F), U = r.mul(U, q), O = r.add(O, U), F = r.mul(R, D), F = r.add(F, F), U = r.mul(F, q), S = r.sub(S, U), M = r.mul(F, k), M = r.add(M, M), M = r.add(M, M), new b(S, O, M)
        }
        add(C) {
            w(C);
            const {
                px: $,
                py: P,
                pz: N
            } = this, {
                px: R,
                py: D,
                pz: S
            } = C;
            let O = r.ZERO,
                M = r.ZERO,
                U = r.ZERO;
            const k = t.a,
                F = r.mul(t.b, vg);
            let q = r.mul($, R),
                W = r.mul(P, D),
                K = r.mul(N, S),
                H = r.add($, P),
                j = r.add(R, D);
            H = r.mul(H, j), j = r.add(q, W), H = r.sub(H, j), j = r.add($, N);
            let V = r.add(R, S);
            return j = r.mul(j, V), V = r.add(q, K), j = r.sub(j, V), V = r.add(P, N), O = r.add(D, S), V = r.mul(V, O), O = r.add(W, K), V = r.sub(V, O), U = r.mul(k, j), O = r.mul(F, K), U = r.add(O, U), O = r.sub(W, U), U = r.add(W, U), M = r.mul(O, U), W = r.add(q, q), W = r.add(W, q), K = r.mul(k, K), j = r.mul(F, j), W = r.add(W, K), K = r.sub(q, K), K = r.mul(k, K), j = r.add(j, K), q = r.mul(W, j), M = r.add(M, q), q = r.mul(V, j), O = r.mul(H, O), O = r.sub(O, q), q = r.mul(H, W), U = r.mul(V, U), U = r.add(U, q), new b(O, M, U)
        }
        subtract(C) {
            return this.add(C.negate())
        }
        is0() {
            return this.equals(b.ZERO)
        }
        multiply(C) {
            const {
                endo: $
            } = e;
            if (!n.isValidNot0(C)) throw new Error("invalid scalar: out of range");
            let P, N;
            const R = D => I.wNAFCached(this, D, b.normalizeZ);
            if ($) {
                const {
                    k1neg: D,
                    k1: S,
                    k2neg: O,
                    k2: M
                } = $.splitScalar(C), {
                    p: U,
                    f: k
                } = R(S), {
                    p: F,
                    f: q
                } = R(M);
                N = k.add(q), P = _($.beta, U, F, D, O)
            } else {
                const {
                    p: D,
                    f: S
                } = R(C);
                P = D, N = S
            }
            return b.normalizeZ([P, N])[0]
        }
        multiplyUnsafe(C) {
            const {
                endo: $
            } = e, P = this;
            if (!n.isValid(C)) throw new Error("invalid scalar: out of range");
            if (C === qf || P.is0()) return b.ZERO;
            if (C === Hf) return P;
            if (I.hasPrecomputes(this)) return this.multiply(C);
            if ($) {
                const {
                    k1neg: N,
                    k1: R,
                    k2neg: D,
                    k2: S
                } = $.splitScalar(C), {
                    p1: O,
                    p2: M
                } = l2e(b, P, R, S);
                return _($.beta, O, M, N, D)
            } else return I.wNAFCachedUnsafe(P, C)
        }
        multiplyAndAddUnsafe(C, $, P) {
            const N = this.multiplyUnsafe($).add(C.multiplyUnsafe(P));
            return N.is0() ? void 0 : N
        }
        toAffine(C) {
            return x(this, C)
        }
        isTorsionFree() {
            const {
                isTorsionFree: C
            } = e;
            return i === Hf ? !0 : C ? C(b, this) : I.wNAFCachedUnsafe(this, s).is0()
        }
        clearCofactor() {
            const {
                clearCofactor: C
            } = e;
            return i === Hf ? this : C ? C(b, this) : this.multiplyUnsafe(i)
        }
        toBytes(C = !0) {
            return Xm("isCompressed", C), this.assertValidity(), u(b, this, C)
        }
        toRawBytes(C = !0) {
            return this.toBytes(C)
        }
        toHex(C = !0) {
            return Lp(this.toBytes(C))
        }
        toString() {
            return `<Point ${this.is0()?"ZERO":this.toHex()}>`
        }
    }
    b.BASE = new b(t.Gx, t.Gy, r.ONE), b.ZERO = new b(r.ZERO, r.ONE, r.ZERO), b.Fp = r, b.Fn = n;
    const A = n.BITS,
        I = c2e(b, e.endo ? Math.ceil(A / 2) : A);
    return b
}

function OD(t) {
    return Uint8Array.of(t ? 2 : 3)
}

function C2e(t, e, r = {}) {
    jy(e, {
        hash: "function"
    }, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
    });
    const n = e.randomBytes || Sh,
        i = e.hmac || ((P, ...N) => Ty(e.hash, P, ql(...N))),
        {
            Fp: s,
            Fn: a
        } = t,
        {
            ORDER: o,
            BITS: c
        } = a;

    function l(P) {
        const N = o >> Hf;
        return P > N
    }

    function u(P) {
        return l(P) ? a.neg(P) : P
    }

    function h(P, N) {
        if (!a.isValidNot0(N)) throw new Error(`invalid signature ${P}: out of range 1..CURVE.n`)
    }
    class f {
        constructor(N, R, D) {
            h("r", N), h("s", R), this.r = N, this.s = R, D != null && (this.recovery = D), Object.freeze(this)
        }
        static fromCompact(N) {
            const R = a.BYTES,
                D = Si("compactSignature", N, R * 2);
            return new f(a.fromBytes(D.subarray(0, R)), a.fromBytes(D.subarray(R, R * 2)))
        }
        static fromDER(N) {
            const {
                r: R,
                s: D
            } = Lo.toSig(Si("DER", N));
            return new f(R, D)
        }
        assertValidity() {}
        addRecoveryBit(N) {
            return new f(this.r, this.s, N)
        }
        recoverPublicKey(N) {
            const R = s.ORDER,
                {
                    r: D,
                    s: S,
                    recovery: O
                } = this;
            if (O == null || ![0, 1, 2, 3].includes(O)) throw new Error("recovery id invalid");
            if (o * v2e < R && O > 1) throw new Error("recovery id is ambiguous for h>1 curve");
            const M = O === 2 || O === 3 ? D + o : D;
            if (!s.isValid(M)) throw new Error("recovery id 2 or 3 invalid");
            const U = s.toBytes(M),
                k = t.fromHex(ql(OD((O & 1) === 0), U)),
                F = a.inv(M),
                q = E(Si("msgHash", N)),
                W = a.create(-q * F),
                K = a.create(S * F),
                H = t.BASE.multiplyUnsafe(W).add(k.multiplyUnsafe(K));
            if (H.is0()) throw new Error("point at infinify");
            return H.assertValidity(), H
        }
        hasHighS() {
            return l(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new f(this.r, a.neg(this.s), this.recovery) : this
        }
        toBytes(N) {
            if (N === "compact") return ql(a.toBytes(this.r), a.toBytes(this.s));
            if (N === "der") return zx(Lo.hexFromSig(this));
            throw new Error("invalid format")
        }
        toDERRawBytes() {
            return this.toBytes("der")
        }
        toDERHex() {
            return Lp(this.toBytes("der"))
        }
        toCompactRawBytes() {
            return this.toBytes("compact")
        }
        toCompactHex() {
            return Lp(this.toBytes("compact"))
        }
    }
    const p = ND(a, r.allowedPrivateKeyLengths, r.wrapPrivateKey),
        g = {
            isValidPrivateKey(P) {
                try {
                    return p(P), !0
                } catch {
                    return !1
                }
            },
            normPrivateKeyToScalar: p,
            randomPrivateKey: () => {
                const P = o;
                return i2e(n($D(P)), P)
            },
            precompute(P = 8, N = t.BASE) {
                return N.precompute(P, !1)
            }
        };

    function m(P, N = !0) {
        return t.fromPrivateKey(P).toBytes(N)
    }

    function y(P) {
        if (typeof P == "bigint") return !1;
        if (P instanceof t) return !0;
        const N = Si("key", P).length,
            R = s.BYTES,
            D = R + 1,
            S = 2 * R + 1;
        if (!(r.allowedPrivateKeyLengths || a.BYTES === D)) return N === D || N === S
    }

    function w(P, N, R = !0) {
        if (y(P) === !0) throw new Error("first arg must be private key");
        if (y(N) === !1) throw new Error("second arg must be public key");
        return t.fromHex(N).multiply(p(P)).toBytes(R)
    }
    const x = e.bits2int || function(P) {
            if (P.length > 8192) throw new Error("input is too large");
            const N = Ny(P),
                R = P.length * 8 - c;
            return R > 0 ? N >> BigInt(R) : N
        },
        E = e.bits2int_modN || function(P) {
            return a.create(x(P))
        },
        _ = Oy(c);

    function b(P) {
        return R5("num < 2^" + c, P, qf, _), a.toBytes(P)
    }

    function A(P, N, R = I) {
        if (["recovered", "canonical"].some(H => H in R)) throw new Error("sign() legacy options not supported");
        const {
            hash: D
        } = e;
        let {
            lowS: S,
            prehash: O,
            extraEntropy: M
        } = R;
        S == null && (S = !0), P = Si("msgHash", P), LA(R), O && (P = Si("prehashed msgHash", D(P)));
        const U = E(P),
            k = p(N),
            F = [b(k), b(U)];
        if (M != null && M !== !1) {
            const H = M === !0 ? n(s.BYTES) : M;
            F.push(Si("extraEntropy", H))
        }
        const q = ql(...F),
            W = U;

        function K(H) {
            const j = x(H);
            if (!a.isValidNot0(j)) return;
            const V = a.inv(j),
                Y = t.BASE.multiply(j).toAffine(),
                X = a.create(Y.x);
            if (X === qf) return;
            const ne = a.create(V * a.create(W + X * k));
            if (ne === qf) return;
            let ae = (Y.x === X ? 0 : 2) | Number(Y.y & Hf),
                ue = ne;
            return S && l(ne) && (ue = u(ne), ae ^= 1), new f(X, ue, ae)
        }
        return {
            seed: q,
            k2sig: K
        }
    }
    const I = {
            lowS: e.lowS,
            prehash: !1
        },
        T = {
            lowS: e.lowS,
            prehash: !1
        };

    function C(P, N, R = I) {
        const {
            seed: D,
            k2sig: S
        } = A(P, N, R);
        return Ywe(e.hash.outputLen, a.BYTES, i)(D, S)
    }
    t.BASE.precompute(8);

    function $(P, N, R, D = T) {
        const S = P;
        N = Si("msgHash", N), R = Si("publicKey", R), LA(D);
        const {
            lowS: O,
            prehash: M,
            format: U
        } = D;
        if ("strict" in D) throw new Error("options.strict was renamed to lowS");
        if (U !== void 0 && !["compact", "der", "js"].includes(U)) throw new Error('format must be "compact", "der" or "js"');
        const k = typeof S == "string" || Fx(S),
            F = !k && !U && typeof S == "object" && S !== null && typeof S.r == "bigint" && typeof S.s == "bigint";
        if (!k && !F) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        let q, W;
        try {
            if (F)
                if (U === void 0 || U === "js") q = new f(S.r, S.s);
                else throw new Error("invalid format");
            if (k) {
                try {
                    U !== "compact" && (q = f.fromDER(S))
                } catch (ae) {
                    if (!(ae instanceof Lo.Err)) throw ae
                }!q && U !== "der" && (q = f.fromCompact(S))
            }
            W = t.fromHex(R)
        } catch {
            return !1
        }
        if (!q || O && q.hasHighS()) return !1;
        M && (N = e.hash(N));
        const {
            r: K,
            s: H
        } = q, j = E(N), V = a.inv(H), Y = a.create(j * V), X = a.create(K * V), ne = t.BASE.multiplyUnsafe(Y).add(W.multiplyUnsafe(X));
        return ne.is0() ? !1 : a.create(ne.x) === K
    }
    return Object.freeze({
        getPublicKey: m,
        getSharedSecret: w,
        sign: C,
        verify: $,
        utils: g,
        Point: t,
        Signature: f
    })
}

function A2e(t) {
    const e = {
            a: t.a,
            b: t.b,
            p: t.Fp.ORDER,
            n: t.n,
            h: t.h,
            Gx: t.Gx,
            Gy: t.Gy
        },
        r = t.Fp,
        n = Th(e.n, t.nBitLength),
        i = {
            Fp: r,
            Fn: n,
            allowedPrivateKeyLengths: t.allowedPrivateKeyLengths,
            allowInfinityPoint: t.allowInfinityPoint,
            endo: t.endo,
            wrapPrivateKey: t.wrapPrivateKey,
            isTorsionFree: t.isTorsionFree,
            clearCofactor: t.clearCofactor,
            fromBytes: t.fromBytes,
            toBytes: t.toBytes
        };
    return {
        CURVE: e,
        curveOpts: i
    }
}

function k2e(t) {
    const {
        CURVE: e,
        curveOpts: r
    } = A2e(t), n = {
        hash: t.hash,
        hmac: t.hmac,
        randomBytes: t.randomBytes,
        lowS: t.lowS,
        bits2int: t.bits2int,
        bits2int_modN: t.bits2int_modN
    };
    return {
        CURVE: e,
        curveOpts: r,
        ecdsaOpts: n
    }
}

function I2e(t, e) {
    return Object.assign({}, e, {
        ProjectivePoint: e.Point,
        CURVE: t
    })
}

function $2e(t) {
    const {
        CURVE: e,
        curveOpts: r,
        ecdsaOpts: n
    } = k2e(t), i = _2e(e, r), s = C2e(i, n, r);
    return I2e(t, s)
}

function D5(t, e) {
    const r = n => $2e({ ...t,
        hash: n
    });
    return { ...r(e),
        create: r
    }
}
const jD = {
        p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),
        n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
        h: BigInt(1),
        a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),
        b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),
        Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
        Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")
    },
    RD = {
        p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),
        n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
        h: BigInt(1),
        a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),
        b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),
        Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
        Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")
    },
    MD = {
        p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
        n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
        h: BigInt(1),
        a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),
        b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),
        Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
        Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")
    },
    S2e = Th(jD.p),
    T2e = Th(RD.p),
    P2e = Th(MD.p),
    N2e = D5({ ...jD,
        Fp: S2e,
        lowS: !1
    }, Sy);
D5({ ...RD,
    Fp: T2e,
    lowS: !1
}, Fye), D5({ ...MD,
    Fp: P2e,
    lowS: !1,
    allowedPrivateKeyLengths: [130, 131, 132]
}, Uye);
const O2e = N2e,
    DD = "base10",
    fi = "base16",
    ga = "base64pad",
    zc = "base64url",
    A0 = "utf8",
    LD = 0,
    Ko = 1,
    k0 = 2,
    j2e = 0,
    UA = 1,
    Vf = 12,
    Yx = 32;

function R2e() {
    const t = M5.utils.randomPrivateKey(),
        e = M5.getPublicKey(t);
    return {
        privateKey: Li(t, fi),
        publicKey: Li(e, fi)
    }
}

function L5() {
    const t = Sh(Yx);
    return Li(t, fi)
}

function M2e(t, e) {
    const r = M5.getSharedSecret(Ts(t, fi), Ts(e, fi)),
        n = Vwe(Py, r, void 0, void 0, Yx);
    return Li(n, fi)
}

function em(t) {
    const e = Py(Ts(t, fi));
    return Li(e, fi)
}

function eo(t) {
    const e = Py(Ts(t, A0));
    return Li(e, fi)
}

function UD(t) {
    return Ts(`${t}`, DD)
}

function bd(t) {
    return Number(Li(t, DD))
}

function FD(t) {
    return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "")
}

function BD(t) {
    const e = t.replace(/-/g, "+").replace(/_/g, "/"),
        r = (4 - e.length % 4) % 4;
    return e + "=".repeat(r)
}

function D2e(t) {
    const e = UD(typeof t.type < "u" ? t.type : LD);
    if (bd(e) === Ko && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    const r = typeof t.senderPublicKey < "u" ? Ts(t.senderPublicKey, fi) : void 0,
        n = typeof t.iv < "u" ? Ts(t.iv, fi) : Sh(Vf),
        i = Ts(t.symKey, fi),
        s = bD(i, n).encrypt(Ts(t.message, A0)),
        a = WD({
            type: e,
            sealed: s,
            iv: n,
            senderPublicKey: r
        });
    return t.encoding === zc ? FD(a) : a
}

function L2e(t) {
    const e = Ts(t.symKey, fi),
        {
            sealed: r,
            iv: n
        } = Fp({
            encoded: t.encoded,
            encoding: t.encoding
        }),
        i = bD(e, n).decrypt(r);
    if (i === null) throw new Error("Failed to decrypt");
    return Li(i, A0)
}

function U2e(t, e) {
    const r = UD(k0),
        n = Sh(Vf),
        i = Ts(t, A0),
        s = WD({
            type: r,
            sealed: i,
            iv: n
        });
    return e === zc ? FD(s) : s
}

function F2e(t, e) {
    const {
        sealed: r
    } = Fp({
        encoded: t,
        encoding: e
    });
    return Li(r, A0)
}

function WD(t) {
    if (bd(t.type) === k0) return Li(Wf([t.type, t.sealed]), ga);
    if (bd(t.type) === Ko) {
        if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
        return Li(Wf([t.type, t.senderPublicKey, t.iv, t.sealed]), ga)
    }
    return Li(Wf([t.type, t.iv, t.sealed]), ga)
}

function Fp(t) {
    const e = (t.encoding || ga) === zc ? BD(t.encoded) : t.encoded,
        r = Ts(e, ga),
        n = r.slice(j2e, UA),
        i = UA;
    if (bd(n) === Ko) {
        const c = i + Yx,
            l = c + Vf,
            u = r.slice(i, c),
            h = r.slice(c, l),
            f = r.slice(l);
        return {
            type: n,
            sealed: f,
            iv: h,
            senderPublicKey: u
        }
    }
    if (bd(n) === k0) {
        const c = r.slice(i),
            l = Sh(Vf);
        return {
            type: n,
            sealed: c,
            iv: l
        }
    }
    const s = i + Vf,
        a = r.slice(i, s),
        o = r.slice(s);
    return {
        type: n,
        sealed: o,
        iv: a
    }
}

function B2e(t, e) {
    const r = Fp({
        encoded: t,
        encoding: e == null ? void 0 : e.encoding
    });
    return zD({
        type: bd(r.type),
        senderPublicKey: typeof r.senderPublicKey < "u" ? Li(r.senderPublicKey, fi) : void 0,
        receiverPublicKey: e == null ? void 0 : e.receiverPublicKey
    })
}

function zD(t) {
    const e = (t == null ? void 0 : t.type) || LD;
    if (e === Ko) {
        if (typeof(t == null ? void 0 : t.senderPublicKey) > "u") throw new Error("missing sender public key");
        if (typeof(t == null ? void 0 : t.receiverPublicKey) > "u") throw new Error("missing receiver public key")
    }
    return {
        type: e,
        senderPublicKey: t == null ? void 0 : t.senderPublicKey,
        receiverPublicKey: t == null ? void 0 : t.receiverPublicKey
    }
}

function FA(t) {
    return t.type === Ko && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string"
}

function BA(t) {
    return t.type === k0
}

function W2e(t) {
    const e = Ve.from(t.x, "base64"),
        r = Ve.from(t.y, "base64");
    return Wf([new Uint8Array([4]), e, r])
}

function z2e(t, e) {
    const [r, n, i] = t.split("."), s = Ve.from(BD(i), "base64");
    if (s.length !== 64) throw new Error("Invalid signature length");
    const a = s.slice(0, 32),
        o = s.slice(32, 64),
        c = `${r}.${n}`,
        l = Py(c),
        u = W2e(e);
    if (!O2e.verify(Wf([a, o]), l, u)) throw new Error("Invalid signature");
    return A5(t).payload
}
const q2e = "irn";

function t1(t) {
    return (t == null ? void 0 : t.relay) || {
        protocol: q2e
    }
}

function Sf(t) {
    const e = k1e[t];
    if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
    return e
}

function H2e(t, e = "-") {
    const r = {},
        n = "relay" + e;
    return Object.keys(t).forEach(i => {
        if (i.startsWith(n)) {
            const s = i.replace(n, ""),
                a = t[i];
            r[s] = a
        }
    }), r
}

function WA(t) {
    if (!t.includes("wc:")) {
        const l = eD(t);
        l != null && l.includes("wc:") && (t = l)
    }
    t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
    const e = t.indexOf(":"),
        r = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0,
        n = t.substring(0, e),
        i = t.substring(e + 1, r).split("@"),
        s = typeof r < "u" ? t.substring(r) : "",
        a = new URLSearchParams(s),
        o = {};
    a.forEach((l, u) => {
        o[u] = l
    });
    const c = typeof o.methods == "string" ? o.methods.split(",") : void 0;
    return {
        protocol: n,
        topic: V2e(i[0]),
        version: parseInt(i[1], 10),
        symKey: o.symKey,
        relay: H2e(o),
        methods: c,
        expiryTimestamp: o.expiryTimestamp ? parseInt(o.expiryTimestamp, 10) : void 0
    }
}

function V2e(t) {
    return t.startsWith("//") ? t.substring(2) : t
}

function G2e(t, e = "-") {
    const r = "relay",
        n = {};
    return Object.keys(t).forEach(i => {
        const s = i,
            a = r + e + s;
        t[s] && (n[a] = t[s])
    }), n
}

function zA(t) {
    const e = new URLSearchParams,
        r = G2e(t.relay);
    Object.keys(r).sort().forEach(i => {
        e.set(i, r[i])
    }), e.set("symKey", t.symKey), t.expiryTimestamp && e.set("expiryTimestamp", t.expiryTimestamp.toString()), t.methods && e.set("methods", t.methods.join(","));
    const n = e.toString();
    return `${t.protocol}:${t.topic}@${t.version}?${n}`
}

function xg(t, e, r) {
    return `${t}?wc_ev=${r}&topic=${e}`
}
var K2e = Object.defineProperty,
    Y2e = Object.defineProperties,
    Z2e = Object.getOwnPropertyDescriptors,
    qA = Object.getOwnPropertySymbols,
    J2e = Object.prototype.hasOwnProperty,
    Q2e = Object.prototype.propertyIsEnumerable,
    HA = (t, e, r) => e in t ? K2e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    X2e = (t, e) => {
        for (var r in e || (e = {})) J2e.call(e, r) && HA(t, r, e[r]);
        if (qA)
            for (var r of qA(e)) Q2e.call(e, r) && HA(t, r, e[r]);
        return t
    },
    ebe = (t, e) => Y2e(t, Z2e(e));

function Ph(t) {
    const e = [];
    return t.forEach(r => {
        const [n, i] = r.split(":");
        e.push(`${n}:${i}`)
    }), e
}

function tbe(t) {
    const e = [];
    return Object.values(t).forEach(r => {
        e.push(...Ph(r.accounts))
    }), e
}

function rbe(t, e) {
    const r = [];
    return Object.values(t).forEach(n => {
        Ph(n.accounts).includes(e) && r.push(...n.methods)
    }), r
}

function nbe(t, e) {
    const r = [];
    return Object.values(t).forEach(n => {
        Ph(n.accounts).includes(e) && r.push(...n.events)
    }), r
}

function Ry(t) {
    return t.includes(":")
}

function Su(t) {
    return Ry(t) ? t.split(":")[0] : t
}

function VA(t) {
    var e, r, n;
    const i = {};
    if (!ao(t)) return i;
    for (const [s, a] of Object.entries(t)) {
        const o = Ry(s) ? [s] : a.chains,
            c = a.methods || [],
            l = a.events || [],
            u = Su(s);
        i[u] = ebe(X2e({}, i[u]), {
            chains: so(o, (e = i[u]) == null ? void 0 : e.chains),
            methods: so(c, (r = i[u]) == null ? void 0 : r.methods),
            events: so(l, (n = i[u]) == null ? void 0 : n.events)
        })
    }
    return i
}

function ibe(t) {
    const e = {};
    return t == null || t.forEach(r => {
        var n;
        const [i, s] = r.split(":");
        e[i] || (e[i] = {
            accounts: [],
            chains: [],
            events: [],
            methods: []
        }), e[i].accounts.push(r), (n = e[i].chains) == null || n.push(`${i}:${s}`)
    }), e
}

function GA(t, e) {
    e = e.map(n => n.replace("did:pkh:", ""));
    const r = ibe(e);
    for (const [n, i] of Object.entries(r)) i.methods ? i.methods = so(i.methods, t) : i.methods = t, i.events = ["chainChanged", "accountsChanged"];
    return r
}

function sbe(t, e) {
    var r, n, i, s, a, o;
    const c = VA(t),
        l = VA(e),
        u = {},
        h = Object.keys(c).concat(Object.keys(l));
    for (const f of h) u[f] = {
        chains: so((r = c[f]) == null ? void 0 : r.chains, (n = l[f]) == null ? void 0 : n.chains),
        methods: so((i = c[f]) == null ? void 0 : i.methods, (s = l[f]) == null ? void 0 : s.methods),
        events: so((a = c[f]) == null ? void 0 : a.events, (o = l[f]) == null ? void 0 : o.events)
    };
    return u
}
const abe = {
        INVALID_METHOD: {
            message: "Invalid method.",
            code: 1001
        },
        INVALID_EVENT: {
            message: "Invalid event.",
            code: 1002
        },
        INVALID_UPDATE_REQUEST: {
            message: "Invalid update request.",
            code: 1003
        },
        INVALID_EXTEND_REQUEST: {
            message: "Invalid extend request.",
            code: 1004
        },
        INVALID_SESSION_SETTLE_REQUEST: {
            message: "Invalid session settle request.",
            code: 1005
        },
        UNAUTHORIZED_METHOD: {
            message: "Unauthorized method.",
            code: 3001
        },
        UNAUTHORIZED_EVENT: {
            message: "Unauthorized event.",
            code: 3002
        },
        UNAUTHORIZED_UPDATE_REQUEST: {
            message: "Unauthorized update request.",
            code: 3003
        },
        UNAUTHORIZED_EXTEND_REQUEST: {
            message: "Unauthorized extend request.",
            code: 3004
        },
        USER_REJECTED: {
            message: "User rejected.",
            code: 5e3
        },
        USER_REJECTED_CHAINS: {
            message: "User rejected chains.",
            code: 5001
        },
        USER_REJECTED_METHODS: {
            message: "User rejected methods.",
            code: 5002
        },
        USER_REJECTED_EVENTS: {
            message: "User rejected events.",
            code: 5003
        },
        UNSUPPORTED_CHAINS: {
            message: "Unsupported chains.",
            code: 5100
        },
        UNSUPPORTED_METHODS: {
            message: "Unsupported methods.",
            code: 5101
        },
        UNSUPPORTED_EVENTS: {
            message: "Unsupported events.",
            code: 5102
        },
        UNSUPPORTED_ACCOUNTS: {
            message: "Unsupported accounts.",
            code: 5103
        },
        UNSUPPORTED_NAMESPACE_KEY: {
            message: "Unsupported namespace key.",
            code: 5104
        },
        USER_DISCONNECTED: {
            message: "User disconnected.",
            code: 6e3
        },
        SESSION_SETTLEMENT_FAILED: {
            message: "Session settlement failed.",
            code: 7e3
        },
        WC_METHOD_UNSUPPORTED: {
            message: "Unsupported wc_ method.",
            code: 10001
        }
    },
    obe = {
        NOT_INITIALIZED: {
            message: "Not initialized.",
            code: 1
        },
        NO_MATCHING_KEY: {
            message: "No matching key.",
            code: 2
        },
        RESTORE_WILL_OVERRIDE: {
            message: "Restore will override.",
            code: 3
        },
        RESUBSCRIBED: {
            message: "Resubscribed.",
            code: 4
        },
        MISSING_OR_INVALID: {
            message: "Missing or invalid.",
            code: 5
        },
        EXPIRED: {
            message: "Expired.",
            code: 6
        },
        UNKNOWN_TYPE: {
            message: "Unknown type.",
            code: 7
        },
        MISMATCHED_TOPIC: {
            message: "Mismatched topic.",
            code: 8
        },
        NON_CONFORMING_NAMESPACES: {
            message: "Non conforming namespaces.",
            code: 9
        }
    };

function je(t, e) {
    const {
        message: r,
        code: n
    } = obe[t];
    return {
        message: e ? `${r} ${e}` : r,
        code: n
    }
}

function _r(t, e) {
    const {
        message: r,
        code: n
    } = abe[t];
    return {
        message: e ? `${r} ${e}` : r,
        code: n
    }
}

function Ps(t, e) {
    return !!Array.isArray(t)
}

function ao(t) {
    return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length
}

function $n(t) {
    return typeof t > "u"
}

function en(t, e) {
    return e && $n(t) ? !0 : typeof t == "string" && !!t.trim().length
}

function Zx(t, e) {
    return e && $n(t) ? !0 : typeof t == "number" && !isNaN(t)
}

function cbe(t, e) {
    const {
        requiredNamespaces: r
    } = e, n = Object.keys(t.namespaces), i = Object.keys(r);
    let s = !0;
    return zl(i, n) ? (n.forEach(a => {
        const {
            accounts: o,
            methods: c,
            events: l
        } = t.namespaces[a], u = Ph(o), h = r[a];
        (!zl(YM(a, h), u) || !zl(h.methods, c) || !zl(h.events, l)) && (s = !1)
    }), s) : !1
}

function r1(t) {
    return en(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1
}

function lbe(t) {
    if (en(t, !1) && t.includes(":")) {
        const e = t.split(":");
        if (e.length === 3) {
            const r = e[0] + ":" + e[1];
            return !!e[2] && r1(r)
        }
    }
    return !1
}

function dbe(t) {
    function e(r) {
        try {
            return typeof new URL(r) < "u"
        } catch {
            return !1
        }
    }
    try {
        if (en(t, !1)) {
            if (e(t)) return !0;
            const r = eD(t);
            return e(r)
        }
    } catch {}
    return !1
}

function ube(t) {
    var e;
    return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey
}

function hbe(t) {
    return t == null ? void 0 : t.topic
}

function fbe(t, e) {
    let r = null;
    return en(t == null ? void 0 : t.publicKey, !1) || (r = je("MISSING_OR_INVALID", `${e} controller public key should be a string`)), r
}

function KA(t) {
    let e = !0;
    return Ps(t) ? t.length && (e = t.every(r => en(r, !1))) : e = !1, e
}

function pbe(t, e, r) {
    let n = null;
    return Ps(e) && e.length ? e.forEach(i => {
        n || r1(i) || (n = _r("UNSUPPORTED_CHAINS", `${r}, chain ${i} should be a string and conform to "namespace:chainId" format`))
    }) : r1(t) || (n = _r("UNSUPPORTED_CHAINS", `${r}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), n
}

function gbe(t, e, r) {
    let n = null;
    return Object.entries(t).forEach(([i, s]) => {
        if (n) return;
        const a = pbe(i, YM(i, s), `${e} ${r}`);
        a && (n = a)
    }), n
}

function mbe(t, e) {
    let r = null;
    return Ps(t) ? t.forEach(n => {
        r || lbe(n) || (r = _r("UNSUPPORTED_ACCOUNTS", `${e}, account ${n} should be a string and conform to "namespace:chainId:address" format`))
    }) : r = _r("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), r
}

function ybe(t, e) {
    let r = null;
    return Object.values(t).forEach(n => {
        if (r) return;
        const i = mbe(n == null ? void 0 : n.accounts, `${e} namespace`);
        i && (r = i)
    }), r
}

function wbe(t, e) {
    let r = null;
    return KA(t == null ? void 0 : t.methods) ? KA(t == null ? void 0 : t.events) || (r = _r("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : r = _r("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), r
}

function qD(t, e) {
    let r = null;
    return Object.values(t).forEach(n => {
        if (r) return;
        const i = wbe(n, `${e}, namespace`);
        i && (r = i)
    }), r
}

function bbe(t, e, r) {
    let n = null;
    if (t && ao(t)) {
        const i = qD(t, e);
        i && (n = i);
        const s = gbe(t, e, r);
        s && (n = s)
    } else n = je("MISSING_OR_INVALID", `${e}, ${r} should be an object with data`);
    return n
}

function Eb(t, e) {
    let r = null;
    if (t && ao(t)) {
        const n = qD(t, e);
        n && (r = n);
        const i = ybe(t, e);
        i && (r = i)
    } else r = je("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
    return r
}

function HD(t) {
    return en(t.protocol, !0)
}

function vbe(t, e) {
    let r = !1;
    return t ? t && Ps(t) && t.length && t.forEach(n => {
        r = HD(n)
    }) : r = !0, r
}

function xbe(t) {
    return typeof t == "number"
}

function $i(t) {
    return typeof t < "u" && typeof t !== null
}

function Ebe(t) {
    return !(!t || typeof t != "object" || !t.code || !Zx(t.code, !1) || !t.message || !en(t.message, !1))
}

function _be(t) {
    return !($n(t) || !en(t.method, !1))
}

function Cbe(t) {
    return !($n(t) || $n(t.result) && $n(t.error) || !Zx(t.id, !1) || !en(t.jsonrpc, !1))
}

function Abe(t) {
    return !($n(t) || !en(t.name, !1))
}

function YA(t, e) {
    return !(!r1(e) || !tbe(t).includes(e))
}

function kbe(t, e, r) {
    return en(r, !1) ? rbe(t, e).includes(r) : !1
}

function Ibe(t, e, r) {
    return en(r, !1) ? nbe(t, e).includes(r) : !1
}

function ZA(t, e, r) {
    let n = null;
    const i = $be(t),
        s = Sbe(e),
        a = Object.keys(i),
        o = Object.keys(s),
        c = JA(Object.keys(t)),
        l = JA(Object.keys(e)),
        u = c.filter(h => !l.includes(h));
    return u.length && (n = je("NON_CONFORMING_NAMESPACES", `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u.toString()}
      Received: ${Object.keys(e).toString()}`)), zl(a, o) || (n = je("NON_CONFORMING_NAMESPACES", `${r} namespaces chains don't satisfy required namespaces.
      Required: ${a.toString()}
      Approved: ${o.toString()}`)), Object.keys(e).forEach(h => {
        if (!h.includes(":") || n) return;
        const f = Ph(e[h].accounts);
        f.includes(h) || (n = je("NON_CONFORMING_NAMESPACES", `${r} namespaces accounts don't satisfy namespace accounts for ${h}
        Required: ${h}
        Approved: ${f.toString()}`))
    }), a.forEach(h => {
        n || (zl(i[h].methods, s[h].methods) ? zl(i[h].events, s[h].events) || (n = je("NON_CONFORMING_NAMESPACES", `${r} namespaces events don't satisfy namespace events for ${h}`)) : n = je("NON_CONFORMING_NAMESPACES", `${r} namespaces methods don't satisfy namespace methods for ${h}`))
    }), n
}

function $be(t) {
    const e = {};
    return Object.keys(t).forEach(r => {
        var n;
        r.includes(":") ? e[r] = t[r] : (n = t[r].chains) == null || n.forEach(i => {
            e[i] = {
                methods: t[r].methods,
                events: t[r].events
            }
        })
    }), e
}

function JA(t) {
    return [...new Set(t.map(e => e.includes(":") ? e.split(":")[0] : e))]
}

function Sbe(t) {
    const e = {};
    return Object.keys(t).forEach(r => {
        if (r.includes(":")) e[r] = t[r];
        else {
            const n = Ph(t[r].accounts);
            n == null || n.forEach(i => {
                e[i] = {
                    accounts: t[r].accounts.filter(s => s.includes(`${i}:`)),
                    methods: t[r].methods,
                    events: t[r].events
                }
            })
        }
    }), e
}

function Tbe(t, e) {
    return Zx(t, !1) && t <= e.max && t >= e.min
}

function QA() {
    const t = _0();
    return new Promise(e => {
        switch (t) {
            case ns.browser:
                e(Pbe());
                break;
            case ns.reactNative:
                e(Nbe());
                break;
            case ns.node:
                e(Obe());
                break;
            default:
                e(!0)
        }
    })
}

function Pbe() {
    return $h() && (navigator == null ? void 0 : navigator.onLine)
}
async function Nbe() {
    if (ul() && typeof globalThis < "u" && globalThis != null && globalThis.NetInfo) {
        const t = await (globalThis == null ? void 0 : globalThis.NetInfo.fetch());
        return t == null ? void 0 : t.isConnected
    }
    return !0
}

function Obe() {
    return !0
}

function jbe(t) {
    switch (_0()) {
        case ns.browser:
            Rbe(t);
            break;
        case ns.reactNative:
            Mbe(t);
            break
    }
}

function Rbe(t) {
    !ul() && $h() && (window.addEventListener("online", () => t(!0)), window.addEventListener("offline", () => t(!1)))
}

function Mbe(t) {
    ul() && typeof globalThis < "u" && globalThis != null && globalThis.NetInfo && (globalThis == null || globalThis.NetInfo.addEventListener(e => t(e == null ? void 0 : e.isConnected)))
}

function Dbe() {
    var t;
    return $h() && sc.getDocument() ? ((t = sc.getDocument()) == null ? void 0 : t.visibilityState) === "visible" : !0
}
const _b = {};
let nf = class {
    static get(e) {
        return _b[e]
    }
    static set(e, r) {
        _b[e] = r
    }
    static delete(e) {
        delete _b[e]
    }
};

function Lbe(t) {
    const e = b0.decode(t);
    if (e.length < 33) throw new Error("Too short to contain a public key");
    return e.slice(1, 33)
}

function Ube({
    publicKey: t,
    signature: e,
    payload: r
}) {
    var n;
    const i = U5(r.method),
        s = 128 | parseInt(((n = r.version) == null ? void 0 : n.toString()) || "4"),
        a = Wbe(r.address),
        o = r.era === "00" ? new Uint8Array([0]) : U5(r.era);
    if (o.length !== 1 && o.length !== 2) throw new Error("Invalid era length");
    const c = parseInt(r.nonce, 16),
        l = new Uint8Array([c & 255, c >> 8 & 255]),
        u = BigInt(`0x${Bbe(r.tip)}`),
        h = qbe(u),
        f = new Uint8Array([0, ...t, a, ...e, ...o, ...l, ...h, ...i]),
        p = zbe(f.length + 1);
    return new Uint8Array([...p, s, ...f])
}

function Fbe(t) {
    const e = U5(t),
        r = T1e.blake2b(e, void 0, 32);
    return "0x" + Ve.from(r).toString("hex")
}

function U5(t) {
    return new Uint8Array(t.replace(/^0x/, "").match(/.{1,2}/g).map(e => parseInt(e, 16)))
}

function Bbe(t) {
    return t.startsWith("0x") ? t.slice(2) : t
}

function Wbe(t) {
    const e = b0.decode(t)[0];
    return e === 42 ? 0 : e === 60 ? 2 : 1
}

function zbe(t) {
    if (t < 64) return new Uint8Array([t << 2]);
    if (t < 16384) {
        const e = t << 2 | 1;
        return new Uint8Array([e & 255, e >> 8 & 255])
    } else if (t < 1 << 30) {
        const e = t << 2 | 2;
        return new Uint8Array([e & 255, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255])
    } else throw new Error("Compact encoding > 2^30 not supported")
}

function qbe(t) {
    if (t < BigInt(1) << BigInt(6)) return new Uint8Array([Number(t << BigInt(2))]);
    if (t < BigInt(1) << BigInt(14)) {
        const e = t << BigInt(2) | BigInt(1);
        return new Uint8Array([Number(e & BigInt(255)), Number(e >> BigInt(8) & BigInt(255))])
    } else if (t < BigInt(1) << BigInt(30)) {
        const e = t << BigInt(2) | BigInt(2);
        return new Uint8Array([Number(e & BigInt(255)), Number(e >> BigInt(8) & BigInt(255)), Number(e >> BigInt(16) & BigInt(255)), Number(e >> BigInt(24) & BigInt(255))])
    } else throw new Error("BigInt compact encoding not supported > 2^30")
}

function Hbe(t) {
    const e = Uint8Array.from(Ve.from(t.signature, "hex")),
        r = Lbe(t.transaction.address),
        n = Ube({
            publicKey: r,
            signature: e,
            payload: t.transaction
        }),
        i = Ve.from(n).toString("hex");
    return Fbe(i)
}
class Od {}
let Vbe = class extends Od {
    constructor(e) {
        super()
    }
};
const XA = Me.FIVE_SECONDS,
    jd = {
        pulse: "heartbeat_pulse"
    };
let Gbe = class VD extends Vbe {
    constructor(e) {
        super(e), this.events = new gs.EventEmitter, this.interval = XA, this.interval = (e == null ? void 0 : e.interval) || XA
    }
    static async init(e) {
        const r = new VD(e);
        return await r.init(), r
    }
    async init() {
        await this.initialize()
    }
    stop() {
        clearInterval(this.intervalRef)
    }
    on(e, r) {
        this.events.on(e, r)
    }
    once(e, r) {
        this.events.once(e, r)
    }
    off(e, r) {
        this.events.off(e, r)
    }
    removeListener(e, r) {
        this.events.removeListener(e, r)
    }
    async initialize() {
        this.intervalRef = setInterval(() => this.pulse(), Me.toMiliseconds(this.interval))
    }
    pulse() {
        this.events.emit(jd.pulse)
    }
};

function Kbe(t) {
    return !t || typeof t.then != "function" ? Promise.resolve(t) : t
}

function hn(t, ...e) {
    try {
        return Kbe(t(...e))
    } catch (r) {
        return Promise.reject(r)
    }
}

function Ybe(t) {
    const e = typeof t;
    return t === null || e !== "object" && e !== "function"
}

function Zbe(t) {
    const e = Object.getPrototypeOf(t);
    return !e || e.isPrototypeOf(Object)
}

function tm(t) {
    if (Ybe(t)) return String(t);
    if (Zbe(t) || Array.isArray(t)) return JSON.stringify(t);
    if (typeof t.toJSON == "function") return tm(t.toJSON());
    throw new Error("[unstorage] Cannot stringify value!")
}
const F5 = "base64:";

function Jbe(t) {
    return typeof t == "string" ? t : F5 + eve(t)
}

function Qbe(t) {
    return typeof t != "string" || !t.startsWith(F5) ? t : Xbe(t.slice(F5.length))
}

function Xbe(t) {
    return globalThis.Buffer ? Ve.from(t, "base64") : Uint8Array.from(globalThis.atob(t), e => e.codePointAt(0))
}

function eve(t) {
    return globalThis.Buffer ? Ve.from(t).toString("base64") : globalThis.btoa(String.fromCodePoint(...t))
}

function Ii(t) {
    var e;
    return t && ((e = t.split("?")[0]) == null ? void 0 : e.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || ""
}

function tve(...t) {
    return Ii(t.join(":"))
}

function Eg(t) {
    return t = Ii(t), t ? t + ":" : ""
}

function rve(t, e) {
    if (e === void 0) return !0;
    let r = 0,
        n = t.indexOf(":");
    for (; n > -1;) r++, n = t.indexOf(":", n + 1);
    return r <= e
}

function nve(t, e) {
    return e ? t.startsWith(e) && t[t.length - 1] !== "$" : t[t.length - 1] !== "$"
}
const ive = "memory",
    sve = () => {
        const t = new Map;
        return {
            name: ive,
            getInstance: () => t,
            hasItem(e) {
                return t.has(e)
            },
            getItem(e) {
                return t.get(e) ? ? null
            },
            getItemRaw(e) {
                return t.get(e) ? ? null
            },
            setItem(e, r) {
                t.set(e, r)
            },
            setItemRaw(e, r) {
                t.set(e, r)
            },
            removeItem(e) {
                t.delete(e)
            },
            getKeys() {
                return [...t.keys()]
            },
            clear() {
                t.clear()
            },
            dispose() {
                t.clear()
            }
        }
    };

function ave(t = {}) {
    const e = {
            mounts: {
                "": t.driver || sve()
            },
            mountpoints: [""],
            watching: !1,
            watchListeners: [],
            unwatch: {}
        },
        r = l => {
            for (const u of e.mountpoints)
                if (l.startsWith(u)) return {
                    base: u,
                    relativeKey: l.slice(u.length),
                    driver: e.mounts[u]
                };
            return {
                base: "",
                relativeKey: l,
                driver: e.mounts[""]
            }
        },
        n = (l, u) => e.mountpoints.filter(h => h.startsWith(l) || u && l.startsWith(h)).map(h => ({
            relativeBase: l.length > h.length ? l.slice(h.length) : void 0,
            mountpoint: h,
            driver: e.mounts[h]
        })),
        i = (l, u) => {
            if (e.watching) {
                u = Ii(u);
                for (const h of e.watchListeners) h(l, u)
            }
        },
        s = async () => {
            if (!e.watching) {
                e.watching = !0;
                for (const l in e.mounts) e.unwatch[l] = await ek(e.mounts[l], i, l)
            }
        },
        a = async () => {
            if (e.watching) {
                for (const l in e.unwatch) await e.unwatch[l]();
                e.unwatch = {}, e.watching = !1
            }
        },
        o = (l, u, h) => {
            const f = new Map,
                p = g => {
                    let m = f.get(g.base);
                    return m || (m = {
                        driver: g.driver,
                        base: g.base,
                        items: []
                    }, f.set(g.base, m)), m
                };
            for (const g of l) {
                const m = typeof g == "string",
                    y = Ii(m ? g : g.key),
                    w = m ? void 0 : g.value,
                    x = m || !g.options ? u : { ...u,
                        ...g.options
                    },
                    E = r(y);
                p(E).items.push({
                    key: y,
                    value: w,
                    relativeKey: E.relativeKey,
                    options: x
                })
            }
            return Promise.all([...f.values()].map(g => h(g))).then(g => g.flat())
        },
        c = {
            hasItem(l, u = {}) {
                l = Ii(l);
                const {
                    relativeKey: h,
                    driver: f
                } = r(l);
                return hn(f.hasItem, h, u)
            },
            getItem(l, u = {}) {
                l = Ii(l);
                const {
                    relativeKey: h,
                    driver: f
                } = r(l);
                return hn(f.getItem, h, u).then(p => Ef(p))
            },
            getItems(l, u = {}) {
                return o(l, u, h => h.driver.getItems ? hn(h.driver.getItems, h.items.map(f => ({
                    key: f.relativeKey,
                    options: f.options
                })), u).then(f => f.map(p => ({
                    key: tve(h.base, p.key),
                    value: Ef(p.value)
                }))) : Promise.all(h.items.map(f => hn(h.driver.getItem, f.relativeKey, f.options).then(p => ({
                    key: f.key,
                    value: Ef(p)
                })))))
            },
            getItemRaw(l, u = {}) {
                l = Ii(l);
                const {
                    relativeKey: h,
                    driver: f
                } = r(l);
                return f.getItemRaw ? hn(f.getItemRaw, h, u) : hn(f.getItem, h, u).then(p => Qbe(p))
            },
            async setItem(l, u, h = {}) {
                if (u === void 0) return c.removeItem(l);
                l = Ii(l);
                const {
                    relativeKey: f,
                    driver: p
                } = r(l);
                p.setItem && (await hn(p.setItem, f, tm(u), h), p.watch || i("update", l))
            },
            async setItems(l, u) {
                await o(l, u, async h => {
                    if (h.driver.setItems) return hn(h.driver.setItems, h.items.map(f => ({
                        key: f.relativeKey,
                        value: tm(f.value),
                        options: f.options
                    })), u);
                    h.driver.setItem && await Promise.all(h.items.map(f => hn(h.driver.setItem, f.relativeKey, tm(f.value), f.options)))
                })
            },
            async setItemRaw(l, u, h = {}) {
                if (u === void 0) return c.removeItem(l, h);
                l = Ii(l);
                const {
                    relativeKey: f,
                    driver: p
                } = r(l);
                if (p.setItemRaw) await hn(p.setItemRaw, f, u, h);
                else if (p.setItem) await hn(p.setItem, f, Jbe(u), h);
                else return;
                p.watch || i("update", l)
            },
            async removeItem(l, u = {}) {
                typeof u == "boolean" && (u = {
                    removeMeta: u
                }), l = Ii(l);
                const {
                    relativeKey: h,
                    driver: f
                } = r(l);
                f.removeItem && (await hn(f.removeItem, h, u), (u.removeMeta || u.removeMata) && await hn(f.removeItem, h + "$", u), f.watch || i("remove", l))
            },
            async getMeta(l, u = {}) {
                typeof u == "boolean" && (u = {
                    nativeOnly: u
                }), l = Ii(l);
                const {
                    relativeKey: h,
                    driver: f
                } = r(l), p = Object.create(null);
                if (f.getMeta && Object.assign(p, await hn(f.getMeta, h, u)), !u.nativeOnly) {
                    const g = await hn(f.getItem, h + "$", u).then(m => Ef(m));
                    g && typeof g == "object" && (typeof g.atime == "string" && (g.atime = new Date(g.atime)), typeof g.mtime == "string" && (g.mtime = new Date(g.mtime)), Object.assign(p, g))
                }
                return p
            },
            setMeta(l, u, h = {}) {
                return this.setItem(l + "$", u, h)
            },
            removeMeta(l, u = {}) {
                return this.removeItem(l + "$", u)
            },
            async getKeys(l, u = {}) {
                var y;
                l = Eg(l);
                const h = n(l, !0);
                let f = [];
                const p = [];
                let g = !0;
                for (const w of h) {
                    (y = w.driver.flags) != null && y.maxDepth || (g = !1);
                    const x = await hn(w.driver.getKeys, w.relativeBase, u);
                    for (const E of x) {
                        const _ = w.mountpoint + Ii(E);
                        f.some(b => _.startsWith(b)) || p.push(_)
                    }
                    f = [w.mountpoint, ...f.filter(E => !E.startsWith(w.mountpoint))]
                }
                const m = u.maxDepth !== void 0 && !g;
                return p.filter(w => (!m || rve(w, u.maxDepth)) && nve(w, l))
            },
            async clear(l, u = {}) {
                l = Eg(l), await Promise.all(n(l, !1).map(async h => {
                    if (h.driver.clear) return hn(h.driver.clear, h.relativeBase, u);
                    if (h.driver.removeItem) {
                        const f = await h.driver.getKeys(h.relativeBase || "", u);
                        return Promise.all(f.map(p => h.driver.removeItem(p, u)))
                    }
                }))
            },
            async dispose() {
                await Promise.all(Object.values(e.mounts).map(l => tk(l)))
            },
            async watch(l) {
                return await s(), e.watchListeners.push(l), async () => {
                    e.watchListeners = e.watchListeners.filter(u => u !== l), e.watchListeners.length === 0 && await a()
                }
            },
            async unwatch() {
                e.watchListeners = [], await a()
            },
            mount(l, u) {
                if (l = Eg(l), l && e.mounts[l]) throw new Error(`already mounted at ${l}`);
                return l && (e.mountpoints.push(l), e.mountpoints.sort((h, f) => f.length - h.length)), e.mounts[l] = u, e.watching && Promise.resolve(ek(u, i, l)).then(h => {
                    e.unwatch[l] = h
                }).catch(console.error), c
            },
            async unmount(l, u = !0) {
                var h, f;
                l = Eg(l), !(!l || !e.mounts[l]) && (e.watching && l in e.unwatch && ((f = (h = e.unwatch)[l]) == null || f.call(h), delete e.unwatch[l]), u && await tk(e.mounts[l]), e.mountpoints = e.mountpoints.filter(p => p !== l), delete e.mounts[l])
            },
            getMount(l = "") {
                l = Ii(l) + ":";
                const u = r(l);
                return {
                    driver: u.driver,
                    base: u.base
                }
            },
            getMounts(l = "", u = {}) {
                return l = Ii(l), n(l, u.parents).map(f => ({
                    driver: f.driver,
                    base: f.mountpoint
                }))
            },
            keys: (l, u = {}) => c.getKeys(l, u),
            get: (l, u = {}) => c.getItem(l, u),
            set: (l, u, h = {}) => c.setItem(l, u, h),
            has: (l, u = {}) => c.hasItem(l, u),
            del: (l, u = {}) => c.removeItem(l, u),
            remove: (l, u = {}) => c.removeItem(l, u)
        };
    return c
}

function ek(t, e, r) {
    return t.watch ? t.watch((n, i) => e(n, r + i)) : () => {}
}
async function tk(t) {
    typeof t.dispose == "function" && await hn(t.dispose)
}

function Rd(t) {
    return new Promise((e, r) => {
        t.oncomplete = t.onsuccess = () => e(t.result), t.onabort = t.onerror = () => r(t.error)
    })
}

function GD(t, e) {
    const r = indexedDB.open(t);
    r.onupgradeneeded = () => r.result.createObjectStore(e);
    const n = Rd(r);
    return (i, s) => n.then(a => s(a.transaction(e, i).objectStore(e)))
}
let Cb;

function I0() {
    return Cb || (Cb = GD("keyval-store", "keyval")), Cb
}

function rk(t, e = I0()) {
    return e("readonly", r => Rd(r.get(t)))
}

function ove(t, e, r = I0()) {
    return r("readwrite", n => (n.put(e, t), Rd(n.transaction)))
}

function cve(t, e = I0()) {
    return e("readwrite", r => (r.delete(t), Rd(r.transaction)))
}

function lve(t = I0()) {
    return t("readwrite", e => (e.clear(), Rd(e.transaction)))
}

function dve(t, e) {
    return t.openCursor().onsuccess = function() {
        this.result && (e(this.result), this.result.continue())
    }, Rd(t.transaction)
}

function uve(t = I0()) {
    return t("readonly", e => {
        if (e.getAllKeys) return Rd(e.getAllKeys());
        const r = [];
        return dve(e, n => r.push(n.key)).then(() => r)
    })
}
const hve = "idb-keyval";
var fve = (t = {}) => {
    const e = t.base && t.base.length > 0 ? `${t.base}:` : "",
        r = i => e + i;
    let n;
    return t.dbName && t.storeName && (n = GD(t.dbName, t.storeName)), {
        name: hve,
        options: t,
        async hasItem(i) {
            return !(typeof await rk(r(i), n) > "u")
        },
        async getItem(i) {
            return await rk(r(i), n) ? ? null
        },
        setItem(i, s) {
            return ove(r(i), s, n)
        },
        removeItem(i) {
            return cve(r(i), n)
        },
        getKeys() {
            return uve(n)
        },
        clear() {
            return lve(n)
        }
    }
};
const pve = "WALLET_CONNECT_V2_INDEXED_DB",
    gve = "keyvaluestorage";
let mve = class {
    constructor() {
        this.indexedDb = ave({
            driver: fve({
                dbName: pve,
                storeName: gve
            })
        })
    }
    async getKeys() {
        return this.indexedDb.getKeys()
    }
    async getEntries() {
        return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(e => [e.key, e.value])
    }
    async getItem(e) {
        const r = await this.indexedDb.getItem(e);
        if (r !== null) return r
    }
    async setItem(e, r) {
        await this.indexedDb.setItem(e, ac(r))
    }
    async removeItem(e) {
        await this.indexedDb.removeItem(e)
    }
};
var Ab = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {},
    rm = {
        exports: {}
    };
(function() {
    let t;

    function e() {}
    t = e, t.prototype.getItem = function(r) {
        return this.hasOwnProperty(r) ? String(this[r]) : null
    }, t.prototype.setItem = function(r, n) {
        this[r] = String(n)
    }, t.prototype.removeItem = function(r) {
        delete this[r]
    }, t.prototype.clear = function() {
        const r = this;
        Object.keys(r).forEach(function(n) {
            r[n] = void 0, delete r[n]
        })
    }, t.prototype.key = function(r) {
        return r = r || 0, Object.keys(this)[r]
    }, t.prototype.__defineGetter__("length", function() {
        return Object.keys(this).length
    }), typeof Ab < "u" && Ab.localStorage ? rm.exports = Ab.localStorage : typeof window < "u" && window.localStorage ? rm.exports = window.localStorage : rm.exports = new e
})();

function yve(t) {
    var e;
    return [t[0], yd((e = t[1]) != null ? e : "")]
}
let wve = class {
    constructor() {
        this.localStorage = rm.exports
    }
    async getKeys() {
        return Object.keys(this.localStorage)
    }
    async getEntries() {
        return Object.entries(this.localStorage).map(yve)
    }
    async getItem(e) {
        const r = this.localStorage.getItem(e);
        if (r !== null) return yd(r)
    }
    async setItem(e, r) {
        this.localStorage.setItem(e, ac(r))
    }
    async removeItem(e) {
        this.localStorage.removeItem(e)
    }
};
const bve = "wc_storage_version",
    nk = 1,
    vve = async (t, e, r) => {
        const n = bve,
            i = await e.getItem(n);
        if (i && i >= nk) {
            r(e);
            return
        }
        const s = await t.getKeys();
        if (!s.length) {
            r(e);
            return
        }
        const a = [];
        for (; s.length;) {
            const o = s.shift();
            if (!o) continue;
            const c = o.toLowerCase();
            if (c.includes("wc@") || c.includes("walletconnect") || c.includes("wc_") || c.includes("wallet_connect")) {
                const l = await t.getItem(o);
                await e.setItem(o, l), a.push(o)
            }
        }
        await e.setItem(n, nk), r(e), xve(t, a)
    },
    xve = async (t, e) => {
        e.length && e.forEach(async r => {
            await t.removeItem(r)
        })
    };
let Eve = class {
    constructor() {
        this.initialized = !1, this.setInitialized = r => {
            this.storage = r, this.initialized = !0
        };
        const e = new wve;
        this.storage = e;
        try {
            const r = new mve;
            vve(e, r, this.setInitialized)
        } catch {
            this.initialized = !0
        }
    }
    async getKeys() {
        return await this.initialize(), this.storage.getKeys()
    }
    async getEntries() {
        return await this.initialize(), this.storage.getEntries()
    }
    async getItem(e) {
        return await this.initialize(), this.storage.getItem(e)
    }
    async setItem(e, r) {
        return await this.initialize(), this.storage.setItem(e, r)
    }
    async removeItem(e) {
        return await this.initialize(), this.storage.removeItem(e)
    }
    async initialize() {
        this.initialized || await new Promise(e => {
            const r = setInterval(() => {
                this.initialized && (clearInterval(r), e())
            }, 20)
        })
    }
};
var kb, ik;

function _ve() {
    if (ik) return kb;
    ik = 1;

    function t(r) {
        try {
            return JSON.stringify(r)
        } catch {
            return '"[Circular]"'
        }
    }
    kb = e;

    function e(r, n, i) {
        var s = i && i.stringify || t,
            a = 1;
        if (typeof r == "object" && r !== null) {
            var o = n.length + a;
            if (o === 1) return r;
            var c = new Array(o);
            c[0] = s(r);
            for (var l = 1; l < o; l++) c[l] = s(n[l]);
            return c.join(" ")
        }
        if (typeof r != "string") return r;
        var u = n.length;
        if (u === 0) return r;
        for (var h = "", f = 1 - a, p = -1, g = r && r.length || 0, m = 0; m < g;) {
            if (r.charCodeAt(m) === 37 && m + 1 < g) {
                switch (p = p > -1 ? p : 0, r.charCodeAt(m + 1)) {
                    case 100:
                    case 102:
                        if (f >= u || n[f] == null) break;
                        p < m && (h += r.slice(p, m)), h += Number(n[f]), p = m + 2, m++;
                        break;
                    case 105:
                        if (f >= u || n[f] == null) break;
                        p < m && (h += r.slice(p, m)), h += Math.floor(Number(n[f])), p = m + 2, m++;
                        break;
                    case 79:
                    case 111:
                    case 106:
                        if (f >= u || n[f] === void 0) break;
                        p < m && (h += r.slice(p, m));
                        var y = typeof n[f];
                        if (y === "string") {
                            h += "'" + n[f] + "'", p = m + 2, m++;
                            break
                        }
                        if (y === "function") {
                            h += n[f].name || "<anonymous>", p = m + 2, m++;
                            break
                        }
                        h += s(n[f]), p = m + 2, m++;
                        break;
                    case 115:
                        if (f >= u) break;
                        p < m && (h += r.slice(p, m)), h += String(n[f]), p = m + 2, m++;
                        break;
                    case 37:
                        p < m && (h += r.slice(p, m)), h += "%", p = m + 2, m++, f--;
                        break
                }++f
            }++m
        }
        return p === -1 ? r : (p < g && (h += r.slice(p)), h)
    }
    return kb
}
var Ib, sk;

function Cve() {
    if (sk) return Ib;
    sk = 1;
    const t = _ve();
    Ib = i;
    const e = b().console || {},
        r = {
            mapHttpRequest: g,
            mapHttpResponse: g,
            wrapRequestSerializer: m,
            wrapResponseSerializer: m,
            wrapErrorSerializer: m,
            req: g,
            res: g,
            err: f
        };

    function n(A, I) {
        return Array.isArray(A) ? A.filter(function(C) {
            return C !== "!stdSerializers.err"
        }) : A === !0 ? Object.keys(I) : !1
    }

    function i(A) {
        A = A || {}, A.browser = A.browser || {};
        const I = A.browser.transmit;
        if (I && typeof I.send != "function") throw Error("pino: transmit option must have a send function");
        const T = A.browser.write || e;
        A.browser.write && (A.browser.asObject = !0);
        const C = A.serializers || {},
            $ = n(A.browser.serialize, C);
        let P = A.browser.serialize;
        Array.isArray(A.browser.serialize) && A.browser.serialize.indexOf("!stdSerializers.err") > -1 && (P = !1);
        const N = ["error", "fatal", "warn", "info", "debug", "trace"];
        typeof T == "function" && (T.error = T.fatal = T.warn = T.info = T.debug = T.trace = T), A.enabled === !1 && (A.level = "silent");
        const R = A.level || "info",
            D = Object.create(T);
        D.log || (D.log = y), Object.defineProperty(D, "levelVal", {
            get: O
        }), Object.defineProperty(D, "level", {
            get: M,
            set: U
        });
        const S = {
            transmit: I,
            serialize: $,
            asObject: A.browser.asObject,
            levels: N,
            timestamp: p(A)
        };
        D.levels = i.levels, D.level = R, D.setMaxListeners = D.getMaxListeners = D.emit = D.addListener = D.on = D.prependListener = D.once = D.prependOnceListener = D.removeListener = D.removeAllListeners = D.listeners = D.listenerCount = D.eventNames = D.write = D.flush = y, D.serializers = C, D._serialize = $, D._stdErrSerialize = P, D.child = k, I && (D._logEvent = h());

        function O() {
            return this.level === "silent" ? 1 / 0 : this.levels.values[this.level]
        }

        function M() {
            return this._level
        }

        function U(F) {
            if (F !== "silent" && !this.levels.values[F]) throw Error("unknown level " + F);
            this._level = F, s(S, D, "error", "log"), s(S, D, "fatal", "error"), s(S, D, "warn", "error"), s(S, D, "info", "log"), s(S, D, "debug", "log"), s(S, D, "trace", "log")
        }

        function k(F, q) {
            if (!F) throw new Error("missing bindings for child Pino");
            q = q || {}, $ && F.serializers && (q.serializers = F.serializers);
            const W = q.serializers;
            if ($ && W) {
                var K = Object.assign({}, C, W),
                    H = A.browser.serialize === !0 ? Object.keys(K) : $;
                delete F.serializers, c([F], H, K, this._stdErrSerialize)
            }

            function j(V) {
                this._childLevel = (V._childLevel | 0) + 1, this.error = l(V, F, "error"), this.fatal = l(V, F, "fatal"), this.warn = l(V, F, "warn"), this.info = l(V, F, "info"), this.debug = l(V, F, "debug"), this.trace = l(V, F, "trace"), K && (this.serializers = K, this._serialize = H), I && (this._logEvent = h([].concat(V._logEvent.bindings, F)))
            }
            return j.prototype = this, new j(this)
        }
        return D
    }
    i.levels = {
        values: {
            fatal: 60,
            error: 50,
            warn: 40,
            info: 30,
            debug: 20,
            trace: 10
        },
        labels: {
            10: "trace",
            20: "debug",
            30: "info",
            40: "warn",
            50: "error",
            60: "fatal"
        }
    }, i.stdSerializers = r, i.stdTimeFunctions = Object.assign({}, {
        nullTime: w,
        epochTime: x,
        unixTime: E,
        isoTime: _
    });

    function s(A, I, T, C) {
        const $ = Object.getPrototypeOf(I);
        I[T] = I.levelVal > I.levels.values[T] ? y : $[T] ? $[T] : e[T] || e[C] || y, a(A, I, T)
    }

    function a(A, I, T) {
        !A.transmit && I[T] === y || (I[T] = function(C) {
            return function() {
                const P = A.timestamp(),
                    N = new Array(arguments.length),
                    R = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this;
                for (var D = 0; D < N.length; D++) N[D] = arguments[D];
                if (A.serialize && !A.asObject && c(N, this._serialize, this.serializers, this._stdErrSerialize), A.asObject ? C.call(R, o(this, T, N, P)) : C.apply(R, N), A.transmit) {
                    const S = A.transmit.level || I.level,
                        O = i.levels.values[S],
                        M = i.levels.values[T];
                    if (M < O) return;
                    u(this, {
                        ts: P,
                        methodLevel: T,
                        methodValue: M,
                        transmitValue: i.levels.values[A.transmit.level || I.level],
                        send: A.transmit.send,
                        val: I.levelVal
                    }, N)
                }
            }
        }(I[T]))
    }

    function o(A, I, T, C) {
        A._serialize && c(T, A._serialize, A.serializers, A._stdErrSerialize);
        const $ = T.slice();
        let P = $[0];
        const N = {};
        C && (N.time = C), N.level = i.levels.values[I];
        let R = (A._childLevel | 0) + 1;
        if (R < 1 && (R = 1), P !== null && typeof P == "object") {
            for (; R-- && typeof $[0] == "object";) Object.assign(N, $.shift());
            P = $.length ? t($.shift(), $) : void 0
        } else typeof P == "string" && (P = t($.shift(), $));
        return P !== void 0 && (N.msg = P), N
    }

    function c(A, I, T, C) {
        for (const $ in A)
            if (C && A[$] instanceof Error) A[$] = i.stdSerializers.err(A[$]);
            else if (typeof A[$] == "object" && !Array.isArray(A[$]))
            for (const P in A[$]) I && I.indexOf(P) > -1 && P in T && (A[$][P] = T[P](A[$][P]))
    }

    function l(A, I, T) {
        return function() {
            const C = new Array(1 + arguments.length);
            C[0] = I;
            for (var $ = 1; $ < C.length; $++) C[$] = arguments[$ - 1];
            return A[T].apply(this, C)
        }
    }

    function u(A, I, T) {
        const C = I.send,
            $ = I.ts,
            P = I.methodLevel,
            N = I.methodValue,
            R = I.val,
            D = A._logEvent.bindings;
        c(T, A._serialize || Object.keys(A.serializers), A.serializers, A._stdErrSerialize === void 0 ? !0 : A._stdErrSerialize), A._logEvent.ts = $, A._logEvent.messages = T.filter(function(S) {
            return D.indexOf(S) === -1
        }), A._logEvent.level.label = P, A._logEvent.level.value = N, C(P, A._logEvent, R), A._logEvent = h(D)
    }

    function h(A) {
        return {
            ts: 0,
            messages: [],
            bindings: A || [],
            level: {
                label: "",
                value: 0
            }
        }
    }

    function f(A) {
        const I = {
            type: A.constructor.name,
            msg: A.message,
            stack: A.stack
        };
        for (const T in A) I[T] === void 0 && (I[T] = A[T]);
        return I
    }

    function p(A) {
        return typeof A.timestamp == "function" ? A.timestamp : A.timestamp === !1 ? w : x
    }

    function g() {
        return {}
    }

    function m(A) {
        return A
    }

    function y() {}

    function w() {
        return !1
    }

    function x() {
        return Date.now()
    }

    function E() {
        return Math.round(Date.now() / 1e3)
    }

    function _() {
        return new Date(Date.now()).toISOString()
    }

    function b() {
        function A(I) {
            return typeof I < "u" && I
        }
        try {
            return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
                get: function() {
                    return delete Object.prototype.globalThis, this.globalThis = this
                },
                configurable: !0
            }), globalThis
        } catch {
            return A(self) || A(window) || A(this) || {}
        }
    }
    return Ib
}
var _u = Cve();
const $0 = Oa(_u),
    Ave = {
        level: "info"
    },
    S0 = "custom_context",
    Jx = 1e3 * 1024;
let kve = class {
        constructor(e) {
            this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null
        }
        get value() {
            return this.nodeValue
        }
        get size() {
            return this.sizeInBytes
        }
    },
    ak = class {
        constructor(e) {
            this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0
        }
        append(e) {
            const r = new kve(e);
            if (r.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${r.size}`);
            for (; this.size + r.size > this.maxSizeInBytes;) this.shift();
            this.head ? (this.tail && (this.tail.next = r), this.tail = r) : (this.head = r, this.tail = r), this.lengthInNodes++, this.sizeInBytes += r.size
        }
        shift() {
            if (!this.head) return;
            const e = this.head;
            this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size
        }
        toArray() {
            const e = [];
            let r = this.head;
            for (; r !== null;) e.push(r.value), r = r.next;
            return e
        }
        get length() {
            return this.lengthInNodes
        }
        get size() {
            return this.sizeInBytes
        }
        toOrderedArray() {
            return Array.from(this)
        }[Symbol.iterator]() {
            let e = this.head;
            return {
                next: () => {
                    if (!e) return {
                        done: !0,
                        value: null
                    };
                    const r = e.value;
                    return e = e.next, {
                        done: !1,
                        value: r
                    }
                }
            }
        }
    },
    KD = class {
        constructor(e, r = Jx) {
            this.level = e ? ? "error", this.levelValue = _u.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = r, this.logs = new ak(this.MAX_LOG_SIZE_IN_BYTES)
        }
        forwardToConsole(e, r) {
            r === _u.levels.values.error ? console.error(e) : r === _u.levels.values.warn ? console.warn(e) : r === _u.levels.values.debug ? console.debug(e) : r === _u.levels.values.trace ? console.trace(e) : console.log(e)
        }
        appendToLogs(e) {
            this.logs.append(ac({
                timestamp: new Date().toISOString(),
                log: e
            }));
            const r = typeof e == "string" ? JSON.parse(e).level : e.level;
            r >= this.levelValue && this.forwardToConsole(e, r)
        }
        getLogs() {
            return this.logs
        }
        clearLogs() {
            this.logs = new ak(this.MAX_LOG_SIZE_IN_BYTES)
        }
        getLogArray() {
            return Array.from(this.logs)
        }
        logsToBlob(e) {
            const r = this.getLogArray();
            return r.push(ac({
                extraMetadata: e
            })), new Blob(r, {
                type: "application/json"
            })
        }
    },
    Ive = class {
        constructor(e, r = Jx) {
            this.baseChunkLogger = new KD(e, r)
        }
        write(e) {
            this.baseChunkLogger.appendToLogs(e)
        }
        getLogs() {
            return this.baseChunkLogger.getLogs()
        }
        clearLogs() {
            this.baseChunkLogger.clearLogs()
        }
        getLogArray() {
            return this.baseChunkLogger.getLogArray()
        }
        logsToBlob(e) {
            return this.baseChunkLogger.logsToBlob(e)
        }
        downloadLogsBlobInBrowser(e) {
            const r = URL.createObjectURL(this.logsToBlob(e)),
                n = document.createElement("a");
            n.href = r, n.download = `walletconnect-logs-${new Date().toISOString()}.txt`, document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(r)
        }
    },
    $ve = class {
        constructor(e, r = Jx) {
            this.baseChunkLogger = new KD(e, r)
        }
        write(e) {
            this.baseChunkLogger.appendToLogs(e)
        }
        getLogs() {
            return this.baseChunkLogger.getLogs()
        }
        clearLogs() {
            this.baseChunkLogger.clearLogs()
        }
        getLogArray() {
            return this.baseChunkLogger.getLogArray()
        }
        logsToBlob(e) {
            return this.baseChunkLogger.logsToBlob(e)
        }
    };
var Sve = Object.defineProperty,
    Tve = Object.defineProperties,
    Pve = Object.getOwnPropertyDescriptors,
    ok = Object.getOwnPropertySymbols,
    Nve = Object.prototype.hasOwnProperty,
    Ove = Object.prototype.propertyIsEnumerable,
    ck = (t, e, r) => e in t ? Sve(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    n1 = (t, e) => {
        for (var r in e || (e = {})) Nve.call(e, r) && ck(t, r, e[r]);
        if (ok)
            for (var r of ok(e)) Ove.call(e, r) && ck(t, r, e[r]);
        return t
    },
    i1 = (t, e) => Tve(t, Pve(e));

function My(t) {
    return i1(n1({}, t), {
        level: (t == null ? void 0 : t.level) || Ave.level
    })
}

function jve(t, e = S0) {
    return t[e] || ""
}

function Rve(t, e, r = S0) {
    return t[r] = e, t
}

function zi(t, e = S0) {
    let r = "";
    return typeof t.bindings > "u" ? r = jve(t, e) : r = t.bindings().context || "", r
}

function Mve(t, e, r = S0) {
    const n = zi(t, r);
    return n.trim() ? `${n}/${e}` : e
}

function wi(t, e, r = S0) {
    const n = Mve(t, e, r),
        i = t.child({
            context: n
        });
    return Rve(i, n, r)
}

function Dve(t) {
    var e, r;
    const n = new Ive((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
    return {
        logger: $0(i1(n1({}, t.opts), {
            level: "trace",
            browser: i1(n1({}, (r = t.opts) == null ? void 0 : r.browser), {
                write: i => n.write(i)
            })
        })),
        chunkLoggerController: n
    }
}

function Lve(t) {
    var e;
    const r = new $ve((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
    return {
        logger: $0(i1(n1({}, t.opts), {
            level: "trace"
        }), r),
        chunkLoggerController: r
    }
}

function Uve(t) {
    return typeof t.loggerOverride < "u" && typeof t.loggerOverride != "string" ? {
        logger: t.loggerOverride,
        chunkLoggerController: null
    } : typeof window < "u" ? Dve(t) : Lve(t)
}
var Fve = Object.defineProperty,
    Bve = (t, e, r) => e in t ? Fve(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    lk = (t, e, r) => Bve(t, typeof e != "symbol" ? e + "" : e, r);
let Wve = class extends Od {
    constructor(e) {
        super(), this.opts = e, lk(this, "protocol", "wc"), lk(this, "version", 2)
    }
};
var zve = Object.defineProperty,
    qve = (t, e, r) => e in t ? zve(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Hve = (t, e, r) => qve(t, e + "", r);
let Vve = class extends Od {
        constructor(e, r) {
            super(), this.core = e, this.logger = r, Hve(this, "records", new Map)
        }
    },
    Gve = class {
        constructor(e, r) {
            this.logger = e, this.core = r
        }
    };
class Kve extends Od {
    constructor(e, r) {
        super(), this.relayer = e, this.logger = r
    }
}
let Yve = class extends Od {
        constructor(e) {
            super()
        }
    },
    Zve = class {
        constructor(e, r, n, i) {
            this.core = e, this.logger = r, this.name = n
        }
    },
    Jve = class extends Od {
        constructor(e, r) {
            super(), this.relayer = e, this.logger = r
        }
    },
    Qve = class extends Od {
        constructor(e, r) {
            super(), this.core = e, this.logger = r
        }
    },
    Xve = class {
        constructor(e, r, n) {
            this.core = e, this.logger = r, this.store = n
        }
    },
    e3e = class {
        constructor(e, r) {
            this.projectId = e, this.logger = r
        }
    },
    t3e = class {
        constructor(e, r, n) {
            this.core = e, this.logger = r, this.telemetryEnabled = n
        }
    };
var r3e = Object.defineProperty,
    n3e = (t, e, r) => e in t ? r3e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    dk = (t, e, r) => n3e(t, typeof e != "symbol" ? e + "" : e, r);
let i3e = class {
        constructor(e) {
            this.opts = e, dk(this, "protocol", "wc"), dk(this, "version", 2)
        }
    },
    s3e = class {
        constructor(e) {
            this.client = e
        }
    };
const a3e = "PARSE_ERROR",
    o3e = "INVALID_REQUEST",
    c3e = "METHOD_NOT_FOUND",
    l3e = "INVALID_PARAMS",
    YD = "INTERNAL_ERROR",
    Qx = "SERVER_ERROR",
    d3e = [-32700, -32600, -32601, -32602, -32603],
    Gf = {
        [a3e]: {
            code: -32700,
            message: "Parse error"
        },
        [o3e]: {
            code: -32600,
            message: "Invalid Request"
        },
        [c3e]: {
            code: -32601,
            message: "Method not found"
        },
        [l3e]: {
            code: -32602,
            message: "Invalid params"
        },
        [YD]: {
            code: -32603,
            message: "Internal error"
        },
        [Qx]: {
            code: -32e3,
            message: "Server error"
        }
    },
    ZD = Qx;

function u3e(t) {
    return d3e.includes(t)
}

function uk(t) {
    return Object.keys(Gf).includes(t) ? Gf[t] : Gf[ZD]
}

function h3e(t) {
    const e = Object.values(Gf).find(r => r.code === t);
    return e || Gf[ZD]
}

function JD(t, e, r) {
    return t.message.includes("getaddrinfo ENOTFOUND") || t.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${r} RPC url at ${e}`) : t
}
var $b = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var B5 = function(t, e) {
    return B5 = Object.setPrototypeOf || {
        __proto__: []
    }
    instanceof Array && function(r, n) {
        r.__proto__ = n
    } || function(r, n) {
        for (var i in n) n.hasOwnProperty(i) && (r[i] = n[i])
    }, B5(t, e)
};

function f3e(t, e) {
    B5(t, e);

    function r() {
        this.constructor = t
    }
    t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r)
}
var W5 = function() {
    return W5 = Object.assign || function(e) {
        for (var r, n = 1, i = arguments.length; n < i; n++) {
            r = arguments[n];
            for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s])
        }
        return e
    }, W5.apply(this, arguments)
};

function p3e(t, e) {
    var r = {};
    for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++) e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
    return r
}

function g3e(t, e, r, n) {
    var i = arguments.length,
        s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n,
        a;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, r, n);
    else
        for (var o = t.length - 1; o >= 0; o--)(a = t[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, r, s) : a(e, r)) || s);
    return i > 3 && s && Object.defineProperty(e, r, s), s
}

function m3e(t, e) {
    return function(r, n) {
        e(r, n, t)
    }
}

function y3e(t, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e)
}

function w3e(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(a) {
            a(s)
        })
    }
    return new(r || (r = Promise))(function(s, a) {
        function o(u) {
            try {
                l(n.next(u))
            } catch (h) {
                a(h)
            }
        }

        function c(u) {
            try {
                l(n.throw(u))
            } catch (h) {
                a(h)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(o, c)
        }
        l((n = n.apply(t, e || [])).next())
    })
}

function b3e(t, e) {
    var r = {
            label: 0,
            sent: function() {
                if (s[0] & 1) throw s[1];
                return s[1]
            },
            trys: [],
            ops: []
        },
        n, i, s, a;
    return a = {
        next: o(0),
        throw: o(1),
        return: o(2)
    }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
        return this
    }), a;

    function o(l) {
        return function(u) {
            return c([l, u])
        }
    }

    function c(l) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; r;) try {
            if (n = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done) return s;
            switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
                case 0:
                case 1:
                    s = l;
                    break;
                case 4:
                    return r.label++, {
                        value: l[1],
                        done: !1
                    };
                case 5:
                    r.label++, i = l[1], l = [0];
                    continue;
                case 7:
                    l = r.ops.pop(), r.trys.pop();
                    continue;
                default:
                    if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
                        r = 0;
                        continue
                    }
                    if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
                        r.label = l[1];
                        break
                    }
                    if (l[0] === 6 && r.label < s[1]) {
                        r.label = s[1], s = l;
                        break
                    }
                    if (s && r.label < s[2]) {
                        r.label = s[2], r.ops.push(l);
                        break
                    }
                    s[2] && r.ops.pop(), r.trys.pop();
                    continue
            }
            l = e.call(t, r)
        } catch (u) {
            l = [6, u], i = 0
        } finally {
            n = s = 0
        }
        if (l[0] & 5) throw l[1];
        return {
            value: l[0] ? l[1] : void 0,
            done: !0
        }
    }
}

function v3e(t, e, r, n) {
    n === void 0 && (n = r), t[n] = e[r]
}

function x3e(t, e) {
    for (var r in t) r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r])
}

function z5(t) {
    var e = typeof Symbol == "function" && Symbol.iterator,
        r = e && t[e],
        n = 0;
    if (r) return r.call(t);
    if (t && typeof t.length == "number") return {
        next: function() {
            return t && n >= t.length && (t = void 0), {
                value: t && t[n++],
                done: !t
            }
        }
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}

function QD(t, e) {
    var r = typeof Symbol == "function" && t[Symbol.iterator];
    if (!r) return t;
    var n = r.call(t),
        i, s = [],
        a;
    try {
        for (;
            (e === void 0 || e-- > 0) && !(i = n.next()).done;) s.push(i.value)
    } catch (o) {
        a = {
            error: o
        }
    } finally {
        try {
            i && !i.done && (r = n.return) && r.call(n)
        } finally {
            if (a) throw a.error
        }
    }
    return s
}

function E3e() {
    for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(QD(arguments[e]));
    return t
}

function _3e() {
    for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length;
    for (var n = Array(t), i = 0, e = 0; e < r; e++)
        for (var s = arguments[e], a = 0, o = s.length; a < o; a++, i++) n[i] = s[a];
    return n
}

function Bp(t) {
    return this instanceof Bp ? (this.v = t, this) : new Bp(t)
}

function C3e(t, e, r) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var n = r.apply(t, e || []),
        i, s = [];
    return i = {}, a("next"), a("throw"), a("return"), i[Symbol.asyncIterator] = function() {
        return this
    }, i;

    function a(f) {
        n[f] && (i[f] = function(p) {
            return new Promise(function(g, m) {
                s.push([f, p, g, m]) > 1 || o(f, p)
            })
        })
    }

    function o(f, p) {
        try {
            c(n[f](p))
        } catch (g) {
            h(s[0][3], g)
        }
    }

    function c(f) {
        f.value instanceof Bp ? Promise.resolve(f.value.v).then(l, u) : h(s[0][2], f)
    }

    function l(f) {
        o("next", f)
    }

    function u(f) {
        o("throw", f)
    }

    function h(f, p) {
        f(p), s.shift(), s.length && o(s[0][0], s[0][1])
    }
}

function A3e(t) {
    var e, r;
    return e = {}, n("next"), n("throw", function(i) {
        throw i
    }), n("return"), e[Symbol.iterator] = function() {
        return this
    }, e;

    function n(i, s) {
        e[i] = t[i] ? function(a) {
            return (r = !r) ? {
                value: Bp(t[i](a)),
                done: i === "return"
            } : s ? s(a) : a
        } : s
    }
}

function k3e(t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = t[Symbol.asyncIterator],
        r;
    return e ? e.call(t) : (t = typeof z5 == "function" ? z5(t) : t[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
        return this
    }, r);

    function n(s) {
        r[s] = t[s] && function(a) {
            return new Promise(function(o, c) {
                a = t[s](a), i(o, c, a.done, a.value)
            })
        }
    }

    function i(s, a, o, c) {
        Promise.resolve(c).then(function(l) {
            s({
                value: l,
                done: o
            })
        }, a)
    }
}

function I3e(t, e) {
    return Object.defineProperty ? Object.defineProperty(t, "raw", {
        value: e
    }) : t.raw = e, t
}

function $3e(t) {
    if (t && t.__esModule) return t;
    var e = {};
    if (t != null)
        for (var r in t) Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
    return e.default = t, e
}

function S3e(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}

function T3e(t, e) {
    if (!e.has(t)) throw new TypeError("attempted to get private field on non-instance");
    return e.get(t)
}

function P3e(t, e, r) {
    if (!e.has(t)) throw new TypeError("attempted to set private field on non-instance");
    return e.set(t, r), r
}
const N3e = Object.freeze(Object.defineProperty({
        __proto__: null,
        get __assign() {
            return W5
        },
        __asyncDelegator: A3e,
        __asyncGenerator: C3e,
        __asyncValues: k3e,
        __await: Bp,
        __awaiter: w3e,
        __classPrivateFieldGet: T3e,
        __classPrivateFieldSet: P3e,
        __createBinding: v3e,
        __decorate: g3e,
        __exportStar: x3e,
        __extends: f3e,
        __generator: b3e,
        __importDefault: S3e,
        __importStar: $3e,
        __makeTemplateObject: I3e,
        __metadata: y3e,
        __param: m3e,
        __read: QD,
        __rest: p3e,
        __spread: E3e,
        __spreadArrays: _3e,
        __values: z5
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    O3e = xS(N3e);
var Io = {},
    hk;

function j3e() {
    if (hk) return Io;
    hk = 1, Object.defineProperty(Io, "__esModule", {
        value: !0
    }), Io.isBrowserCryptoAvailable = Io.getSubtleCrypto = Io.getBrowerCrypto = void 0;

    function t() {
        return (globalThis == null ? void 0 : globalThis.crypto) || (globalThis == null ? void 0 : globalThis.msCrypto) || {}
    }
    Io.getBrowerCrypto = t;

    function e() {
        const n = t();
        return n.subtle || n.webkitSubtle
    }
    Io.getSubtleCrypto = e;

    function r() {
        return !!t() && !!e()
    }
    return Io.isBrowserCryptoAvailable = r, Io
}
var $o = {},
    fk;

function R3e() {
    if (fk) return $o;
    fk = 1, Object.defineProperty($o, "__esModule", {
        value: !0
    }), $o.isBrowser = $o.isNode = $o.isReactNative = void 0;

    function t() {
        return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative"
    }
    $o.isReactNative = t;

    function e() {
        return typeof jn < "u" && typeof jn.versions < "u" && typeof jn.versions.node < "u"
    }
    $o.isNode = e;

    function r() {
        return !t() && !e()
    }
    return $o.isBrowser = r, $o
}
var pk;

function M3e() {
    return pk || (pk = 1, function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const e = O3e;
        e.__exportStar(j3e(), t), e.__exportStar(R3e(), t)
    }($b)), $b
}
var D3e = M3e();

function Za(t = 3) {
    const e = Date.now() * Math.pow(10, t),
        r = Math.floor(Math.random() * Math.pow(10, t));
    return e + r
}

function Gl(t = 6) {
    return BigInt(Za(t))
}

function Zc(t, e, r) {
    return {
        id: r || Za(),
        jsonrpc: "2.0",
        method: t,
        params: e
    }
}

function Dy(t, e) {
    return {
        id: t,
        jsonrpc: "2.0",
        result: e
    }
}

function Ly(t, e, r) {
    return {
        id: t,
        jsonrpc: "2.0",
        error: L3e(e)
    }
}

function L3e(t, e) {
    return typeof t > "u" ? uk(YD) : (typeof t == "string" && (t = Object.assign(Object.assign({}, uk(Qx)), {
        message: t
    })), u3e(t.code) && (t = h3e(t.code)), t)
}
class U3e {}
class F3e extends U3e {
    constructor() {
        super()
    }
}
class B3e extends F3e {
    constructor(e) {
        super()
    }
}
const W3e = "^https?:",
    z3e = "^wss?:";

function q3e(t) {
    const e = t.match(new RegExp(/^\w+:/, "gi"));
    if (!(!e || !e.length)) return e[0]
}

function XD(t, e) {
    const r = q3e(t);
    return typeof r > "u" ? !1 : new RegExp(e).test(r)
}

function gk(t) {
    return XD(t, W3e)
}

function mk(t) {
    return XD(t, z3e)
}

function H3e(t) {
    return new RegExp("wss?://localhost(:d{2,5})?").test(t)
}

function eL(t) {
    return typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0"
}

function Xx(t) {
    return eL(t) && "method" in t
}

function Uy(t) {
    return eL(t) && (Ja(t) || Is(t))
}

function Ja(t) {
    return "result" in t
}

function Is(t) {
    return "error" in t
}
let Hs = class extends B3e {
    constructor(e) {
        super(e), this.events = new gs.EventEmitter, this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners()
    }
    async connect(e = this.connection) {
        await this.open(e)
    }
    async disconnect() {
        await this.close()
    }
    on(e, r) {
        this.events.on(e, r)
    }
    once(e, r) {
        this.events.once(e, r)
    }
    off(e, r) {
        this.events.off(e, r)
    }
    removeListener(e, r) {
        this.events.removeListener(e, r)
    }
    async request(e, r) {
        return this.requestStrict(Zc(e.method, e.params || [], e.id || Gl().toString()), r)
    }
    async requestStrict(e, r) {
        return new Promise(async (n, i) => {
            if (!this.connection.connected) try {
                await this.open()
            } catch (s) {
                i(s)
            }
            this.events.on(`${e.id}`, s => {
                Is(s) ? i(s.error) : n(s.result)
            });
            try {
                await this.connection.send(e, r)
            } catch (s) {
                i(s)
            }
        })
    }
    setConnection(e = this.connection) {
        return e
    }
    onPayload(e) {
        this.events.emit("payload", e), Uy(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
            type: e.method,
            data: e.params
        })
    }
    onClose(e) {
        e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason?`(${e.reason})`:""}`)), this.events.emit("disconnect")
    }
    async open(e = this.connection) {
        this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"))
    }
    async close() {
        await this.connection.close()
    }
    registerEventListeners() {
        this.hasRegisteredEventListeners || (this.connection.on("payload", e => this.onPayload(e)), this.connection.on("close", e => this.onClose(e)), this.connection.on("error", e => this.events.emit("error", e)), this.connection.on("register_error", e => this.onClose()), this.hasRegisteredEventListeners = !0)
    }
};
const V3e = () => typeof WebSocket < "u" ? WebSocket : typeof globalThis < "u" && typeof globalThis.WebSocket < "u" ? globalThis.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"),
    G3e = () => typeof WebSocket < "u" || typeof globalThis < "u" && typeof globalThis.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u",
    yk = t => t.split("?")[0],
    wk = 10,
    K3e = V3e();
let Y3e = class {
    constructor(e) {
        if (this.url = e, this.events = new gs.EventEmitter, this.registering = !1, !mk(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
        this.url = e
    }
    get connected() {
        return typeof this.socket < "u"
    }
    get connecting() {
        return this.registering
    }
    on(e, r) {
        this.events.on(e, r)
    }
    once(e, r) {
        this.events.once(e, r)
    }
    off(e, r) {
        this.events.off(e, r)
    }
    removeListener(e, r) {
        this.events.removeListener(e, r)
    }
    async open(e = this.url) {
        await this.register(e)
    }
    async close() {
        return new Promise((e, r) => {
            if (typeof this.socket > "u") {
                r(new Error("Connection already closed"));
                return
            }
            this.socket.onclose = n => {
                this.onClose(n), e()
            }, this.socket.close()
        })
    }
    async send(e) {
        typeof this.socket > "u" && (this.socket = await this.register());
        try {
            this.socket.send(ac(e))
        } catch (r) {
            this.onError(e.id, r)
        }
    }
    register(e = this.url) {
        if (!mk(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
        if (this.registering) {
            const r = this.events.getMaxListeners();
            return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((n, i) => {
                this.events.once("register_error", s => {
                    this.resetMaxListeners(), i(s)
                }), this.events.once("open", () => {
                    if (this.resetMaxListeners(), typeof this.socket > "u") return i(new Error("WebSocket connection is missing or invalid"));
                    n(this.socket)
                })
            })
        }
        return this.url = e, this.registering = !0, new Promise((r, n) => {
            const i = D3e.isReactNative() ? void 0 : {
                    rejectUnauthorized: !H3e(e)
                },
                s = new K3e(e, [], i);
            G3e() ? s.onerror = a => {
                const o = a;
                n(this.emitError(o.error))
            } : s.on("error", a => {
                n(this.emitError(a))
            }), s.onopen = () => {
                this.onOpen(s), r(s)
            }
        })
    }
    onOpen(e) {
        e.onmessage = r => this.onPayload(r), e.onclose = r => this.onClose(r), this.socket = e, this.registering = !1, this.events.emit("open")
    }
    onClose(e) {
        this.socket = void 0, this.registering = !1, this.events.emit("close", e)
    }
    onPayload(e) {
        if (typeof e.data > "u") return;
        const r = typeof e.data == "string" ? yd(e.data) : e.data;
        this.events.emit("payload", r)
    }
    onError(e, r) {
        const n = this.parseError(r),
            i = n.message || n.toString(),
            s = Ly(e, i);
        this.events.emit("payload", s)
    }
    parseError(e, r = this.url) {
        return JD(e, yk(r), "WS")
    }
    resetMaxListeners() {
        this.events.getMaxListeners() > wk && this.events.setMaxListeners(wk)
    }
    emitError(e) {
        const r = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${yk(this.url)}`));
        return this.events.emit("register_error", r), r
    }
};
var Z3e = {};
const tL = "wc",
    rL = 2,
    q5 = "core",
    fo = `${tL}@2:${q5}:`,
    J3e = {
        logger: "error"
    },
    Q3e = {
        database: ":memory:"
    },
    X3e = "crypto",
    bk = "client_ed25519_seed",
    e5e = Me.ONE_DAY,
    t5e = "keychain",
    r5e = "0.3",
    n5e = "messages",
    i5e = "0.3",
    vk = Me.SIX_HOURS,
    s5e = "publisher",
    nL = "irn",
    a5e = "error",
    iL = "wss://relay.walletconnect.org",
    o5e = "relayer",
    mn = {
        message: "relayer_message",
        message_ack: "relayer_message_ack",
        connect: "relayer_connect",
        disconnect: "relayer_disconnect",
        error: "relayer_error",
        connection_stalled: "relayer_connection_stalled",
        transport_closed: "relayer_transport_closed",
        publish: "relayer_publish"
    },
    c5e = "_subscription",
    vs = {
        payload: "payload",
        connect: "connect",
        disconnect: "disconnect",
        error: "error"
    },
    l5e = .1,
    H5 = "2.21.5",
    Er = {
        link_mode: "link_mode",
        relay: "relay"
    },
    nm = {
        inbound: "inbound",
        outbound: "outbound"
    },
    d5e = "0.3",
    u5e = "WALLETCONNECT_CLIENT_ID",
    xk = "WALLETCONNECT_LINK_MODE_APPS",
    Ki = {
        created: "subscription_created",
        deleted: "subscription_deleted",
        expired: "subscription_expired",
        disabled: "subscription_disabled",
        sync: "subscription_sync",
        resubscribed: "subscription_resubscribed"
    },
    h5e = "subscription",
    f5e = "0.3",
    p5e = "pairing",
    g5e = "0.3",
    sf = {
        wc_pairingDelete: {
            req: {
                ttl: Me.ONE_DAY,
                prompt: !1,
                tag: 1e3
            },
            res: {
                ttl: Me.ONE_DAY,
                prompt: !1,
                tag: 1001
            }
        },
        wc_pairingPing: {
            req: {
                ttl: Me.THIRTY_SECONDS,
                prompt: !1,
                tag: 1002
            },
            res: {
                ttl: Me.THIRTY_SECONDS,
                prompt: !1,
                tag: 1003
            }
        },
        unregistered_method: {
            req: {
                ttl: Me.ONE_DAY,
                prompt: !1,
                tag: 0
            },
            res: {
                ttl: Me.ONE_DAY,
                prompt: !1,
                tag: 0
            }
        }
    },
    Rl = {
        create: "pairing_create",
        expire: "pairing_expire",
        delete: "pairing_delete",
        ping: "pairing_ping"
    },
    Zs = {
        created: "history_created",
        updated: "history_updated",
        deleted: "history_deleted",
        sync: "history_sync"
    },
    m5e = "history",
    y5e = "0.3",
    w5e = "expirer",
    As = {
        created: "expirer_created",
        deleted: "expirer_deleted",
        expired: "expirer_expired",
        sync: "expirer_sync"
    },
    b5e = "0.3",
    v5e = "verify-api",
    x5e = "https://verify.walletconnect.com",
    sL = "https://verify.walletconnect.org",
    Kf = sL,
    E5e = `${Kf}/v3`,
    _5e = [x5e, sL],
    C5e = "echo",
    A5e = "https://echo.walletconnect.com",
    Ka = {
        pairing_started: "pairing_started",
        pairing_uri_validation_success: "pairing_uri_validation_success",
        pairing_uri_not_expired: "pairing_uri_not_expired",
        store_new_pairing: "store_new_pairing",
        subscribing_pairing_topic: "subscribing_pairing_topic",
        subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
        existing_pairing: "existing_pairing",
        pairing_not_expired: "pairing_not_expired",
        emit_inactive_pairing: "emit_inactive_pairing",
        emit_session_proposal: "emit_session_proposal",
        subscribing_to_pairing_topic: "subscribing_to_pairing_topic"
    },
    Po = {
        no_wss_connection: "no_wss_connection",
        no_internet_connection: "no_internet_connection",
        malformed_pairing_uri: "malformed_pairing_uri",
        active_pairing_already_exists: "active_pairing_already_exists",
        subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
        pairing_expired: "pairing_expired",
        proposal_expired: "proposal_expired",
        proposal_listener_not_found: "proposal_listener_not_found"
    },
    Js = {
        session_approve_started: "session_approve_started",
        proposal_not_expired: "proposal_not_expired",
        session_namespaces_validation_success: "session_namespaces_validation_success",
        create_session_topic: "create_session_topic",
        subscribing_session_topic: "subscribing_session_topic",
        subscribe_session_topic_success: "subscribe_session_topic_success",
        publishing_session_approve: "publishing_session_approve",
        session_approve_publish_success: "session_approve_publish_success",
        store_session: "store_session",
        publishing_session_settle: "publishing_session_settle",
        session_settle_publish_success: "session_settle_publish_success"
    },
    Cl = {
        no_internet_connection: "no_internet_connection",
        no_wss_connection: "no_wss_connection",
        proposal_expired: "proposal_expired",
        subscribe_session_topic_failure: "subscribe_session_topic_failure",
        session_approve_publish_failure: "session_approve_publish_failure",
        session_settle_publish_failure: "session_settle_publish_failure",
        session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure",
        proposal_not_found: "proposal_not_found"
    },
    Al = {
        authenticated_session_approve_started: "authenticated_session_approve_started",
        create_authenticated_session_topic: "create_authenticated_session_topic",
        cacaos_verified: "cacaos_verified",
        store_authenticated_session: "store_authenticated_session",
        subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic",
        subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success",
        publishing_authenticated_session_approve: "publishing_authenticated_session_approve"
    },
    af = {
        no_internet_connection: "no_internet_connection",
        invalid_cacao: "invalid_cacao",
        subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure",
        authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure",
        authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found"
    },
    k5e = .1,
    I5e = "event-client",
    $5e = 86400,
    S5e = "https://pulse.walletconnect.org/batch";

function T5e(t, e) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    for (var r = new Uint8Array(256), n = 0; n < r.length; n++) r[n] = 255;
    for (var i = 0; i < t.length; i++) {
        var s = t.charAt(i),
            a = s.charCodeAt(0);
        if (r[a] !== 255) throw new TypeError(s + " is ambiguous");
        r[a] = i
    }
    var o = t.length,
        c = t.charAt(0),
        l = Math.log(o) / Math.log(256),
        u = Math.log(256) / Math.log(o);

    function h(g) {
        if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))), !(g instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (g.length === 0) return "";
        for (var m = 0, y = 0, w = 0, x = g.length; w !== x && g[w] === 0;) w++, m++;
        for (var E = (x - w) * u + 1 >>> 0, _ = new Uint8Array(E); w !== x;) {
            for (var b = g[w], A = 0, I = E - 1;
                (b !== 0 || A < y) && I !== -1; I--, A++) b += 256 * _[I] >>> 0, _[I] = b % o >>> 0, b = b / o >>> 0;
            if (b !== 0) throw new Error("Non-zero carry");
            y = A, w++
        }
        for (var T = E - y; T !== E && _[T] === 0;) T++;
        for (var C = c.repeat(m); T < E; ++T) C += t.charAt(_[T]);
        return C
    }

    function f(g) {
        if (typeof g != "string") throw new TypeError("Expected String");
        if (g.length === 0) return new Uint8Array;
        var m = 0;
        if (g[m] !== " ") {
            for (var y = 0, w = 0; g[m] === c;) y++, m++;
            for (var x = (g.length - m) * l + 1 >>> 0, E = new Uint8Array(x); g[m];) {
                var _ = r[g.charCodeAt(m)];
                if (_ === 255) return;
                for (var b = 0, A = x - 1;
                    (_ !== 0 || b < w) && A !== -1; A--, b++) _ += o * E[A] >>> 0, E[A] = _ % 256 >>> 0, _ = _ / 256 >>> 0;
                if (_ !== 0) throw new Error("Non-zero carry");
                w = b, m++
            }
            if (g[m] !== " ") {
                for (var I = x - w; I !== x && E[I] === 0;) I++;
                for (var T = new Uint8Array(y + (x - I)), C = y; I !== x;) T[C++] = E[I++];
                return T
            }
        }
    }

    function p(g) {
        var m = f(g);
        if (m) return m;
        throw new Error(`Non-${e} character`)
    }
    return {
        encode: h,
        decodeUnsafe: f,
        decode: p
    }
}
var P5e = T5e,
    N5e = P5e;
const aL = t => {
        if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t;
        if (t instanceof ArrayBuffer) return new Uint8Array(t);
        if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
        throw new Error("Unknown type, must be binary type")
    },
    O5e = t => new TextEncoder().encode(t),
    j5e = t => new TextDecoder().decode(t);
let R5e = class {
        constructor(e, r, n) {
            this.name = e, this.prefix = r, this.baseEncode = n
        }
        encode(e) {
            if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
            throw Error("Unknown type, must be binary type")
        }
    },
    M5e = class {
        constructor(e, r, n) {
            if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
            this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n
        }
        decode(e) {
            if (typeof e == "string") {
                if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
                return this.baseDecode(e.slice(this.prefix.length))
            } else throw Error("Can only multibase decode strings")
        }
        or(e) {
            return oL(this, e)
        }
    },
    D5e = class {
        constructor(e) {
            this.decoders = e
        }
        or(e) {
            return oL(this, e)
        }
        decode(e) {
            const r = e[0],
                n = this.decoders[r];
            if (n) return n.decode(e);
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
        }
    };
const oL = (t, e) => new D5e({ ...t.decoders || {
        [t.prefix]: t
    },
    ...e.decoders || {
        [e.prefix]: e
    }
});
let L5e = class {
    constructor(e, r, n, i) {
        this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new R5e(e, r, n), this.decoder = new M5e(e, r, i)
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
};
const Fy = ({
        name: t,
        prefix: e,
        encode: r,
        decode: n
    }) => new L5e(t, e, r, n),
    T0 = ({
        prefix: t,
        name: e,
        alphabet: r
    }) => {
        const {
            encode: n,
            decode: i
        } = N5e(r, e);
        return Fy({
            prefix: t,
            name: e,
            encode: n,
            decode: s => aL(i(s))
        })
    },
    U5e = (t, e, r, n) => {
        const i = {};
        for (let u = 0; u < e.length; ++u) i[e[u]] = u;
        let s = t.length;
        for (; t[s - 1] === "=";) --s;
        const a = new Uint8Array(s * r / 8 | 0);
        let o = 0,
            c = 0,
            l = 0;
        for (let u = 0; u < s; ++u) {
            const h = i[t[u]];
            if (h === void 0) throw new SyntaxError(`Non-${n} character`);
            c = c << r | h, o += r, o >= 8 && (o -= 8, a[l++] = 255 & c >> o)
        }
        if (o >= r || 255 & c << 8 - o) throw new SyntaxError("Unexpected end of data");
        return a
    },
    F5e = (t, e, r) => {
        const n = e[e.length - 1] === "=",
            i = (1 << r) - 1;
        let s = "",
            a = 0,
            o = 0;
        for (let c = 0; c < t.length; ++c)
            for (o = o << 8 | t[c], a += 8; a > r;) a -= r, s += e[i & o >> a];
        if (a && (s += e[i & o << r - a]), n)
            for (; s.length * r & 7;) s += "=";
        return s
    },
    Ln = ({
        name: t,
        prefix: e,
        bitsPerChar: r,
        alphabet: n
    }) => Fy({
        prefix: e,
        name: t,
        encode(i) {
            return F5e(i, n, r)
        },
        decode(i) {
            return U5e(i, n, r, t)
        }
    }),
    B5e = Fy({
        prefix: "\0",
        name: "identity",
        encode: t => j5e(t),
        decode: t => O5e(t)
    });
var W5e = Object.freeze({
    __proto__: null,
    identity: B5e
});
const z5e = Ln({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
});
var q5e = Object.freeze({
    __proto__: null,
    base2: z5e
});
const H5e = Ln({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
});
var V5e = Object.freeze({
    __proto__: null,
    base8: H5e
});
const G5e = T0({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
});
var K5e = Object.freeze({
    __proto__: null,
    base10: G5e
});
const Y5e = Ln({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
    }),
    Z5e = Ln({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
    });
var J5e = Object.freeze({
    __proto__: null,
    base16: Y5e,
    base16upper: Z5e
});
const Q5e = Ln({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
    }),
    X5e = Ln({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
    }),
    e4e = Ln({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
    }),
    t4e = Ln({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
    }),
    r4e = Ln({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
    }),
    n4e = Ln({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
    }),
    i4e = Ln({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
    }),
    s4e = Ln({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
    }),
    a4e = Ln({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
    });
var o4e = Object.freeze({
    __proto__: null,
    base32: Q5e,
    base32upper: X5e,
    base32pad: e4e,
    base32padupper: t4e,
    base32hex: r4e,
    base32hexupper: n4e,
    base32hexpad: i4e,
    base32hexpadupper: s4e,
    base32z: a4e
});
const c4e = T0({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    }),
    l4e = T0({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
var d4e = Object.freeze({
    __proto__: null,
    base36: c4e,
    base36upper: l4e
});
const u4e = T0({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }),
    h4e = T0({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
var f4e = Object.freeze({
    __proto__: null,
    base58btc: u4e,
    base58flickr: h4e
});
const p4e = Ln({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
    }),
    g4e = Ln({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
    }),
    m4e = Ln({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
    }),
    y4e = Ln({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
    });
var w4e = Object.freeze({
    __proto__: null,
    base64: p4e,
    base64pad: g4e,
    base64url: m4e,
    base64urlpad: y4e
});
const cL = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),
    b4e = cL.reduce((t, e, r) => (t[r] = e, t), []),
    v4e = cL.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);

function x4e(t) {
    return t.reduce((e, r) => (e += b4e[r], e), "")
}

function E4e(t) {
    const e = [];
    for (const r of t) {
        const n = v4e[r.codePointAt(0)];
        if (n === void 0) throw new Error(`Non-base256emoji character: ${r}`);
        e.push(n)
    }
    return new Uint8Array(e)
}
const _4e = Fy({
    prefix: "🚀",
    name: "base256emoji",
    encode: x4e,
    decode: E4e
});
var C4e = Object.freeze({
        __proto__: null,
        base256emoji: _4e
    }),
    A4e = lL,
    Ek = 128,
    k4e = -128,
    I4e = Math.pow(2, 31);

function lL(t, e, r) {
    e = e || [], r = r || 0;
    for (var n = r; t >= I4e;) e[r++] = t & 255 | Ek, t /= 128;
    for (; t & k4e;) e[r++] = t & 255 | Ek, t >>>= 7;
    return e[r] = t | 0, lL.bytes = r - n + 1, e
}
var $4e = V5,
    S4e = 128,
    _k = 127;

function V5(t, n) {
    var r = 0,
        n = n || 0,
        i = 0,
        s = n,
        a, o = t.length;
    do {
        if (s >= o) throw V5.bytes = 0, new RangeError("Could not decode varint");
        a = t[s++], r += i < 28 ? (a & _k) << i : (a & _k) * Math.pow(2, i), i += 7
    } while (a >= S4e);
    return V5.bytes = s - n, r
}
var T4e = Math.pow(2, 7),
    P4e = Math.pow(2, 14),
    N4e = Math.pow(2, 21),
    O4e = Math.pow(2, 28),
    j4e = Math.pow(2, 35),
    R4e = Math.pow(2, 42),
    M4e = Math.pow(2, 49),
    D4e = Math.pow(2, 56),
    L4e = Math.pow(2, 63),
    U4e = function(t) {
        return t < T4e ? 1 : t < P4e ? 2 : t < N4e ? 3 : t < O4e ? 4 : t < j4e ? 5 : t < R4e ? 6 : t < M4e ? 7 : t < D4e ? 8 : t < L4e ? 9 : 10
    },
    F4e = {
        encode: A4e,
        decode: $4e,
        encodingLength: U4e
    },
    dL = F4e;
const Ck = (t, e, r = 0) => (dL.encode(t, e, r), e),
    Ak = t => dL.encodingLength(t),
    G5 = (t, e) => {
        const r = e.byteLength,
            n = Ak(t),
            i = n + Ak(r),
            s = new Uint8Array(i + r);
        return Ck(t, s, 0), Ck(r, s, n), s.set(e, i), new B4e(t, r, e, s)
    };
class B4e {
    constructor(e, r, n, i) {
        this.code = e, this.size = r, this.digest = n, this.bytes = i
    }
}
const uL = ({
    name: t,
    code: e,
    encode: r
}) => new W4e(t, e, r);
class W4e {
    constructor(e, r, n) {
        this.name = e, this.code = r, this.encode = n
    }
    digest(e) {
        if (e instanceof Uint8Array) {
            const r = this.encode(e);
            return r instanceof Uint8Array ? G5(this.code, r) : r.then(n => G5(this.code, n))
        } else throw Error("Unknown type, must be binary type")
    }
}
const hL = t => async e => new Uint8Array(await crypto.subtle.digest(t, e)),
    z4e = uL({
        name: "sha2-256",
        code: 18,
        encode: hL("SHA-256")
    }),
    q4e = uL({
        name: "sha2-512",
        code: 19,
        encode: hL("SHA-512")
    });
var H4e = Object.freeze({
    __proto__: null,
    sha256: z4e,
    sha512: q4e
});
const fL = 0,
    V4e = "identity",
    pL = aL,
    G4e = t => G5(fL, pL(t)),
    K4e = {
        code: fL,
        name: V4e,
        encode: pL,
        digest: G4e
    };
var Y4e = Object.freeze({
    __proto__: null,
    identity: K4e
});
new TextEncoder, new TextDecoder;
const kk = { ...W5e,
    ...q5e,
    ...V5e,
    ...K5e,
    ...J5e,
    ...o4e,
    ...d4e,
    ...f4e,
    ...w4e,
    ...C4e
};
({ ...H4e,
    ...Y4e
});

function gL(t) {
    return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t
}

function Z4e(t = 0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? gL(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t)
}

function mL(t, e, r, n) {
    return {
        name: t,
        prefix: e,
        encoder: {
            name: t,
            prefix: e,
            encode: r
        },
        decoder: {
            decode: n
        }
    }
}
const Ik = mL("utf8", "u", t => "u" + new TextDecoder("utf8").decode(t), t => new TextEncoder().encode(t.substring(1))),
    Sb = mL("ascii", "a", t => {
        let e = "a";
        for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
        return e
    }, t => {
        t = t.substring(1);
        const e = Z4e(t.length);
        for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
        return e
    }),
    J4e = {
        utf8: Ik,
        "utf-8": Ik,
        hex: kk.base16,
        latin1: Sb,
        ascii: Sb,
        binary: Sb,
        ...kk
    };

function Q4e(t, e = "utf8") {
    const r = J4e[e];
    if (!r) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? gL(globalThis.Buffer.from(t, "utf-8")) : r.decoder.decode(`${r.prefix}${t}`)
}
var X4e = Object.defineProperty,
    e6e = (t, e, r) => e in t ? X4e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Wa = (t, e, r) => e6e(t, typeof e != "symbol" ? e + "" : e, r);
let t6e = class {
    constructor(e, r) {
        this.core = e, this.logger = r, Wa(this, "keychain", new Map), Wa(this, "name", t5e), Wa(this, "version", r5e), Wa(this, "initialized", !1), Wa(this, "storagePrefix", fo), Wa(this, "init", async () => {
            if (!this.initialized) {
                const n = await this.getKeyChain();
                typeof n < "u" && (this.keychain = n), this.initialized = !0
            }
        }), Wa(this, "has", n => (this.isInitialized(), this.keychain.has(n))), Wa(this, "set", async (n, i) => {
            this.isInitialized(), this.keychain.set(n, i), await this.persist()
        }), Wa(this, "get", n => {
            this.isInitialized();
            const i = this.keychain.get(n);
            if (typeof i > "u") {
                const {
                    message: s
                } = je("NO_MATCHING_KEY", `${this.name}: ${n}`);
                throw new Error(s)
            }
            return i
        }), Wa(this, "del", async n => {
            this.isInitialized(), this.keychain.delete(n), await this.persist()
        }), this.core = e, this.logger = wi(r, this.name)
    }
    get context() {
        return zi(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    async setKeyChain(e) {
        await this.core.storage.setItem(this.storageKey, I5(e))
    }
    async getKeyChain() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? $5(e) : void 0
    }
    async persist() {
        await this.setKeyChain(this.keychain)
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = je("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
};
var r6e = Object.defineProperty,
    n6e = (t, e, r) => e in t ? r6e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    xn = (t, e, r) => n6e(t, typeof e != "symbol" ? e + "" : e, r);
let i6e = class {
    constructor(e, r, n) {
        this.core = e, this.logger = r, xn(this, "name", X3e), xn(this, "keychain"), xn(this, "randomSessionIdentifier", L5()), xn(this, "initialized", !1), xn(this, "init", async () => {
            this.initialized || (await this.keychain.init(), this.initialized = !0)
        }), xn(this, "hasKeys", i => (this.isInitialized(), this.keychain.has(i))), xn(this, "getClientId", async () => {
            this.isInitialized();
            const i = await this.getClientSeed(),
                s = JC(i);
            return WM(s.publicKey)
        }), xn(this, "generateKeyPair", () => {
            this.isInitialized();
            const i = R2e();
            return this.setPrivateKey(i.publicKey, i.privateKey)
        }), xn(this, "signJWT", async i => {
            this.isInitialized();
            const s = await this.getClientSeed(),
                a = JC(s),
                o = this.randomSessionIdentifier;
            return await Sme(o, i, e5e, a)
        }), xn(this, "generateSharedKey", (i, s, a) => {
            this.isInitialized();
            const o = this.getPrivateKey(i),
                c = M2e(o, s);
            return this.setSymKey(c, a)
        }), xn(this, "setSymKey", async (i, s) => {
            this.isInitialized();
            const a = s || em(i);
            return await this.keychain.set(a, i), a
        }), xn(this, "deleteKeyPair", async i => {
            this.isInitialized(), await this.keychain.del(i)
        }), xn(this, "deleteSymKey", async i => {
            this.isInitialized(), await this.keychain.del(i)
        }), xn(this, "encode", async (i, s, a) => {
            this.isInitialized();
            const o = zD(a),
                c = ac(s);
            if (BA(o)) return U2e(c, a == null ? void 0 : a.encoding);
            if (FA(o)) {
                const f = o.senderPublicKey,
                    p = o.receiverPublicKey;
                i = await this.generateSharedKey(f, p)
            }
            const l = this.getSymKey(i),
                {
                    type: u,
                    senderPublicKey: h
                } = o;
            return D2e({
                type: u,
                symKey: l,
                message: c,
                senderPublicKey: h,
                encoding: a == null ? void 0 : a.encoding
            })
        }), xn(this, "decode", async (i, s, a) => {
            this.isInitialized();
            const o = B2e(s, a);
            if (BA(o)) {
                const c = F2e(s, a == null ? void 0 : a.encoding);
                return yd(c)
            }
            if (FA(o)) {
                const c = o.receiverPublicKey,
                    l = o.senderPublicKey;
                i = await this.generateSharedKey(c, l)
            }
            try {
                const c = this.getSymKey(i),
                    l = L2e({
                        symKey: c,
                        encoded: s,
                        encoding: a == null ? void 0 : a.encoding
                    });
                return yd(l)
            } catch (c) {
                this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`), this.logger.error(c)
            }
        }), xn(this, "getPayloadType", (i, s = ga) => {
            const a = Fp({
                encoded: i,
                encoding: s
            });
            return bd(a.type)
        }), xn(this, "getPayloadSenderPublicKey", (i, s = ga) => {
            const a = Fp({
                encoded: i,
                encoding: s
            });
            return a.senderPublicKey ? Li(a.senderPublicKey, fi) : void 0
        }), this.core = e, this.logger = wi(r, this.name), this.keychain = n || new t6e(this.core, this.logger)
    }
    get context() {
        return zi(this.logger)
    }
    async setPrivateKey(e, r) {
        return await this.keychain.set(e, r), e
    }
    getPrivateKey(e) {
        return this.keychain.get(e)
    }
    async getClientSeed() {
        let e = "";
        try {
            e = this.keychain.get(bk)
        } catch {
            e = L5(), await this.keychain.set(bk, e)
        }
        return Q4e(e, "base16")
    }
    getSymKey(e) {
        return this.keychain.get(e)
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = je("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
};
var s6e = Object.defineProperty,
    a6e = Object.defineProperties,
    o6e = Object.getOwnPropertyDescriptors,
    $k = Object.getOwnPropertySymbols,
    c6e = Object.prototype.hasOwnProperty,
    l6e = Object.prototype.propertyIsEnumerable,
    K5 = (t, e, r) => e in t ? s6e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    d6e = (t, e) => {
        for (var r in e || (e = {})) c6e.call(e, r) && K5(t, r, e[r]);
        if ($k)
            for (var r of $k(e)) l6e.call(e, r) && K5(t, r, e[r]);
        return t
    },
    u6e = (t, e) => a6e(t, o6e(e)),
    Hi = (t, e, r) => K5(t, typeof e != "symbol" ? e + "" : e, r);
let h6e = class extends Gve {
    constructor(e, r) {
        super(e, r), this.logger = e, this.core = r, Hi(this, "messages", new Map), Hi(this, "messagesWithoutClientAck", new Map), Hi(this, "name", n5e), Hi(this, "version", i5e), Hi(this, "initialized", !1), Hi(this, "storagePrefix", fo), Hi(this, "init", async () => {
            if (!this.initialized) {
                this.logger.trace("Initialized");
                try {
                    const n = await this.getRelayerMessages();
                    typeof n < "u" && (this.messages = n);
                    const i = await this.getRelayerMessagesWithoutClientAck();
                    typeof i < "u" && (this.messagesWithoutClientAck = i), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                        type: "method",
                        method: "restore",
                        size: this.messages.size
                    })
                } catch (n) {
                    this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(n)
                } finally {
                    this.initialized = !0
                }
            }
        }), Hi(this, "set", async (n, i, s) => {
            this.isInitialized();
            const a = eo(i);
            let o = this.messages.get(n);
            if (typeof o > "u" && (o = {}), typeof o[a] < "u") return a;
            if (o[a] = i, this.messages.set(n, o), s === nm.inbound) {
                const c = this.messagesWithoutClientAck.get(n) || {};
                this.messagesWithoutClientAck.set(n, u6e(d6e({}, c), {
                    [a]: i
                }))
            }
            return await this.persist(), a
        }), Hi(this, "get", n => {
            this.isInitialized();
            let i = this.messages.get(n);
            return typeof i > "u" && (i = {}), i
        }), Hi(this, "getWithoutAck", n => {
            this.isInitialized();
            const i = {};
            for (const s of n) {
                const a = this.messagesWithoutClientAck.get(s) || {};
                i[s] = Object.values(a)
            }
            return i
        }), Hi(this, "has", (n, i) => {
            this.isInitialized();
            const s = this.get(n),
                a = eo(i);
            return typeof s[a] < "u"
        }), Hi(this, "ack", async (n, i) => {
            this.isInitialized();
            const s = this.messagesWithoutClientAck.get(n);
            if (typeof s > "u") return;
            const a = eo(i);
            delete s[a], Object.keys(s).length === 0 ? this.messagesWithoutClientAck.delete(n) : this.messagesWithoutClientAck.set(n, s), await this.persist()
        }), Hi(this, "del", async n => {
            this.isInitialized(), this.messages.delete(n), this.messagesWithoutClientAck.delete(n), await this.persist()
        }), this.logger = wi(e, this.name), this.core = r
    }
    get context() {
        return zi(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get storageKeyWithoutClientAck() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck"
    }
    async setRelayerMessages(e) {
        await this.core.storage.setItem(this.storageKey, I5(e))
    }
    async setRelayerMessagesWithoutClientAck(e) {
        await this.core.storage.setItem(this.storageKeyWithoutClientAck, I5(e))
    }
    async getRelayerMessages() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? $5(e) : void 0
    }
    async getRelayerMessagesWithoutClientAck() {
        const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
        return typeof e < "u" ? $5(e) : void 0
    }
    async persist() {
        await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck)
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = je("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
};
var f6e = Object.defineProperty,
    p6e = Object.defineProperties,
    g6e = Object.getOwnPropertyDescriptors,
    Sk = Object.getOwnPropertySymbols,
    m6e = Object.prototype.hasOwnProperty,
    y6e = Object.prototype.propertyIsEnumerable,
    Y5 = (t, e, r) => e in t ? f6e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    _g = (t, e) => {
        for (var r in e || (e = {})) m6e.call(e, r) && Y5(t, r, e[r]);
        if (Sk)
            for (var r of Sk(e)) y6e.call(e, r) && Y5(t, r, e[r]);
        return t
    },
    Tb = (t, e) => p6e(t, g6e(e)),
    Qs = (t, e, r) => Y5(t, typeof e != "symbol" ? e + "" : e, r);
let w6e = class extends Kve {
    constructor(e, r) {
        super(e, r), this.relayer = e, this.logger = r, Qs(this, "events", new gs.EventEmitter), Qs(this, "name", s5e), Qs(this, "queue", new Map), Qs(this, "publishTimeout", Me.toMiliseconds(Me.ONE_MINUTE)), Qs(this, "initialPublishTimeout", Me.toMiliseconds(Me.ONE_SECOND * 15)), Qs(this, "needsTransportRestart", !1), Qs(this, "publish", async (n, i, s) => {
            var a;
            this.logger.debug("Publishing Payload"), this.logger.trace({
                type: "method",
                method: "publish",
                params: {
                    topic: n,
                    message: i,
                    opts: s
                }
            });
            const o = (s == null ? void 0 : s.ttl) || vk,
                c = t1(s),
                l = (s == null ? void 0 : s.prompt) || !1,
                u = (s == null ? void 0 : s.tag) || 0,
                h = (s == null ? void 0 : s.id) || Gl().toString(),
                f = {
                    topic: n,
                    message: i,
                    opts: {
                        ttl: o,
                        relay: c,
                        prompt: l,
                        tag: u,
                        id: h,
                        attestation: s == null ? void 0 : s.attestation,
                        tvf: s == null ? void 0 : s.tvf
                    }
                },
                p = `Failed to publish payload, please try again. id:${h} tag:${u}`;
            try {
                const g = new Promise(async m => {
                    const y = ({
                        id: x
                    }) => {
                        f.opts.id === x && (this.removeRequestFromQueue(x), this.relayer.events.removeListener(mn.publish, y), m(f))
                    };
                    this.relayer.events.on(mn.publish, y);
                    const w = Yc(new Promise((x, E) => {
                        this.rpcPublish({
                            topic: n,
                            message: i,
                            ttl: o,
                            prompt: l,
                            tag: u,
                            id: h,
                            attestation: s == null ? void 0 : s.attestation,
                            tvf: s == null ? void 0 : s.tvf
                        }).then(x).catch(_ => {
                            this.logger.warn(_, _ == null ? void 0 : _.message), E(_)
                        })
                    }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${h} tag:${u}`);
                    try {
                        await w, this.events.removeListener(mn.publish, y)
                    } catch (x) {
                        this.queue.set(h, Tb(_g({}, f), {
                            attempt: 1
                        })), this.logger.warn(x, x == null ? void 0 : x.message)
                    }
                });
                this.logger.trace({
                    type: "method",
                    method: "publish",
                    params: {
                        id: h,
                        topic: n,
                        message: i,
                        opts: s
                    }
                }), await Yc(g, this.publishTimeout, p)
            } catch (g) {
                if (this.logger.debug("Failed to Publish Payload"), this.logger.error(g), (a = s == null ? void 0 : s.internal) != null && a.throwOnFailedPublish) throw g
            } finally {
                this.queue.delete(h)
            }
        }), Qs(this, "on", (n, i) => {
            this.events.on(n, i)
        }), Qs(this, "once", (n, i) => {
            this.events.once(n, i)
        }), Qs(this, "off", (n, i) => {
            this.events.off(n, i)
        }), Qs(this, "removeListener", (n, i) => {
            this.events.removeListener(n, i)
        }), this.relayer = e, this.logger = wi(r, this.name), this.registerEventListeners()
    }
    get context() {
        return zi(this.logger)
    }
    async rpcPublish(e) {
        var r, n, i, s;
        const {
            topic: a,
            message: o,
            ttl: c = vk,
            prompt: l,
            tag: u,
            id: h,
            attestation: f,
            tvf: p
        } = e, g = {
            method: Sf(t1().protocol).publish,
            params: _g({
                topic: a,
                message: o,
                ttl: c,
                prompt: l,
                tag: u,
                attestation: f
            }, p),
            id: h
        };
        $n((r = g.params) == null ? void 0 : r.prompt) && ((n = g.params) == null || delete n.prompt), $n((i = g.params) == null ? void 0 : i.tag) && ((s = g.params) == null || delete s.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "message",
            direction: "outgoing",
            request: g
        });
        const m = await this.relayer.request(g);
        return this.relayer.events.emit(mn.publish, e), this.logger.debug("Successfully Published Payload"), m
    }
    removeRequestFromQueue(e) {
        this.queue.delete(e)
    }
    checkQueue() {
        this.queue.forEach(async (e, r) => {
            const n = e.attempt + 1;
            this.queue.set(r, Tb(_g({}, e), {
                attempt: n
            }));
            const {
                topic: i,
                message: s,
                opts: a,
                attestation: o
            } = e;
            this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${n}`), await this.rpcPublish(Tb(_g({}, e), {
                topic: i,
                message: s,
                ttl: a.ttl,
                prompt: a.prompt,
                tag: a.tag,
                id: a.id,
                attestation: o,
                tvf: a.tvf
            })), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`)
        })
    }
    registerEventListeners() {
        this.relayer.core.heartbeat.on(jd.pulse, () => {
            if (this.needsTransportRestart) {
                this.needsTransportRestart = !1, this.relayer.events.emit(mn.connection_stalled);
                return
            }
            this.checkQueue()
        }), this.relayer.on(mn.message_ack, e => {
            this.removeRequestFromQueue(e.id.toString())
        })
    }
};
var b6e = Object.defineProperty,
    v6e = (t, e, r) => e in t ? b6e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    au = (t, e, r) => v6e(t, typeof e != "symbol" ? e + "" : e, r);
class x6e {
    constructor() {
        au(this, "map", new Map), au(this, "set", (e, r) => {
            const n = this.get(e);
            this.exists(e, r) || this.map.set(e, [...n, r])
        }), au(this, "get", e => this.map.get(e) || []), au(this, "exists", (e, r) => this.get(e).includes(r)), au(this, "delete", (e, r) => {
            if (typeof r > "u") {
                this.map.delete(e);
                return
            }
            if (!this.map.has(e)) return;
            const n = this.get(e);
            if (!this.exists(e, r)) return;
            const i = n.filter(s => s !== r);
            if (!i.length) {
                this.map.delete(e);
                return
            }
            this.map.set(e, i)
        }), au(this, "clear", () => {
            this.map.clear()
        })
    }
    get topics() {
        return Array.from(this.map.keys())
    }
}
var E6e = Object.defineProperty,
    _6e = Object.defineProperties,
    C6e = Object.getOwnPropertyDescriptors,
    Tk = Object.getOwnPropertySymbols,
    A6e = Object.prototype.hasOwnProperty,
    k6e = Object.prototype.propertyIsEnumerable,
    Z5 = (t, e, r) => e in t ? E6e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    of = (t, e) => {
        for (var r in e || (e = {})) A6e.call(e, r) && Z5(t, r, e[r]);
        if (Tk)
            for (var r of Tk(e)) k6e.call(e, r) && Z5(t, r, e[r]);
        return t
    },
    Pb = (t, e) => _6e(t, C6e(e)),
    fr = (t, e, r) => Z5(t, typeof e != "symbol" ? e + "" : e, r);
let I6e = class extends Jve {
    constructor(e, r) {
        super(e, r), this.relayer = e, this.logger = r, fr(this, "subscriptions", new Map), fr(this, "topicMap", new x6e), fr(this, "events", new gs.EventEmitter), fr(this, "name", h5e), fr(this, "version", f5e), fr(this, "pending", new Map), fr(this, "cached", []), fr(this, "initialized", !1), fr(this, "storagePrefix", fo), fr(this, "subscribeTimeout", Me.toMiliseconds(Me.ONE_MINUTE)), fr(this, "initialSubscribeTimeout", Me.toMiliseconds(Me.ONE_SECOND * 15)), fr(this, "clientId"), fr(this, "batchSubscribeTopicsLimit", 500), fr(this, "init", async () => {
            this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = !0
        }), fr(this, "subscribe", async (n, i) => {
            this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({
                type: "method",
                method: "subscribe",
                params: {
                    topic: n,
                    opts: i
                }
            });
            try {
                const s = t1(i),
                    a = {
                        topic: n,
                        relay: s,
                        transportType: i == null ? void 0 : i.transportType
                    };
                this.pending.set(n, a);
                const o = await this.rpcSubscribe(n, s, i);
                return typeof o == "string" && (this.onSubscribe(o, a), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({
                    type: "method",
                    method: "subscribe",
                    params: {
                        topic: n,
                        opts: i
                    }
                })), o
            } catch (s) {
                throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(s), s
            }
        }), fr(this, "unsubscribe", async (n, i) => {
            this.isInitialized(), typeof(i == null ? void 0 : i.id) < "u" ? await this.unsubscribeById(n, i.id, i) : await this.unsubscribeByTopic(n, i)
        }), fr(this, "isSubscribed", n => new Promise(i => {
            i(this.topicMap.topics.includes(n))
        })), fr(this, "isKnownTopic", n => new Promise(i => {
            i(this.topicMap.topics.includes(n) || this.pending.has(n) || this.cached.some(s => s.topic === n))
        })), fr(this, "on", (n, i) => {
            this.events.on(n, i)
        }), fr(this, "once", (n, i) => {
            this.events.once(n, i)
        }), fr(this, "off", (n, i) => {
            this.events.off(n, i)
        }), fr(this, "removeListener", (n, i) => {
            this.events.removeListener(n, i)
        }), fr(this, "start", async () => {
            await this.onConnect()
        }), fr(this, "stop", async () => {
            await this.onDisconnect()
        }), fr(this, "restart", async () => {
            await this.restore(), await this.onRestart()
        }), fr(this, "checkPending", async () => {
            if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
            const n = [];
            this.pending.forEach(i => {
                n.push(i)
            }), await this.batchSubscribe(n)
        }), fr(this, "registerEventListeners", () => {
            this.relayer.core.heartbeat.on(jd.pulse, async () => {
                await this.checkPending()
            }), this.events.on(Ki.created, async n => {
                const i = Ki.created;
                this.logger.info(`Emitting ${i}`), this.logger.debug({
                    type: "event",
                    event: i,
                    data: n
                }), await this.persist()
            }), this.events.on(Ki.deleted, async n => {
                const i = Ki.deleted;
                this.logger.info(`Emitting ${i}`), this.logger.debug({
                    type: "event",
                    event: i,
                    data: n
                }), await this.persist()
            })
        }), this.relayer = e, this.logger = wi(r, this.name), this.clientId = ""
    }
    get context() {
        return zi(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.subscriptions.size
    }
    get ids() {
        return Array.from(this.subscriptions.keys())
    }
    get values() {
        return Array.from(this.subscriptions.values())
    }
    get topics() {
        return this.topicMap.topics
    }
    get hasAnyTopics() {
        return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0
    }
    hasSubscription(e, r) {
        let n = !1;
        try {
            n = this.getSubscription(e).topic === r
        } catch {}
        return n
    }
    reset() {
        this.cached = [], this.initialized = !0
    }
    onDisable() {
        this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear()
    }
    async unsubscribeByTopic(e, r) {
        const n = this.topicMap.get(e);
        await Promise.all(n.map(async i => await this.unsubscribeById(e, i, r)))
    }
    async unsubscribeById(e, r, n) {
        this.logger.debug("Unsubscribing Topic"), this.logger.trace({
            type: "method",
            method: "unsubscribe",
            params: {
                topic: e,
                id: r,
                opts: n
            }
        });
        try {
            const i = t1(n);
            await this.restartToComplete({
                topic: e,
                id: r,
                relay: i
            }), await this.rpcUnsubscribe(e, r, i);
            const s = _r("USER_DISCONNECTED", `${this.name}, ${e}`);
            await this.onUnsubscribe(e, r, s), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({
                type: "method",
                method: "unsubscribe",
                params: {
                    topic: e,
                    id: r,
                    opts: n
                }
            })
        } catch (i) {
            throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i), i
        }
    }
    async rpcSubscribe(e, r, n) {
        var i;
        (!n || (n == null ? void 0 : n.transportType) === Er.relay) && await this.restartToComplete({
            topic: e,
            id: e,
            relay: r
        });
        const s = {
            method: Sf(r.protocol).subscribe,
            params: {
                topic: e
            }
        };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: s
        });
        const a = (i = n == null ? void 0 : n.internal) == null ? void 0 : i.throwOnFailedPublish;
        try {
            const o = await this.getSubscriptionId(e);
            if ((n == null ? void 0 : n.transportType) === Er.link_mode) return setTimeout(() => {
                (this.relayer.connected || this.relayer.connecting) && this.relayer.request(s).catch(u => this.logger.warn(u))
            }, Me.toMiliseconds(Me.ONE_SECOND)), o;
            const c = new Promise(async u => {
                    const h = f => {
                        f.topic === e && (this.events.removeListener(Ki.created, h), u(f.id))
                    };
                    this.events.on(Ki.created, h);
                    try {
                        const f = await Yc(new Promise((p, g) => {
                            this.relayer.request(s).catch(m => {
                                this.logger.warn(m, m == null ? void 0 : m.message), g(m)
                            }).then(p)
                        }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
                        this.events.removeListener(Ki.created, h), u(f)
                    } catch {}
                }),
                l = await Yc(c, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
            if (!l && a) throw new Error(`Subscribing to ${e} failed, please try again`);
            return l ? o : null
        } catch (o) {
            if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(mn.connection_stalled), a) throw o
        }
        return null
    }
    async rpcBatchSubscribe(e) {
        if (!e.length) return;
        const r = e[0].relay,
            n = {
                method: Sf(r.protocol).batchSubscribe,
                params: {
                    topics: e.map(i => i.topic)
                }
            };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: n
        });
        try {
            await await Yc(new Promise(i => {
                this.relayer.request(n).catch(s => this.logger.warn(s)).then(i)
            }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again")
        } catch {
            this.relayer.events.emit(mn.connection_stalled)
        }
    }
    async rpcBatchFetchMessages(e) {
        if (!e.length) return;
        const r = e[0].relay,
            n = {
                method: Sf(r.protocol).batchFetchMessages,
                params: {
                    topics: e.map(s => s.topic)
                }
            };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: n
        });
        let i;
        try {
            i = await await Yc(new Promise((s, a) => {
                this.relayer.request(n).catch(o => {
                    this.logger.warn(o), a(o)
                }).then(s)
            }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again")
        } catch {
            this.relayer.events.emit(mn.connection_stalled)
        }
        return i
    }
    rpcUnsubscribe(e, r, n) {
        const i = {
            method: Sf(n.protocol).unsubscribe,
            params: {
                topic: e,
                id: r
            }
        };
        return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: i
        }), this.relayer.request(i)
    }
    onSubscribe(e, r) {
        this.setSubscription(e, Pb( of ({}, r), {
            id: e
        })), this.pending.delete(r.topic)
    }
    onBatchSubscribe(e) {
        e.length && e.forEach(r => {
            this.setSubscription(r.id, of ({}, r)), this.pending.delete(r.topic)
        })
    }
    async onUnsubscribe(e, r, n) {
        this.events.removeAllListeners(r), this.hasSubscription(r, e) && this.deleteSubscription(r, n), await this.relayer.messages.del(e)
    }
    async setRelayerSubscriptions(e) {
        await this.relayer.core.storage.setItem(this.storageKey, e)
    }
    async getRelayerSubscriptions() {
        return await this.relayer.core.storage.getItem(this.storageKey)
    }
    setSubscription(e, r) {
        this.logger.debug("Setting subscription"), this.logger.trace({
            type: "method",
            method: "setSubscription",
            id: e,
            subscription: r
        }), this.addSubscription(e, r)
    }
    addSubscription(e, r) {
        this.subscriptions.set(e, of ({}, r)), this.topicMap.set(r.topic, e), this.events.emit(Ki.created, r)
    }
    getSubscription(e) {
        this.logger.debug("Getting subscription"), this.logger.trace({
            type: "method",
            method: "getSubscription",
            id: e
        });
        const r = this.subscriptions.get(e);
        if (!r) {
            const {
                message: n
            } = je("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw new Error(n)
        }
        return r
    }
    deleteSubscription(e, r) {
        this.logger.debug("Deleting subscription"), this.logger.trace({
            type: "method",
            method: "deleteSubscription",
            id: e,
            reason: r
        });
        const n = this.getSubscription(e);
        this.subscriptions.delete(e), this.topicMap.delete(n.topic, e), this.events.emit(Ki.deleted, Pb( of ({}, n), {
            reason: r
        }))
    }
    async persist() {
        await this.setRelayerSubscriptions(this.values), this.events.emit(Ki.sync)
    }
    async onRestart() {
        if (this.cached.length) {
            const e = [...this.cached],
                r = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
            for (let n = 0; n < r; n++) {
                const i = e.splice(0, this.batchSubscribeTopicsLimit);
                await this.batchSubscribe(i)
            }
        }
        this.events.emit(Ki.resubscribed)
    }
    async restore() {
        try {
            const e = await this.getRelayerSubscriptions();
            if (typeof e > "u" || !e.length) return;
            if (this.subscriptions.size) {
                const {
                    message: r
                } = je("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(r), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(r)
            }
            this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                subscriptions: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e)
        }
    }
    async batchSubscribe(e) {
        e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async r => Pb( of ({}, r), {
            id: await this.getSubscriptionId(r.topic)
        })))))
    }
    async batchFetchMessages(e) {
        if (!e.length) return;
        this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
        const r = await this.rpcBatchFetchMessages(e);
        r && r.messages && (await nye(Me.toMiliseconds(Me.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(r.messages))
    }
    async onConnect() {
        await this.restart(), this.reset()
    }
    onDisconnect() {
        this.onDisable()
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = je("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    async restartToComplete(e) {
        !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen())
    }
    async getClientId() {
        return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId
    }
    async getSubscriptionId(e) {
        return eo(e + await this.getClientId())
    }
};
var $6e = Object.defineProperty,
    Pk = Object.getOwnPropertySymbols,
    S6e = Object.prototype.hasOwnProperty,
    T6e = Object.prototype.propertyIsEnumerable,
    J5 = (t, e, r) => e in t ? $6e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Nk = (t, e) => {
        for (var r in e || (e = {})) S6e.call(e, r) && J5(t, r, e[r]);
        if (Pk)
            for (var r of Pk(e)) T6e.call(e, r) && J5(t, r, e[r]);
        return t
    },
    Jt = (t, e, r) => J5(t, typeof e != "symbol" ? e + "" : e, r);
let P6e = class extends Yve {
    constructor(e) {
        super(e), Jt(this, "protocol", "wc"), Jt(this, "version", 2), Jt(this, "core"), Jt(this, "logger"), Jt(this, "events", new gs.EventEmitter), Jt(this, "provider"), Jt(this, "messages"), Jt(this, "subscriber"), Jt(this, "publisher"), Jt(this, "name", o5e), Jt(this, "transportExplicitlyClosed", !1), Jt(this, "initialized", !1), Jt(this, "connectionAttemptInProgress", !1), Jt(this, "relayUrl"), Jt(this, "projectId"), Jt(this, "packageName"), Jt(this, "bundleId"), Jt(this, "hasExperiencedNetworkDisruption", !1), Jt(this, "pingTimeout"), Jt(this, "heartBeatTimeout", Me.toMiliseconds(Me.THIRTY_SECONDS + Me.FIVE_SECONDS)), Jt(this, "reconnectTimeout"), Jt(this, "connectPromise"), Jt(this, "reconnectInProgress", !1), Jt(this, "requestsInFlight", []), Jt(this, "connectTimeout", Me.toMiliseconds(Me.ONE_SECOND * 15)), Jt(this, "request", async r => {
            var n, i;
            this.logger.debug("Publishing Request Payload");
            const s = r.id || Gl().toString();
            await this.toEstablishConnection();
            try {
                this.logger.trace({
                    id: s,
                    method: r.method,
                    topic: (n = r.params) == null ? void 0 : n.topic
                }, "relayer.request - publishing...");
                const a = `${s}:${((i=r.params)==null?void 0:i.tag)||""}`;
                this.requestsInFlight.push(a);
                const o = await this.provider.request(r);
                return this.requestsInFlight = this.requestsInFlight.filter(c => c !== a), o
            } catch (a) {
                throw this.logger.debug(`Failed to Publish Request: ${s}`), a
            }
        }), Jt(this, "resetPingTimeout", () => {
            Jm() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
                var r, n, i, s;
                try {
                    this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (s = (i = (n = (r = this.provider) == null ? void 0 : r.connection) == null ? void 0 : n.socket) == null ? void 0 : i.terminate) == null || s.call(i)
                } catch (a) {
                    this.logger.warn(a, a == null ? void 0 : a.message)
                }
            }, this.heartBeatTimeout))
        }), Jt(this, "onPayloadHandler", r => {
            this.onProviderPayload(r), this.resetPingTimeout()
        }), Jt(this, "onConnectHandler", () => {
            this.logger.warn({}, "Relayer connected 🛜"), this.startPingTimeout(), this.events.emit(mn.connect)
        }), Jt(this, "onDisconnectHandler", () => {
            this.logger.warn({}, "Relayer disconnected 🛑"), this.requestsInFlight = [], this.onProviderDisconnect()
        }), Jt(this, "onProviderErrorHandler", r => {
            this.logger.fatal(`Fatal socket error: ${r.message}`), this.events.emit(mn.error, r), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose()
        }), Jt(this, "registerProviderListeners", () => {
            this.provider.on(vs.payload, this.onPayloadHandler), this.provider.on(vs.connect, this.onConnectHandler), this.provider.on(vs.disconnect, this.onDisconnectHandler), this.provider.on(vs.error, this.onProviderErrorHandler)
        }), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? wi(e.logger, this.name) : $0(My({
            level: e.logger || a5e
        })), this.messages = new h6e(this.logger, e.core), this.subscriber = new I6e(this, this.logger), this.publisher = new w6e(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || iL, this.projectId = e.projectId, B1e() ? this.packageName = cA() : W1e() && (this.bundleId = cA()), this.provider = {}
    }
    async init() {
        this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.transportOpen().catch(e => this.logger.warn(e, e == null ? void 0 : e.message))
    }
    get context() {
        return zi(this.logger)
    }
    get connected() {
        var e, r, n;
        return ((n = (r = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : r.socket) == null ? void 0 : n.readyState) === 1 || !1
    }
    get connecting() {
        var e, r, n;
        return ((n = (r = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : r.socket) == null ? void 0 : n.readyState) === 0 || this.connectPromise !== void 0 || !1
    }
    async publish(e, r, n) {
        this.isInitialized(), await this.publisher.publish(e, r, n), await this.recordMessageEvent({
            topic: e,
            message: r,
            publishedAt: Date.now(),
            transportType: Er.relay
        }, nm.outbound)
    }
    async subscribe(e, r) {
        var n, i, s;
        this.isInitialized(), (!(r != null && r.transportType) || (r == null ? void 0 : r.transportType) === "relay") && await this.toEstablishConnection();
        const a = typeof((n = r == null ? void 0 : r.internal) == null ? void 0 : n.throwOnFailedPublish) > "u" ? !0 : (i = r == null ? void 0 : r.internal) == null ? void 0 : i.throwOnFailedPublish;
        let o = ((s = this.subscriber.topicMap.get(e)) == null ? void 0 : s[0]) || "",
            c;
        const l = u => {
            u.topic === e && (this.subscriber.off(Ki.created, l), c())
        };
        return await Promise.all([new Promise(u => {
            c = u, this.subscriber.on(Ki.created, l)
        }), new Promise(async (u, h) => {
            o = await this.subscriber.subscribe(e, Nk({
                internal: {
                    throwOnFailedPublish: a
                }
            }, r)).catch(f => {
                a && h(f)
            }) || o, u()
        })]), o
    }
    async unsubscribe(e, r) {
        this.isInitialized(), await this.subscriber.unsubscribe(e, r)
    }
    on(e, r) {
        this.events.on(e, r)
    }
    once(e, r) {
        this.events.once(e, r)
    }
    off(e, r) {
        this.events.off(e, r)
    }
    removeListener(e, r) {
        this.events.removeListener(e, r)
    }
    async transportDisconnect() {
        this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await Yc(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect()
    }
    async transportClose() {
        this.transportExplicitlyClosed = !0, await this.transportDisconnect()
    }
    async transportOpen(e) {
        if (!this.subscriber.hasAnyTopics) {
            this.logger.info("Starting WS connection skipped because the client has no topics to work with.");
            return
        }
        if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (r, n) => {
                await this.connect(e).then(r).catch(n).finally(() => {
                    this.connectPromise = void 0
                })
            }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`)
    }
    async restartTransport(e) {
        this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen())
    }
    async confirmOnlineStateOrThrow() {
        if (!await QA()) throw new Error("No internet connection detected. Please restart your network and try again.")
    }
    async handleBatchMessageEvents(e) {
        if ((e == null ? void 0 : e.length) === 0) {
            this.logger.trace("Batch message events is empty. Ignoring...");
            return
        }
        const r = e.sort((n, i) => n.publishedAt - i.publishedAt);
        this.logger.debug(`Batch of ${r.length} message events sorted`);
        for (const n of r) try {
            await this.onMessageEvent(n)
        } catch (i) {
            this.logger.warn(i, "Error while processing batch message event: " + (i == null ? void 0 : i.message))
        }
        this.logger.trace(`Batch of ${r.length} message events processed`)
    }
    async onLinkMessageEvent(e, r) {
        const {
            topic: n
        } = e;
        if (!r.sessionExists) {
            const i = an(Me.FIVE_MINUTES),
                s = {
                    topic: n,
                    expiry: i,
                    relay: {
                        protocol: "irn"
                    },
                    active: !1
                };
            await this.core.pairing.pairings.set(n, s)
        }
        this.events.emit(mn.message, e), await this.recordMessageEvent(e, nm.inbound)
    }
    async connect(e) {
        await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
        let r = 1;
        for (; r < 6;) {
            try {
                if (this.transportExplicitlyClosed) break;
                this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${r}...`), await this.createProvider(), await new Promise(async (n, i) => {
                    const s = () => {
                        i(new Error("Connection interrupted while trying to connect"))
                    };
                    this.provider.once(vs.disconnect, s), await Yc(new Promise((a, o) => {
                        this.provider.connect().then(a).catch(o)
                    }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch(a => {
                        i(a)
                    }).finally(() => {
                        this.provider.off(vs.disconnect, s), clearTimeout(this.reconnectTimeout)
                    }), await new Promise(async (a, o) => {
                        const c = () => {
                            i(new Error("Connection interrupted while trying to subscribe"))
                        };
                        this.provider.once(vs.disconnect, c), await this.subscriber.start().then(a).catch(o).finally(() => {
                            this.provider.off(vs.disconnect, c)
                        })
                    }), this.hasExperiencedNetworkDisruption = !1, n()
                })
            } catch (n) {
                await this.subscriber.stop();
                const i = n;
                this.logger.warn({}, i.message), this.hasExperiencedNetworkDisruption = !0
            } finally {
                this.connectionAttemptInProgress = !1
            }
            if (this.connected) {
                this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${r}`);
                break
            }
            await new Promise(n => setTimeout(n, Me.toMiliseconds(r * 1))), r++
        }
    }
    startPingTimeout() {
        var e, r, n, i, s;
        if (Jm()) try {
            (r = (e = this.provider) == null ? void 0 : e.connection) != null && r.socket && ((s = (i = (n = this.provider) == null ? void 0 : n.connection) == null ? void 0 : i.socket) == null || s.on("ping", () => {
                this.resetPingTimeout()
            })), this.resetPingTimeout()
        } catch (a) {
            this.logger.warn(a, a == null ? void 0 : a.message)
        }
    }
    async createProvider() {
        this.provider.connection && this.unregisterProviderListeners();
        const e = await this.core.crypto.signJWT(this.relayUrl);
        this.provider = new Hs(new Y3e(G1e({
            sdkVersion: H5,
            protocol: this.protocol,
            version: this.version,
            relayUrl: this.relayUrl,
            projectId: this.projectId,
            auth: e,
            useOnCloseEvent: !0,
            bundleId: this.bundleId,
            packageName: this.packageName
        }))), this.registerProviderListeners()
    }
    async recordMessageEvent(e, r) {
        const {
            topic: n,
            message: i
        } = e;
        await this.messages.set(n, i, r)
    }
    async shouldIgnoreMessageEvent(e) {
        const {
            topic: r,
            message: n
        } = e;
        if (!n || n.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${n}`), !0;
        if (!await this.subscriber.isKnownTopic(r)) return this.logger.warn(`Ignoring message for unknown topic ${r}`), !0;
        const i = this.messages.has(r, n);
        return i && this.logger.warn(`Ignoring duplicate message: ${n}`), i
    }
    async onProviderPayload(e) {
        if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({
                type: "payload",
                direction: "incoming",
                payload: e
            }), Xx(e)) {
            if (!e.method.endsWith(c5e)) return;
            const r = e.params,
                {
                    topic: n,
                    message: i,
                    publishedAt: s,
                    attestation: a
                } = r.data,
                o = {
                    topic: n,
                    message: i,
                    publishedAt: s,
                    transportType: Er.relay,
                    attestation: a
                };
            this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Nk({
                type: "event",
                event: r.id
            }, o)), this.events.emit(r.id, o), await this.acknowledgePayload(e), await this.onMessageEvent(o)
        } else Uy(e) && this.events.emit(mn.message_ack, e)
    }
    async onMessageEvent(e) {
        await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, nm.inbound), this.events.emit(mn.message, e))
    }
    async acknowledgePayload(e) {
        const r = Dy(e.id, !0);
        await this.provider.connection.send(r)
    }
    unregisterProviderListeners() {
        this.provider.off(vs.payload, this.onPayloadHandler), this.provider.off(vs.connect, this.onConnectHandler), this.provider.off(vs.disconnect, this.onDisconnectHandler), this.provider.off(vs.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout)
    }
    async registerEventListeners() {
        let e = await QA();
        jbe(async r => {
            e !== r && (e = r, r ? await this.transportOpen().catch(n => this.logger.error(n, n == null ? void 0 : n.message)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1))
        }), this.core.heartbeat.on(jd.pulse, async () => {
            if (!this.transportExplicitlyClosed && !this.connected && Dbe()) try {
                await this.confirmOnlineStateOrThrow(), await this.transportOpen()
            } catch (r) {
                this.logger.warn(r, r == null ? void 0 : r.message)
            }
        })
    }
    async onProviderDisconnect() {
        clearTimeout(this.pingTimeout), this.events.emit(mn.disconnect), this.connectionAttemptInProgress = !1, !this.reconnectInProgress && (this.reconnectInProgress = !0, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
            await this.transportOpen().catch(e => this.logger.error(e, e == null ? void 0 : e.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = !1
        }, Me.toMiliseconds(l5e)))))
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = je("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    async toEstablishConnection() {
        if (await this.confirmOnlineStateOrThrow(), !this.connected) {
            if (this.connectPromise) {
                await this.connectPromise;
                return
            }
            await this.connect()
        }
    }
};

function N6e(t, e) {
    return t === e || Number.isNaN(t) && Number.isNaN(e)
}

function Ok(t) {
    return Object.getOwnPropertySymbols(t).filter(e => Object.prototype.propertyIsEnumerable.call(t, e))
}

function jk(t) {
    return t == null ? t === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(t)
}
const O6e = "[object RegExp]",
    j6e = "[object String]",
    R6e = "[object Number]",
    M6e = "[object Boolean]",
    Rk = "[object Arguments]",
    D6e = "[object Symbol]",
    L6e = "[object Date]",
    U6e = "[object Map]",
    F6e = "[object Set]",
    B6e = "[object Array]",
    W6e = "[object Function]",
    z6e = "[object ArrayBuffer]",
    Nb = "[object Object]",
    q6e = "[object Error]",
    H6e = "[object DataView]",
    V6e = "[object Uint8Array]",
    G6e = "[object Uint8ClampedArray]",
    K6e = "[object Uint16Array]",
    Y6e = "[object Uint32Array]",
    Z6e = "[object BigUint64Array]",
    J6e = "[object Int8Array]",
    Q6e = "[object Int16Array]",
    X6e = "[object Int32Array]",
    exe = "[object BigInt64Array]",
    txe = "[object Float32Array]",
    rxe = "[object Float64Array]";

function nxe() {}

function Mk(t) {
    if (!t || typeof t != "object") return !1;
    const e = Object.getPrototypeOf(t);
    return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(t) === "[object Object]" : !1
}

function ixe(t, e, r) {
    return Tf(t, e, void 0, void 0, void 0, void 0, r)
}

function Tf(t, e, r, n, i, s, a) {
    const o = a(t, e, r, n, i, s);
    if (o !== void 0) return o;
    if (typeof t == typeof e) switch (typeof t) {
        case "bigint":
        case "string":
        case "boolean":
        case "symbol":
        case "undefined":
            return t === e;
        case "number":
            return t === e || Object.is(t, e);
        case "function":
            return t === e;
        case "object":
            return Yf(t, e, s, a)
    }
    return Yf(t, e, s, a)
}

function Yf(t, e, r, n) {
    if (Object.is(t, e)) return !0;
    let i = jk(t),
        s = jk(e);
    if (i === Rk && (i = Nb), s === Rk && (s = Nb), i !== s) return !1;
    switch (i) {
        case j6e:
            return t.toString() === e.toString();
        case R6e:
            {
                const c = t.valueOf(),
                    l = e.valueOf();
                return N6e(c, l)
            }
        case M6e:
        case L6e:
        case D6e:
            return Object.is(t.valueOf(), e.valueOf());
        case O6e:
            return t.source === e.source && t.flags === e.flags;
        case W6e:
            return t === e
    }
    r = r ? ? new Map;
    const a = r.get(t),
        o = r.get(e);
    if (a != null && o != null) return a === e;
    r.set(t, e), r.set(e, t);
    try {
        switch (i) {
            case U6e:
                {
                    if (t.size !== e.size) return !1;
                    for (const [c, l] of t.entries())
                        if (!e.has(c) || !Tf(l, e.get(c), c, t, e, r, n)) return !1;
                    return !0
                }
            case F6e:
                {
                    if (t.size !== e.size) return !1;
                    const c = Array.from(t.values()),
                        l = Array.from(e.values());
                    for (let u = 0; u < c.length; u++) {
                        const h = c[u],
                            f = l.findIndex(p => Tf(h, p, void 0, t, e, r, n));
                        if (f === -1) return !1;
                        l.splice(f, 1)
                    }
                    return !0
                }
            case B6e:
            case V6e:
            case G6e:
            case K6e:
            case Y6e:
            case Z6e:
            case J6e:
            case Q6e:
            case X6e:
            case exe:
            case txe:
            case rxe:
                {
                    if (typeof Ve < "u" && Ve.isBuffer(t) !== Ve.isBuffer(e) || t.length !== e.length) return !1;
                    for (let c = 0; c < t.length; c++)
                        if (!Tf(t[c], e[c], c, t, e, r, n)) return !1;
                    return !0
                }
            case z6e:
                return t.byteLength !== e.byteLength ? !1 : Yf(new Uint8Array(t), new Uint8Array(e), r, n);
            case H6e:
                return t.byteLength !== e.byteLength || t.byteOffset !== e.byteOffset ? !1 : Yf(new Uint8Array(t), new Uint8Array(e), r, n);
            case q6e:
                return t.name === e.name && t.message === e.message;
            case Nb:
                {
                    if (!(Yf(t.constructor, e.constructor, r, n) || Mk(t) && Mk(e))) return !1;
                    const c = [...Object.keys(t), ...Ok(t)],
                        l = [...Object.keys(e), ...Ok(e)];
                    if (c.length !== l.length) return !1;
                    for (let u = 0; u < c.length; u++) {
                        const h = c[u],
                            f = t[h];
                        if (!Object.hasOwn(e, h)) return !1;
                        const p = e[h];
                        if (!Tf(f, p, h, t, e, r, n)) return !1
                    }
                    return !0
                }
            default:
                return !1
        }
    } finally {
        r.delete(t), r.delete(e)
    }
}

function sxe(t, e) {
    return ixe(t, e, nxe)
}
var axe = Object.defineProperty,
    Dk = Object.getOwnPropertySymbols,
    oxe = Object.prototype.hasOwnProperty,
    cxe = Object.prototype.propertyIsEnumerable,
    Q5 = (t, e, r) => e in t ? axe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Lk = (t, e) => {
        for (var r in e || (e = {})) oxe.call(e, r) && Q5(t, r, e[r]);
        if (Dk)
            for (var r of Dk(e)) cxe.call(e, r) && Q5(t, r, e[r]);
        return t
    },
    Ci = (t, e, r) => Q5(t, typeof e != "symbol" ? e + "" : e, r);
let Md = class extends Zve {
    constructor(e, r, n, i = fo, s = void 0) {
        super(e, r, n, i), this.core = e, this.logger = r, this.name = n, Ci(this, "map", new Map), Ci(this, "version", d5e), Ci(this, "cached", []), Ci(this, "initialized", !1), Ci(this, "getKey"), Ci(this, "storagePrefix", fo), Ci(this, "recentlyDeleted", []), Ci(this, "recentlyDeletedLimit", 200), Ci(this, "init", async () => {
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(a => {
                this.getKey && a !== null && !$n(a) ? this.map.set(this.getKey(a), a) : ube(a) ? this.map.set(a.id, a) : hbe(a) && this.map.set(a.topic, a)
            }), this.cached = [], this.initialized = !0)
        }), Ci(this, "set", async (a, o) => {
            this.isInitialized(), this.map.has(a) ? await this.update(a, o) : (this.logger.debug("Setting value"), this.logger.trace({
                type: "method",
                method: "set",
                key: a,
                value: o
            }), this.map.set(a, o), await this.persist())
        }), Ci(this, "get", a => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({
            type: "method",
            method: "get",
            key: a
        }), this.getData(a))), Ci(this, "getAll", a => (this.isInitialized(), a ? this.values.filter(o => Object.keys(a).every(c => sxe(o[c], a[c]))) : this.values)), Ci(this, "update", async (a, o) => {
            this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({
                type: "method",
                method: "update",
                key: a,
                update: o
            });
            const c = Lk(Lk({}, this.getData(a)), o);
            this.map.set(a, c), await this.persist()
        }), Ci(this, "delete", async (a, o) => {
            this.isInitialized(), this.map.has(a) && (this.logger.debug("Deleting value"), this.logger.trace({
                type: "method",
                method: "delete",
                key: a,
                reason: o
            }), this.map.delete(a), this.addToRecentlyDeleted(a), await this.persist())
        }), this.logger = wi(r, this.name), this.storagePrefix = i, this.getKey = s
    }
    get context() {
        return zi(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.map.size
    }
    get keys() {
        return Array.from(this.map.keys())
    }
    get values() {
        return Array.from(this.map.values())
    }
    addToRecentlyDeleted(e) {
        this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2)
    }
    async setDataStore(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getDataStore() {
        return await this.core.storage.getItem(this.storageKey)
    }
    getData(e) {
        const r = this.map.get(e);
        if (!r) {
            if (this.recentlyDeleted.includes(e)) {
                const {
                    message: i
                } = je("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
                throw this.logger.error(i), new Error(i)
            }
            const {
                message: n
            } = je("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw this.logger.error(n), new Error(n)
        }
        return r
    }
    async persist() {
        await this.setDataStore(this.values)
    }
    async restore() {
        try {
            const e = await this.getDataStore();
            if (typeof e > "u" || !e.length) return;
            if (this.map.size) {
                const {
                    message: r
                } = je("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(r), new Error(r)
            }
            this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                value: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e)
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = je("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
};
var lxe = Object.defineProperty,
    dxe = (t, e, r) => e in t ? lxe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Ht = (t, e, r) => dxe(t, typeof e != "symbol" ? e + "" : e, r);
let uxe = class {
    constructor(e, r) {
        this.core = e, this.logger = r, Ht(this, "name", p5e), Ht(this, "version", g5e), Ht(this, "events", new _x), Ht(this, "pairings"), Ht(this, "initialized", !1), Ht(this, "storagePrefix", fo), Ht(this, "ignoredPayloadTypes", [Ko]), Ht(this, "registeredMethods", []), Ht(this, "init", async () => {
            this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"))
        }), Ht(this, "register", ({
            methods: n
        }) => {
            this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...n])]
        }), Ht(this, "create", async n => {
            this.isInitialized();
            const i = L5(),
                s = await this.core.crypto.setSymKey(i),
                a = an(Me.FIVE_MINUTES),
                o = {
                    protocol: nL
                },
                c = {
                    topic: s,
                    expiry: a,
                    relay: o,
                    active: !1,
                    methods: n == null ? void 0 : n.methods
                },
                l = zA({
                    protocol: this.core.protocol,
                    version: this.core.version,
                    topic: s,
                    symKey: i,
                    relay: o,
                    expiryTimestamp: a,
                    methods: n == null ? void 0 : n.methods
                });
            return this.events.emit(Rl.create, c), this.core.expirer.set(s, a), await this.pairings.set(s, c), await this.core.relayer.subscribe(s, {
                transportType: n == null ? void 0 : n.transportType
            }), {
                topic: s,
                uri: l
            }
        }), Ht(this, "pair", async n => {
            this.isInitialized();
            const i = this.core.eventClient.createEvent({
                properties: {
                    topic: n == null ? void 0 : n.uri,
                    trace: [Ka.pairing_started]
                }
            });
            this.isValidPair(n, i);
            const {
                topic: s,
                symKey: a,
                relay: o,
                expiryTimestamp: c,
                methods: l
            } = WA(n.uri);
            i.props.properties.topic = s, i.addTrace(Ka.pairing_uri_validation_success), i.addTrace(Ka.pairing_uri_not_expired);
            let u;
            if (this.pairings.keys.includes(s)) {
                if (u = this.pairings.get(s), i.addTrace(Ka.existing_pairing), u.active) throw i.setError(Po.active_pairing_already_exists), new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);
                i.addTrace(Ka.pairing_not_expired)
            }
            const h = c || an(Me.FIVE_MINUTES),
                f = {
                    topic: s,
                    relay: o,
                    expiry: h,
                    active: !1,
                    methods: l
                };
            this.core.expirer.set(s, h), await this.pairings.set(s, f), i.addTrace(Ka.store_new_pairing), n.activatePairing && await this.activate({
                topic: s
            }), this.events.emit(Rl.create, f), i.addTrace(Ka.emit_inactive_pairing), this.core.crypto.keychain.has(s) || await this.core.crypto.setSymKey(a, s), i.addTrace(Ka.subscribing_pairing_topic);
            try {
                await this.core.relayer.confirmOnlineStateOrThrow()
            } catch {
                i.setError(Po.no_internet_connection)
            }
            try {
                await this.core.relayer.subscribe(s, {
                    relay: o
                })
            } catch (p) {
                throw i.setError(Po.subscribe_pairing_topic_failure), p
            }
            return i.addTrace(Ka.subscribe_pairing_topic_success), f
        }), Ht(this, "activate", async ({
            topic: n
        }) => {
            this.isInitialized();
            const i = an(Me.FIVE_MINUTES);
            this.core.expirer.set(n, i), await this.pairings.update(n, {
                active: !0,
                expiry: i
            })
        }), Ht(this, "ping", async n => {
            this.isInitialized(), await this.isValidPing(n), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
            const {
                topic: i
            } = n;
            if (this.pairings.keys.includes(i)) {
                const s = await this.sendRequest(i, "wc_pairingPing", {}),
                    {
                        done: a,
                        resolve: o,
                        reject: c
                    } = $l();
                this.events.once(rr("pairing_ping", s), ({
                    error: l
                }) => {
                    l ? c(l) : o()
                }), await a()
            }
        }), Ht(this, "updateExpiry", async ({
            topic: n,
            expiry: i
        }) => {
            this.isInitialized(), await this.pairings.update(n, {
                expiry: i
            })
        }), Ht(this, "updateMetadata", async ({
            topic: n,
            metadata: i
        }) => {
            this.isInitialized(), await this.pairings.update(n, {
                peerMetadata: i
            })
        }), Ht(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), Ht(this, "disconnect", async n => {
            this.isInitialized(), await this.isValidDisconnect(n);
            const {
                topic: i
            } = n;
            this.pairings.keys.includes(i) && (await this.sendRequest(i, "wc_pairingDelete", _r("USER_DISCONNECTED")), await this.deletePairing(i))
        }), Ht(this, "formatUriFromPairing", n => {
            this.isInitialized();
            const {
                topic: i,
                relay: s,
                expiry: a,
                methods: o
            } = n, c = this.core.crypto.keychain.get(i);
            return zA({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: i,
                symKey: c,
                relay: s,
                expiryTimestamp: a,
                methods: o
            })
        }), Ht(this, "sendRequest", async (n, i, s) => {
            const a = Zc(i, s),
                o = await this.core.crypto.encode(n, a),
                c = sf[i].req;
            return this.core.history.set(n, a), this.core.relayer.publish(n, o, c), a.id
        }), Ht(this, "sendResult", async (n, i, s) => {
            const a = Dy(n, s),
                o = await this.core.crypto.encode(i, a),
                c = (await this.core.history.get(i, n)).request.method,
                l = sf[c].res;
            await this.core.relayer.publish(i, o, l), await this.core.history.resolve(a)
        }), Ht(this, "sendError", async (n, i, s) => {
            const a = Ly(n, s),
                o = await this.core.crypto.encode(i, a),
                c = (await this.core.history.get(i, n)).request.method,
                l = sf[c] ? sf[c].res : sf.unregistered_method.res;
            await this.core.relayer.publish(i, o, l), await this.core.history.resolve(a)
        }), Ht(this, "deletePairing", async (n, i) => {
            await this.core.relayer.unsubscribe(n), await Promise.all([this.pairings.delete(n, _r("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(n), i ? Promise.resolve() : this.core.expirer.del(n)])
        }), Ht(this, "cleanup", async () => {
            const n = this.pairings.getAll().filter(i => jc(i.expiry));
            await Promise.all(n.map(i => this.deletePairing(i.topic)))
        }), Ht(this, "onRelayEventRequest", async n => {
            const {
                topic: i,
                payload: s
            } = n;
            switch (s.method) {
                case "wc_pairingPing":
                    return await this.onPairingPingRequest(i, s);
                case "wc_pairingDelete":
                    return await this.onPairingDeleteRequest(i, s);
                default:
                    return await this.onUnknownRpcMethodRequest(i, s)
            }
        }), Ht(this, "onRelayEventResponse", async n => {
            const {
                topic: i,
                payload: s
            } = n, a = (await this.core.history.get(i, s.id)).request.method;
            switch (a) {
                case "wc_pairingPing":
                    return this.onPairingPingResponse(i, s);
                default:
                    return this.onUnknownRpcMethodResponse(a)
            }
        }), Ht(this, "onPairingPingRequest", async (n, i) => {
            const {
                id: s
            } = i;
            try {
                this.isValidPing({
                    topic: n
                }), await this.sendResult(s, n, !0), this.events.emit(Rl.ping, {
                    id: s,
                    topic: n
                })
            } catch (a) {
                await this.sendError(s, n, a), this.logger.error(a)
            }
        }), Ht(this, "onPairingPingResponse", (n, i) => {
            const {
                id: s
            } = i;
            setTimeout(() => {
                Ja(i) ? this.events.emit(rr("pairing_ping", s), {}) : Is(i) && this.events.emit(rr("pairing_ping", s), {
                    error: i.error
                })
            }, 500)
        }), Ht(this, "onPairingDeleteRequest", async (n, i) => {
            const {
                id: s
            } = i;
            try {
                this.isValidDisconnect({
                    topic: n
                }), await this.deletePairing(n), this.events.emit(Rl.delete, {
                    id: s,
                    topic: n
                })
            } catch (a) {
                await this.sendError(s, n, a), this.logger.error(a)
            }
        }), Ht(this, "onUnknownRpcMethodRequest", async (n, i) => {
            const {
                id: s,
                method: a
            } = i;
            try {
                if (this.registeredMethods.includes(a)) return;
                const o = _r("WC_METHOD_UNSUPPORTED", a);
                await this.sendError(s, n, o), this.logger.error(o)
            } catch (o) {
                await this.sendError(s, n, o), this.logger.error(o)
            }
        }), Ht(this, "onUnknownRpcMethodResponse", n => {
            this.registeredMethods.includes(n) || this.logger.error(_r("WC_METHOD_UNSUPPORTED", n))
        }), Ht(this, "isValidPair", (n, i) => {
            var s;
            if (!$i(n)) {
                const {
                    message: o
                } = je("MISSING_OR_INVALID", `pair() params: ${n}`);
                throw i.setError(Po.malformed_pairing_uri), new Error(o)
            }
            if (!dbe(n.uri)) {
                const {
                    message: o
                } = je("MISSING_OR_INVALID", `pair() uri: ${n.uri}`);
                throw i.setError(Po.malformed_pairing_uri), new Error(o)
            }
            const a = WA(n == null ? void 0 : n.uri);
            if (!((s = a == null ? void 0 : a.relay) != null && s.protocol)) {
                const {
                    message: o
                } = je("MISSING_OR_INVALID", "pair() uri#relay-protocol");
                throw i.setError(Po.malformed_pairing_uri), new Error(o)
            }
            if (!(a != null && a.symKey)) {
                const {
                    message: o
                } = je("MISSING_OR_INVALID", "pair() uri#symKey");
                throw i.setError(Po.malformed_pairing_uri), new Error(o)
            }
            if (a != null && a.expiryTimestamp && Me.toMiliseconds(a == null ? void 0 : a.expiryTimestamp) < Date.now()) {
                i.setError(Po.pairing_expired);
                const {
                    message: o
                } = je("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
                throw new Error(o)
            }
        }), Ht(this, "isValidPing", async n => {
            if (!$i(n)) {
                const {
                    message: s
                } = je("MISSING_OR_INVALID", `ping() params: ${n}`);
                throw new Error(s)
            }
            const {
                topic: i
            } = n;
            await this.isValidPairingTopic(i)
        }), Ht(this, "isValidDisconnect", async n => {
            if (!$i(n)) {
                const {
                    message: s
                } = je("MISSING_OR_INVALID", `disconnect() params: ${n}`);
                throw new Error(s)
            }
            const {
                topic: i
            } = n;
            await this.isValidPairingTopic(i)
        }), Ht(this, "isValidPairingTopic", async n => {
            if (!en(n, !1)) {
                const {
                    message: i
                } = je("MISSING_OR_INVALID", `pairing topic should be a string: ${n}`);
                throw new Error(i)
            }
            if (!this.pairings.keys.includes(n)) {
                const {
                    message: i
                } = je("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n}`);
                throw new Error(i)
            }
            if (jc(this.pairings.get(n).expiry)) {
                await this.deletePairing(n);
                const {
                    message: i
                } = je("EXPIRED", `pairing topic: ${n}`);
                throw new Error(i)
            }
        }), this.core = e, this.logger = wi(r, this.name), this.pairings = new Md(this.core, this.logger, this.name, this.storagePrefix)
    }
    get context() {
        return zi(this.logger)
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = je("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    registerRelayerEvents() {
        this.core.relayer.on(mn.message, async e => {
            const {
                topic: r,
                message: n,
                transportType: i
            } = e;
            if (this.pairings.keys.includes(r) && i !== Er.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n))) try {
                const s = await this.core.crypto.decode(r, n);
                Xx(s) ? (this.core.history.set(r, s), await this.onRelayEventRequest({
                    topic: r,
                    payload: s
                })) : Uy(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({
                    topic: r,
                    payload: s
                }), this.core.history.delete(r, s.id)), await this.core.relayer.messages.ack(r, n)
            } catch (s) {
                this.logger.error(s)
            }
        })
    }
    registerExpirerEvents() {
        this.core.expirer.on(As.expired, async e => {
            const {
                topic: r
            } = XM(e.target);
            r && this.pairings.keys.includes(r) && (await this.deletePairing(r, !0), this.events.emit(Rl.expire, {
                topic: r
            }))
        })
    }
};
var hxe = Object.defineProperty,
    fxe = (t, e, r) => e in t ? hxe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    En = (t, e, r) => fxe(t, typeof e != "symbol" ? e + "" : e, r);
let pxe = class extends Vve {
    constructor(e, r) {
        super(e, r), this.core = e, this.logger = r, En(this, "records", new Map), En(this, "events", new gs.EventEmitter), En(this, "name", m5e), En(this, "version", y5e), En(this, "cached", []), En(this, "initialized", !1), En(this, "storagePrefix", fo), En(this, "init", async () => {
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(n => this.records.set(n.id, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
        }), En(this, "set", (n, i, s) => {
            if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({
                    type: "method",
                    method: "set",
                    topic: n,
                    request: i,
                    chainId: s
                }), this.records.has(i.id)) return;
            const a = {
                id: i.id,
                topic: n,
                request: {
                    method: i.method,
                    params: i.params || null
                },
                chainId: s,
                expiry: an(Me.THIRTY_DAYS)
            };
            this.records.set(a.id, a), this.persist(), this.events.emit(Zs.created, a)
        }), En(this, "resolve", async n => {
            if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({
                    type: "method",
                    method: "update",
                    response: n
                }), !this.records.has(n.id)) return;
            const i = await this.getRecord(n.id);
            typeof i.response > "u" && (i.response = Is(n) ? {
                error: n.error
            } : {
                result: n.result
            }, this.records.set(i.id, i), this.persist(), this.events.emit(Zs.updated, i))
        }), En(this, "get", async (n, i) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({
            type: "method",
            method: "get",
            topic: n,
            id: i
        }), await this.getRecord(i))), En(this, "delete", (n, i) => {
            this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({
                type: "method",
                method: "delete",
                id: i
            }), this.values.forEach(s => {
                if (s.topic === n) {
                    if (typeof i < "u" && s.id !== i) return;
                    this.records.delete(s.id), this.events.emit(Zs.deleted, s)
                }
            }), this.persist()
        }), En(this, "exists", async (n, i) => (this.isInitialized(), this.records.has(i) ? (await this.getRecord(i)).topic === n : !1)), En(this, "on", (n, i) => {
            this.events.on(n, i)
        }), En(this, "once", (n, i) => {
            this.events.once(n, i)
        }), En(this, "off", (n, i) => {
            this.events.off(n, i)
        }), En(this, "removeListener", (n, i) => {
            this.events.removeListener(n, i)
        }), this.logger = wi(r, this.name)
    }
    get context() {
        return zi(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get size() {
        return this.records.size
    }
    get keys() {
        return Array.from(this.records.keys())
    }
    get values() {
        return Array.from(this.records.values())
    }
    get pending() {
        const e = [];
        return this.values.forEach(r => {
            if (typeof r.response < "u") return;
            const n = {
                topic: r.topic,
                request: Zc(r.request.method, r.request.params, r.id),
                chainId: r.chainId
            };
            return e.push(n)
        }), e
    }
    async setJsonRpcRecords(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getJsonRpcRecords() {
        return await this.core.storage.getItem(this.storageKey)
    }
    getRecord(e) {
        this.isInitialized();
        const r = this.records.get(e);
        if (!r) {
            const {
                message: n
            } = je("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw new Error(n)
        }
        return r
    }
    async persist() {
        await this.setJsonRpcRecords(this.values), this.events.emit(Zs.sync)
    }
    async restore() {
        try {
            const e = await this.getJsonRpcRecords();
            if (typeof e > "u" || !e.length) return;
            if (this.records.size) {
                const {
                    message: r
                } = je("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(r), new Error(r)
            }
            this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                records: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e)
        }
    }
    registerEventListeners() {
        this.events.on(Zs.created, e => {
            const r = Zs.created;
            this.logger.info(`Emitting ${r}`), this.logger.debug({
                type: "event",
                event: r,
                record: e
            })
        }), this.events.on(Zs.updated, e => {
            const r = Zs.updated;
            this.logger.info(`Emitting ${r}`), this.logger.debug({
                type: "event",
                event: r,
                record: e
            })
        }), this.events.on(Zs.deleted, e => {
            const r = Zs.deleted;
            this.logger.info(`Emitting ${r}`), this.logger.debug({
                type: "event",
                event: r,
                record: e
            })
        }), this.core.heartbeat.on(jd.pulse, () => {
            this.cleanup()
        })
    }
    cleanup() {
        try {
            this.isInitialized();
            let e = !1;
            this.records.forEach(r => {
                Me.toMiliseconds(r.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${r.id}`), this.records.delete(r.id), this.events.emit(Zs.deleted, r, !1), e = !0)
            }), e && this.persist()
        } catch (e) {
            this.logger.warn(e)
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = je("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
};
var gxe = Object.defineProperty,
    mxe = (t, e, r) => e in t ? gxe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Hn = (t, e, r) => mxe(t, typeof e != "symbol" ? e + "" : e, r);
let yxe = class extends Qve {
    constructor(e, r) {
        super(e, r), this.core = e, this.logger = r, Hn(this, "expirations", new Map), Hn(this, "events", new gs.EventEmitter), Hn(this, "name", w5e), Hn(this, "version", b5e), Hn(this, "cached", []), Hn(this, "initialized", !1), Hn(this, "storagePrefix", fo), Hn(this, "init", async () => {
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(n => this.expirations.set(n.target, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
        }), Hn(this, "has", n => {
            try {
                const i = this.formatTarget(n);
                return typeof this.getExpiration(i) < "u"
            } catch {
                return !1
            }
        }), Hn(this, "set", (n, i) => {
            this.isInitialized();
            const s = this.formatTarget(n),
                a = {
                    target: s,
                    expiry: i
                };
            this.expirations.set(s, a), this.checkExpiry(s, a), this.events.emit(As.created, {
                target: s,
                expiration: a
            })
        }), Hn(this, "get", n => {
            this.isInitialized();
            const i = this.formatTarget(n);
            return this.getExpiration(i)
        }), Hn(this, "del", n => {
            if (this.isInitialized(), this.has(n)) {
                const i = this.formatTarget(n),
                    s = this.getExpiration(i);
                this.expirations.delete(i), this.events.emit(As.deleted, {
                    target: i,
                    expiration: s
                })
            }
        }), Hn(this, "on", (n, i) => {
            this.events.on(n, i)
        }), Hn(this, "once", (n, i) => {
            this.events.once(n, i)
        }), Hn(this, "off", (n, i) => {
            this.events.off(n, i)
        }), Hn(this, "removeListener", (n, i) => {
            this.events.removeListener(n, i)
        }), this.logger = wi(r, this.name)
    }
    get context() {
        return zi(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.expirations.size
    }
    get keys() {
        return Array.from(this.expirations.keys())
    }
    get values() {
        return Array.from(this.expirations.values())
    }
    formatTarget(e) {
        if (typeof e == "string") return K1e(e);
        if (typeof e == "number") return Y1e(e);
        const {
            message: r
        } = je("UNKNOWN_TYPE", `Target type: ${typeof e}`);
        throw new Error(r)
    }
    async setExpirations(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getExpirations() {
        return await this.core.storage.getItem(this.storageKey)
    }
    async persist() {
        await this.setExpirations(this.values), this.events.emit(As.sync)
    }
    async restore() {
        try {
            const e = await this.getExpirations();
            if (typeof e > "u" || !e.length) return;
            if (this.expirations.size) {
                const {
                    message: r
                } = je("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(r), new Error(r)
            }
            this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                expirations: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e)
        }
    }
    getExpiration(e) {
        const r = this.expirations.get(e);
        if (!r) {
            const {
                message: n
            } = je("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw this.logger.warn(n), new Error(n)
        }
        return r
    }
    checkExpiry(e, r) {
        const {
            expiry: n
        } = r;
        Me.toMiliseconds(n) - Date.now() <= 0 && this.expire(e, r)
    }
    expire(e, r) {
        this.expirations.delete(e), this.events.emit(As.expired, {
            target: e,
            expiration: r
        })
    }
    checkExpirations() {
        this.core.relayer.connected && this.expirations.forEach((e, r) => this.checkExpiry(r, e))
    }
    registerEventListeners() {
        this.core.heartbeat.on(jd.pulse, () => this.checkExpirations()), this.events.on(As.created, e => {
            const r = As.created;
            this.logger.info(`Emitting ${r}`), this.logger.debug({
                type: "event",
                event: r,
                data: e
            }), this.persist()
        }), this.events.on(As.expired, e => {
            const r = As.expired;
            this.logger.info(`Emitting ${r}`), this.logger.debug({
                type: "event",
                event: r,
                data: e
            }), this.persist()
        }), this.events.on(As.deleted, e => {
            const r = As.deleted;
            this.logger.info(`Emitting ${r}`), this.logger.debug({
                type: "event",
                event: r,
                data: e
            }), this.persist()
        })
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = je("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
};
var wxe = Object.defineProperty,
    bxe = (t, e, r) => e in t ? wxe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Kr = (t, e, r) => bxe(t, typeof e != "symbol" ? e + "" : e, r);
let vxe = class extends Xve {
    constructor(e, r, n) {
        super(e, r, n), this.core = e, this.logger = r, this.store = n, Kr(this, "name", v5e), Kr(this, "abortController"), Kr(this, "isDevEnv"), Kr(this, "verifyUrlV3", E5e), Kr(this, "storagePrefix", fo), Kr(this, "version", rL), Kr(this, "publicKey"), Kr(this, "fetchPromise"), Kr(this, "init", async () => {
            var i;
            this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && Me.toMiliseconds((i = this.publicKey) == null ? void 0 : i.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()))
        }), Kr(this, "register", async i => {
            if (!$h() || this.isDevEnv) return;
            const s = window.location.origin,
                {
                    id: a,
                    decryptedId: o
                } = i,
                c = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${s}&id=${a}&decryptedId=${o}`;
            try {
                const l = sc.getDocument(),
                    u = this.startAbortTimer(Me.ONE_SECOND * 5),
                    h = await new Promise((f, p) => {
                        const g = () => {
                            window.removeEventListener("message", y), l.body.removeChild(m), p("attestation aborted")
                        };
                        this.abortController.signal.addEventListener("abort", g);
                        const m = l.createElement("iframe");
                        m.src = c, m.style.display = "none", m.addEventListener("error", g, {
                            signal: this.abortController.signal
                        });
                        const y = w => {
                            if (w.data && typeof w.data == "string") try {
                                const x = JSON.parse(w.data);
                                if (x.type === "verify_attestation") {
                                    if (A5(x.attestation).payload.id !== a) return;
                                    clearInterval(u), l.body.removeChild(m), this.abortController.signal.removeEventListener("abort", g), window.removeEventListener("message", y), f(x.attestation === null ? "" : x.attestation)
                                }
                            } catch (x) {
                                this.logger.warn(x)
                            }
                        };
                        l.body.appendChild(m), window.addEventListener("message", y, {
                            signal: this.abortController.signal
                        })
                    });
                return this.logger.debug("jwt attestation", h), h
            } catch (l) {
                this.logger.warn(l)
            }
            return ""
        }), Kr(this, "resolve", async i => {
            if (this.isDevEnv) return "";
            const {
                attestationId: s,
                hash: a,
                encryptedId: o
            } = i;
            if (s === "") {
                this.logger.debug("resolve: attestationId is empty, skipping");
                return
            }
            if (s) {
                if (A5(s).payload.id !== o) return;
                const l = await this.isValidJwtAttestation(s);
                if (l) {
                    if (!l.isVerified) {
                        this.logger.warn("resolve: jwt attestation: origin url not verified");
                        return
                    }
                    return l
                }
            }
            if (!a) return;
            const c = this.getVerifyUrl(i == null ? void 0 : i.verifyUrl);
            return this.fetchAttestation(a, c)
        }), Kr(this, "fetchAttestation", async (i, s) => {
            this.logger.debug(`resolving attestation: ${i} from url: ${s}`);
            const a = this.startAbortTimer(Me.ONE_SECOND * 5),
                o = await fetch(`${s}/attestation/${i}?v2Supported=true`, {
                    signal: this.abortController.signal
                });
            return clearTimeout(a), o.status === 200 ? await o.json() : void 0
        }), Kr(this, "getVerifyUrl", i => {
            let s = i || Kf;
            return _5e.includes(s) || (this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${Kf}`), s = Kf), s
        }), Kr(this, "fetchPublicKey", async () => {
            try {
                this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
                const i = this.startAbortTimer(Me.FIVE_SECONDS),
                    s = await fetch(`${this.verifyUrlV3}/public-key`, {
                        signal: this.abortController.signal
                    });
                return clearTimeout(i), await s.json()
            } catch (i) {
                this.logger.warn(i)
            }
        }), Kr(this, "persistPublicKey", async i => {
            this.logger.debug("persisting public key to local storage", i), await this.store.setItem(this.storeKey, i), this.publicKey = i
        }), Kr(this, "removePublicKey", async () => {
            this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0
        }), Kr(this, "isValidJwtAttestation", async i => {
            const s = await this.getPublicKey();
            try {
                if (s) return this.validateAttestation(i, s)
            } catch (o) {
                this.logger.error(o), this.logger.warn("error validating attestation")
            }
            const a = await this.fetchAndPersistPublicKey();
            try {
                if (a) return this.validateAttestation(i, a)
            } catch (o) {
                this.logger.error(o), this.logger.warn("error validating attestation")
            }
        }), Kr(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), Kr(this, "fetchAndPersistPublicKey", async () => {
            if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
            this.fetchPromise = new Promise(async s => {
                const a = await this.fetchPublicKey();
                a && (await this.persistPublicKey(a), s(a))
            });
            const i = await this.fetchPromise;
            return this.fetchPromise = void 0, i
        }), Kr(this, "validateAttestation", (i, s) => {
            const a = z2e(i, s.publicKey),
                o = {
                    hasExpired: Me.toMiliseconds(a.exp) < Date.now(),
                    payload: a
                };
            if (o.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
            return {
                origin: o.payload.origin,
                isScam: o.payload.isScam,
                isVerified: o.payload.isVerified
            }
        }), this.logger = wi(r, this.name), this.abortController = new AbortController, this.isDevEnv = Dx(), this.init()
    }
    get storeKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key"
    }
    get context() {
        return zi(this.logger)
    }
    startAbortTimer(e) {
        return this.abortController = new AbortController, setTimeout(() => this.abortController.abort(), Me.toMiliseconds(e))
    }
};
var xxe = Object.defineProperty,
    Exe = (t, e, r) => e in t ? xxe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Uk = (t, e, r) => Exe(t, typeof e != "symbol" ? e + "" : e, r);
let _xe = class extends e3e {
    constructor(e, r) {
        super(e, r), this.projectId = e, this.logger = r, Uk(this, "context", C5e), Uk(this, "registerDeviceToken", async n => {
            const {
                clientId: i,
                token: s,
                notificationType: a,
                enableEncrypted: o = !1
            } = n, c = `${A5e}/${this.projectId}/clients`;
            await fetch(c, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    client_id: i,
                    type: a,
                    token: s,
                    always_raw: o
                })
            })
        }), this.logger = wi(r, this.context)
    }
};
var Cxe = Object.defineProperty,
    Fk = Object.getOwnPropertySymbols,
    Axe = Object.prototype.hasOwnProperty,
    kxe = Object.prototype.propertyIsEnumerable,
    X5 = (t, e, r) => e in t ? Cxe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    cf = (t, e) => {
        for (var r in e || (e = {})) Axe.call(e, r) && X5(t, r, e[r]);
        if (Fk)
            for (var r of Fk(e)) kxe.call(e, r) && X5(t, r, e[r]);
        return t
    },
    dn = (t, e, r) => X5(t, typeof e != "symbol" ? e + "" : e, r);
let Ixe = class extends t3e {
    constructor(e, r, n = !0) {
        super(e, r, n), this.core = e, this.logger = r, dn(this, "context", I5e), dn(this, "storagePrefix", fo), dn(this, "storageVersion", k5e), dn(this, "events", new Map), dn(this, "shouldPersist", !1), dn(this, "init", async () => {
            if (!Dx()) try {
                const i = {
                    eventId: dA(),
                    timestamp: Date.now(),
                    domain: this.getAppDomain(),
                    props: {
                        event: "INIT",
                        type: "",
                        properties: {
                            client_id: await this.core.crypto.getClientId(),
                            user_agent: JM(this.core.relayer.protocol, this.core.relayer.version, H5)
                        }
                    }
                };
                await this.sendEvent([i])
            } catch (i) {
                this.logger.warn(i)
            }
        }), dn(this, "createEvent", i => {
            const {
                event: s = "ERROR",
                type: a = "",
                properties: {
                    topic: o,
                    trace: c
                }
            } = i, l = dA(), u = this.core.projectId || "", h = Date.now(), f = cf({
                eventId: l,
                timestamp: h,
                props: {
                    event: s,
                    type: a,
                    properties: {
                        topic: o,
                        trace: c
                    }
                },
                bundleId: u,
                domain: this.getAppDomain()
            }, this.setMethods(l));
            return this.telemetryEnabled && (this.events.set(l, f), this.shouldPersist = !0), f
        }), dn(this, "getEvent", i => {
            const {
                eventId: s,
                topic: a
            } = i;
            if (s) return this.events.get(s);
            const o = Array.from(this.events.values()).find(c => c.props.properties.topic === a);
            if (o) return cf(cf({}, o), this.setMethods(o.eventId))
        }), dn(this, "deleteEvent", i => {
            const {
                eventId: s
            } = i;
            this.events.delete(s), this.shouldPersist = !0
        }), dn(this, "setEventListeners", () => {
            this.core.heartbeat.on(jd.pulse, async () => {
                this.shouldPersist && await this.persist(), this.events.forEach(i => {
                    Me.fromMiliseconds(Date.now()) - Me.fromMiliseconds(i.timestamp) > $5e && (this.events.delete(i.eventId), this.shouldPersist = !0)
                })
            })
        }), dn(this, "setMethods", i => ({
            addTrace: s => this.addTrace(i, s),
            setError: s => this.setError(i, s)
        })), dn(this, "addTrace", (i, s) => {
            const a = this.events.get(i);
            a && (a.props.properties.trace.push(s), this.events.set(i, a), this.shouldPersist = !0)
        }), dn(this, "setError", (i, s) => {
            const a = this.events.get(i);
            a && (a.props.type = s, a.timestamp = Date.now(), this.events.set(i, a), this.shouldPersist = !0)
        }), dn(this, "persist", async () => {
            await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1
        }), dn(this, "restore", async () => {
            try {
                const i = await this.core.storage.getItem(this.storageKey) || [];
                if (!i.length) return;
                i.forEach(s => {
                    this.events.set(s.eventId, cf(cf({}, s), this.setMethods(s.eventId)))
                })
            } catch (i) {
                this.logger.warn(i)
            }
        }), dn(this, "submit", async () => {
            if (!this.telemetryEnabled || this.events.size === 0) return;
            const i = [];
            for (const [s, a] of this.events) a.props.type && i.push(a);
            if (i.length !== 0) try {
                if ((await this.sendEvent(i)).ok)
                    for (const s of i) this.events.delete(s.eventId), this.shouldPersist = !0
            } catch (s) {
                this.logger.warn(s)
            }
        }), dn(this, "sendEvent", async i => {
            const s = this.getAppDomain() ? "" : "&sp=desktop";
            return await fetch(`${S5e}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${H5}${s}`, {
                method: "POST",
                body: JSON.stringify(i)
            })
        }), dn(this, "getAppDomain", () => ZM().url), this.logger = wi(r, this.context), this.telemetryEnabled = n, n ? this.restore().then(async () => {
            await this.submit(), this.setEventListeners()
        }) : this.persist()
    }
    get storageKey() {
        return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context
    }
};
var $xe = Object.defineProperty,
    Bk = Object.getOwnPropertySymbols,
    Sxe = Object.prototype.hasOwnProperty,
    Txe = Object.prototype.propertyIsEnumerable,
    e4 = (t, e, r) => e in t ? $xe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Wk = (t, e) => {
        for (var r in e || (e = {})) Sxe.call(e, r) && e4(t, r, e[r]);
        if (Bk)
            for (var r of Bk(e)) Txe.call(e, r) && e4(t, r, e[r]);
        return t
    },
    wr = (t, e, r) => e4(t, typeof e != "symbol" ? e + "" : e, r);
let Pxe = class yL extends Wve {
    constructor(e) {
        var r;
        super(e), wr(this, "protocol", tL), wr(this, "version", rL), wr(this, "name", q5), wr(this, "relayUrl"), wr(this, "projectId"), wr(this, "customStoragePrefix"), wr(this, "events", new gs.EventEmitter), wr(this, "logger"), wr(this, "heartbeat"), wr(this, "relayer"), wr(this, "crypto"), wr(this, "storage"), wr(this, "history"), wr(this, "expirer"), wr(this, "pairing"), wr(this, "verify"), wr(this, "echoClient"), wr(this, "linkModeSupportedApps"), wr(this, "eventClient"), wr(this, "initialized", !1), wr(this, "logChunkController"), wr(this, "on", (o, c) => this.events.on(o, c)), wr(this, "once", (o, c) => this.events.once(o, c)), wr(this, "off", (o, c) => this.events.off(o, c)), wr(this, "removeListener", (o, c) => this.events.removeListener(o, c)), wr(this, "dispatchEnvelope", ({
            topic: o,
            message: c,
            sessionExists: l
        }) => {
            if (!o || !c) return;
            const u = {
                topic: o,
                message: c,
                publishedAt: Date.now(),
                transportType: Er.link_mode
            };
            this.relayer.onLinkMessageEvent(u, {
                sessionExists: l
            })
        });
        const n = this.getGlobalCore(e == null ? void 0 : e.customStoragePrefix);
        if (n) try {
            return this.customStoragePrefix = n.customStoragePrefix, this.logger = n.logger, this.heartbeat = n.heartbeat, this.crypto = n.crypto, this.history = n.history, this.expirer = n.expirer, this.storage = n.storage, this.relayer = n.relayer, this.pairing = n.pairing, this.verify = n.verify, this.echoClient = n.echoClient, this.linkModeSupportedApps = n.linkModeSupportedApps, this.eventClient = n.eventClient, this.initialized = n.initialized, this.logChunkController = n.logChunkController, n
        } catch (o) {
            console.warn("Failed to copy global core", o)
        }
        this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || iL, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
        const i = My({
                level: typeof(e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : J3e.logger,
                name: q5
            }),
            {
                logger: s,
                chunkLoggerController: a
            } = Uve({
                opts: i,
                maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes,
                loggerOverride: e == null ? void 0 : e.logger
            });
        this.logChunkController = a, (r = this.logChunkController) != null && r.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
            var o, c;
            (o = this.logChunkController) != null && o.downloadLogsBlobInBrowser && ((c = this.logChunkController) == null || c.downloadLogsBlobInBrowser({
                clientId: await this.crypto.getClientId()
            }))
        }), this.logger = wi(s, this.name), this.heartbeat = new Gbe, this.crypto = new i6e(this, this.logger, e == null ? void 0 : e.keychain), this.history = new pxe(this, this.logger), this.expirer = new yxe(this, this.logger), this.storage = e != null && e.storage ? e.storage : new Eve(Wk(Wk({}, Q3e), e == null ? void 0 : e.storageOptions)), this.relayer = new P6e({
            core: this,
            logger: this.logger,
            relayUrl: this.relayUrl,
            projectId: this.projectId
        }), this.pairing = new uxe(this, this.logger), this.verify = new vxe(this, this.logger, this.storage), this.echoClient = new _xe(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Ixe(this, this.logger, e == null ? void 0 : e.telemetryEnabled), this.setGlobalCore(this)
    }
    static async init(e) {
        const r = new yL(e);
        await r.initialize();
        const n = await r.crypto.getClientId();
        return await r.storage.setItem(u5e, n), r
    }
    get context() {
        return zi(this.logger)
    }
    async start() {
        this.initialized || await this.initialize()
    }
    async getLogsBlob() {
        var e;
        return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({
            clientId: await this.crypto.getClientId()
        })
    }
    async addLinkModeSupportedApp(e) {
        this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(xk, this.linkModeSupportedApps))
    }
    async initialize() {
        this.logger.trace("Initialized");
        try {
            await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(xk) || [], this.initialized = !0, this.logger.info("Core Initialization Success")
        } catch (e) {
            throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e
        }
    }
    getGlobalCore(e = "") {
        try {
            if (this.isGlobalCoreDisabled()) return;
            const r = `_walletConnectCore_${e}`,
                n = `${r}_count`;
            return globalThis[n] = (globalThis[n] || 0) + 1, globalThis[n] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[n]} times.`), globalThis[r]
        } catch (r) {
            console.warn("Failed to get global WalletConnect core", r);
            return
        }
    }
    setGlobalCore(e) {
        var r;
        try {
            if (this.isGlobalCoreDisabled()) return;
            const n = `_walletConnectCore_${((r=e.opts)==null?void 0:r.customStoragePrefix)||""}`;
            globalThis[n] = e
        } catch (n) {
            console.warn("Failed to set global WalletConnect core", n)
        }
    }
    isGlobalCoreDisabled() {
        try {
            return typeof jn < "u" && Z3e.DISABLE_GLOBAL_CORE === "true"
        } catch {
            return !0
        }
    }
};
const Nxe = Pxe,
    wL = "wc",
    bL = 2,
    vL = "client",
    e8 = `${wL}@${bL}:${vL}:`,
    Ob = {
        name: vL,
        logger: "error"
    },
    zk = "WALLETCONNECT_DEEPLINK_CHOICE",
    Oxe = "proposal",
    qk = "Proposal expired",
    jxe = "session",
    ou = Me.SEVEN_DAYS,
    Rxe = "engine",
    un = {
        wc_sessionPropose: {
            req: {
                ttl: Me.FIVE_MINUTES,
                prompt: !0,
                tag: 1100
            },
            res: {
                ttl: Me.FIVE_MINUTES,
                prompt: !1,
                tag: 1101
            },
            reject: {
                ttl: Me.FIVE_MINUTES,
                prompt: !1,
                tag: 1120
            },
            autoReject: {
                ttl: Me.FIVE_MINUTES,
                prompt: !1,
                tag: 1121
            }
        },
        wc_sessionSettle: {
            req: {
                ttl: Me.FIVE_MINUTES,
                prompt: !1,
                tag: 1102
            },
            res: {
                ttl: Me.FIVE_MINUTES,
                prompt: !1,
                tag: 1103
            }
        },
        wc_sessionUpdate: {
            req: {
                ttl: Me.ONE_DAY,
                prompt: !1,
                tag: 1104
            },
            res: {
                ttl: Me.ONE_DAY,
                prompt: !1,
                tag: 1105
            }
        },
        wc_sessionExtend: {
            req: {
                ttl: Me.ONE_DAY,
                prompt: !1,
                tag: 1106
            },
            res: {
                ttl: Me.ONE_DAY,
                prompt: !1,
                tag: 1107
            }
        },
        wc_sessionRequest: {
            req: {
                ttl: Me.FIVE_MINUTES,
                prompt: !0,
                tag: 1108
            },
            res: {
                ttl: Me.FIVE_MINUTES,
                prompt: !1,
                tag: 1109
            }
        },
        wc_sessionEvent: {
            req: {
                ttl: Me.FIVE_MINUTES,
                prompt: !0,
                tag: 1110
            },
            res: {
                ttl: Me.FIVE_MINUTES,
                prompt: !1,
                tag: 1111
            }
        },
        wc_sessionDelete: {
            req: {
                ttl: Me.ONE_DAY,
                prompt: !1,
                tag: 1112
            },
            res: {
                ttl: Me.ONE_DAY,
                prompt: !1,
                tag: 1113
            }
        },
        wc_sessionPing: {
            req: {
                ttl: Me.ONE_DAY,
                prompt: !1,
                tag: 1114
            },
            res: {
                ttl: Me.ONE_DAY,
                prompt: !1,
                tag: 1115
            }
        },
        wc_sessionAuthenticate: {
            req: {
                ttl: Me.ONE_HOUR,
                prompt: !0,
                tag: 1116
            },
            res: {
                ttl: Me.ONE_HOUR,
                prompt: !1,
                tag: 1117
            },
            reject: {
                ttl: Me.FIVE_MINUTES,
                prompt: !1,
                tag: 1118
            },
            autoReject: {
                ttl: Me.FIVE_MINUTES,
                prompt: !1,
                tag: 1119
            }
        }
    },
    jb = {
        min: Me.FIVE_MINUTES,
        max: Me.SEVEN_DAYS
    },
    za = {
        idle: "IDLE",
        active: "ACTIVE"
    },
    Mxe = {
        eth_sendTransaction: {
            key: ""
        },
        eth_sendRawTransaction: {
            key: ""
        },
        wallet_sendCalls: {
            key: ""
        },
        solana_signTransaction: {
            key: "signature"
        },
        solana_signAllTransactions: {
            key: "transactions"
        },
        solana_signAndSendTransaction: {
            key: "signature"
        },
        sui_signAndExecuteTransaction: {
            key: "digest"
        },
        sui_signTransaction: {
            key: ""
        },
        hedera_signAndExecuteTransaction: {
            key: "transactionId"
        },
        hedera_executeTransaction: {
            key: "transactionId"
        },
        near_signTransaction: {
            key: ""
        },
        near_signTransactions: {
            key: ""
        },
        tron_signTransaction: {
            key: "txID"
        },
        xrpl_signTransaction: {
            key: ""
        },
        xrpl_signTransactionFor: {
            key: ""
        },
        algo_signTxn: {
            key: ""
        },
        sendTransfer: {
            key: "txid"
        },
        stacks_stxTransfer: {
            key: "txId"
        },
        polkadot_signTransaction: {
            key: ""
        },
        cosmos_signDirect: {
            key: ""
        }
    },
    Dxe = "request",
    Lxe = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"],
    Uxe = "wc",
    Fxe = "auth",
    Bxe = "authKeys",
    Wxe = "pairingTopics",
    zxe = "requests",
    By = `${Uxe}@${1.5}:${Fxe}:`,
    im = `${By}:PUB_KEY`;
var qxe = Object.defineProperty,
    Hxe = Object.defineProperties,
    Vxe = Object.getOwnPropertyDescriptors,
    Hk = Object.getOwnPropertySymbols,
    Gxe = Object.prototype.hasOwnProperty,
    Kxe = Object.prototype.propertyIsEnumerable,
    t4 = (t, e, r) => e in t ? qxe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    vr = (t, e) => {
        for (var r in e || (e = {})) Gxe.call(e, r) && t4(t, r, e[r]);
        if (Hk)
            for (var r of Hk(e)) Kxe.call(e, r) && t4(t, r, e[r]);
        return t
    },
    Ai = (t, e) => Hxe(t, Vxe(e)),
    Ce = (t, e, r) => t4(t, typeof e != "symbol" ? e + "" : e, r);
let Yxe = class extends s3e {
        constructor(e) {
            super(e), Ce(this, "name", Rxe), Ce(this, "events", new _x), Ce(this, "initialized", !1), Ce(this, "requestQueue", {
                state: za.idle,
                queue: []
            }), Ce(this, "sessionRequestQueue", {
                state: za.idle,
                queue: []
            }), Ce(this, "emittedSessionRequests", new iye({
                limit: 500
            })), Ce(this, "requestQueueDelay", Me.ONE_SECOND), Ce(this, "expectedPairingMethodMap", new Map), Ce(this, "recentlyDeletedMap", new Map), Ce(this, "recentlyDeletedLimit", 200), Ce(this, "relayMessageCache", []), Ce(this, "pendingSessions", new Map), Ce(this, "init", async () => {
                this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({
                    methods: Object.keys(un)
                }), this.initialized = !0, setTimeout(async () => {
                    await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue()
                }, Me.toMiliseconds(this.requestQueueDelay)))
            }), Ce(this, "connect", async r => {
                this.isInitialized(), await this.confirmOnlineStateOrThrow();
                const n = Ai(vr({}, r), {
                    requiredNamespaces: r.requiredNamespaces || {},
                    optionalNamespaces: r.optionalNamespaces || {}
                });
                await this.isValidConnect(n), n.optionalNamespaces = sbe(n.requiredNamespaces, n.optionalNamespaces), n.requiredNamespaces = {};
                const {
                    pairingTopic: i,
                    requiredNamespaces: s,
                    optionalNamespaces: a,
                    sessionProperties: o,
                    scopedProperties: c,
                    relays: l
                } = n;
                let u = i,
                    h, f = !1;
                try {
                    if (u) {
                        const A = this.client.core.pairing.pairings.get(u);
                        this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), f = A.active
                    }
                } catch (A) {
                    throw this.client.logger.error(`connect() -> pairing.get(${u}) failed`), A
                }
                if (!u || !f) {
                    const {
                        topic: A,
                        uri: I
                    } = await this.client.core.pairing.create();
                    u = A, h = I
                }
                if (!u) {
                    const {
                        message: A
                    } = je("NO_MATCHING_KEY", `connect() pairing topic: ${u}`);
                    throw new Error(A)
                }
                const p = await this.client.core.crypto.generateKeyPair(),
                    g = un.wc_sessionPropose.req.ttl || Me.FIVE_MINUTES,
                    m = an(g),
                    y = Ai(vr(vr({
                        requiredNamespaces: s,
                        optionalNamespaces: a,
                        relays: l ? ? [{
                            protocol: nL
                        }],
                        proposer: {
                            publicKey: p,
                            metadata: this.client.metadata
                        },
                        expiryTimestamp: m,
                        pairingTopic: u
                    }, o && {
                        sessionProperties: o
                    }), c && {
                        scopedProperties: c
                    }), {
                        id: Za()
                    }),
                    w = rr("session_connect", y.id),
                    {
                        reject: x,
                        resolve: E,
                        done: _
                    } = $l(g, qk),
                    b = ({
                        id: A
                    }) => {
                        A === y.id && (this.client.events.off("proposal_expire", b), this.pendingSessions.delete(y.id), this.events.emit(w, {
                            error: {
                                message: qk,
                                code: 0
                            }
                        }))
                    };
                return this.client.events.on("proposal_expire", b), this.events.once(w, ({
                    error: A,
                    session: I
                }) => {
                    this.client.events.off("proposal_expire", b), A ? x(A) : I && E(I)
                }), await this.sendRequest({
                    topic: u,
                    method: "wc_sessionPropose",
                    params: y,
                    throwOnFailedPublish: !0,
                    clientRpcId: y.id
                }), await this.setProposal(y.id, y), {
                    uri: h,
                    approval: _
                }
            }), Ce(this, "pair", async r => {
                this.isInitialized(), await this.confirmOnlineStateOrThrow();
                try {
                    return await this.client.core.pairing.pair(r)
                } catch (n) {
                    throw this.client.logger.error("pair() failed"), n
                }
            }), Ce(this, "approve", async r => {
                var n, i, s;
                const a = this.client.core.eventClient.createEvent({
                    properties: {
                        topic: (n = r == null ? void 0 : r.id) == null ? void 0 : n.toString(),
                        trace: [Js.session_approve_started]
                    }
                });
                try {
                    this.isInitialized(), await this.confirmOnlineStateOrThrow()
                } catch (C) {
                    throw a.setError(Cl.no_internet_connection), C
                }
                try {
                    await this.isValidProposalId(r == null ? void 0 : r.id)
                } catch (C) {
                    throw this.client.logger.error(`approve() -> proposal.get(${r==null?void 0:r.id}) failed`), a.setError(Cl.proposal_not_found), C
                }
                try {
                    await this.isValidApprove(r)
                } catch (C) {
                    throw this.client.logger.error("approve() -> isValidApprove() failed"), a.setError(Cl.session_approve_namespace_validation_failure), C
                }
                const {
                    id: o,
                    relayProtocol: c,
                    namespaces: l,
                    sessionProperties: u,
                    scopedProperties: h,
                    sessionConfig: f
                } = r, p = this.client.proposal.get(o);
                this.client.core.eventClient.deleteEvent({
                    eventId: a.eventId
                });
                const {
                    pairingTopic: g,
                    proposer: m,
                    requiredNamespaces: y,
                    optionalNamespaces: w
                } = p;
                let x = (i = this.client.core.eventClient) == null ? void 0 : i.getEvent({
                    topic: g
                });
                x || (x = (s = this.client.core.eventClient) == null ? void 0 : s.createEvent({
                    type: Js.session_approve_started,
                    properties: {
                        topic: g,
                        trace: [Js.session_approve_started, Js.session_namespaces_validation_success]
                    }
                }));
                const E = await this.client.core.crypto.generateKeyPair(),
                    _ = m.publicKey,
                    b = await this.client.core.crypto.generateSharedKey(E, _),
                    A = vr(vr(vr({
                        relay: {
                            protocol: c ? ? "irn"
                        },
                        namespaces: l,
                        controller: {
                            publicKey: E,
                            metadata: this.client.metadata
                        },
                        expiry: an(ou)
                    }, u && {
                        sessionProperties: u
                    }), h && {
                        scopedProperties: h
                    }), f && {
                        sessionConfig: f
                    }),
                    I = Er.relay;
                x.addTrace(Js.subscribing_session_topic);
                try {
                    await this.client.core.relayer.subscribe(b, {
                        transportType: I
                    })
                } catch (C) {
                    throw x.setError(Cl.subscribe_session_topic_failure), C
                }
                x.addTrace(Js.subscribe_session_topic_success);
                const T = Ai(vr({}, A), {
                    topic: b,
                    requiredNamespaces: y,
                    optionalNamespaces: w,
                    pairingTopic: g,
                    acknowledged: !1,
                    self: A.controller,
                    peer: {
                        publicKey: m.publicKey,
                        metadata: m.metadata
                    },
                    controller: E,
                    transportType: Er.relay
                });
                await this.client.session.set(b, T), x.addTrace(Js.store_session);
                try {
                    x.addTrace(Js.publishing_session_settle), await this.sendRequest({
                        topic: b,
                        method: "wc_sessionSettle",
                        params: A,
                        throwOnFailedPublish: !0
                    }).catch(C => {
                        throw x == null || x.setError(Cl.session_settle_publish_failure), C
                    }), x.addTrace(Js.session_settle_publish_success), x.addTrace(Js.publishing_session_approve), await this.sendResult({
                        id: o,
                        topic: g,
                        result: {
                            relay: {
                                protocol: c ? ? "irn"
                            },
                            responderPublicKey: E
                        },
                        throwOnFailedPublish: !0
                    }).catch(C => {
                        throw x == null || x.setError(Cl.session_approve_publish_failure), C
                    }), x.addTrace(Js.session_approve_publish_success)
                } catch (C) {
                    throw this.client.logger.error(C), this.client.session.delete(b, _r("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(b), C
                }
                return this.client.core.eventClient.deleteEvent({
                    eventId: x.eventId
                }), await this.client.core.pairing.updateMetadata({
                    topic: g,
                    metadata: m.metadata
                }), await this.deleteProposal(o), await this.client.core.pairing.activate({
                    topic: g
                }), await this.setExpiry(b, an(ou)), {
                    topic: b,
                    acknowledged: () => Promise.resolve(this.client.session.get(b))
                }
            }), Ce(this, "reject", async r => {
                this.isInitialized(), await this.confirmOnlineStateOrThrow();
                try {
                    await this.isValidReject(r)
                } catch (a) {
                    throw this.client.logger.error("reject() -> isValidReject() failed"), a
                }
                const {
                    id: n,
                    reason: i
                } = r;
                let s;
                try {
                    s = this.client.proposal.get(n).pairingTopic
                } catch (a) {
                    throw this.client.logger.error(`reject() -> proposal.get(${n}) failed`), a
                }
                s && await this.sendError({
                    id: n,
                    topic: s,
                    error: i,
                    rpcOpts: un.wc_sessionPropose.reject
                }), await this.deleteProposal(n)
            }), Ce(this, "update", async r => {
                this.isInitialized(), await this.confirmOnlineStateOrThrow();
                try {
                    await this.isValidUpdate(r)
                } catch (h) {
                    throw this.client.logger.error("update() -> isValidUpdate() failed"), h
                }
                const {
                    topic: n,
                    namespaces: i
                } = r, {
                    done: s,
                    resolve: a,
                    reject: o
                } = $l(), c = Za(), l = Gl().toString(), u = this.client.session.get(n).namespaces;
                return this.events.once(rr("session_update", c), ({
                    error: h
                }) => {
                    h ? o(h) : a()
                }), await this.client.session.update(n, {
                    namespaces: i
                }), await this.sendRequest({
                    topic: n,
                    method: "wc_sessionUpdate",
                    params: {
                        namespaces: i
                    },
                    throwOnFailedPublish: !0,
                    clientRpcId: c,
                    relayRpcId: l
                }).catch(h => {
                    this.client.logger.error(h), this.client.session.update(n, {
                        namespaces: u
                    }), o(h)
                }), {
                    acknowledged: s
                }
            }), Ce(this, "extend", async r => {
                this.isInitialized(), await this.confirmOnlineStateOrThrow();
                try {
                    await this.isValidExtend(r)
                } catch (c) {
                    throw this.client.logger.error("extend() -> isValidExtend() failed"), c
                }
                const {
                    topic: n
                } = r, i = Za(), {
                    done: s,
                    resolve: a,
                    reject: o
                } = $l();
                return this.events.once(rr("session_extend", i), ({
                    error: c
                }) => {
                    c ? o(c) : a()
                }), await this.setExpiry(n, an(ou)), this.sendRequest({
                    topic: n,
                    method: "wc_sessionExtend",
                    params: {},
                    clientRpcId: i,
                    throwOnFailedPublish: !0
                }).catch(c => {
                    o(c)
                }), {
                    acknowledged: s
                }
            }), Ce(this, "request", async r => {
                this.isInitialized();
                try {
                    await this.isValidRequest(r)
                } catch (y) {
                    throw this.client.logger.error("request() -> isValidRequest() failed"), y
                }
                const {
                    chainId: n,
                    request: i,
                    topic: s,
                    expiry: a = un.wc_sessionRequest.req.ttl
                } = r, o = this.client.session.get(s);
                (o == null ? void 0 : o.transportType) === Er.relay && await this.confirmOnlineStateOrThrow();
                const c = Za(),
                    l = Gl().toString(),
                    {
                        done: u,
                        resolve: h,
                        reject: f
                    } = $l(a, "Request expired. Please try again.");
                this.events.once(rr("session_request", c), ({
                    error: y,
                    result: w
                }) => {
                    y ? f(y) : h(w)
                });
                const p = "wc_sessionRequest",
                    g = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);
                if (g) return await this.sendRequest({
                    clientRpcId: c,
                    relayRpcId: l,
                    topic: s,
                    method: p,
                    params: {
                        request: Ai(vr({}, i), {
                            expiryTimestamp: an(a)
                        }),
                        chainId: n
                    },
                    expiry: a,
                    throwOnFailedPublish: !0,
                    appLink: g
                }).catch(y => f(y)), this.client.events.emit("session_request_sent", {
                    topic: s,
                    request: i,
                    chainId: n,
                    id: c
                }), await u();
                const m = {
                    request: Ai(vr({}, i), {
                        expiryTimestamp: an(a)
                    }),
                    chainId: n
                };
                return await Promise.all([new Promise(async y => {
                    await this.sendRequest({
                        clientRpcId: c,
                        relayRpcId: l,
                        topic: s,
                        method: p,
                        params: m,
                        expiry: a,
                        throwOnFailedPublish: !0,
                        tvf: this.getTVFParams(c, m)
                    }).catch(w => f(w)), this.client.events.emit("session_request_sent", {
                        topic: s,
                        request: i,
                        chainId: n,
                        id: c
                    }), y()
                }), new Promise(async y => {
                    var w;
                    if (!((w = o.sessionConfig) != null && w.disableDeepLink)) {
                        const x = await X1e(this.client.core.storage, zk);
                        await Z1e({
                            id: c,
                            topic: s,
                            wcDeepLink: x
                        })
                    }
                    y()
                }), u()]).then(y => y[2])
            }), Ce(this, "respond", async r => {
                this.isInitialized(), await this.isValidRespond(r);
                const {
                    topic: n,
                    response: i
                } = r, {
                    id: s
                } = i, a = this.client.session.get(n);
                a.transportType === Er.relay && await this.confirmOnlineStateOrThrow();
                const o = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
                Ja(i) ? await this.sendResult({
                    id: s,
                    topic: n,
                    result: i.result,
                    throwOnFailedPublish: !0,
                    appLink: o
                }) : Is(i) && await this.sendError({
                    id: s,
                    topic: n,
                    error: i.error,
                    appLink: o
                }), this.cleanupAfterResponse(r)
            }), Ce(this, "ping", async r => {
                this.isInitialized(), await this.confirmOnlineStateOrThrow();
                try {
                    await this.isValidPing(r)
                } catch (i) {
                    throw this.client.logger.error("ping() -> isValidPing() failed"), i
                }
                const {
                    topic: n
                } = r;
                if (this.client.session.keys.includes(n)) {
                    const i = Za(),
                        s = Gl().toString(),
                        {
                            done: a,
                            resolve: o,
                            reject: c
                        } = $l();
                    this.events.once(rr("session_ping", i), ({
                        error: l
                    }) => {
                        l ? c(l) : o()
                    }), await Promise.all([this.sendRequest({
                        topic: n,
                        method: "wc_sessionPing",
                        params: {},
                        throwOnFailedPublish: !0,
                        clientRpcId: i,
                        relayRpcId: s
                    }), a()])
                } else this.client.core.pairing.pairings.keys.includes(n) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({
                    topic: n
                }))
            }), Ce(this, "emit", async r => {
                this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(r);
                const {
                    topic: n,
                    event: i,
                    chainId: s
                } = r, a = Gl().toString(), o = Za();
                await this.sendRequest({
                    topic: n,
                    method: "wc_sessionEvent",
                    params: {
                        event: i,
                        chainId: s
                    },
                    throwOnFailedPublish: !0,
                    relayRpcId: a,
                    clientRpcId: o
                })
            }), Ce(this, "disconnect", async r => {
                this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(r);
                const {
                    topic: n
                } = r;
                if (this.client.session.keys.includes(n)) await this.sendRequest({
                    topic: n,
                    method: "wc_sessionDelete",
                    params: _r("USER_DISCONNECTED"),
                    throwOnFailedPublish: !0
                }), await this.deleteSession({
                    topic: n,
                    emitEvent: !1
                });
                else if (this.client.core.pairing.pairings.keys.includes(n)) await this.client.core.pairing.disconnect({
                    topic: n
                });
                else {
                    const {
                        message: i
                    } = je("MISMATCHED_TOPIC", `Session or pairing topic not found: ${n}`);
                    throw new Error(i)
                }
            }), Ce(this, "find", r => (this.isInitialized(), this.client.session.getAll().filter(n => cbe(n, r)))), Ce(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), Ce(this, "authenticate", async (r, n) => {
                var i;
                this.isInitialized(), this.isValidAuthenticate(r);
                const s = n && this.client.core.linkModeSupportedApps.includes(n) && ((i = this.client.metadata.redirect) == null ? void 0 : i.linkMode),
                    a = s ? Er.link_mode : Er.relay;
                a === Er.relay && await this.confirmOnlineStateOrThrow();
                const {
                    chains: o,
                    statement: c = "",
                    uri: l,
                    domain: u,
                    nonce: h,
                    type: f,
                    exp: p,
                    nbf: g,
                    methods: m = [],
                    expiry: y
                } = r, w = [...r.resources || []], {
                    topic: x,
                    uri: E
                } = await this.client.core.pairing.create({
                    methods: ["wc_sessionAuthenticate"],
                    transportType: a
                });
                this.client.logger.info({
                    message: "Generated new pairing",
                    pairing: {
                        topic: x,
                        uri: E
                    }
                });
                const _ = await this.client.core.crypto.generateKeyPair(),
                    b = em(_);
                if (await Promise.all([this.client.auth.authKeys.set(im, {
                        responseTopic: b,
                        publicKey: _
                    }), this.client.auth.pairingTopics.set(b, {
                        topic: b,
                        pairingTopic: x
                    })]), await this.client.core.relayer.subscribe(b, {
                        transportType: a
                    }), this.client.logger.info(`sending request to new pairing topic: ${x}`), m.length > 0) {
                    const {
                        namespace: k
                    } = zu(o[0]);
                    let F = gwe(k, "request", m);
                    Xg(w) && (F = ywe(F, w.pop())), w.push(F)
                }
                const A = y && y > un.wc_sessionAuthenticate.req.ttl ? y : un.wc_sessionAuthenticate.req.ttl,
                    I = {
                        authPayload: {
                            type: f ? ? "caip122",
                            chains: o,
                            statement: c,
                            aud: l,
                            domain: u,
                            version: "1",
                            nonce: h,
                            iat: new Date().toISOString(),
                            exp: p,
                            nbf: g,
                            resources: w
                        },
                        requester: {
                            publicKey: _,
                            metadata: this.client.metadata
                        },
                        expiryTimestamp: an(A)
                    },
                    T = {
                        eip155: {
                            chains: o,
                            methods: [...new Set(["personal_sign", ...m])],
                            events: ["chainChanged", "accountsChanged"]
                        }
                    },
                    C = {
                        requiredNamespaces: {},
                        optionalNamespaces: T,
                        relays: [{
                            protocol: "irn"
                        }],
                        pairingTopic: x,
                        proposer: {
                            publicKey: _,
                            metadata: this.client.metadata
                        },
                        expiryTimestamp: an(un.wc_sessionPropose.req.ttl),
                        id: Za()
                    },
                    {
                        done: $,
                        resolve: P,
                        reject: N
                    } = $l(A, "Request expired"),
                    R = Za(),
                    D = rr("session_connect", C.id),
                    S = rr("session_request", R),
                    O = async ({
                        error: k,
                        session: F
                    }) => {
                        this.events.off(S, M), k ? N(k) : F && P({
                            session: F
                        })
                    },
                    M = async k => {
                        var F, q, W;
                        if (await this.deletePendingAuthRequest(R, {
                                message: "fulfilled",
                                code: 0
                            }), k.error) {
                            const ne = _r("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
                            return k.error.code === ne.code ? void 0 : (this.events.off(D, O), N(k.error.message))
                        }
                        await this.deleteProposal(C.id), this.events.off(D, O);
                        const {
                            cacaos: K,
                            responder: H
                        } = k.result, j = [], V = [];
                        for (const ne of K) {
                            await xA({
                                cacao: ne,
                                projectId: this.client.core.projectId
                            }) || (this.client.logger.error(ne, "Signature verification failed"), N(_r("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
                            const {
                                p: ae
                            } = ne, ue = Xg(ae.resources), he = [S5(ae.iss)], fe = Qm(ae.iss);
                            if (ue) {
                                const de = EA(ue),
                                    ye = _A(ue);
                                j.push(...de), he.push(...ye)
                            }
                            for (const de of he) V.push(`${de}:${fe}`)
                        }
                        const Y = await this.client.core.crypto.generateSharedKey(_, H.publicKey);
                        let X;
                        j.length > 0 && (X = {
                            topic: Y,
                            acknowledged: !0,
                            self: {
                                publicKey: _,
                                metadata: this.client.metadata
                            },
                            peer: H,
                            controller: H.publicKey,
                            expiry: an(ou),
                            requiredNamespaces: {},
                            optionalNamespaces: {},
                            relay: {
                                protocol: "irn"
                            },
                            pairingTopic: x,
                            namespaces: GA([...new Set(j)], [...new Set(V)]),
                            transportType: a
                        }, await this.client.core.relayer.subscribe(Y, {
                            transportType: a
                        }), await this.client.session.set(Y, X), x && await this.client.core.pairing.updateMetadata({
                            topic: x,
                            metadata: H.metadata
                        }), X = this.client.session.get(Y)), (F = this.client.metadata.redirect) != null && F.linkMode && (q = H.metadata.redirect) != null && q.linkMode && (W = H.metadata.redirect) != null && W.universal && n && (this.client.core.addLinkModeSupportedApp(H.metadata.redirect.universal), this.client.session.update(Y, {
                            transportType: Er.link_mode
                        })), P({
                            auths: K,
                            session: X
                        })
                    };
                this.events.once(D, O), this.events.once(S, M);
                let U;
                try {
                    if (s) {
                        const k = Zc("wc_sessionAuthenticate", I, R);
                        this.client.core.history.set(x, k);
                        const F = await this.client.core.crypto.encode("", k, {
                            type: k0,
                            encoding: zc
                        });
                        U = xg(n, x, F)
                    } else await Promise.all([this.sendRequest({
                        topic: x,
                        method: "wc_sessionAuthenticate",
                        params: I,
                        expiry: r.expiry,
                        throwOnFailedPublish: !0,
                        clientRpcId: R
                    }), this.sendRequest({
                        topic: x,
                        method: "wc_sessionPropose",
                        params: C,
                        expiry: un.wc_sessionPropose.req.ttl,
                        throwOnFailedPublish: !0,
                        clientRpcId: C.id
                    })])
                } catch (k) {
                    throw this.events.off(D, O), this.events.off(S, M), k
                }
                return await this.setProposal(C.id, C), await this.setAuthRequest(R, {
                    request: Ai(vr({}, I), {
                        verifyContext: {}
                    }),
                    pairingTopic: x,
                    transportType: a
                }), {
                    uri: U ? ? E,
                    response: $
                }
            }), Ce(this, "approveSessionAuthenticate", async r => {
                const {
                    id: n,
                    auths: i
                } = r, s = this.client.core.eventClient.createEvent({
                    properties: {
                        topic: n.toString(),
                        trace: [Al.authenticated_session_approve_started]
                    }
                });
                try {
                    this.isInitialized()
                } catch (y) {
                    throw s.setError(af.no_internet_connection), y
                }
                const a = this.getPendingAuthRequest(n);
                if (!a) throw s.setError(af.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${n}`);
                const o = a.transportType || Er.relay;
                o === Er.relay && await this.confirmOnlineStateOrThrow();
                const c = a.requester.publicKey,
                    l = await this.client.core.crypto.generateKeyPair(),
                    u = em(c),
                    h = {
                        type: Ko,
                        receiverPublicKey: c,
                        senderPublicKey: l
                    },
                    f = [],
                    p = [];
                for (const y of i) {
                    if (!await xA({
                            cacao: y,
                            projectId: this.client.core.projectId
                        })) {
                        s.setError(af.invalid_cacao);
                        const b = _r("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
                        throw await this.sendError({
                            id: n,
                            topic: u,
                            error: b,
                            encodeOpts: h
                        }), new Error(b.message)
                    }
                    s.addTrace(Al.cacaos_verified);
                    const {
                        p: w
                    } = y, x = Xg(w.resources), E = [S5(w.iss)], _ = Qm(w.iss);
                    if (x) {
                        const b = EA(x),
                            A = _A(x);
                        f.push(...b), E.push(...A)
                    }
                    for (const b of E) p.push(`${b}:${_}`)
                }
                const g = await this.client.core.crypto.generateSharedKey(l, c);
                s.addTrace(Al.create_authenticated_session_topic);
                let m;
                if ((f == null ? void 0 : f.length) > 0) {
                    m = {
                        topic: g,
                        acknowledged: !0,
                        self: {
                            publicKey: l,
                            metadata: this.client.metadata
                        },
                        peer: {
                            publicKey: c,
                            metadata: a.requester.metadata
                        },
                        controller: c,
                        expiry: an(ou),
                        authentication: i,
                        requiredNamespaces: {},
                        optionalNamespaces: {},
                        relay: {
                            protocol: "irn"
                        },
                        pairingTopic: a.pairingTopic,
                        namespaces: GA([...new Set(f)], [...new Set(p)]),
                        transportType: o
                    }, s.addTrace(Al.subscribing_authenticated_session_topic);
                    try {
                        await this.client.core.relayer.subscribe(g, {
                            transportType: o
                        })
                    } catch (y) {
                        throw s.setError(af.subscribe_authenticated_session_topic_failure), y
                    }
                    s.addTrace(Al.subscribe_authenticated_session_topic_success), await this.client.session.set(g, m), s.addTrace(Al.store_authenticated_session), await this.client.core.pairing.updateMetadata({
                        topic: a.pairingTopic,
                        metadata: a.requester.metadata
                    })
                }
                s.addTrace(Al.publishing_authenticated_session_approve);
                try {
                    await this.sendResult({
                        topic: u,
                        id: n,
                        result: {
                            cacaos: i,
                            responder: {
                                publicKey: l,
                                metadata: this.client.metadata
                            }
                        },
                        encodeOpts: h,
                        throwOnFailedPublish: !0,
                        appLink: this.getAppLinkIfEnabled(a.requester.metadata, o)
                    })
                } catch (y) {
                    throw s.setError(af.authenticated_session_approve_publish_failure), y
                }
                return await this.client.auth.requests.delete(n, {
                    message: "fulfilled",
                    code: 0
                }), await this.client.core.pairing.activate({
                    topic: a.pairingTopic
                }), this.client.core.eventClient.deleteEvent({
                    eventId: s.eventId
                }), {
                    session: m
                }
            }), Ce(this, "rejectSessionAuthenticate", async r => {
                this.isInitialized();
                const {
                    id: n,
                    reason: i
                } = r, s = this.getPendingAuthRequest(n);
                if (!s) throw new Error(`Could not find pending auth request with id ${n}`);
                s.transportType === Er.relay && await this.confirmOnlineStateOrThrow();
                const a = s.requester.publicKey,
                    o = await this.client.core.crypto.generateKeyPair(),
                    c = em(a),
                    l = {
                        type: Ko,
                        receiverPublicKey: a,
                        senderPublicKey: o
                    };
                await this.sendError({
                    id: n,
                    topic: c,
                    error: i,
                    encodeOpts: l,
                    rpcOpts: un.wc_sessionAuthenticate.reject,
                    appLink: this.getAppLinkIfEnabled(s.requester.metadata, s.transportType)
                }), await this.client.auth.requests.delete(n, {
                    message: "rejected",
                    code: 0
                }), await this.deleteProposal(n)
            }), Ce(this, "formatAuthMessage", r => {
                this.isInitialized();
                const {
                    request: n,
                    iss: i
                } = r;
                return pD(n, i)
            }), Ce(this, "processRelayMessageCache", () => {
                setTimeout(async () => {
                    if (this.relayMessageCache.length !== 0)
                        for (; this.relayMessageCache.length > 0;) try {
                            const r = this.relayMessageCache.shift();
                            r && await this.onRelayMessage(r)
                        } catch (r) {
                            this.client.logger.error(r)
                        }
                }, 50)
            }), Ce(this, "cleanupDuplicatePairings", async r => {
                if (r.pairingTopic) try {
                    const n = this.client.core.pairing.pairings.get(r.pairingTopic),
                        i = this.client.core.pairing.pairings.getAll().filter(s => {
                            var a, o;
                            return ((a = s.peerMetadata) == null ? void 0 : a.url) && ((o = s.peerMetadata) == null ? void 0 : o.url) === r.peer.metadata.url && s.topic && s.topic !== n.topic
                        });
                    if (i.length === 0) return;
                    this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`), await Promise.all(i.map(s => this.client.core.pairing.disconnect({
                        topic: s.topic
                    }))), this.client.logger.info("Duplicate pairings clean up finished")
                } catch (n) {
                    this.client.logger.error(n)
                }
            }), Ce(this, "deleteSession", async r => {
                var n;
                const {
                    topic: i,
                    expirerHasDeleted: s = !1,
                    emitEvent: a = !0,
                    id: o = 0
                } = r, {
                    self: c
                } = this.client.session.get(i);
                await this.client.core.relayer.unsubscribe(i), await this.client.session.delete(i, _r("USER_DISCONNECTED")), this.addToRecentlyDeleted(i, "session"), this.client.core.crypto.keychain.has(c.publicKey) && await this.client.core.crypto.deleteKeyPair(c.publicKey), this.client.core.crypto.keychain.has(i) && await this.client.core.crypto.deleteSymKey(i), s || this.client.core.expirer.del(i), this.client.core.storage.removeItem(zk).catch(l => this.client.logger.warn(l)), this.getPendingSessionRequests().forEach(l => {
                    l.topic === i && this.deletePendingSessionRequest(l.id, _r("USER_DISCONNECTED"))
                }), i === ((n = this.sessionRequestQueue.queue[0]) == null ? void 0 : n.topic) && (this.sessionRequestQueue.state = za.idle), a && this.client.events.emit("session_delete", {
                    id: o,
                    topic: i
                })
            }), Ce(this, "deleteProposal", async (r, n) => {
                if (n) try {
                    const i = this.client.proposal.get(r),
                        s = this.client.core.eventClient.getEvent({
                            topic: i.pairingTopic
                        });
                    s == null || s.setError(Cl.proposal_expired)
                } catch {}
                await Promise.all([this.client.proposal.delete(r, _r("USER_DISCONNECTED")), n ? Promise.resolve() : this.client.core.expirer.del(r)]), this.addToRecentlyDeleted(r, "proposal")
            }), Ce(this, "deletePendingSessionRequest", async (r, n, i = !1) => {
                await Promise.all([this.client.pendingRequest.delete(r, n), i ? Promise.resolve() : this.client.core.expirer.del(r)]), this.addToRecentlyDeleted(r, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(s => s.id !== r), i && (this.sessionRequestQueue.state = za.idle, this.client.events.emit("session_request_expire", {
                    id: r
                }))
            }), Ce(this, "deletePendingAuthRequest", async (r, n, i = !1) => {
                await Promise.all([this.client.auth.requests.delete(r, n), i ? Promise.resolve() : this.client.core.expirer.del(r)])
            }), Ce(this, "setExpiry", async (r, n) => {
                this.client.session.keys.includes(r) && (this.client.core.expirer.set(r, n), await this.client.session.update(r, {
                    expiry: n
                }))
            }), Ce(this, "setProposal", async (r, n) => {
                this.client.core.expirer.set(r, an(un.wc_sessionPropose.req.ttl)), await this.client.proposal.set(r, n)
            }), Ce(this, "setAuthRequest", async (r, n) => {
                const {
                    request: i,
                    pairingTopic: s,
                    transportType: a = Er.relay
                } = n;
                this.client.core.expirer.set(r, i.expiryTimestamp), await this.client.auth.requests.set(r, {
                    authPayload: i.authPayload,
                    requester: i.requester,
                    expiryTimestamp: i.expiryTimestamp,
                    id: r,
                    pairingTopic: s,
                    verifyContext: i.verifyContext,
                    transportType: a
                })
            }), Ce(this, "setPendingSessionRequest", async r => {
                const {
                    id: n,
                    topic: i,
                    params: s,
                    verifyContext: a
                } = r, o = s.request.expiryTimestamp || an(un.wc_sessionRequest.req.ttl);
                this.client.core.expirer.set(n, o), await this.client.pendingRequest.set(n, {
                    id: n,
                    topic: i,
                    params: s,
                    verifyContext: a
                })
            }), Ce(this, "sendRequest", async r => {
                const {
                    topic: n,
                    method: i,
                    params: s,
                    expiry: a,
                    relayRpcId: o,
                    clientRpcId: c,
                    throwOnFailedPublish: l,
                    appLink: u,
                    tvf: h
                } = r, f = Zc(i, s, c);
                let p;
                const g = !!u;
                try {
                    const w = g ? zc : ga;
                    p = await this.client.core.crypto.encode(n, f, {
                        encoding: w
                    })
                } catch (w) {
                    throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${n} failed`), w
                }
                let m;
                if (Lxe.includes(i)) {
                    const w = eo(JSON.stringify(f)),
                        x = eo(p);
                    m = await this.client.core.verify.register({
                        id: x,
                        decryptedId: w
                    })
                }
                const y = un[i].req;
                if (y.attestation = m, a && (y.ttl = a), o && (y.id = o), this.client.core.history.set(n, f), g) {
                    const w = xg(u, n, p);
                    await globalThis.Linking.openURL(w, this.client.name)
                } else {
                    const w = un[i].req;
                    a && (w.ttl = a), o && (w.id = o), w.tvf = Ai(vr({}, h), {
                        correlationId: f.id
                    }), l ? (w.internal = Ai(vr({}, w.internal), {
                        throwOnFailedPublish: !0
                    }), await this.client.core.relayer.publish(n, p, w)) : this.client.core.relayer.publish(n, p, w).catch(x => this.client.logger.error(x))
                }
                return f.id
            }), Ce(this, "sendResult", async r => {
                const {
                    id: n,
                    topic: i,
                    result: s,
                    throwOnFailedPublish: a,
                    encodeOpts: o,
                    appLink: c
                } = r, l = Dy(n, s);
                let u;
                const h = c && typeof(globalThis == null ? void 0 : globalThis.Linking) < "u";
                try {
                    const g = h ? zc : ga;
                    u = await this.client.core.crypto.encode(i, l, Ai(vr({}, o || {}), {
                        encoding: g
                    }))
                } catch (g) {
                    throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`), g
                }
                let f, p;
                try {
                    f = await this.client.core.history.get(i, n);
                    const g = f.request;
                    try {
                        p = this.getTVFParams(n, g.params, s)
                    } catch (m) {
                        this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${m==null?void 0:m.message}`)
                    }
                } catch (g) {
                    throw this.client.logger.error(`sendResult() -> history.get(${i}, ${n}) failed`), g
                }
                if (h) {
                    const g = xg(c, i, u);
                    await globalThis.Linking.openURL(g, this.client.name)
                } else {
                    const g = f.request.method,
                        m = un[g].res;
                    m.tvf = Ai(vr({}, p), {
                        correlationId: n
                    }), a ? (m.internal = Ai(vr({}, m.internal), {
                        throwOnFailedPublish: !0
                    }), await this.client.core.relayer.publish(i, u, m)) : this.client.core.relayer.publish(i, u, m).catch(y => this.client.logger.error(y))
                }
                await this.client.core.history.resolve(l)
            }), Ce(this, "sendError", async r => {
                const {
                    id: n,
                    topic: i,
                    error: s,
                    encodeOpts: a,
                    rpcOpts: o,
                    appLink: c
                } = r, l = Ly(n, s);
                let u;
                const h = c && typeof(globalThis == null ? void 0 : globalThis.Linking) < "u";
                try {
                    const p = h ? zc : ga;
                    u = await this.client.core.crypto.encode(i, l, Ai(vr({}, a || {}), {
                        encoding: p
                    }))
                } catch (p) {
                    throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`), p
                }
                let f;
                try {
                    f = await this.client.core.history.get(i, n)
                } catch (p) {
                    throw this.client.logger.error(`sendError() -> history.get(${i}, ${n}) failed`), p
                }
                if (h) {
                    const p = xg(c, i, u);
                    await globalThis.Linking.openURL(p, this.client.name)
                } else {
                    const p = f.request.method,
                        g = o || un[p].res;
                    this.client.core.relayer.publish(i, u, g)
                }
                await this.client.core.history.resolve(l)
            }), Ce(this, "cleanup", async () => {
                const r = [],
                    n = [];
                this.client.session.getAll().forEach(i => {
                    let s = !1;
                    jc(i.expiry) && (s = !0), this.client.core.crypto.keychain.has(i.topic) || (s = !0), s && r.push(i.topic)
                }), this.client.proposal.getAll().forEach(i => {
                    jc(i.expiryTimestamp) && n.push(i.id)
                }), await Promise.all([...r.map(i => this.deleteSession({
                    topic: i
                })), ...n.map(i => this.deleteProposal(i))])
            }), Ce(this, "onProviderMessageEvent", async r => {
                !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(r) : await this.onRelayMessage(r)
            }), Ce(this, "onRelayEventRequest", async r => {
                this.requestQueue.queue.push(r), await this.processRequestsQueue()
            }), Ce(this, "processRequestsQueue", async () => {
                if (this.requestQueue.state === za.active) {
                    this.client.logger.info("Request queue already active, skipping...");
                    return
                }
                for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {
                    this.requestQueue.state = za.active;
                    const r = this.requestQueue.queue.shift();
                    if (r) try {
                        await this.processRequest(r)
                    } catch (n) {
                        this.client.logger.warn(n)
                    }
                }
                this.requestQueue.state = za.idle
            }), Ce(this, "processRequest", async r => {
                const {
                    topic: n,
                    payload: i,
                    attestation: s,
                    transportType: a,
                    encryptedId: o
                } = r, c = i.method;
                if (!this.shouldIgnorePairingRequest({
                        topic: n,
                        requestMethod: c
                    })) switch (c) {
                    case "wc_sessionPropose":
                        return await this.onSessionProposeRequest({
                            topic: n,
                            payload: i,
                            attestation: s,
                            encryptedId: o
                        });
                    case "wc_sessionSettle":
                        return await this.onSessionSettleRequest(n, i);
                    case "wc_sessionUpdate":
                        return await this.onSessionUpdateRequest(n, i);
                    case "wc_sessionExtend":
                        return await this.onSessionExtendRequest(n, i);
                    case "wc_sessionPing":
                        return await this.onSessionPingRequest(n, i);
                    case "wc_sessionDelete":
                        return await this.onSessionDeleteRequest(n, i);
                    case "wc_sessionRequest":
                        return await this.onSessionRequest({
                            topic: n,
                            payload: i,
                            attestation: s,
                            encryptedId: o,
                            transportType: a
                        });
                    case "wc_sessionEvent":
                        return await this.onSessionEventRequest(n, i);
                    case "wc_sessionAuthenticate":
                        return await this.onSessionAuthenticateRequest({
                            topic: n,
                            payload: i,
                            attestation: s,
                            encryptedId: o,
                            transportType: a
                        });
                    default:
                        return this.client.logger.info(`Unsupported request method ${c}`)
                }
            }), Ce(this, "onRelayEventResponse", async r => {
                const {
                    topic: n,
                    payload: i,
                    transportType: s
                } = r, a = (await this.client.core.history.get(n, i.id)).request.method;
                switch (a) {
                    case "wc_sessionPropose":
                        return this.onSessionProposeResponse(n, i, s);
                    case "wc_sessionSettle":
                        return this.onSessionSettleResponse(n, i);
                    case "wc_sessionUpdate":
                        return this.onSessionUpdateResponse(n, i);
                    case "wc_sessionExtend":
                        return this.onSessionExtendResponse(n, i);
                    case "wc_sessionPing":
                        return this.onSessionPingResponse(n, i);
                    case "wc_sessionRequest":
                        return this.onSessionRequestResponse(n, i);
                    case "wc_sessionAuthenticate":
                        return this.onSessionAuthenticateResponse(n, i);
                    default:
                        return this.client.logger.info(`Unsupported response method ${a}`)
                }
            }), Ce(this, "onRelayEventUnknownPayload", r => {
                const {
                    topic: n
                } = r, {
                    message: i
                } = je("MISSING_OR_INVALID", `Decoded payload on topic ${n} is not identifiable as a JSON-RPC request or a response.`);
                throw new Error(i)
            }), Ce(this, "shouldIgnorePairingRequest", r => {
                const {
                    topic: n,
                    requestMethod: i
                } = r, s = this.expectedPairingMethodMap.get(n);
                return !s || s.includes(i) ? !1 : !!(s.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0)
            }), Ce(this, "onSessionProposeRequest", async r => {
                const {
                    topic: n,
                    payload: i,
                    attestation: s,
                    encryptedId: a
                } = r, {
                    params: o,
                    id: c
                } = i;
                try {
                    const l = this.client.core.eventClient.getEvent({
                        topic: n
                    });
                    this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l == null || l.setError(Po.proposal_listener_not_found)), this.isValidConnect(vr({}, i.params));
                    const u = o.expiryTimestamp || an(un.wc_sessionPropose.req.ttl),
                        h = vr({
                            id: c,
                            pairingTopic: n,
                            expiryTimestamp: u,
                            attestation: s,
                            encryptedId: a
                        }, o);
                    await this.setProposal(c, h);
                    const f = await this.getVerifyContext({
                        attestationId: s,
                        hash: eo(JSON.stringify(i)),
                        encryptedId: a,
                        metadata: h.proposer.metadata
                    });
                    l == null || l.addTrace(Ka.emit_session_proposal), this.client.events.emit("session_proposal", {
                        id: c,
                        params: h,
                        verifyContext: f
                    })
                } catch (l) {
                    await this.sendError({
                        id: c,
                        topic: n,
                        error: l,
                        rpcOpts: un.wc_sessionPropose.autoReject
                    }), this.client.logger.error(l)
                }
            }), Ce(this, "onSessionProposeResponse", async (r, n, i) => {
                const {
                    id: s
                } = n;
                if (Ja(n)) {
                    const {
                        result: a
                    } = n;
                    this.client.logger.trace({
                        type: "method",
                        method: "onSessionProposeResponse",
                        result: a
                    });
                    const o = this.client.proposal.get(s);
                    this.client.logger.trace({
                        type: "method",
                        method: "onSessionProposeResponse",
                        proposal: o
                    });
                    const c = o.proposer.publicKey;
                    this.client.logger.trace({
                        type: "method",
                        method: "onSessionProposeResponse",
                        selfPublicKey: c
                    });
                    const l = a.responderPublicKey;
                    this.client.logger.trace({
                        type: "method",
                        method: "onSessionProposeResponse",
                        peerPublicKey: l
                    });
                    const u = await this.client.core.crypto.generateSharedKey(c, l);
                    this.pendingSessions.set(s, {
                        sessionTopic: u,
                        pairingTopic: r,
                        proposalId: s,
                        publicKey: c
                    });
                    const h = await this.client.core.relayer.subscribe(u, {
                        transportType: i
                    });
                    this.client.logger.trace({
                        type: "method",
                        method: "onSessionProposeResponse",
                        subscriptionId: h
                    }), await this.client.core.pairing.activate({
                        topic: r
                    })
                } else if (Is(n)) {
                    await this.deleteProposal(s);
                    const a = rr("session_connect", s);
                    if (this.events.listenerCount(a) === 0) throw new Error(`emitting ${a} without any listeners, 954`);
                    this.events.emit(a, {
                        error: n.error
                    })
                }
            }), Ce(this, "onSessionSettleRequest", async (r, n) => {
                const {
                    id: i,
                    params: s
                } = n;
                try {
                    this.isValidSessionSettleRequest(s);
                    const {
                        relay: a,
                        controller: o,
                        expiry: c,
                        namespaces: l,
                        sessionProperties: u,
                        scopedProperties: h,
                        sessionConfig: f
                    } = n.params, p = [...this.pendingSessions.values()].find(y => y.sessionTopic === r);
                    if (!p) return this.client.logger.error(`Pending session not found for topic ${r}`);
                    const g = this.client.proposal.get(p.proposalId),
                        m = Ai(vr(vr(vr({
                            topic: r,
                            relay: a,
                            expiry: c,
                            namespaces: l,
                            acknowledged: !0,
                            pairingTopic: p.pairingTopic,
                            requiredNamespaces: g.requiredNamespaces,
                            optionalNamespaces: g.optionalNamespaces,
                            controller: o.publicKey,
                            self: {
                                publicKey: p.publicKey,
                                metadata: this.client.metadata
                            },
                            peer: {
                                publicKey: o.publicKey,
                                metadata: o.metadata
                            }
                        }, u && {
                            sessionProperties: u
                        }), h && {
                            scopedProperties: h
                        }), f && {
                            sessionConfig: f
                        }), {
                            transportType: Er.relay
                        });
                    await this.client.session.set(m.topic, m), await this.setExpiry(m.topic, m.expiry), await this.client.core.pairing.updateMetadata({
                        topic: p.pairingTopic,
                        metadata: m.peer.metadata
                    }), this.client.events.emit("session_connect", {
                        session: m
                    }), this.events.emit(rr("session_connect", p.proposalId), {
                        session: m
                    }), this.pendingSessions.delete(p.proposalId), this.deleteProposal(p.proposalId, !1), this.cleanupDuplicatePairings(m), await this.sendResult({
                        id: n.id,
                        topic: r,
                        result: !0
                    })
                } catch (a) {
                    await this.sendError({
                        id: i,
                        topic: r,
                        error: a
                    }), this.client.logger.error(a)
                }
            }), Ce(this, "onSessionSettleResponse", async (r, n) => {
                const {
                    id: i
                } = n;
                Ja(n) ? (await this.client.session.update(r, {
                    acknowledged: !0
                }), this.events.emit(rr("session_approve", i), {})) : Is(n) && (await this.client.session.delete(r, _r("USER_DISCONNECTED")), this.events.emit(rr("session_approve", i), {
                    error: n.error
                }))
            }), Ce(this, "onSessionUpdateRequest", async (r, n) => {
                const {
                    params: i,
                    id: s
                } = n;
                try {
                    const a = `${r}_session_update`,
                        o = nf.get(a);
                    if (o && this.isRequestOutOfSync(o, s)) {
                        this.client.logger.warn(`Discarding out of sync request - ${s}`), this.sendError({
                            id: s,
                            topic: r,
                            error: _r("INVALID_UPDATE_REQUEST")
                        });
                        return
                    }
                    this.isValidUpdate(vr({
                        topic: r
                    }, i));
                    try {
                        nf.set(a, s), await this.client.session.update(r, {
                            namespaces: i.namespaces
                        }), await this.sendResult({
                            id: s,
                            topic: r,
                            result: !0
                        })
                    } catch (c) {
                        throw nf.delete(a), c
                    }
                    this.client.events.emit("session_update", {
                        id: s,
                        topic: r,
                        params: i
                    })
                } catch (a) {
                    await this.sendError({
                        id: s,
                        topic: r,
                        error: a
                    }), this.client.logger.error(a)
                }
            }), Ce(this, "isRequestOutOfSync", (r, n) => n.toString().slice(0, -3) < r.toString().slice(0, -3)), Ce(this, "onSessionUpdateResponse", (r, n) => {
                const {
                    id: i
                } = n, s = rr("session_update", i);
                if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
                Ja(n) ? this.events.emit(rr("session_update", i), {}) : Is(n) && this.events.emit(rr("session_update", i), {
                    error: n.error
                })
            }), Ce(this, "onSessionExtendRequest", async (r, n) => {
                const {
                    id: i
                } = n;
                try {
                    this.isValidExtend({
                        topic: r
                    }), await this.setExpiry(r, an(ou)), await this.sendResult({
                        id: i,
                        topic: r,
                        result: !0
                    }), this.client.events.emit("session_extend", {
                        id: i,
                        topic: r
                    })
                } catch (s) {
                    await this.sendError({
                        id: i,
                        topic: r,
                        error: s
                    }), this.client.logger.error(s)
                }
            }), Ce(this, "onSessionExtendResponse", (r, n) => {
                const {
                    id: i
                } = n, s = rr("session_extend", i);
                if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
                Ja(n) ? this.events.emit(rr("session_extend", i), {}) : Is(n) && this.events.emit(rr("session_extend", i), {
                    error: n.error
                })
            }), Ce(this, "onSessionPingRequest", async (r, n) => {
                const {
                    id: i
                } = n;
                try {
                    this.isValidPing({
                        topic: r
                    }), await this.sendResult({
                        id: i,
                        topic: r,
                        result: !0,
                        throwOnFailedPublish: !0
                    }), this.client.events.emit("session_ping", {
                        id: i,
                        topic: r
                    })
                } catch (s) {
                    await this.sendError({
                        id: i,
                        topic: r,
                        error: s
                    }), this.client.logger.error(s)
                }
            }), Ce(this, "onSessionPingResponse", (r, n) => {
                const {
                    id: i
                } = n, s = rr("session_ping", i);
                setTimeout(() => {
                    if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners 2176`);
                    Ja(n) ? this.events.emit(rr("session_ping", i), {}) : Is(n) && this.events.emit(rr("session_ping", i), {
                        error: n.error
                    })
                }, 500)
            }), Ce(this, "onSessionDeleteRequest", async (r, n) => {
                const {
                    id: i
                } = n;
                try {
                    this.isValidDisconnect({
                        topic: r,
                        reason: n.params
                    }), Promise.all([new Promise(s => {
                        this.client.core.relayer.once(mn.publish, async () => {
                            s(await this.deleteSession({
                                topic: r,
                                id: i
                            }))
                        })
                    }), this.sendResult({
                        id: i,
                        topic: r,
                        result: !0
                    }), this.cleanupPendingSentRequestsForTopic({
                        topic: r,
                        error: _r("USER_DISCONNECTED")
                    })]).catch(s => this.client.logger.error(s))
                } catch (s) {
                    this.client.logger.error(s)
                }
            }), Ce(this, "onSessionRequest", async r => {
                var n, i, s;
                const {
                    topic: a,
                    payload: o,
                    attestation: c,
                    encryptedId: l,
                    transportType: u
                } = r, {
                    id: h,
                    params: f
                } = o;
                try {
                    await this.isValidRequest(vr({
                        topic: a
                    }, f));
                    const p = this.client.session.get(a),
                        g = await this.getVerifyContext({
                            attestationId: c,
                            hash: eo(JSON.stringify(Zc("wc_sessionRequest", f, h))),
                            encryptedId: l,
                            metadata: p.peer.metadata,
                            transportType: u
                        }),
                        m = {
                            id: h,
                            topic: a,
                            params: f,
                            verifyContext: g
                        };
                    await this.setPendingSessionRequest(m), u === Er.link_mode && (n = p.peer.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp((i = p.peer.metadata.redirect) == null ? void 0 : i.universal), (s = this.client.signConfig) != null && s.disableRequestQueue ? this.emitSessionRequest(m) : (this.addSessionRequestToSessionRequestQueue(m), this.processSessionRequestQueue())
                } catch (p) {
                    await this.sendError({
                        id: h,
                        topic: a,
                        error: p
                    }), this.client.logger.error(p)
                }
            }), Ce(this, "onSessionRequestResponse", (r, n) => {
                const {
                    id: i
                } = n, s = rr("session_request", i);
                if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
                Ja(n) ? this.events.emit(rr("session_request", i), {
                    result: n.result
                }) : Is(n) && this.events.emit(rr("session_request", i), {
                    error: n.error
                })
            }), Ce(this, "onSessionEventRequest", async (r, n) => {
                const {
                    id: i,
                    params: s
                } = n;
                try {
                    const a = `${r}_session_event_${s.event.name}`,
                        o = nf.get(a);
                    if (o && this.isRequestOutOfSync(o, i)) {
                        this.client.logger.info(`Discarding out of sync request - ${i}`);
                        return
                    }
                    this.isValidEmit(vr({
                        topic: r
                    }, s)), this.client.events.emit("session_event", {
                        id: i,
                        topic: r,
                        params: s
                    }), nf.set(a, i)
                } catch (a) {
                    await this.sendError({
                        id: i,
                        topic: r,
                        error: a
                    }), this.client.logger.error(a)
                }
            }), Ce(this, "onSessionAuthenticateResponse", (r, n) => {
                const {
                    id: i
                } = n;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionAuthenticateResponse",
                    topic: r,
                    payload: n
                }), Ja(n) ? this.events.emit(rr("session_request", i), {
                    result: n.result
                }) : Is(n) && this.events.emit(rr("session_request", i), {
                    error: n.error
                })
            }), Ce(this, "onSessionAuthenticateRequest", async r => {
                var n;
                const {
                    topic: i,
                    payload: s,
                    attestation: a,
                    encryptedId: o,
                    transportType: c
                } = r;
                try {
                    const {
                        requester: l,
                        authPayload: u,
                        expiryTimestamp: h
                    } = s.params, f = await this.getVerifyContext({
                        attestationId: a,
                        hash: eo(JSON.stringify(s)),
                        encryptedId: o,
                        metadata: l.metadata,
                        transportType: c
                    }), p = {
                        requester: l,
                        pairingTopic: i,
                        id: s.id,
                        authPayload: u,
                        verifyContext: f,
                        expiryTimestamp: h
                    };
                    await this.setAuthRequest(s.id, {
                        request: p,
                        pairingTopic: i,
                        transportType: c
                    }), c === Er.link_mode && (n = l.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal), this.client.events.emit("session_authenticate", {
                        topic: i,
                        params: s.params,
                        id: s.id,
                        verifyContext: f
                    })
                } catch (l) {
                    this.client.logger.error(l);
                    const u = s.params.requester.publicKey,
                        h = await this.client.core.crypto.generateKeyPair(),
                        f = this.getAppLinkIfEnabled(s.params.requester.metadata, c),
                        p = {
                            type: Ko,
                            receiverPublicKey: u,
                            senderPublicKey: h
                        };
                    await this.sendError({
                        id: s.id,
                        topic: i,
                        error: l,
                        encodeOpts: p,
                        rpcOpts: un.wc_sessionAuthenticate.autoReject,
                        appLink: f
                    })
                }
            }), Ce(this, "addSessionRequestToSessionRequestQueue", r => {
                this.sessionRequestQueue.queue.push(r)
            }), Ce(this, "cleanupAfterResponse", r => {
                this.deletePendingSessionRequest(r.response.id, {
                    message: "fulfilled",
                    code: 0
                }), setTimeout(() => {
                    this.sessionRequestQueue.state = za.idle, this.processSessionRequestQueue()
                }, Me.toMiliseconds(this.requestQueueDelay))
            }), Ce(this, "cleanupPendingSentRequestsForTopic", ({
                topic: r,
                error: n
            }) => {
                const i = this.client.core.history.pending;
                i.length > 0 && i.filter(s => s.topic === r && s.request.method === "wc_sessionRequest").forEach(s => {
                    const a = s.request.id,
                        o = rr("session_request", a);
                    if (this.events.listenerCount(o) === 0) throw new Error(`emitting ${o} without any listeners`);
                    this.events.emit(rr("session_request", s.request.id), {
                        error: n
                    })
                })
            }), Ce(this, "processSessionRequestQueue", () => {
                if (this.sessionRequestQueue.state === za.active) {
                    this.client.logger.info("session request queue is already active.");
                    return
                }
                const r = this.sessionRequestQueue.queue[0];
                if (!r) {
                    this.client.logger.info("session request queue is empty.");
                    return
                }
                try {
                    this.emitSessionRequest(r)
                } catch (n) {
                    this.client.logger.error(n)
                }
            }), Ce(this, "emitSessionRequest", r => {
                if (this.emittedSessionRequests.has(r.id)) {
                    this.client.logger.warn({
                        id: r.id
                    }, `Skipping emitting \`session_request\` event for duplicate request. id: ${r.id}`);
                    return
                }
                this.sessionRequestQueue.state = za.active, this.emittedSessionRequests.add(r.id), this.client.events.emit("session_request", r)
            }), Ce(this, "onPairingCreated", r => {
                if (r.methods && this.expectedPairingMethodMap.set(r.topic, r.methods), r.active) return;
                const n = this.client.proposal.getAll().find(i => i.pairingTopic === r.topic);
                n && this.onSessionProposeRequest({
                    topic: r.topic,
                    payload: Zc("wc_sessionPropose", Ai(vr({}, n), {
                        requiredNamespaces: n.requiredNamespaces,
                        optionalNamespaces: n.optionalNamespaces,
                        relays: n.relays,
                        proposer: n.proposer,
                        sessionProperties: n.sessionProperties,
                        scopedProperties: n.scopedProperties
                    }), n.id),
                    attestation: n.attestation,
                    encryptedId: n.encryptedId
                })
            }), Ce(this, "isValidConnect", async r => {
                if (!$i(r)) {
                    const {
                        message: l
                    } = je("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(r)}`);
                    throw new Error(l)
                }
                const {
                    pairingTopic: n,
                    requiredNamespaces: i,
                    optionalNamespaces: s,
                    sessionProperties: a,
                    scopedProperties: o,
                    relays: c
                } = r;
                if ($n(n) || await this.isValidPairingTopic(n), !vbe(c)) {
                    const {
                        message: l
                    } = je("MISSING_OR_INVALID", `connect() relays: ${c}`);
                    throw new Error(l)
                }
                if (!$n(i) && ao(i) !== 0) {
                    const l = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
                    ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(l) : this.client.logger.warn(l), this.validateNamespaces(i, "requiredNamespaces")
                }
                if (!$n(s) && ao(s) !== 0 && this.validateNamespaces(s, "optionalNamespaces"), $n(a) || this.validateSessionProps(a, "sessionProperties"), !$n(o)) {
                    this.validateSessionProps(o, "scopedProperties");
                    const l = Object.keys(i || {}).concat(Object.keys(s || {}));
                    if (!Object.keys(o).every(u => l.includes(u.split(":")[0]))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o)}, required/optional namespaces: ${JSON.stringify(l)}`)
                }
            }), Ce(this, "validateNamespaces", (r, n) => {
                const i = bbe(r, "connect()", n);
                if (i) throw new Error(i.message)
            }), Ce(this, "isValidApprove", async r => {
                if (!$i(r)) throw new Error(je("MISSING_OR_INVALID", `approve() params: ${r}`).message);
                const {
                    id: n,
                    namespaces: i,
                    relayProtocol: s,
                    sessionProperties: a,
                    scopedProperties: o
                } = r;
                this.checkRecentlyDeleted(n), await this.isValidProposalId(n);
                const c = this.client.proposal.get(n),
                    l = Eb(i, "approve()");
                if (l) throw new Error(l.message);
                const u = ZA(c.requiredNamespaces, i, "approve()");
                if (u) throw new Error(u.message);
                if (!en(s, !0)) {
                    const {
                        message: h
                    } = je("MISSING_OR_INVALID", `approve() relayProtocol: ${s}`);
                    throw new Error(h)
                }
                if ($n(a) || this.validateSessionProps(a, "sessionProperties"), !$n(o)) {
                    this.validateSessionProps(o, "scopedProperties");
                    const h = new Set(Object.keys(i));
                    if (!Object.keys(o).every(f => h.has(f.split(":")[0]))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o)}, approved namespaces: ${Array.from(h).join(", ")}`)
                }
            }), Ce(this, "isValidReject", async r => {
                if (!$i(r)) {
                    const {
                        message: s
                    } = je("MISSING_OR_INVALID", `reject() params: ${r}`);
                    throw new Error(s)
                }
                const {
                    id: n,
                    reason: i
                } = r;
                if (this.checkRecentlyDeleted(n), await this.isValidProposalId(n), !Ebe(i)) {
                    const {
                        message: s
                    } = je("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(i)}`);
                    throw new Error(s)
                }
            }), Ce(this, "isValidSessionSettleRequest", r => {
                if (!$i(r)) {
                    const {
                        message: l
                    } = je("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${r}`);
                    throw new Error(l)
                }
                const {
                    relay: n,
                    controller: i,
                    namespaces: s,
                    expiry: a
                } = r;
                if (!HD(n)) {
                    const {
                        message: l
                    } = je("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
                    throw new Error(l)
                }
                const o = fbe(i, "onSessionSettleRequest()");
                if (o) throw new Error(o.message);
                const c = Eb(s, "onSessionSettleRequest()");
                if (c) throw new Error(c.message);
                if (jc(a)) {
                    const {
                        message: l
                    } = je("EXPIRED", "onSessionSettleRequest()");
                    throw new Error(l)
                }
            }), Ce(this, "isValidUpdate", async r => {
                if (!$i(r)) {
                    const {
                        message: c
                    } = je("MISSING_OR_INVALID", `update() params: ${r}`);
                    throw new Error(c)
                }
                const {
                    topic: n,
                    namespaces: i
                } = r;
                this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
                const s = this.client.session.get(n),
                    a = Eb(i, "update()");
                if (a) throw new Error(a.message);
                const o = ZA(s.requiredNamespaces, i, "update()");
                if (o) throw new Error(o.message)
            }), Ce(this, "isValidExtend", async r => {
                if (!$i(r)) {
                    const {
                        message: i
                    } = je("MISSING_OR_INVALID", `extend() params: ${r}`);
                    throw new Error(i)
                }
                const {
                    topic: n
                } = r;
                this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n)
            }), Ce(this, "isValidRequest", async r => {
                if (!$i(r)) {
                    const {
                        message: c
                    } = je("MISSING_OR_INVALID", `request() params: ${r}`);
                    throw new Error(c)
                }
                const {
                    topic: n,
                    request: i,
                    chainId: s,
                    expiry: a
                } = r;
                this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
                const {
                    namespaces: o
                } = this.client.session.get(n);
                if (!YA(o, s)) {
                    const {
                        message: c
                    } = je("MISSING_OR_INVALID", `request() chainId: ${s}`);
                    throw new Error(c)
                }
                if (!_be(i)) {
                    const {
                        message: c
                    } = je("MISSING_OR_INVALID", `request() ${JSON.stringify(i)}`);
                    throw new Error(c)
                }
                if (!kbe(o, s, i.method)) {
                    const {
                        message: c
                    } = je("MISSING_OR_INVALID", `request() method: ${i.method}`);
                    throw new Error(c)
                }
                if (a && !Tbe(a, jb)) {
                    const {
                        message: c
                    } = je("MISSING_OR_INVALID", `request() expiry: ${a}. Expiry must be a number (in seconds) between ${jb.min} and ${jb.max}`);
                    throw new Error(c)
                }
            }), Ce(this, "isValidRespond", async r => {
                var n;
                if (!$i(r)) {
                    const {
                        message: a
                    } = je("MISSING_OR_INVALID", `respond() params: ${r}`);
                    throw new Error(a)
                }
                const {
                    topic: i,
                    response: s
                } = r;
                try {
                    await this.isValidSessionTopic(i)
                } catch (a) {
                    throw (n = r == null ? void 0 : r.response) != null && n.id && this.cleanupAfterResponse(r), a
                }
                if (!Cbe(s)) {
                    const {
                        message: a
                    } = je("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(s)}`);
                    throw new Error(a)
                }
            }), Ce(this, "isValidPing", async r => {
                if (!$i(r)) {
                    const {
                        message: i
                    } = je("MISSING_OR_INVALID", `ping() params: ${r}`);
                    throw new Error(i)
                }
                const {
                    topic: n
                } = r;
                await this.isValidSessionOrPairingTopic(n)
            }), Ce(this, "isValidEmit", async r => {
                if (!$i(r)) {
                    const {
                        message: o
                    } = je("MISSING_OR_INVALID", `emit() params: ${r}`);
                    throw new Error(o)
                }
                const {
                    topic: n,
                    event: i,
                    chainId: s
                } = r;
                await this.isValidSessionTopic(n);
                const {
                    namespaces: a
                } = this.client.session.get(n);
                if (!YA(a, s)) {
                    const {
                        message: o
                    } = je("MISSING_OR_INVALID", `emit() chainId: ${s}`);
                    throw new Error(o)
                }
                if (!Abe(i)) {
                    const {
                        message: o
                    } = je("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
                    throw new Error(o)
                }
                if (!Ibe(a, s, i.name)) {
                    const {
                        message: o
                    } = je("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
                    throw new Error(o)
                }
            }), Ce(this, "isValidDisconnect", async r => {
                if (!$i(r)) {
                    const {
                        message: i
                    } = je("MISSING_OR_INVALID", `disconnect() params: ${r}`);
                    throw new Error(i)
                }
                const {
                    topic: n
                } = r;
                await this.isValidSessionOrPairingTopic(n)
            }), Ce(this, "isValidAuthenticate", r => {
                const {
                    chains: n,
                    uri: i,
                    domain: s,
                    nonce: a
                } = r;
                if (!Array.isArray(n) || n.length === 0) throw new Error("chains is required and must be a non-empty array");
                if (!en(i, !1)) throw new Error("uri is required parameter");
                if (!en(s, !1)) throw new Error("domain is required parameter");
                if (!en(a, !1)) throw new Error("nonce is required parameter");
                if ([...new Set(n.map(c => zu(c).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
                const {
                    namespace: o
                } = zu(n[0]);
                if (o !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")
            }), Ce(this, "getVerifyContext", async r => {
                const {
                    attestationId: n,
                    hash: i,
                    encryptedId: s,
                    metadata: a,
                    transportType: o
                } = r, c = {
                    verified: {
                        verifyUrl: a.verifyUrl || Kf,
                        validation: "UNKNOWN",
                        origin: a.url || ""
                    }
                };
                try {
                    if (o === Er.link_mode) {
                        const u = this.getAppLinkIfEnabled(a, o);
                        return c.verified.validation = u && new URL(u).origin === new URL(a.url).origin ? "VALID" : "INVALID", c
                    }
                    const l = await this.client.core.verify.resolve({
                        attestationId: n,
                        hash: i,
                        encryptedId: s,
                        verifyUrl: a.verifyUrl
                    });
                    l && (c.verified.origin = l.origin, c.verified.isScam = l.isScam, c.verified.validation = l.origin === new URL(a.url).origin ? "VALID" : "INVALID")
                } catch (l) {
                    this.client.logger.warn(l)
                }
                return this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`), c
            }), Ce(this, "validateSessionProps", (r, n) => {
                Object.values(r).forEach((i, s) => {
                    if (i == null) {
                        const {
                            message: a
                        } = je("MISSING_OR_INVALID", `${n} must contain an existing value for each key. Received: ${i} for key ${Object.keys(r)[s]}`);
                        throw new Error(a)
                    }
                })
            }), Ce(this, "getPendingAuthRequest", r => {
                const n = this.client.auth.requests.get(r);
                return typeof n == "object" ? n : void 0
            }), Ce(this, "addToRecentlyDeleted", (r, n) => {
                if (this.recentlyDeletedMap.set(r, n), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
                    let i = 0;
                    const s = this.recentlyDeletedLimit / 2;
                    for (const a of this.recentlyDeletedMap.keys()) {
                        if (i++ >= s) break;
                        this.recentlyDeletedMap.delete(a)
                    }
                }
            }), Ce(this, "checkRecentlyDeleted", r => {
                const n = this.recentlyDeletedMap.get(r);
                if (n) {
                    const {
                        message: i
                    } = je("MISSING_OR_INVALID", `Record was recently deleted - ${n}: ${r}`);
                    throw new Error(i)
                }
            }), Ce(this, "isLinkModeEnabled", (r, n) => {
                var i, s, a, o, c, l, u, h, f;
                return !r || n !== Er.link_mode ? !1 : ((s = (i = this.client.metadata) == null ? void 0 : i.redirect) == null ? void 0 : s.linkMode) === !0 && ((o = (a = this.client.metadata) == null ? void 0 : a.redirect) == null ? void 0 : o.universal) !== void 0 && ((l = (c = this.client.metadata) == null ? void 0 : c.redirect) == null ? void 0 : l.universal) !== "" && ((u = r == null ? void 0 : r.redirect) == null ? void 0 : u.universal) !== void 0 && ((h = r == null ? void 0 : r.redirect) == null ? void 0 : h.universal) !== "" && ((f = r == null ? void 0 : r.redirect) == null ? void 0 : f.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(r.redirect.universal) && typeof(globalThis == null ? void 0 : globalThis.Linking) < "u"
            }), Ce(this, "getAppLinkIfEnabled", (r, n) => {
                var i;
                return this.isLinkModeEnabled(r, n) ? (i = r == null ? void 0 : r.redirect) == null ? void 0 : i.universal : void 0
            }), Ce(this, "handleLinkModeMessage", ({
                url: r
            }) => {
                if (!r || !r.includes("wc_ev") || !r.includes("topic")) return;
                const n = lA(r, "topic") || "",
                    i = decodeURIComponent(lA(r, "wc_ev") || ""),
                    s = this.client.session.keys.includes(n);
                s && this.client.session.update(n, {
                    transportType: Er.link_mode
                }), this.client.core.dispatchEnvelope({
                    topic: n,
                    message: i,
                    sessionExists: s
                })
            }), Ce(this, "registerLinkModeListeners", async () => {
                var r;
                if (Dx() || ul() && (r = this.client.metadata.redirect) != null && r.linkMode) {
                    const n = globalThis == null ? void 0 : globalThis.Linking;
                    if (typeof n < "u") {
                        n.addEventListener("url", this.handleLinkModeMessage, this.client.name);
                        const i = await n.getInitialURL();
                        i && setTimeout(() => {
                            this.handleLinkModeMessage({
                                url: i
                            })
                        }, 50)
                    }
                }
            }), Ce(this, "getTVFParams", (r, n, i) => {
                var s, a, o;
                if (!((s = n.request) != null && s.method)) return {};
                const c = {
                    correlationId: r,
                    rpcMethods: [n.request.method],
                    chainId: n.chainId
                };
                try {
                    const l = this.extractTxHashesFromResult(n.request, i);
                    c.txHashes = l, c.contractAddresses = this.isValidContractData(n.request.params) ? [(o = (a = n.request.params) == null ? void 0 : a[0]) == null ? void 0 : o.to] : []
                } catch (l) {
                    this.client.logger.warn("Error getting TVF params", l)
                }
                return c
            }), Ce(this, "isValidContractData", r => {
                var n;
                if (!r) return !1;
                try {
                    const i = (r == null ? void 0 : r.data) || ((n = r == null ? void 0 : r[0]) == null ? void 0 : n.data);
                    if (!i.startsWith("0x")) return !1;
                    const s = i.slice(2);
                    return /^[0-9a-fA-F]*$/.test(s) ? s.length % 2 === 0 : !1
                } catch {}
                return !1
            }), Ce(this, "extractTxHashesFromResult", (r, n) => {
                var i;
                try {
                    if (!n) return [];
                    const s = r.method,
                        a = Mxe[s];
                    if (s === "sui_signTransaction") return [Xye(n.transactionBytes)];
                    if (s === "near_signTransaction") return [yA(n)];
                    if (s === "near_signTransactions") return n.map(c => yA(c));
                    if (s === "xrpl_signTransactionFor" || s === "xrpl_signTransaction") return [(i = n.tx_json) == null ? void 0 : i.hash];
                    if (s === "polkadot_signTransaction") return [Hbe({
                        transaction: r.params.transactionPayload,
                        signature: n.signature
                    })];
                    if (s === "algo_signTxn") return Ps(n) ? n.map(c => wA(c)) : [wA(n)];
                    if (s === "cosmos_signDirect") return [twe(n)];
                    if (typeof n == "string") return [n];
                    const o = n[a.key];
                    if (Ps(o)) return s === "solana_signAllTransactions" ? o.map(c => Qye(c)) : o;
                    if (typeof o == "string") return [o]
                } catch (s) {
                    this.client.logger.warn("Error extracting tx hashes from result", s)
                }
                return []
            })
        }
        async processPendingMessageEvents() {
            try {
                const e = this.client.session.keys,
                    r = this.client.core.relayer.messages.getWithoutAck(e);
                for (const [n, i] of Object.entries(r))
                    for (const s of i) try {
                        await this.onProviderMessageEvent({
                            topic: n,
                            message: s,
                            publishedAt: Date.now()
                        })
                    } catch {
                        this.client.logger.warn(`Error processing pending message event for topic: ${n}, message: ${s}`)
                    }
            } catch (e) {
                this.client.logger.warn("processPendingMessageEvents failed", e)
            }
        }
        isInitialized() {
            if (!this.initialized) {
                const {
                    message: e
                } = je("NOT_INITIALIZED", this.name);
                throw new Error(e)
            }
        }
        async confirmOnlineStateOrThrow() {
            await this.client.core.relayer.confirmOnlineStateOrThrow()
        }
        registerRelayerEvents() {
            this.client.core.relayer.on(mn.message, e => {
                this.onProviderMessageEvent(e)
            })
        }
        async onRelayMessage(e) {
            const {
                topic: r,
                message: n,
                attestation: i,
                transportType: s
            } = e, {
                publicKey: a
            } = this.client.auth.authKeys.keys.includes(im) ? this.client.auth.authKeys.get(im) : {
                publicKey: void 0
            };
            try {
                const o = await this.client.core.crypto.decode(r, n, {
                    receiverPublicKey: a,
                    encoding: s === Er.link_mode ? zc : ga
                });
                Xx(o) ? (this.client.core.history.set(r, o), await this.onRelayEventRequest({
                    topic: r,
                    payload: o,
                    attestation: i,
                    transportType: s,
                    encryptedId: eo(n)
                })) : Uy(o) ? (await this.client.core.history.resolve(o), await this.onRelayEventResponse({
                    topic: r,
                    payload: o,
                    transportType: s
                }), this.client.core.history.delete(r, o.id)) : await this.onRelayEventUnknownPayload({
                    topic: r,
                    payload: o,
                    transportType: s
                }), await this.client.core.relayer.messages.ack(r, n)
            } catch (o) {
                this.client.logger.error(o)
            }
        }
        registerExpirerEvents() {
            this.client.core.expirer.on(As.expired, async e => {
                const {
                    topic: r,
                    id: n
                } = XM(e.target);
                if (n && this.client.pendingRequest.keys.includes(n)) return await this.deletePendingSessionRequest(n, je("EXPIRED"), !0);
                if (n && this.client.auth.requests.keys.includes(n)) return await this.deletePendingAuthRequest(n, je("EXPIRED"), !0);
                r ? this.client.session.keys.includes(r) && (await this.deleteSession({
                    topic: r,
                    expirerHasDeleted: !0
                }), this.client.events.emit("session_expire", {
                    topic: r
                })) : n && (await this.deleteProposal(n, !0), this.client.events.emit("proposal_expire", {
                    id: n
                }))
            })
        }
        registerPairingEvents() {
            this.client.core.pairing.events.on(Rl.create, e => this.onPairingCreated(e)), this.client.core.pairing.events.on(Rl.delete, e => {
                this.addToRecentlyDeleted(e.topic, "pairing")
            })
        }
        isValidPairingTopic(e) {
            if (!en(e, !1)) {
                const {
                    message: r
                } = je("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
                throw new Error(r)
            }
            if (!this.client.core.pairing.pairings.keys.includes(e)) {
                const {
                    message: r
                } = je("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
                throw new Error(r)
            }
            if (jc(this.client.core.pairing.pairings.get(e).expiry)) {
                const {
                    message: r
                } = je("EXPIRED", `pairing topic: ${e}`);
                throw new Error(r)
            }
        }
        async isValidSessionTopic(e) {
            if (!en(e, !1)) {
                const {
                    message: r
                } = je("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
                throw new Error(r)
            }
            if (this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e)) {
                const {
                    message: r
                } = je("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
                throw new Error(r)
            }
            if (jc(this.client.session.get(e).expiry)) {
                await this.deleteSession({
                    topic: e
                });
                const {
                    message: r
                } = je("EXPIRED", `session topic: ${e}`);
                throw new Error(r)
            }
            if (!this.client.core.crypto.keychain.has(e)) {
                const {
                    message: r
                } = je("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
                throw await this.deleteSession({
                    topic: e
                }), new Error(r)
            }
        }
        async isValidSessionOrPairingTopic(e) {
            if (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e)) await this.isValidSessionTopic(e);
            else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e);
            else if (en(e, !1)) {
                const {
                    message: r
                } = je("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
                throw new Error(r)
            } else {
                const {
                    message: r
                } = je("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
                throw new Error(r)
            }
        }
        async isValidProposalId(e) {
            if (!xbe(e)) {
                const {
                    message: r
                } = je("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
                throw new Error(r)
            }
            if (!this.client.proposal.keys.includes(e)) {
                const {
                    message: r
                } = je("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
                throw new Error(r)
            }
            if (jc(this.client.proposal.get(e).expiryTimestamp)) {
                await this.deleteProposal(e);
                const {
                    message: r
                } = je("EXPIRED", `proposal id: ${e}`);
                throw new Error(r)
            }
        }
    },
    Zxe = class extends Md {
        constructor(e, r) {
            super(e, r, Oxe, e8), this.core = e, this.logger = r
        }
    },
    Jxe = class extends Md {
        constructor(e, r) {
            super(e, r, jxe, e8), this.core = e, this.logger = r
        }
    },
    Qxe = class extends Md {
        constructor(e, r) {
            super(e, r, Dxe, e8, n => n.id), this.core = e, this.logger = r
        }
    },
    Xxe = class extends Md {
        constructor(e, r) {
            super(e, r, Bxe, By, () => im), this.core = e, this.logger = r
        }
    },
    e8e = class extends Md {
        constructor(e, r) {
            super(e, r, Wxe, By), this.core = e, this.logger = r
        }
    },
    t8e = class extends Md {
        constructor(e, r) {
            super(e, r, zxe, By, n => n.id), this.core = e, this.logger = r
        }
    };
var r8e = Object.defineProperty,
    n8e = (t, e, r) => e in t ? r8e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Rb = (t, e, r) => n8e(t, typeof e != "symbol" ? e + "" : e, r);
let i8e = class {
    constructor(e, r) {
        this.core = e, this.logger = r, Rb(this, "authKeys"), Rb(this, "pairingTopics"), Rb(this, "requests"), this.authKeys = new Xxe(this.core, this.logger), this.pairingTopics = new e8e(this.core, this.logger), this.requests = new t8e(this.core, this.logger)
    }
    async init() {
        await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init()
    }
};
var s8e = Object.defineProperty,
    a8e = (t, e, r) => e in t ? s8e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Vt = (t, e, r) => a8e(t, typeof e != "symbol" ? e + "" : e, r);
let o8e = class xL extends i3e {
    constructor(e) {
        super(e), Vt(this, "protocol", wL), Vt(this, "version", bL), Vt(this, "name", Ob.name), Vt(this, "metadata"), Vt(this, "core"), Vt(this, "logger"), Vt(this, "events", new gs.EventEmitter), Vt(this, "engine"), Vt(this, "session"), Vt(this, "proposal"), Vt(this, "pendingRequest"), Vt(this, "auth"), Vt(this, "signConfig"), Vt(this, "on", (n, i) => this.events.on(n, i)), Vt(this, "once", (n, i) => this.events.once(n, i)), Vt(this, "off", (n, i) => this.events.off(n, i)), Vt(this, "removeListener", (n, i) => this.events.removeListener(n, i)), Vt(this, "removeAllListeners", n => this.events.removeAllListeners(n)), Vt(this, "connect", async n => {
            try {
                return await this.engine.connect(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "pair", async n => {
            try {
                return await this.engine.pair(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "approve", async n => {
            try {
                return await this.engine.approve(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "reject", async n => {
            try {
                return await this.engine.reject(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "update", async n => {
            try {
                return await this.engine.update(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "extend", async n => {
            try {
                return await this.engine.extend(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "request", async n => {
            try {
                return await this.engine.request(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "respond", async n => {
            try {
                return await this.engine.respond(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "ping", async n => {
            try {
                return await this.engine.ping(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "emit", async n => {
            try {
                return await this.engine.emit(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "disconnect", async n => {
            try {
                return await this.engine.disconnect(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "find", n => {
            try {
                return this.engine.find(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "getPendingSessionRequests", () => {
            try {
                return this.engine.getPendingSessionRequests()
            } catch (n) {
                throw this.logger.error(n.message), n
            }
        }), Vt(this, "authenticate", async (n, i) => {
            try {
                return await this.engine.authenticate(n, i)
            } catch (s) {
                throw this.logger.error(s.message), s
            }
        }), Vt(this, "formatAuthMessage", n => {
            try {
                return this.engine.formatAuthMessage(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "approveSessionAuthenticate", async n => {
            try {
                return await this.engine.approveSessionAuthenticate(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), Vt(this, "rejectSessionAuthenticate", async n => {
            try {
                return await this.engine.rejectSessionAuthenticate(n)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }), this.name = (e == null ? void 0 : e.name) || Ob.name, this.metadata = q1e(e == null ? void 0 : e.metadata), this.signConfig = e == null ? void 0 : e.signConfig;
        const r = typeof(e == null ? void 0 : e.logger) < "u" && typeof(e == null ? void 0 : e.logger) != "string" ? e.logger : $0(My({
            level: (e == null ? void 0 : e.logger) || Ob.logger
        }));
        this.core = (e == null ? void 0 : e.core) || new Nxe(e), this.logger = wi(r, this.name), this.session = new Jxe(this.core, this.logger), this.proposal = new Zxe(this.core, this.logger), this.pendingRequest = new Qxe(this.core, this.logger), this.engine = new Yxe(this), this.auth = new i8e(this.core, this.logger)
    }
    static async init(e) {
        const r = new xL(e);
        return await r.initialize(), r
    }
    get context() {
        return zi(this.logger)
    }
    get pairing() {
        return this.core.pairing.pairings
    }
    async initialize() {
        this.logger.trace("Initialized");
        try {
            await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success")
        } catch (e) {
            throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e
        }
    }
};
var Cg = {
        exports: {}
    },
    Vk;

function c8e() {
    return Vk || (Vk = 1, function(t, e) {
        var r = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof globalThis < "u" && globalThis,
            n = function() {
                function s() {
                    this.fetch = !1, this.DOMException = r.DOMException
                }
                return s.prototype = r, new s
            }();
        (function(s) {
            (function(a) {
                var o = typeof s < "u" && s || typeof self < "u" && self || typeof s < "u" && s || {},
                    c = {
                        searchParams: "URLSearchParams" in o,
                        iterable: "Symbol" in o && "iterator" in Symbol,
                        blob: "FileReader" in o && "Blob" in o && function() {
                            try {
                                return new Blob, !0
                            } catch {
                                return !1
                            }
                        }(),
                        formData: "FormData" in o,
                        arrayBuffer: "ArrayBuffer" in o
                    };

                function l(S) {
                    return S && DataView.prototype.isPrototypeOf(S)
                }
                if (c.arrayBuffer) var u = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                    h = ArrayBuffer.isView || function(S) {
                        return S && u.indexOf(Object.prototype.toString.call(S)) > -1
                    };

                function f(S) {
                    if (typeof S != "string" && (S = String(S)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(S) || S === "") throw new TypeError('Invalid character in header field name: "' + S + '"');
                    return S.toLowerCase()
                }

                function p(S) {
                    return typeof S != "string" && (S = String(S)), S
                }

                function g(S) {
                    var O = {
                        next: function() {
                            var M = S.shift();
                            return {
                                done: M === void 0,
                                value: M
                            }
                        }
                    };
                    return c.iterable && (O[Symbol.iterator] = function() {
                        return O
                    }), O
                }

                function m(S) {
                    this.map = {}, S instanceof m ? S.forEach(function(O, M) {
                        this.append(M, O)
                    }, this) : Array.isArray(S) ? S.forEach(function(O) {
                        if (O.length != 2) throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + O.length);
                        this.append(O[0], O[1])
                    }, this) : S && Object.getOwnPropertyNames(S).forEach(function(O) {
                        this.append(O, S[O])
                    }, this)
                }
                m.prototype.append = function(S, O) {
                    S = f(S), O = p(O);
                    var M = this.map[S];
                    this.map[S] = M ? M + ", " + O : O
                }, m.prototype.delete = function(S) {
                    delete this.map[f(S)]
                }, m.prototype.get = function(S) {
                    return S = f(S), this.has(S) ? this.map[S] : null
                }, m.prototype.has = function(S) {
                    return this.map.hasOwnProperty(f(S))
                }, m.prototype.set = function(S, O) {
                    this.map[f(S)] = p(O)
                }, m.prototype.forEach = function(S, O) {
                    for (var M in this.map) this.map.hasOwnProperty(M) && S.call(O, this.map[M], M, this)
                }, m.prototype.keys = function() {
                    var S = [];
                    return this.forEach(function(O, M) {
                        S.push(M)
                    }), g(S)
                }, m.prototype.values = function() {
                    var S = [];
                    return this.forEach(function(O) {
                        S.push(O)
                    }), g(S)
                }, m.prototype.entries = function() {
                    var S = [];
                    return this.forEach(function(O, M) {
                        S.push([M, O])
                    }), g(S)
                }, c.iterable && (m.prototype[Symbol.iterator] = m.prototype.entries);

                function y(S) {
                    if (!S._noBody) {
                        if (S.bodyUsed) return Promise.reject(new TypeError("Already read"));
                        S.bodyUsed = !0
                    }
                }

                function w(S) {
                    return new Promise(function(O, M) {
                        S.onload = function() {
                            O(S.result)
                        }, S.onerror = function() {
                            M(S.error)
                        }
                    })
                }

                function x(S) {
                    var O = new FileReader,
                        M = w(O);
                    return O.readAsArrayBuffer(S), M
                }

                function E(S) {
                    var O = new FileReader,
                        M = w(O),
                        U = /charset=([A-Za-z0-9_-]+)/.exec(S.type),
                        k = U ? U[1] : "utf-8";
                    return O.readAsText(S, k), M
                }

                function _(S) {
                    for (var O = new Uint8Array(S), M = new Array(O.length), U = 0; U < O.length; U++) M[U] = String.fromCharCode(O[U]);
                    return M.join("")
                }

                function b(S) {
                    if (S.slice) return S.slice(0);
                    var O = new Uint8Array(S.byteLength);
                    return O.set(new Uint8Array(S)), O.buffer
                }

                function A() {
                    return this.bodyUsed = !1, this._initBody = function(S) {
                        this.bodyUsed = this.bodyUsed, this._bodyInit = S, S ? typeof S == "string" ? this._bodyText = S : c.blob && Blob.prototype.isPrototypeOf(S) ? this._bodyBlob = S : c.formData && FormData.prototype.isPrototypeOf(S) ? this._bodyFormData = S : c.searchParams && URLSearchParams.prototype.isPrototypeOf(S) ? this._bodyText = S.toString() : c.arrayBuffer && c.blob && l(S) ? (this._bodyArrayBuffer = b(S.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : c.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(S) || h(S)) ? this._bodyArrayBuffer = b(S) : this._bodyText = S = Object.prototype.toString.call(S) : (this._noBody = !0, this._bodyText = ""), this.headers.get("content-type") || (typeof S == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : c.searchParams && URLSearchParams.prototype.isPrototypeOf(S) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                    }, c.blob && (this.blob = function() {
                        var S = y(this);
                        if (S) return S;
                        if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                        if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                        if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                        return Promise.resolve(new Blob([this._bodyText]))
                    }), this.arrayBuffer = function() {
                        if (this._bodyArrayBuffer) {
                            var S = y(this);
                            return S || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
                        } else {
                            if (c.blob) return this.blob().then(x);
                            throw new Error("could not read as ArrayBuffer")
                        }
                    }, this.text = function() {
                        var S = y(this);
                        if (S) return S;
                        if (this._bodyBlob) return E(this._bodyBlob);
                        if (this._bodyArrayBuffer) return Promise.resolve(_(this._bodyArrayBuffer));
                        if (this._bodyFormData) throw new Error("could not read FormData body as text");
                        return Promise.resolve(this._bodyText)
                    }, c.formData && (this.formData = function() {
                        return this.text().then($)
                    }), this.json = function() {
                        return this.text().then(JSON.parse)
                    }, this
                }
                var I = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];

                function T(S) {
                    var O = S.toUpperCase();
                    return I.indexOf(O) > -1 ? O : S
                }

                function C(S, O) {
                    if (!(this instanceof C)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                    O = O || {};
                    var M = O.body;
                    if (S instanceof C) {
                        if (S.bodyUsed) throw new TypeError("Already read");
                        this.url = S.url, this.credentials = S.credentials, O.headers || (this.headers = new m(S.headers)), this.method = S.method, this.mode = S.mode, this.signal = S.signal, !M && S._bodyInit != null && (M = S._bodyInit, S.bodyUsed = !0)
                    } else this.url = String(S);
                    if (this.credentials = O.credentials || this.credentials || "same-origin", (O.headers || !this.headers) && (this.headers = new m(O.headers)), this.method = T(O.method || this.method || "GET"), this.mode = O.mode || this.mode || null, this.signal = O.signal || this.signal || function() {
                            if ("AbortController" in o) {
                                var F = new AbortController;
                                return F.signal
                            }
                        }(), this.referrer = null, (this.method === "GET" || this.method === "HEAD") && M) throw new TypeError("Body not allowed for GET or HEAD requests");
                    if (this._initBody(M), (this.method === "GET" || this.method === "HEAD") && (O.cache === "no-store" || O.cache === "no-cache")) {
                        var U = /([?&])_=[^&]*/;
                        if (U.test(this.url)) this.url = this.url.replace(U, "$1_=" + new Date().getTime());
                        else {
                            var k = /\?/;
                            this.url += (k.test(this.url) ? "&" : "?") + "_=" + new Date().getTime()
                        }
                    }
                }
                C.prototype.clone = function() {
                    return new C(this, {
                        body: this._bodyInit
                    })
                };

                function $(S) {
                    var O = new FormData;
                    return S.trim().split("&").forEach(function(M) {
                        if (M) {
                            var U = M.split("="),
                                k = U.shift().replace(/\+/g, " "),
                                F = U.join("=").replace(/\+/g, " ");
                            O.append(decodeURIComponent(k), decodeURIComponent(F))
                        }
                    }), O
                }

                function P(S) {
                    var O = new m,
                        M = S.replace(/\r?\n[\t ]+/g, " ");
                    return M.split("\r").map(function(U) {
                        return U.indexOf(`
`) === 0 ? U.substr(1, U.length) : U
                    }).forEach(function(U) {
                        var k = U.split(":"),
                            F = k.shift().trim();
                        if (F) {
                            var q = k.join(":").trim();
                            try {
                                O.append(F, q)
                            } catch (W) {
                                console.warn("Response " + W.message)
                            }
                        }
                    }), O
                }
                A.call(C.prototype);

                function N(S, O) {
                    if (!(this instanceof N)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                    if (O || (O = {}), this.type = "default", this.status = O.status === void 0 ? 200 : O.status, this.status < 200 || this.status > 599) throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
                    this.ok = this.status >= 200 && this.status < 300, this.statusText = O.statusText === void 0 ? "" : "" + O.statusText, this.headers = new m(O.headers), this.url = O.url || "", this._initBody(S)
                }
                A.call(N.prototype), N.prototype.clone = function() {
                    return new N(this._bodyInit, {
                        status: this.status,
                        statusText: this.statusText,
                        headers: new m(this.headers),
                        url: this.url
                    })
                }, N.error = function() {
                    var S = new N(null, {
                        status: 200,
                        statusText: ""
                    });
                    return S.ok = !1, S.status = 0, S.type = "error", S
                };
                var R = [301, 302, 303, 307, 308];
                N.redirect = function(S, O) {
                    if (R.indexOf(O) === -1) throw new RangeError("Invalid status code");
                    return new N(null, {
                        status: O,
                        headers: {
                            location: S
                        }
                    })
                }, a.DOMException = o.DOMException;
                try {
                    new a.DOMException
                } catch {
                    a.DOMException = function(O, M) {
                        this.message = O, this.name = M;
                        var U = Error(O);
                        this.stack = U.stack
                    }, a.DOMException.prototype = Object.create(Error.prototype), a.DOMException.prototype.constructor = a.DOMException
                }

                function D(S, O) {
                    return new Promise(function(M, U) {
                        var k = new C(S, O);
                        if (k.signal && k.signal.aborted) return U(new a.DOMException("Aborted", "AbortError"));
                        var F = new XMLHttpRequest;

                        function q() {
                            F.abort()
                        }
                        F.onload = function() {
                            var H = {
                                statusText: F.statusText,
                                headers: P(F.getAllResponseHeaders() || "")
                            };
                            k.url.indexOf("file://") === 0 && (F.status < 200 || F.status > 599) ? H.status = 200 : H.status = F.status, H.url = "responseURL" in F ? F.responseURL : H.headers.get("X-Request-URL");
                            var j = "response" in F ? F.response : F.responseText;
                            setTimeout(function() {
                                M(new N(j, H))
                            }, 0)
                        }, F.onerror = function() {
                            setTimeout(function() {
                                U(new TypeError("Network request failed"))
                            }, 0)
                        }, F.ontimeout = function() {
                            setTimeout(function() {
                                U(new TypeError("Network request timed out"))
                            }, 0)
                        }, F.onabort = function() {
                            setTimeout(function() {
                                U(new a.DOMException("Aborted", "AbortError"))
                            }, 0)
                        };

                        function W(H) {
                            try {
                                return H === "" && o.location.href ? o.location.href : H
                            } catch {
                                return H
                            }
                        }
                        if (F.open(k.method, W(k.url), !0), k.credentials === "include" ? F.withCredentials = !0 : k.credentials === "omit" && (F.withCredentials = !1), "responseType" in F && (c.blob ? F.responseType = "blob" : c.arrayBuffer && (F.responseType = "arraybuffer")), O && typeof O.headers == "object" && !(O.headers instanceof m || o.Headers && O.headers instanceof o.Headers)) {
                            var K = [];
                            Object.getOwnPropertyNames(O.headers).forEach(function(H) {
                                K.push(f(H)), F.setRequestHeader(H, p(O.headers[H]))
                            }), k.headers.forEach(function(H, j) {
                                K.indexOf(j) === -1 && F.setRequestHeader(j, H)
                            })
                        } else k.headers.forEach(function(H, j) {
                            F.setRequestHeader(j, H)
                        });
                        k.signal && (k.signal.addEventListener("abort", q), F.onreadystatechange = function() {
                            F.readyState === 4 && k.signal.removeEventListener("abort", q)
                        }), F.send(typeof k._bodyInit > "u" ? null : k._bodyInit)
                    })
                }
                return D.polyfill = !0, o.fetch || (o.fetch = D, o.Headers = m, o.Request = C, o.Response = N), a.Headers = m, a.Request = C, a.Response = N, a.fetch = D, Object.defineProperty(a, "__esModule", {
                    value: !0
                }), a
            })({})
        })(n), n.fetch.ponyfill = !0, delete n.fetch.polyfill;
        var i = r.fetch ? r : n;
        e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, t.exports = e
    }(Cg, Cg.exports)), Cg.exports
}
var l8e = c8e();
const Gk = Oa(l8e);
var d8e = Object.defineProperty,
    u8e = Object.defineProperties,
    h8e = Object.getOwnPropertyDescriptors,
    Kk = Object.getOwnPropertySymbols,
    f8e = Object.prototype.hasOwnProperty,
    p8e = Object.prototype.propertyIsEnumerable,
    Yk = (t, e, r) => e in t ? d8e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Zk = (t, e) => {
        for (var r in e || (e = {})) f8e.call(e, r) && Yk(t, r, e[r]);
        if (Kk)
            for (var r of Kk(e)) p8e.call(e, r) && Yk(t, r, e[r]);
        return t
    },
    Jk = (t, e) => u8e(t, h8e(e));
const g8e = {
        Accept: "application/json",
        "Content-Type": "application/json"
    },
    m8e = "POST",
    Qk = {
        headers: g8e,
        method: m8e
    },
    Xk = 10;
let Ra = class {
    constructor(e, r = !1) {
        if (this.url = e, this.disableProviderPing = r, this.events = new gs.EventEmitter, this.isAvailable = !1, this.registering = !1, !gk(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
        this.url = e, this.disableProviderPing = r
    }
    get connected() {
        return this.isAvailable
    }
    get connecting() {
        return this.registering
    }
    on(e, r) {
        this.events.on(e, r)
    }
    once(e, r) {
        this.events.once(e, r)
    }
    off(e, r) {
        this.events.off(e, r)
    }
    removeListener(e, r) {
        this.events.removeListener(e, r)
    }
    async open(e = this.url) {
        await this.register(e)
    }
    async close() {
        if (!this.isAvailable) throw new Error("Connection already closed");
        this.onClose()
    }
    async send(e) {
        this.isAvailable || await this.register();
        try {
            const r = ac(e),
                n = await (await Gk(this.url, Jk(Zk({}, Qk), {
                    body: r
                }))).json();
            this.onPayload({
                data: n
            })
        } catch (r) {
            this.onError(e.id, r)
        }
    }
    async register(e = this.url) {
        if (!gk(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
        if (this.registering) {
            const r = this.events.getMaxListeners();
            return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((n, i) => {
                this.events.once("register_error", s => {
                    this.resetMaxListeners(), i(s)
                }), this.events.once("open", () => {
                    if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i(new Error("HTTP connection is missing or invalid"));
                    n()
                })
            })
        }
        this.url = e, this.registering = !0;
        try {
            if (!this.disableProviderPing) {
                const r = ac({
                    id: 1,
                    jsonrpc: "2.0",
                    method: "test",
                    params: []
                });
                await Gk(e, Jk(Zk({}, Qk), {
                    body: r
                }))
            }
            this.onOpen()
        } catch (r) {
            const n = this.parseError(r);
            throw this.events.emit("register_error", n), this.onClose(), n
        }
    }
    onOpen() {
        this.isAvailable = !0, this.registering = !1, this.events.emit("open")
    }
    onClose() {
        this.isAvailable = !1, this.registering = !1, this.events.emit("close")
    }
    onPayload(e) {
        if (typeof e.data > "u") return;
        const r = typeof e.data == "string" ? yd(e.data) : e.data;
        this.events.emit("payload", r)
    }
    onError(e, r) {
        const n = this.parseError(r),
            i = n.message || n.toString(),
            s = Ly(e, i);
        this.events.emit("payload", s)
    }
    parseError(e, r = this.url) {
        return JD(e, r, "HTTP")
    }
    resetMaxListeners() {
        this.events.getMaxListeners() > Xk && this.events.setMaxListeners(Xk)
    }
};
const eI = "error",
    y8e = "wss://relay.walletconnect.org",
    w8e = "wc",
    b8e = "universal_provider",
    Ag = `${w8e}@2:${b8e}:`,
    EL = "https://rpc.walletconnect.org/v1/",
    Cu = "generic",
    v8e = `${EL}bundler`,
    Vs = {
        DEFAULT_CHAIN_CHANGED: "default_chain_changed"
    };

function t8(t) {
    return t == null || typeof t != "object" && typeof t != "function"
}

function _L(t) {
    return Object.getOwnPropertySymbols(t).filter(e => Object.prototype.propertyIsEnumerable.call(t, e))
}

function CL(t) {
    return t == null ? t === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(t)
}
const x8e = "[object RegExp]",
    AL = "[object String]",
    kL = "[object Number]",
    IL = "[object Boolean]",
    $L = "[object Arguments]",
    E8e = "[object Symbol]",
    _8e = "[object Date]",
    C8e = "[object Map]",
    A8e = "[object Set]",
    k8e = "[object Array]",
    I8e = "[object ArrayBuffer]",
    $8e = "[object Object]",
    S8e = "[object DataView]",
    T8e = "[object Uint8Array]",
    P8e = "[object Uint8ClampedArray]",
    N8e = "[object Uint16Array]",
    O8e = "[object Uint32Array]",
    j8e = "[object Int8Array]",
    R8e = "[object Int16Array]",
    M8e = "[object Int32Array]",
    D8e = "[object Float32Array]",
    L8e = "[object Float64Array]";

function r8(t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView)
}

function U8e(t, e) {
    return Tu(t, void 0, t, new Map, e)
}

function Tu(t, e, r, n = new Map, i = void 0) {
    const s = i == null ? void 0 : i(t, e, r, n);
    if (s != null) return s;
    if (t8(t)) return t;
    if (n.has(t)) return n.get(t);
    if (Array.isArray(t)) {
        const a = new Array(t.length);
        n.set(t, a);
        for (let o = 0; o < t.length; o++) a[o] = Tu(t[o], o, r, n, i);
        return Object.hasOwn(t, "index") && (a.index = t.index), Object.hasOwn(t, "input") && (a.input = t.input), a
    }
    if (t instanceof Date) return new Date(t.getTime());
    if (t instanceof RegExp) {
        const a = new RegExp(t.source, t.flags);
        return a.lastIndex = t.lastIndex, a
    }
    if (t instanceof Map) {
        const a = new Map;
        n.set(t, a);
        for (const [o, c] of t) a.set(o, Tu(c, o, r, n, i));
        return a
    }
    if (t instanceof Set) {
        const a = new Set;
        n.set(t, a);
        for (const o of t) a.add(Tu(o, void 0, r, n, i));
        return a
    }
    if (typeof Ve < "u" && Ve.isBuffer(t)) return t.subarray();
    if (r8(t)) {
        const a = new(Object.getPrototypeOf(t)).constructor(t.length);
        n.set(t, a);
        for (let o = 0; o < t.length; o++) a[o] = Tu(t[o], o, r, n, i);
        return a
    }
    if (t instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer) return t.slice(0);
    if (t instanceof DataView) {
        const a = new DataView(t.buffer.slice(0), t.byteOffset, t.byteLength);
        return n.set(t, a), Ml(a, t, r, n, i), a
    }
    if (typeof File < "u" && t instanceof File) {
        const a = new File([t], t.name, {
            type: t.type
        });
        return n.set(t, a), Ml(a, t, r, n, i), a
    }
    if (t instanceof Blob) {
        const a = new Blob([t], {
            type: t.type
        });
        return n.set(t, a), Ml(a, t, r, n, i), a
    }
    if (t instanceof Error) {
        const a = new t.constructor;
        return n.set(t, a), a.message = t.message, a.name = t.name, a.stack = t.stack, a.cause = t.cause, Ml(a, t, r, n, i), a
    }
    if (typeof t == "object" && F8e(t)) {
        const a = Object.create(Object.getPrototypeOf(t));
        return n.set(t, a), Ml(a, t, r, n, i), a
    }
    return t
}

function Ml(t, e, r = t, n, i) {
    const s = [...Object.keys(e), ..._L(e)];
    for (let a = 0; a < s.length; a++) {
        const o = s[a],
            c = Object.getOwnPropertyDescriptor(t, o);
        (c == null || c.writable) && (t[o] = Tu(e[o], o, r, n, i))
    }
}

function F8e(t) {
    switch (CL(t)) {
        case $L:
        case k8e:
        case I8e:
        case S8e:
        case IL:
        case _8e:
        case D8e:
        case L8e:
        case j8e:
        case R8e:
        case M8e:
        case C8e:
        case kL:
        case $8e:
        case x8e:
        case A8e:
        case AL:
        case E8e:
        case T8e:
        case P8e:
        case N8e:
        case O8e:
            return !0;
        default:
            return !1
    }
}

function B8e(t, e) {
    return U8e(t, (r, n, i, s) => {
        if (typeof t == "object") switch (Object.prototype.toString.call(t)) {
            case kL:
            case AL:
            case IL:
                {
                    const a = new t.constructor(t == null ? void 0 : t.valueOf());
                    return Ml(a, t),
                    a
                }
            case $L:
                {
                    const a = {};
                    return Ml(a, t),
                    a.length = t.length,
                    a[Symbol.iterator] = t[Symbol.iterator],
                    a
                }
            default:
                return
        }
    })
}

function tI(t) {
    return B8e(t)
}

function rI(t) {
    return t !== null && typeof t == "object" && CL(t) === "[object Arguments]"
}

function nI(t) {
    return typeof t == "object" && t !== null
}

function W8e() {}

function z8e(t) {
    return r8(t)
}

function q8e(t) {
    var r;
    if (typeof t != "object" || t == null) return !1;
    if (Object.getPrototypeOf(t) === null) return !0;
    if (Object.prototype.toString.call(t) !== "[object Object]") {
        const n = t[Symbol.toStringTag];
        return n == null || !((r = Object.getOwnPropertyDescriptor(t, Symbol.toStringTag)) != null && r.writable) ? !1 : t.toString() === `[object ${n}]`
    }
    let e = t;
    for (; Object.getPrototypeOf(e) !== null;) e = Object.getPrototypeOf(e);
    return Object.getPrototypeOf(t) === e
}

function H8e(t) {
    if (t8(t)) return t;
    if (Array.isArray(t) || r8(t) || t instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer) return t.slice(0);
    const e = Object.getPrototypeOf(t),
        r = e.constructor;
    if (t instanceof Date || t instanceof Map || t instanceof Set) return new r(t);
    if (t instanceof RegExp) {
        const n = new r(t);
        return n.lastIndex = t.lastIndex, n
    }
    if (t instanceof DataView) return new r(t.buffer.slice(0));
    if (t instanceof Error) {
        const n = new r(t.message);
        return n.stack = t.stack, n.name = t.name, n.cause = t.cause, n
    }
    if (typeof File < "u" && t instanceof File) return new r([t], t.name, {
        type: t.type,
        lastModified: t.lastModified
    });
    if (typeof t == "object") {
        const n = Object.create(e);
        return Object.assign(n, t)
    }
    return t
}

function V8e(t, ...e) {
    const r = e.slice(0, -1),
        n = e[e.length - 1];
    let i = t;
    for (let s = 0; s < r.length; s++) {
        const a = r[s];
        i = r4(i, a, n, new Map)
    }
    return i
}

function r4(t, e, r, n) {
    if (t8(t) && (t = Object(t)), e == null || typeof e != "object") return t;
    if (n.has(e)) return H8e(n.get(e));
    if (n.set(e, t), Array.isArray(e)) {
        e = e.slice();
        for (let s = 0; s < e.length; s++) e[s] = e[s] ? ? void 0
    }
    const i = [...Object.keys(e), ..._L(e)];
    for (let s = 0; s < i.length; s++) {
        const a = i[s];
        let o = e[a],
            c = t[a];
        if (rI(o) && (o = { ...o
            }), rI(c) && (c = { ...c
            }), typeof Ve < "u" && Ve.isBuffer(o) && (o = tI(o)), Array.isArray(o))
            if (typeof c == "object" && c != null) {
                const u = [],
                    h = Reflect.ownKeys(c);
                for (let f = 0; f < h.length; f++) {
                    const p = h[f];
                    u[p] = c[p]
                }
                c = u
            } else c = [];
        const l = r(c, o, a, t, e, n);
        l != null ? t[a] = l : Array.isArray(o) || nI(c) && nI(o) ? t[a] = r4(c, o, r, n) : c == null && q8e(o) ? t[a] = r4({}, o, r, n) : c == null && z8e(o) ? t[a] = tI(o) : (c === void 0 || o !== void 0) && (t[a] = o)
    }
    return t
}

function G8e(t, ...e) {
    return V8e(t, ...e, W8e)
}
var K8e = Object.defineProperty,
    Y8e = Object.defineProperties,
    Z8e = Object.getOwnPropertyDescriptors,
    iI = Object.getOwnPropertySymbols,
    J8e = Object.prototype.hasOwnProperty,
    Q8e = Object.prototype.propertyIsEnumerable,
    sI = (t, e, r) => e in t ? K8e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    kg = (t, e) => {
        for (var r in e || (e = {})) J8e.call(e, r) && sI(t, r, e[r]);
        if (iI)
            for (var r of iI(e)) Q8e.call(e, r) && sI(t, r, e[r]);
        return t
    },
    X8e = (t, e) => Y8e(t, Z8e(e));

function cs(t, e, r) {
    var n;
    const i = zu(t);
    return ((n = e.rpcMap) == null ? void 0 : n[i.reference]) || `${EL}?chainId=${i.namespace}:${i.reference}&projectId=${r}`
}

function Dd(t) {
    return t.includes(":") ? t.split(":")[1] : t
}

function SL(t) {
    return t.map(e => `${e.split(":")[0]}:${e.split(":")[1]}`)
}

function eEe(t, e) {
    const r = Object.keys(e.namespaces).filter(i => i.includes(t));
    if (!r.length) return [];
    const n = [];
    return r.forEach(i => {
        const s = e.namespaces[i].accounts;
        n.push(...s)
    }), n
}

function aI(t) {
    return Object.fromEntries(Object.entries(t).filter(([e, r]) => {
        var n, i;
        return ((n = r == null ? void 0 : r.chains) == null ? void 0 : n.length) && ((i = r == null ? void 0 : r.chains) == null ? void 0 : i.length) > 0
    }))
}

function Ig(t = {}, e = {}) {
    const r = aI(oI(t)),
        n = aI(oI(e));
    return G8e(r, n)
}

function oI(t) {
    var e, r, n, i, s;
    const a = {};
    if (!ao(t)) return a;
    for (const [o, c] of Object.entries(t)) {
        const l = Ry(o) ? [o] : c.chains,
            u = c.methods || [],
            h = c.events || [],
            f = c.rpcMap || {},
            p = Su(o);
        a[p] = X8e(kg(kg({}, a[p]), c), {
            chains: so(l, (e = a[p]) == null ? void 0 : e.chains),
            methods: so(u, (r = a[p]) == null ? void 0 : r.methods),
            events: so(h, (n = a[p]) == null ? void 0 : n.events)
        }), (ao(f) || ao(((i = a[p]) == null ? void 0 : i.rpcMap) || {})) && (a[p].rpcMap = kg(kg({}, f), (s = a[p]) == null ? void 0 : s.rpcMap))
    }
    return a
}

function cI(t) {
    return t.includes(":") ? t.split(":")[2] : t
}

function lI(t) {
    const e = {};
    for (const [r, n] of Object.entries(t)) {
        const i = n.methods || [],
            s = n.events || [],
            a = n.accounts || [],
            o = Ry(r) ? [r] : n.chains ? n.chains : SL(n.accounts);
        e[r] = {
            chains: o,
            methods: i,
            events: s,
            accounts: a
        }
    }
    return e
}

function Mb(t) {
    return typeof t == "number" ? t : t.includes("0x") ? parseInt(t, 16) : (t = t.includes(":") ? t.split(":")[1] : t, isNaN(Number(t)) ? t : Number(t))
}
const TL = {},
    Xt = t => TL[t],
    Db = (t, e) => {
        TL[t] = e
    };
var tEe = Object.defineProperty,
    dI = Object.getOwnPropertySymbols,
    rEe = Object.prototype.hasOwnProperty,
    nEe = Object.prototype.propertyIsEnumerable,
    uI = (t, e, r) => e in t ? tEe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    hI = (t, e) => {
        for (var r in e || (e = {})) rEe.call(e, r) && uI(t, r, e[r]);
        if (dI)
            for (var r of dI(e)) nEe.call(e, r) && uI(t, r, e[r]);
        return t
    };
const fI = "eip155",
    iEe = ["atomic", "flow-control", "paymasterService", "sessionKeys", "auxiliaryFunds"],
    sEe = t => t && t.startsWith("0x") ? BigInt(t).toString(10) : t,
    Lb = t => t && t.startsWith("0x") ? t : `0x${BigInt(t).toString(16)}`,
    pI = t => Object.keys(t).filter(e => iEe.includes(e)).reduce((e, r) => (e[r] = t[r], e), {}),
    aEe = (t, e, r) => {
        const {
            sessionProperties: n = {},
            scopedProperties: i = {}
        } = t, s = {};
        if (!ao(i) && !ao(n)) return;
        const a = pI(n);
        for (const o of r) {
            const c = sEe(o);
            if (!c) continue;
            s[Lb(c)] = a;
            const l = i == null ? void 0 : i[`${fI}:${c}`];
            if (l) {
                const u = l == null ? void 0 : l[`${fI}:${c}:${e}`];
                s[Lb(c)] = hI(hI({}, s[Lb(c)]), pI(u || l))
            }
        }
        for (const [o, c] of Object.entries(s)) Object.keys(c).length === 0 && delete s[o];
        return Object.keys(s).length > 0 ? s : void 0
    };
var oEe = Object.defineProperty,
    cEe = (t, e, r) => e in t ? oEe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    cu = (t, e, r) => cEe(t, typeof e != "symbol" ? e + "" : e, r);
class lEe {
    constructor(e) {
        cu(this, "name", "polkadot"), cu(this, "client"), cu(this, "httpProviders"), cu(this, "events"), cu(this, "namespace"), cu(this, "chainId"), this.namespace = e.namespace, this.events = Xt("events"), this.client = Xt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(Vs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? e.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]) || [] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(r => {
            var n;
            const i = Dd(r);
            e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            r = this.httpProviders[e];
        if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return r
    }
    setHttpProvider(e, r) {
        const n = this.createHttpProvider(e, r);
        n && (this.httpProviders[e] = n)
    }
    createHttpProvider(e, r) {
        const n = r || cs(e, this.namespace, this.client.core.projectId);
        if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Hs(new Ra(n, Xt("disableProviderPing")))
    }
}
var dEe = Object.defineProperty,
    uEe = Object.defineProperties,
    hEe = Object.getOwnPropertyDescriptors,
    gI = Object.getOwnPropertySymbols,
    fEe = Object.prototype.hasOwnProperty,
    pEe = Object.prototype.propertyIsEnumerable,
    n4 = (t, e, r) => e in t ? dEe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    mI = (t, e) => {
        for (var r in e || (e = {})) fEe.call(e, r) && n4(t, r, e[r]);
        if (gI)
            for (var r of gI(e)) pEe.call(e, r) && n4(t, r, e[r]);
        return t
    },
    yI = (t, e) => uEe(t, hEe(e)),
    lu = (t, e, r) => n4(t, typeof e != "symbol" ? e + "" : e, r);
class gEe {
    constructor(e) {
        lu(this, "name", "eip155"), lu(this, "client"), lu(this, "chainId"), lu(this, "namespace"), lu(this, "httpProviders"), lu(this, "events"), this.namespace = e.namespace, this.events = Xt("events"), this.client = Xt("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain())
    }
    async request(e) {
        switch (e.request.method) {
            case "eth_requestAccounts":
                return this.getAccounts();
            case "eth_accounts":
                return this.getAccounts();
            case "wallet_switchEthereumChain":
                return await this.handleSwitchChain(e);
            case "eth_chainId":
                return parseInt(this.getDefaultChain());
            case "wallet_getCapabilities":
                return await this.getCapabilities(e);
            case "wallet_getCallsStatus":
                return await this.getCallStatus(e)
        }
        return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(parseInt(e), r), this.chainId = parseInt(e), this.events.emit(Vs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId.toString();
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    createHttpProvider(e, r) {
        const n = r || cs(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
        if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Hs(new Ra(n, Xt("disableProviderPing")))
    }
    setHttpProvider(e, r) {
        const n = this.createHttpProvider(e, r);
        n && (this.httpProviders[e] = n)
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(r => {
            var n;
            const i = parseInt(Dd(r));
            e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r])
        }), e
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
    }
    getHttpProvider() {
        const e = this.chainId,
            r = this.httpProviders[e];
        if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return r
    }
    async handleSwitchChain(e) {
        var r, n;
        let i = e.request.params ? (r = e.request.params[0]) == null ? void 0 : r.chainId : "0x0";
        i = i.startsWith("0x") ? i : `0x${i}`;
        const s = parseInt(i, 16);
        if (this.isChainApproved(s)) this.setDefaultChain(`${s}`);
        else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({
            topic: e.topic,
            request: {
                method: e.request.method,
                params: [{
                    chainId: i
                }]
            },
            chainId: (n = this.namespace.chains) == null ? void 0 : n[0]
        }), this.setDefaultChain(`${s}`);
        else throw new Error(`Failed to switch to chain 'eip155:${s}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
        return null
    }
    isChainApproved(e) {
        return this.namespace.chains.includes(`${this.name}:${e}`)
    }
    async getCapabilities(e) {
        var r, n, i, s, a;
        const o = (n = (r = e.request) == null ? void 0 : r.params) == null ? void 0 : n[0],
            c = ((s = (i = e.request) == null ? void 0 : i.params) == null ? void 0 : s[1]) || [];
        if (!o) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
        const l = this.client.session.get(e.topic),
            u = ((a = l == null ? void 0 : l.sessionProperties) == null ? void 0 : a.capabilities) || {},
            h = `${o}${c.join(",")}`,
            f = u == null ? void 0 : u[h];
        if (f) return f;
        let p;
        try {
            p = aEe(l, o, c)
        } catch (m) {
            console.warn("Failed to extract capabilities from session", m)
        }
        if (p) return p;
        const g = await this.client.request(e);
        try {
            await this.client.session.update(e.topic, {
                sessionProperties: yI(mI({}, l.sessionProperties || {}), {
                    capabilities: yI(mI({}, u || {}), {
                        [h]: g
                    })
                })
            })
        } catch (m) {
            console.warn("Failed to update session with capabilities", m)
        }
        return g
    }
    async getCallStatus(e) {
        var r, n;
        const i = this.client.session.get(e.topic),
            s = (r = i.sessionProperties) == null ? void 0 : r.bundler_name;
        if (s) {
            const o = this.getBundlerUrl(e.chainId, s);
            try {
                return await this.getUserOperationReceipt(o, e)
            } catch (c) {
                console.warn("Failed to fetch call status from bundler", c, o)
            }
        }
        const a = (n = i.sessionProperties) == null ? void 0 : n.bundler_url;
        if (a) try {
            return await this.getUserOperationReceipt(a, e)
        } catch (o) {
            console.warn("Failed to fetch call status from custom bundler", o, a)
        }
        if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e);
        throw new Error("Fetching call status not approved by the wallet.")
    }
    async getUserOperationReceipt(e, r) {
        var n;
        const i = new URL(e),
            s = await fetch(i, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(Zc("eth_getUserOperationReceipt", [(n = r.request.params) == null ? void 0 : n[0]]))
            });
        if (!s.ok) throw new Error(`Failed to fetch user operation receipt - ${s.status}`);
        return await s.json()
    }
    getBundlerUrl(e, r) {
        return `${v8e}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${r}`
    }
}
var mEe = Object.defineProperty,
    yEe = (t, e, r) => e in t ? mEe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    du = (t, e, r) => yEe(t, typeof e != "symbol" ? e + "" : e, r);
class wEe {
    constructor(e) {
        du(this, "name", "solana"), du(this, "client"), du(this, "httpProviders"), du(this, "events"), du(this, "namespace"), du(this, "chainId"), this.namespace = e.namespace, this.events = Xt("events"), this.client = Xt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(Vs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(r => {
            var n;
            const i = Dd(r);
            e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            r = this.httpProviders[e];
        if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return r
    }
    setHttpProvider(e, r) {
        const n = this.createHttpProvider(e, r);
        n && (this.httpProviders[e] = n)
    }
    createHttpProvider(e, r) {
        const n = r || cs(e, this.namespace, this.client.core.projectId);
        if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Hs(new Ra(n, Xt("disableProviderPing")))
    }
}
var bEe = Object.defineProperty,
    vEe = (t, e, r) => e in t ? bEe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    uu = (t, e, r) => vEe(t, typeof e != "symbol" ? e + "" : e, r);
class xEe {
    constructor(e) {
        uu(this, "name", "cosmos"), uu(this, "client"), uu(this, "httpProviders"), uu(this, "events"), uu(this, "namespace"), uu(this, "chainId"), this.namespace = e.namespace, this.events = Xt("events"), this.client = Xt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(Vs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(r => {
            var n;
            const i = Dd(r);
            e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            r = this.httpProviders[e];
        if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return r
    }
    setHttpProvider(e, r) {
        const n = this.createHttpProvider(e, r);
        n && (this.httpProviders[e] = n)
    }
    createHttpProvider(e, r) {
        const n = r || cs(e, this.namespace, this.client.core.projectId);
        if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Hs(new Ra(n, Xt("disableProviderPing")))
    }
}
var EEe = Object.defineProperty,
    _Ee = (t, e, r) => e in t ? EEe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    hu = (t, e, r) => _Ee(t, typeof e != "symbol" ? e + "" : e, r);
class CEe {
    constructor(e) {
        hu(this, "name", "algorand"), hu(this, "client"), hu(this, "httpProviders"), hu(this, "events"), hu(this, "namespace"), hu(this, "chainId"), this.namespace = e.namespace, this.events = Xt("events"), this.client = Xt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, r) {
        if (!this.httpProviders[e]) {
            const n = r || cs(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
            if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, n)
        }
        this.chainId = e, this.events.emit(Vs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(r => {
            var n;
            e[r] = this.createHttpProvider(r, (n = this.namespace.rpcMap) == null ? void 0 : n[r])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            r = this.httpProviders[e];
        if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return r
    }
    setHttpProvider(e, r) {
        const n = this.createHttpProvider(e, r);
        n && (this.httpProviders[e] = n)
    }
    createHttpProvider(e, r) {
        const n = r || cs(e, this.namespace, this.client.core.projectId);
        return typeof n > "u" ? void 0 : new Hs(new Ra(n, Xt("disableProviderPing")))
    }
}
var AEe = Object.defineProperty,
    kEe = (t, e, r) => e in t ? AEe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    fu = (t, e, r) => kEe(t, typeof e != "symbol" ? e + "" : e, r);
class IEe {
    constructor(e) {
        fu(this, "name", "cip34"), fu(this, "client"), fu(this, "httpProviders"), fu(this, "events"), fu(this, "namespace"), fu(this, "chainId"), this.namespace = e.namespace, this.events = Xt("events"), this.client = Xt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(Vs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(r => {
            const n = this.getCardanoRPCUrl(r),
                i = Dd(r);
            e[i] = this.createHttpProvider(i, n)
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            r = this.httpProviders[e];
        if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return r
    }
    getCardanoRPCUrl(e) {
        const r = this.namespace.rpcMap;
        if (r) return r[e]
    }
    setHttpProvider(e, r) {
        const n = this.createHttpProvider(e, r);
        n && (this.httpProviders[e] = n)
    }
    createHttpProvider(e, r) {
        const n = r || this.getCardanoRPCUrl(e);
        if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Hs(new Ra(n, Xt("disableProviderPing")))
    }
}
var $Ee = Object.defineProperty,
    SEe = (t, e, r) => e in t ? $Ee(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    pu = (t, e, r) => SEe(t, typeof e != "symbol" ? e + "" : e, r);
class TEe {
    constructor(e) {
        pu(this, "name", "elrond"), pu(this, "client"), pu(this, "httpProviders"), pu(this, "events"), pu(this, "namespace"), pu(this, "chainId"), this.namespace = e.namespace, this.events = Xt("events"), this.client = Xt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(Vs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(r => {
            var n;
            const i = Dd(r);
            e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            r = this.httpProviders[e];
        if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return r
    }
    setHttpProvider(e, r) {
        const n = this.createHttpProvider(e, r);
        n && (this.httpProviders[e] = n)
    }
    createHttpProvider(e, r) {
        const n = r || cs(e, this.namespace, this.client.core.projectId);
        if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Hs(new Ra(n, Xt("disableProviderPing")))
    }
}
var PEe = Object.defineProperty,
    NEe = (t, e, r) => e in t ? PEe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    gu = (t, e, r) => NEe(t, typeof e != "symbol" ? e + "" : e, r);
let OEe = class {
    constructor(e) {
        gu(this, "name", "multiversx"), gu(this, "client"), gu(this, "httpProviders"), gu(this, "events"), gu(this, "namespace"), gu(this, "chainId"), this.namespace = e.namespace, this.events = Xt("events"), this.client = Xt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(Vs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(r => {
            var n;
            const i = Dd(r);
            e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            r = this.httpProviders[e];
        if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return r
    }
    setHttpProvider(e, r) {
        const n = this.createHttpProvider(e, r);
        n && (this.httpProviders[e] = n)
    }
    createHttpProvider(e, r) {
        const n = r || cs(e, this.namespace, this.client.core.projectId);
        if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Hs(new Ra(n, Xt("disableProviderPing")))
    }
};
var jEe = Object.defineProperty,
    REe = (t, e, r) => e in t ? jEe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    mu = (t, e, r) => REe(t, typeof e != "symbol" ? e + "" : e, r);
let MEe = class {
    constructor(e) {
        mu(this, "name", "near"), mu(this, "client"), mu(this, "httpProviders"), mu(this, "events"), mu(this, "namespace"), mu(this, "chainId"), this.namespace = e.namespace, this.events = Xt("events"), this.client = Xt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, r) {
        if (this.chainId = e, !this.httpProviders[e]) {
            const n = r || cs(`${this.name}:${e}`, this.namespace);
            if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, n)
        }
        this.events.emit(Vs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? e.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]) || [] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(r => {
            var n;
            e[r] = this.createHttpProvider(r, (n = this.namespace.rpcMap) == null ? void 0 : n[r])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            r = this.httpProviders[e];
        if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return r
    }
    setHttpProvider(e, r) {
        const n = this.createHttpProvider(e, r);
        n && (this.httpProviders[e] = n)
    }
    createHttpProvider(e, r) {
        const n = r || cs(e, this.namespace);
        return typeof n > "u" ? void 0 : new Hs(new Ra(n, Xt("disableProviderPing")))
    }
};
var DEe = Object.defineProperty,
    LEe = (t, e, r) => e in t ? DEe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    yu = (t, e, r) => LEe(t, typeof e != "symbol" ? e + "" : e, r);
let UEe = class {
    constructor(e) {
        yu(this, "name", "tezos"), yu(this, "client"), yu(this, "httpProviders"), yu(this, "events"), yu(this, "namespace"), yu(this, "chainId"), this.namespace = e.namespace, this.events = Xt("events"), this.client = Xt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, r) {
        if (this.chainId = e, !this.httpProviders[e]) {
            const n = r || cs(`${this.name}:${e}`, this.namespace);
            if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, n)
        }
        this.events.emit(Vs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? e.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]) || [] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(r => {
            e[r] = this.createHttpProvider(r)
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            r = this.httpProviders[e];
        if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return r
    }
    setHttpProvider(e, r) {
        const n = this.createHttpProvider(e, r);
        n && (this.httpProviders[e] = n)
    }
    createHttpProvider(e, r) {
        const n = r || cs(e, this.namespace);
        return typeof n > "u" ? void 0 : new Hs(new Ra(n))
    }
};
var FEe = Object.defineProperty,
    BEe = (t, e, r) => e in t ? FEe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    wu = (t, e, r) => BEe(t, typeof e != "symbol" ? e + "" : e, r);
let WEe = class {
    constructor(e) {
        wu(this, "name", Cu), wu(this, "client"), wu(this, "httpProviders"), wu(this, "events"), wu(this, "namespace"), wu(this, "chainId"), this.namespace = e.namespace, this.events = Xt("events"), this.client = Xt("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))], this.httpProviders = this.createHttpProviders()
    }
    requestAccounts() {
        return this.getAccounts()
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request)
    }
    setDefaultChain(e, r) {
        this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(Vs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
    }
    createHttpProviders() {
        var e, r;
        const n = {};
        return (r = (e = this.namespace) == null ? void 0 : e.accounts) == null || r.forEach(i => {
            const s = zu(i);
            n[`${s.namespace}:${s.reference}`] = this.createHttpProvider(i)
        }), n
    }
    getHttpProvider(e) {
        const r = this.httpProviders[e];
        if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return r
    }
    setHttpProvider(e, r) {
        const n = this.createHttpProvider(e, r);
        n && (this.httpProviders[e] = n)
    }
    createHttpProvider(e, r) {
        const n = r || cs(e, this.namespace, this.client.core.projectId);
        if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new Hs(new Ra(n, Xt("disableProviderPing")))
    }
};
var zEe = Object.defineProperty,
    qEe = Object.defineProperties,
    HEe = Object.getOwnPropertyDescriptors,
    wI = Object.getOwnPropertySymbols,
    VEe = Object.prototype.hasOwnProperty,
    GEe = Object.prototype.propertyIsEnumerable,
    i4 = (t, e, r) => e in t ? zEe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    $g = (t, e) => {
        for (var r in e || (e = {})) VEe.call(e, r) && i4(t, r, e[r]);
        if (wI)
            for (var r of wI(e)) GEe.call(e, r) && i4(t, r, e[r]);
        return t
    },
    Ub = (t, e) => qEe(t, HEe(e)),
    xs = (t, e, r) => i4(t, typeof e != "symbol" ? e + "" : e, r);
let KEe = class PL {
    constructor(e) {
        xs(this, "client"), xs(this, "namespaces"), xs(this, "optionalNamespaces"), xs(this, "sessionProperties"), xs(this, "scopedProperties"), xs(this, "events", new _x), xs(this, "rpcProviders", {}), xs(this, "session"), xs(this, "providerOpts"), xs(this, "logger"), xs(this, "uri"), xs(this, "disableProviderPing", !1), this.providerOpts = e, this.logger = typeof(e == null ? void 0 : e.logger) < "u" && typeof(e == null ? void 0 : e.logger) != "string" ? e.logger : $0(My({
            level: (e == null ? void 0 : e.logger) || eI
        })), this.disableProviderPing = (e == null ? void 0 : e.disableProviderPing) || !1
    }
    static async init(e) {
        const r = new PL(e);
        return await r.initialize(), r
    }
    async request(e, r, n) {
        const [i, s] = this.validateChain(r);
        if (!this.session) throw new Error("Please call connect() before request()");
        return await this.getProvider(i).request({
            request: $g({}, e),
            chainId: `${i}:${s}`,
            topic: this.session.topic,
            expiry: n
        })
    }
    sendAsync(e, r, n, i) {
        const s = new Date().getTime();
        this.request(e, n, i).then(a => r(null, Dy(s, a))).catch(a => r(a, void 0))
    }
    async enable() {
        if (!this.client) throw new Error("Sign Client not initialized");
        return this.session || await this.connect({
            namespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties
        }), await this.requestAccounts()
    }
    async disconnect() {
        var e;
        if (!this.session) throw new Error("Please call connect() before enable()");
        await this.client.disconnect({
            topic: (e = this.session) == null ? void 0 : e.topic,
            reason: _r("USER_DISCONNECTED")
        }), await this.cleanup()
    }
    async connect(e) {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic)
    }
    async authenticate(e, r) {
        if (!this.client) throw new Error("Sign Client not initialized");
        this.setNamespaces(e), await this.cleanupPendingPairings();
        const {
            uri: n,
            response: i
        } = await this.client.authenticate(e, r);
        n && (this.uri = n, this.events.emit("display_uri", n));
        const s = await i();
        if (this.session = s.session, this.session) {
            const a = lI(this.session.namespaces);
            this.namespaces = Ig(this.namespaces, a), await this.persist("namespaces", this.namespaces), this.onConnect()
        }
        return s
    }
    on(e, r) {
        this.events.on(e, r)
    }
    once(e, r) {
        this.events.once(e, r)
    }
    removeListener(e, r) {
        this.events.removeListener(e, r)
    }
    off(e, r) {
        this.events.off(e, r)
    }
    get isWalletConnect() {
        return !0
    }
    async pair(e) {
        const {
            uri: r,
            approval: n
        } = await this.client.connect({
            pairingTopic: e,
            requiredNamespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties
        });
        r && (this.uri = r, this.events.emit("display_uri", r));
        const i = await n();
        this.session = i;
        const s = lI(i.namespaces);
        return this.namespaces = Ig(this.namespaces, s), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session
    }
    setDefaultChain(e, r) {
        try {
            if (!this.session) return;
            const [n, i] = this.validateChain(e), s = this.getProvider(n);
            s.name === Cu ? s.setDefaultChain(`${n}:${i}`, r) : s.setDefaultChain(i, r)
        } catch (n) {
            if (!/Please call connect/.test(n.message)) throw n
        }
    }
    async cleanupPendingPairings(e = {}) {
        this.logger.info("Cleaning up inactive pairings...");
        const r = this.client.pairing.getAll();
        if (Ps(r)) {
            for (const n of r) e.deletePairings ? this.client.core.expirer.set(n.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(n.topic);
            this.logger.info(`Inactive pairings cleared: ${r.length}`)
        }
    }
    abortPairingAttempt() {
        this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")
    }
    async checkStorage() {
        this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders()
    }
    async initialize() {
        this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners()
    }
    async createClient() {
        var e, r;
        if (this.client = this.providerOpts.client || await o8e.init({
                core: this.providerOpts.core,
                logger: this.providerOpts.logger || eI,
                relayUrl: this.providerOpts.relayUrl || y8e,
                projectId: this.providerOpts.projectId,
                metadata: this.providerOpts.metadata,
                storageOptions: this.providerOpts.storageOptions,
                storage: this.providerOpts.storage,
                name: this.providerOpts.name,
                customStoragePrefix: this.providerOpts.customStoragePrefix,
                telemetryEnabled: this.providerOpts.telemetryEnabled
            }), this.providerOpts.session) try {
            this.session = this.client.session.get(this.providerOpts.session.topic)
        } catch (n) {
            throw this.logger.error("Failed to get session", n), new Error(`The provided session: ${(r=(e=this.providerOpts)==null?void 0:e.session)==null?void 0:r.topic} doesn't exist in the Sign client`)
        } else {
            const n = this.client.session.getAll();
            this.session = n[0]
        }
        this.logger.trace("SignClient Initialized")
    }
    createProviders() {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
        const e = [...new Set(Object.keys(this.session.namespaces).map(r => Su(r)))];
        Db("client", this.client), Db("events", this.events), Db("disableProviderPing", this.disableProviderPing), e.forEach(r => {
            if (!this.session) return;
            const n = eEe(r, this.session);
            if ((n == null ? void 0 : n.length) === 0) return;
            const i = SL(n),
                s = Ig(this.namespaces, this.optionalNamespaces),
                a = Ub($g({}, s[r]), {
                    accounts: n,
                    chains: i
                });
            switch (r) {
                case "eip155":
                    this.rpcProviders[r] = new gEe({
                        namespace: a
                    });
                    break;
                case "algorand":
                    this.rpcProviders[r] = new CEe({
                        namespace: a
                    });
                    break;
                case "solana":
                    this.rpcProviders[r] = new wEe({
                        namespace: a
                    });
                    break;
                case "cosmos":
                    this.rpcProviders[r] = new xEe({
                        namespace: a
                    });
                    break;
                case "polkadot":
                    this.rpcProviders[r] = new lEe({
                        namespace: a
                    });
                    break;
                case "cip34":
                    this.rpcProviders[r] = new IEe({
                        namespace: a
                    });
                    break;
                case "elrond":
                    this.rpcProviders[r] = new TEe({
                        namespace: a
                    });
                    break;
                case "multiversx":
                    this.rpcProviders[r] = new OEe({
                        namespace: a
                    });
                    break;
                case "near":
                    this.rpcProviders[r] = new MEe({
                        namespace: a
                    });
                    break;
                case "tezos":
                    this.rpcProviders[r] = new UEe({
                        namespace: a
                    });
                    break;
                default:
                    this.rpcProviders[Cu] ? this.rpcProviders[Cu].updateNamespace(a) : this.rpcProviders[Cu] = new WEe({
                        namespace: a
                    })
            }
        })
    }
    registerEventListeners() {
        if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
        this.client.on("session_ping", e => {
            var r;
            const {
                topic: n
            } = e;
            n === ((r = this.session) == null ? void 0 : r.topic) && this.events.emit("session_ping", e)
        }), this.client.on("session_event", e => {
            var r;
            const {
                params: n,
                topic: i
            } = e;
            if (i !== ((r = this.session) == null ? void 0 : r.topic)) return;
            const {
                event: s
            } = n;
            if (s.name === "accountsChanged") {
                const a = s.data;
                a && Ps(a) && this.events.emit("accountsChanged", a.map(cI))
            } else if (s.name === "chainChanged") {
                const a = n.chainId,
                    o = n.event.data,
                    c = Su(a),
                    l = Mb(a) !== Mb(o) ? `${c}:${Mb(o)}` : a;
                this.onChainChanged(l)
            } else this.events.emit(s.name, s.data);
            this.events.emit("session_event", e)
        }), this.client.on("session_update", ({
            topic: e,
            params: r
        }) => {
            var n, i;
            if (e !== ((n = this.session) == null ? void 0 : n.topic)) return;
            const {
                namespaces: s
            } = r, a = (i = this.client) == null ? void 0 : i.session.get(e);
            this.session = Ub($g({}, a), {
                namespaces: s
            }), this.onSessionUpdate(), this.events.emit("session_update", {
                topic: e,
                params: r
            })
        }), this.client.on("session_delete", async e => {
            var r;
            e.topic === ((r = this.session) == null ? void 0 : r.topic) && (await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", Ub($g({}, _r("USER_DISCONNECTED")), {
                data: e.topic
            })))
        }), this.on(Vs.DEFAULT_CHAIN_CHANGED, e => {
            this.onChainChanged(e, !0)
        })
    }
    getProvider(e) {
        return this.rpcProviders[e] || this.rpcProviders[Cu]
    }
    onSessionUpdate() {
        Object.keys(this.rpcProviders).forEach(e => {
            var r;
            this.getProvider(e).updateNamespace((r = this.session) == null ? void 0 : r.namespaces[e])
        })
    }
    setNamespaces(e) {
        const {
            namespaces: r = {},
            optionalNamespaces: n = {},
            sessionProperties: i,
            scopedProperties: s
        } = e;
        this.optionalNamespaces = Ig(r, n), this.sessionProperties = i, this.scopedProperties = s
    }
    validateChain(e) {
        const [r, n] = (e == null ? void 0 : e.split(":")) || ["", ""];
        if (!this.namespaces || !Object.keys(this.namespaces).length) return [r, n];
        if (r && !Object.keys(this.namespaces || {}).map(a => Su(a)).includes(r)) throw new Error(`Namespace '${r}' is not configured. Please call connect() first with namespace config.`);
        if (r && n) return [r, n];
        const i = Su(Object.keys(this.namespaces)[0]),
            s = this.rpcProviders[i].getDefaultChain();
        return [i, s]
    }
    async requestAccounts() {
        const [e] = this.validateChain();
        return await this.getProvider(e).requestAccounts()
    }
    async onChainChanged(e, r = !1) {
        if (!this.namespaces) return;
        const [n, i] = this.validateChain(e);
        if (!i) return;
        this.updateNamespaceChain(n, i), this.events.emit("chainChanged", i);
        const s = this.getProvider(n).getDefaultChain();
        r || this.getProvider(n).setDefaultChain(i), this.emitAccountsChangedOnChainChange({
            namespace: n,
            previousChainId: s,
            newChainId: e
        }), await this.persist("namespaces", this.namespaces)
    }
    emitAccountsChangedOnChainChange({
        namespace: e,
        previousChainId: r,
        newChainId: n
    }) {
        var i, s;
        try {
            if (r === n) return;
            const a = (s = (i = this.session) == null ? void 0 : i.namespaces[e]) == null ? void 0 : s.accounts;
            if (!a) return;
            const o = a.filter(c => c.includes(`${n}:`)).map(cI);
            if (!Ps(o)) return;
            this.events.emit("accountsChanged", o)
        } catch (a) {
            this.logger.warn("Failed to emit accountsChanged on chain change", a)
        }
    }
    updateNamespaceChain(e, r) {
        if (!this.namespaces) return;
        const n = this.namespaces[e] ? e : `${e}:${r}`,
            i = {
                chains: [],
                methods: [],
                events: [],
                defaultChain: r
            };
        this.namespaces[n] ? this.namespaces[n] && (this.namespaces[n].defaultChain = r) : this.namespaces[n] = i
    }
    onConnect() {
        this.createProviders(), this.events.emit("connect", {
            session: this.session
        })
    }
    async cleanup() {
        this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, await this.cleanupPendingPairings({
            deletePairings: !0
        }), await this.cleanupStorage()
    }
    async persist(e, r) {
        var n;
        const i = ((n = this.session) == null ? void 0 : n.topic) || "";
        await this.client.core.storage.setItem(`${Ag}/${e}${i}`, r)
    }
    async getFromStore(e) {
        var r;
        const n = ((r = this.session) == null ? void 0 : r.topic) || "";
        return await this.client.core.storage.getItem(`${Ag}/${e}${n}`)
    }
    async deleteFromStore(e) {
        var r;
        const n = ((r = this.session) == null ? void 0 : r.topic) || "";
        await this.client.core.storage.removeItem(`${Ag}/${e}${n}`)
    }
    async cleanupStorage() {
        var e;
        try {
            if (((e = this.client) == null ? void 0 : e.session.length) > 0) return;
            const r = await this.client.core.storage.getKeys();
            for (const n of r) n.startsWith(Ag) && await this.client.core.storage.removeItem(n)
        } catch (r) {
            this.logger.warn("Failed to cleanup storage", r)
        }
    }
};
const YEe = KEe,
    ZEe = "wc",
    JEe = "ethereum_provider",
    QEe = `${ZEe}@2:${JEe}:`,
    XEe = "https://rpc.walletconnect.org/v1/",
    s4 = ["eth_sendTransaction", "personal_sign"],
    NL = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode", "wallet_sendCalls", "wallet_getCapabilities", "wallet_getCallsStatus", "wallet_showCallsStatus"],
    a4 = ["chainChanged", "accountsChanged"],
    OL = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"],
    e7e = async () => {
        const {
            createAppKit: t
        } = await ma(() =>
            import ("./core-C7HL8QDL.js").then(e => e.J), __vite__mapDeps([2, 3, 0, 1, 4]));
        return t
    };
var t7e = Object.defineProperty,
    r7e = Object.defineProperties,
    n7e = Object.getOwnPropertyDescriptors,
    bI = Object.getOwnPropertySymbols,
    i7e = Object.prototype.hasOwnProperty,
    s7e = Object.prototype.propertyIsEnumerable,
    o4 = (t, e, r) => e in t ? t7e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Sl = (t, e) => {
        for (var r in e || (e = {})) i7e.call(e, r) && o4(t, r, e[r]);
        if (bI)
            for (var r of bI(e)) s7e.call(e, r) && o4(t, r, e[r]);
        return t
    },
    lf = (t, e) => r7e(t, n7e(e)),
    Vi = (t, e, r) => o4(t, typeof e != "symbol" ? e + "" : e, r);

function s1(t) {
    return Number(t[0].split(":")[1])
}

function Sg(t) {
    return `0x${t.toString(16)}`
}

function a7e(t) {
    const {
        chains: e,
        optionalChains: r,
        methods: n,
        optionalMethods: i,
        events: s,
        optionalEvents: a,
        rpcMap: o
    } = t;
    if (!Ps(e)) throw new Error("Invalid chains");
    const c = {
            chains: e,
            methods: n || s4,
            events: s || a4,
            rpcMap: Sl({}, e.length ? {
                [s1(e)]: o[s1(e)]
            } : {})
        },
        l = s == null ? void 0 : s.filter(p => !a4.includes(p)),
        u = n == null ? void 0 : n.filter(p => !s4.includes(p));
    if (!r && !a && !i && !(l != null && l.length) && !(u != null && u.length)) return {
        required: e.length ? c : void 0
    };
    const h = (l == null ? void 0 : l.length) && (u == null ? void 0 : u.length) || !r,
        f = {
            chains: [...new Set(h ? c.chains.concat(r || []) : r)],
            methods: [...new Set(c.methods.concat(i != null && i.length ? i : NL))],
            events: [...new Set(c.events.concat(a != null && a.length ? a : OL))],
            rpcMap: o
        };
    return {
        required: e.length ? c : void 0,
        optional: r.length ? f : void 0
    }
}
class n8 {
    constructor() {
        Vi(this, "events", new gs.EventEmitter), Vi(this, "namespace", "eip155"), Vi(this, "accounts", []), Vi(this, "signer"), Vi(this, "chainId", 1), Vi(this, "modal"), Vi(this, "rpc"), Vi(this, "STORAGE_KEY", QEe), Vi(this, "on", (e, r) => (this.events.on(e, r), this)), Vi(this, "once", (e, r) => (this.events.once(e, r), this)), Vi(this, "removeListener", (e, r) => (this.events.removeListener(e, r), this)), Vi(this, "off", (e, r) => (this.events.off(e, r), this)), Vi(this, "parseAccount", e => this.isCompatibleChainId(e) ? this.parseAccountId(e).address : e), this.signer = {}, this.rpc = {}
    }
    static async init(e) {
        const r = new n8;
        return await r.initialize(e), r
    }
    async request(e, r) {
        return await this.signer.request(e, this.formatChainId(this.chainId), r)
    }
    sendAsync(e, r, n) {
        this.signer.sendAsync(e, r, this.formatChainId(this.chainId), n)
    }
    get connected() {
        return this.signer.client ? this.signer.client.core.relayer.connected : !1
    }
    get connecting() {
        return this.signer.client ? this.signer.client.core.relayer.connecting : !1
    }
    async enable() {
        return this.session || await this.connect(), await this.request({
            method: "eth_requestAccounts"
        })
    }
    async connect(e) {
        var r;
        if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
        this.loadConnectOpts(e);
        const {
            required: n,
            optional: i
        } = a7e(this.rpc);
        try {
            const s = await new Promise(async (o, c) => {
                var l, u;
                this.rpc.showQrModal && ((l = this.modal) == null || l.open(), (u = this.modal) == null || u.subscribeState(f => {
                    !f.open && !this.signer.session && (this.signer.abortPairingAttempt(), c(new Error("Connection request reset. Please try again.")))
                }));
                const h = e != null && e.scopedProperties ? {
                    [this.namespace]: e.scopedProperties
                } : void 0;
                await this.signer.connect(lf(Sl({
                    namespaces: Sl({}, n && {
                        [this.namespace]: n
                    })
                }, i && {
                    optionalNamespaces: {
                        [this.namespace]: i
                    }
                }), {
                    pairingTopic: e == null ? void 0 : e.pairingTopic,
                    scopedProperties: h
                })).then(f => {
                    o(f)
                }).catch(f => {
                    var p;
                    (p = this.modal) == null || p.showErrorMessage("Unable to connect"), c(new Error(f.message))
                })
            });
            if (!s) return;
            const a = iA(s.namespaces, [this.namespace]);
            this.setChainIds(this.rpc.chains.length ? this.rpc.chains : a), this.setAccounts(a), this.events.emit("connect", {
                chainId: Sg(this.chainId)
            })
        } catch (s) {
            throw this.signer.logger.error(s), s
        } finally {
            (r = this.modal) == null || r.close()
        }
    }
    async authenticate(e, r) {
        var n;
        if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
        this.loadConnectOpts({
            chains: e == null ? void 0 : e.chains
        });
        try {
            const i = await new Promise(async (a, o) => {
                    var c, l;
                    this.rpc.showQrModal && ((c = this.modal) == null || c.open(), (l = this.modal) == null || l.subscribeState(u => {
                        !u.open && !this.signer.session && (this.signer.abortPairingAttempt(), o(new Error("Connection request reset. Please try again.")))
                    })), await this.signer.authenticate(lf(Sl({}, e), {
                        chains: this.rpc.chains
                    }), r).then(u => {
                        a(u)
                    }).catch(u => {
                        var h;
                        (h = this.modal) == null || h.showErrorMessage("Unable to connect"), o(new Error(u.message))
                    })
                }),
                s = i.session;
            if (s) {
                const a = iA(s.namespaces, [this.namespace]);
                this.setChainIds(this.rpc.chains.length ? this.rpc.chains : a), this.setAccounts(a), this.events.emit("connect", {
                    chainId: Sg(this.chainId)
                })
            }
            return i
        } catch (i) {
            throw this.signer.logger.error(i), i
        } finally {
            (n = this.modal) == null || n.close()
        }
    }
    async disconnect() {
        this.session && await this.signer.disconnect(), this.reset()
    }
    get isWalletConnect() {
        return !0
    }
    get session() {
        return this.signer.session
    }
    registerEventListeners() {
        this.signer.on("session_event", e => {
            const {
                params: r
            } = e, {
                event: n
            } = r;
            n.name === "accountsChanged" ? (this.accounts = this.parseAccounts(n.data), this.events.emit("accountsChanged", this.accounts)) : n.name === "chainChanged" ? this.setChainId(this.formatChainId(n.data)) : this.events.emit(n.name, n.data), this.events.emit("session_event", e)
        }), this.signer.on("accountsChanged", e => {
            this.accounts = this.parseAccounts(e), this.events.emit("accountsChanged", this.accounts)
        }), this.signer.on("chainChanged", e => {
            const r = parseInt(e);
            this.chainId = r, this.events.emit("chainChanged", Sg(this.chainId)), this.persist()
        }), this.signer.on("session_update", e => {
            this.events.emit("session_update", e)
        }), this.signer.on("session_delete", e => {
            this.reset(), this.events.emit("session_delete", e), this.events.emit("disconnect", lf(Sl({}, _r("USER_DISCONNECTED")), {
                data: e.topic,
                name: "USER_DISCONNECTED"
            }))
        }), this.signer.on("display_uri", e => {
            this.events.emit("display_uri", e)
        })
    }
    switchEthereumChain(e) {
        this.request({
            method: "wallet_switchEthereumChain",
            params: [{
                chainId: e.toString(16)
            }]
        })
    }
    isCompatibleChainId(e) {
        return typeof e == "string" ? e.startsWith(`${this.namespace}:`) : !1
    }
    formatChainId(e) {
        return `${this.namespace}:${e}`
    }
    parseChainId(e) {
        return Number(e.split(":")[1])
    }
    setChainIds(e) {
        const r = e.filter(n => this.isCompatibleChainId(n)).map(n => this.parseChainId(n));
        r.length && (this.chainId = r[0], this.events.emit("chainChanged", Sg(this.chainId)), this.persist())
    }
    setChainId(e) {
        if (this.isCompatibleChainId(e)) {
            const r = this.parseChainId(e);
            this.chainId = r, this.switchEthereumChain(r)
        }
    }
    parseAccountId(e) {
        const [r, n, i] = e.split(":");
        return {
            chainId: `${r}:${n}`,
            address: i
        }
    }
    setAccounts(e) {
        this.accounts = e.filter(r => this.parseChainId(this.parseAccountId(r).chainId) === this.chainId).map(r => this.parseAccountId(r).address), this.events.emit("accountsChanged", this.accounts)
    }
    getRpcConfig(e) {
        var r, n;
        const i = (r = e == null ? void 0 : e.chains) != null ? r : [],
            s = (n = e == null ? void 0 : e.optionalChains) != null ? n : [],
            a = i.concat(s);
        if (!a.length) throw new Error("No chains specified in either `chains` or `optionalChains`");
        const o = i.length ? (e == null ? void 0 : e.methods) || s4 : [],
            c = i.length ? (e == null ? void 0 : e.events) || a4 : [],
            l = (e == null ? void 0 : e.optionalMethods) || [],
            u = (e == null ? void 0 : e.optionalEvents) || [],
            h = (e == null ? void 0 : e.rpcMap) || this.buildRpcMap(a, e.projectId),
            f = (e == null ? void 0 : e.qrModalOptions) || void 0;
        return {
            chains: i == null ? void 0 : i.map(p => this.formatChainId(p)),
            optionalChains: s.map(p => this.formatChainId(p)),
            methods: o,
            events: c,
            optionalMethods: l,
            optionalEvents: u,
            rpcMap: h,
            showQrModal: !!(e != null && e.showQrModal),
            qrModalOptions: f,
            projectId: e.projectId,
            metadata: e.metadata
        }
    }
    buildRpcMap(e, r) {
        const n = {};
        return e.forEach(i => {
            n[i] = this.getRpcUrl(i, r)
        }), n
    }
    async initialize(e) {
        if (this.rpc = this.getRpcConfig(e), this.chainId = this.rpc.chains.length ? s1(this.rpc.chains) : s1(this.rpc.optionalChains), this.signer = await YEe.init({
                projectId: this.rpc.projectId,
                metadata: this.rpc.metadata,
                disableProviderPing: e.disableProviderPing,
                relayUrl: e.relayUrl,
                storage: e.storage,
                storageOptions: e.storageOptions,
                customStoragePrefix: e.customStoragePrefix,
                telemetryEnabled: e.telemetryEnabled,
                logger: e.logger
            }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
            let r;
            try {
                const n = await e7e(),
                    {
                        convertWCMToAppKitOptions: i
                    } = await Promise.resolve().then(function() {
                        return y7e
                    }),
                    s = i(lf(Sl({}, this.rpc.qrModalOptions), {
                        chains: [...new Set([...this.rpc.chains, ...this.rpc.optionalChains])],
                        metadata: this.rpc.metadata,
                        projectId: this.rpc.projectId
                    }));
                if (!s.networks.length) throw new Error("No networks found for WalletConnect·");
                r = n(lf(Sl({}, s), {
                    universalProvider: this.signer,
                    manualWCControl: !0
                }))
            } catch (n) {
                throw console.warn(n), new Error("To use QR modal, please install @reown/appkit package")
            }
            if (r) try {
                this.modal = r
            } catch (n) {
                throw this.signer.logger.error(n), new Error("Could not generate WalletConnectModal Instance")
            }
        }
    }
    loadConnectOpts(e) {
        if (!e) return;
        const {
            chains: r,
            optionalChains: n,
            rpcMap: i
        } = e;
        r && Ps(r) && (this.rpc.chains = r.map(s => this.formatChainId(s)), r.forEach(s => {
            this.rpc.rpcMap[s] = (i == null ? void 0 : i[s]) || this.getRpcUrl(s)
        })), n && Ps(n) && (this.rpc.optionalChains = [], this.rpc.optionalChains = n == null ? void 0 : n.map(s => this.formatChainId(s)), n.forEach(s => {
            this.rpc.rpcMap[s] = (i == null ? void 0 : i[s]) || this.getRpcUrl(s)
        }))
    }
    getRpcUrl(e, r) {
        var n;
        return ((n = this.rpc.rpcMap) == null ? void 0 : n[e]) || `${XEe}?chainId=eip155:${e}&projectId=${r||this.rpc.projectId}`
    }
    async loadPersistedSession() {
        if (this.session) try {
            const e = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),
                r = this.session.namespaces[`${this.namespace}:${e}`] ? this.session.namespaces[`${this.namespace}:${e}`] : this.session.namespaces[this.namespace];
            this.setChainIds(e ? [this.formatChainId(e)] : r == null ? void 0 : r.accounts), this.setAccounts(r == null ? void 0 : r.accounts)
        } catch (e) {
            this.signer.logger.error("Failed to load persisted session, clearing state..."), this.signer.logger.error(e), await this.disconnect().catch(r => this.signer.logger.warn(r))
        }
    }
    reset() {
        this.chainId = 1, this.accounts = []
    }
    persist() {
        this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId)
    }
    parseAccounts(e) {
        return typeof e == "string" || e instanceof String ? [this.parseAccount(e)] : e.map(r => this.parseAccount(r))
    }
}
const o7e = n8;
var c7e = Object.defineProperty,
    l7e = Object.defineProperties,
    d7e = Object.getOwnPropertyDescriptors,
    vI = Object.getOwnPropertySymbols,
    u7e = Object.prototype.hasOwnProperty,
    h7e = Object.prototype.propertyIsEnumerable,
    xI = (t, e, r) => e in t ? c7e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    jL = (t, e) => {
        for (var r in e || (e = {})) u7e.call(e, r) && xI(t, r, e[r]);
        if (vI)
            for (var r of vI(e)) h7e.call(e, r) && xI(t, r, e[r]);
        return t
    },
    f7e = (t, e) => l7e(t, d7e(e));

function p7e(t) {
    if (t) return {
        "--w3m-font-family": t["--wcm-font-family"],
        "--w3m-accent": t["--wcm-accent-color"],
        "--w3m-color-mix": t["--wcm-background-color"],
        "--w3m-z-index": t["--wcm-z-index"] ? Number(t["--wcm-z-index"]) : void 0,
        "--w3m-qr-color": t["--wcm-accent-color"],
        "--w3m-font-size-master": t["--wcm-text-medium-regular-size"],
        "--w3m-border-radius-master": t["--wcm-container-border-radius"],
        "--w3m-color-mix-strength": 0
    }
}
const g7e = t => {
    const [e, r] = t.split(":");
    return RL({
        id: r,
        caipNetworkId: t,
        chainNamespace: e,
        name: "",
        nativeCurrency: {
            name: "",
            symbol: "",
            decimals: 8
        },
        rpcUrls: {
            default: {
                http: ["https://rpc.walletconnect.org/v1"]
            }
        }
    })
};

function m7e(t) {
    var e, r, n, i, s, a, o;
    const c = (e = t.chains) == null ? void 0 : e.map(g7e).filter(Boolean);
    if (c.length === 0) throw new Error("At least one chain must be specified");
    const l = c.find(h => {
            var f;
            return h.id === ((f = t.defaultChain) == null ? void 0 : f.id)
        }),
        u = {
            projectId: t.projectId,
            networks: c,
            themeMode: t.themeMode,
            themeVariables: p7e(t.themeVariables),
            chainImages: t.chainImages,
            connectorImages: t.walletImages,
            defaultNetwork: l,
            metadata: f7e(jL({}, t.metadata), {
                name: ((r = t.metadata) == null ? void 0 : r.name) || "WalletConnect",
                description: ((n = t.metadata) == null ? void 0 : n.description) || "Connect to WalletConnect-compatible wallets",
                url: ((i = t.metadata) == null ? void 0 : i.url) || "https://walletconnect.org",
                icons: ((s = t.metadata) == null ? void 0 : s.icons) || ["https://walletconnect.org/walletconnect-logo.png"]
            }),
            showWallets: !0,
            featuredWalletIds: t.explorerRecommendedWalletIds === "NONE" ? [] : Array.isArray(t.explorerRecommendedWalletIds) ? t.explorerRecommendedWalletIds : [],
            excludeWalletIds: t.explorerExcludedWalletIds === "ALL" ? [] : Array.isArray(t.explorerExcludedWalletIds) ? t.explorerExcludedWalletIds : [],
            enableEIP6963: !1,
            enableInjected: !1,
            enableCoinbase: !0,
            enableWalletConnect: !0,
            features: {
                email: !1,
                socials: !1
            }
        };
    if ((a = t.mobileWallets) != null && a.length || (o = t.desktopWallets) != null && o.length) {
        const h = [...(t.mobileWallets || []).map(g => ({
                id: g.id,
                name: g.name,
                links: g.links
            })), ...(t.desktopWallets || []).map(g => ({
                id: g.id,
                name: g.name,
                links: {
                    native: g.links.native,
                    universal: g.links.universal
                }
            }))],
            f = [...u.featuredWalletIds || [], ...u.excludeWalletIds || []],
            p = h.filter(g => !f.includes(g.id));
        p.length && (u.customWallets = p)
    }
    return u
}

function RL(t) {
    return jL({
        formatters: void 0,
        fees: void 0,
        serializers: void 0
    }, t)
}
var y7e = Object.freeze({
        __proto__: null,
        convertWCMToAppKitOptions: m7e,
        defineChain: RL
    }),
    Fb, EI;

function w7e() {
    if (EI) return Fb;
    EI = 1;
    var t = function(a, o) {
            return Math.round(o * Math.log(a) / Math.LN2)
        },
        e = [{
            name: "lowercase",
            re: /[a-z]/,
            length: 26
        }, {
            name: "uppercase",
            re: /[A-Z]/,
            length: 26
        }, {
            name: "numbers",
            re: /[0-9]/,
            length: 10
        }, {
            name: "symbols",
            re: /[^a-zA-Z0-9]/,
            length: 33
        }],
        r = function(a) {
            return function(o) {
                return a.reduce(function(c, l) {
                    return c + (l.re.test(o) ? l.length : 0)
                }, 0)
            }
        },
        n = r(e),
        i = function(a) {
            return a ? t(n(a), a.length) : 0
        };
    return Fb = i, Fb
}
var b7e = w7e();
const v7e = Oa(b7e);

function ML(t) {
    return crypto.getRandomValues(new Uint8Array(t))
}
const x7e = 256,
    Zf = 65536;

function E7e() {
    const [t] = ML(1);
    return t
}

function _7e() {
    const [t, e] = ML(2);
    return (t << 8) + e
}

function C7e(t) {
    if (typeof t != "number" || t < 2 || t > Zf) throw new Error(`Invalid number: number must be at least two and at most ${Zf}`);
    const e = t > 256,
        r = e ? Zf : x7e,
        n = e ? _7e : E7e,
        i = t * Math.floor(r / t);
    for (;;) {
        const s = n();
        if (s < i) return s % t
    }
}

function A7e(t, e, r) {
    if (typeof r != "number" || r > Zf) throw new Error(`Invalid argument: end must be a number less than or equal to ${Zf}`);
    if (r - e < 2) throw new Error("Invalid range: range must contain at least two values");
    const n = [];
    for (let i = 0; i < t; i++) n[i] = e + C7e(r - e);
    return n
}

function k7e(t, e, r = "-") {
    if (!Array.isArray(e) || e.length < 2) throw new Error("Invalid argument: wordlist argument must be an array with length greater than or equal to 2");
    if (typeof r != "string") throw new Error("Invalid argument: sep argument must be a string");
    return A7e(t, 0, e.length).reduce((n, i, s) => {
        const a = e[i];
        return n + (s === 0 ? a : r + a)
    }, "")
}
const I7e = Object.freeze(["abacus", "abdomen", "abdominal", "abide", "abiding", "ability", "ablaze", "able", "abnormal", "abrasion", "abrasive", "abreast", "abridge", "abroad", "abruptly", "absence", "absentee", "absently", "absinthe", "absolute", "absolve", "abstain", "abstract", "absurd", "accent", "acclaim", "acclimate", "accompany", "account", "accuracy", "accurate", "accustom", "acetone", "achiness", "aching", "acid", "acorn", "acquaint", "acquire", "acre", "acrobat", "acronym", "acting", "action", "activate", "activator", "active", "activism", "activist", "activity", "actress", "acts", "acutely", "acuteness", "aeration", "aerobics", "aerosol", "aerospace", "afar", "affair", "affected", "affecting", "affection", "affidavit", "affiliate", "affirm", "affix", "afflicted", "affluent", "afford", "affront", "aflame", "afloat", "aflutter", "afoot", "afraid", "afterglow", "afterlife", "aftermath", "aftermost", "afternoon", "aged", "ageless", "agency", "agenda", "agent", "aggregate", "aghast", "agile", "agility", "aging", "agnostic", "agonize", "agonizing", "agony", "agreeable", "agreeably", "agreed", "agreeing", "agreement", "aground", "ahead", "ahoy", "aide", "aids", "aim", "ajar", "alabaster", "alarm", "albatross", "album", "alfalfa", "algebra", "algorithm", "alias", "alibi", "alienable", "alienate", "aliens", "alike", "alive", "alkaline", "alkalize", "almanac", "almighty", "almost", "aloe", "aloft", "aloha", "alone", "alongside", "aloof", "alphabet", "alright", "although", "altitude", "alto", "aluminum", "alumni", "always", "amaretto", "amaze", "amazingly", "amber", "ambiance", "ambiguity", "ambiguous", "ambition", "ambitious", "ambulance", "ambush", "amendable", "amendment", "amends", "amenity", "amiable", "amicably", "amid", "amigo", "amino", "amiss", "ammonia", "ammonium", "amnesty", "amniotic", "among", "amount", "amperage", "ample", "amplifier", "amplify", "amply", "amuck", "amulet", "amusable", "amused", "amusement", "amuser", "amusing", "anaconda", "anaerobic", "anagram", "anatomist", "anatomy", "anchor", "anchovy", "ancient", "android", "anemia", "anemic", "aneurism", "anew", "angelfish", "angelic", "anger", "angled", "angler", "angles", "angling", "angrily", "angriness", "anguished", "angular", "animal", "animate", "animating", "animation", "animator", "anime", "animosity", "ankle", "annex", "annotate", "announcer", "annoying", "annually", "annuity", "anointer", "another", "answering", "antacid", "antarctic", "anteater", "antelope", "antennae", "anthem", "anthill", "anthology", "antibody", "antics", "antidote", "antihero", "antiquely", "antiques", "antiquity", "antirust", "antitoxic", "antitrust", "antiviral", "antivirus", "antler", "antonym", "antsy", "anvil", "anybody", "anyhow", "anymore", "anyone", "anyplace", "anything", "anytime", "anyway", "anywhere", "aorta", "apache", "apostle", "appealing", "appear", "appease", "appeasing", "appendage", "appendix", "appetite", "appetizer", "applaud", "applause", "apple", "appliance", "applicant", "applied", "apply", "appointee", "appraisal", "appraiser", "apprehend", "approach", "approval", "approve", "apricot", "april", "apron", "aptitude", "aptly", "aqua", "aqueduct", "arbitrary", "arbitrate", "ardently", "area", "arena", "arguable", "arguably", "argue", "arise", "armadillo", "armband", "armchair", "armed", "armful", "armhole", "arming", "armless", "armoire", "armored", "armory", "armrest", "army", "aroma", "arose", "around", "arousal", "arrange", "array", "arrest", "arrival", "arrive", "arrogance", "arrogant", "arson", "art", "ascend", "ascension", "ascent", "ascertain", "ashamed", "ashen", "ashes", "ashy", "aside", "askew", "asleep", "asparagus", "aspect", "aspirate", "aspire", "aspirin", "astonish", "astound", "astride", "astrology", "astronaut", "astronomy", "astute", "atlantic", "atlas", "atom", "atonable", "atop", "atrium", "atrocious", "atrophy", "attach", "attain", "attempt", "attendant", "attendee", "attention", "attentive", "attest", "attic", "attire", "attitude", "attractor", "attribute", "atypical", "auction", "audacious", "audacity", "audible", "audibly", "audience", "audio", "audition", "augmented", "august", "authentic", "author", "autism", "autistic", "autograph", "automaker", "automated", "automatic", "autopilot", "available", "avalanche", "avatar", "avenge", "avenging", "avenue", "average", "aversion", "avert", "aviation", "aviator", "avid", "avoid", "await", "awaken", "award", "aware", "awhile", "awkward", "awning", "awoke", "awry", "axis", "babble", "babbling", "babied", "baboon", "backache", "backboard", "backboned", "backdrop", "backed", "backer", "backfield", "backfire", "backhand", "backing", "backlands", "backlash", "backless", "backlight", "backlit", "backlog", "backpack", "backpedal", "backrest", "backroom", "backshift", "backside", "backslid", "backspace", "backspin", "backstab", "backstage", "backtalk", "backtrack", "backup", "backward", "backwash", "backwater", "backyard", "bacon", "bacteria", "bacterium", "badass", "badge", "badland", "badly", "badness", "baffle", "baffling", "bagel", "bagful", "baggage", "bagged", "baggie", "bagginess", "bagging", "baggy", "bagpipe", "baguette", "baked", "bakery", "bakeshop", "baking", "balance", "balancing", "balcony", "balmy", "balsamic", "bamboo", "banana", "banish", "banister", "banjo", "bankable", "bankbook", "banked", "banker", "banking", "banknote", "bankroll", "banner", "bannister", "banshee", "banter", "barbecue", "barbed", "barbell", "barber", "barcode", "barge", "bargraph", "barista", "baritone", "barley", "barmaid", "barman", "barn", "barometer", "barrack", "barracuda", "barrel", "barrette", "barricade", "barrier", "barstool", "bartender", "barterer", "bash", "basically", "basics", "basil", "basin", "basis", "basket", "batboy", "batch", "bath", "baton", "bats", "battalion", "battered", "battering", "battery", "batting", "battle", "bauble", "bazooka", "blabber", "bladder", "blade", "blah", "blame", "blaming", "blanching", "blandness", "blank", "blaspheme", "blasphemy", "blast", "blatancy", "blatantly", "blazer", "blazing", "bleach", "bleak", "bleep", "blemish", "blend", "bless", "blighted", "blimp", "bling", "blinked", "blinker", "blinking", "blinks", "blip", "blissful", "blitz", "blizzard", "bloated", "bloating", "blob", "blog", "bloomers", "blooming", "blooper", "blot", "blouse", "blubber", "bluff", "bluish", "blunderer", "blunt", "blurb", "blurred", "blurry", "blurt", "blush", "blustery", "boaster", "boastful", "boasting", "boat", "bobbed", "bobbing", "bobble", "bobcat", "bobsled", "bobtail", "bodacious", "body", "bogged", "boggle", "bogus", "boil", "bok", "bolster", "bolt", "bonanza", "bonded", "bonding", "bondless", "boned", "bonehead", "boneless", "bonelike", "boney", "bonfire", "bonnet", "bonsai", "bonus", "bony", "boogeyman", "boogieman", "book", "boondocks", "booted", "booth", "bootie", "booting", "bootlace", "bootleg", "boots", "boozy", "borax", "boring", "borough", "borrower", "borrowing", "boss", "botanical", "botanist", "botany", "botch", "both", "bottle", "bottling", "bottom", "bounce", "bouncing", "bouncy", "bounding", "boundless", "bountiful", "bovine", "boxcar", "boxer", "boxing", "boxlike", "boxy", "breach", "breath", "breeches", "breeching", "breeder", "breeding", "breeze", "breezy", "brethren", "brewery", "brewing", "briar", "bribe", "brick", "bride", "bridged", "brigade", "bright", "brilliant", "brim", "bring", "brink", "brisket", "briskly", "briskness", "bristle", "brittle", "broadband", "broadcast", "broaden", "broadly", "broadness", "broadside", "broadways", "broiler", "broiling", "broken", "broker", "bronchial", "bronco", "bronze", "bronzing", "brook", "broom", "brought", "browbeat", "brownnose", "browse", "browsing", "bruising", "brunch", "brunette", "brunt", "brush", "brussels", "brute", "brutishly", "bubble", "bubbling", "bubbly", "buccaneer", "bucked", "bucket", "buckle", "buckshot", "buckskin", "bucktooth", "buckwheat", "buddhism", "buddhist", "budding", "buddy", "budget", "buffalo", "buffed", "buffer", "buffing", "buffoon", "buggy", "bulb", "bulge", "bulginess", "bulgur", "bulk", "bulldog", "bulldozer", "bullfight", "bullfrog", "bullhorn", "bullion", "bullish", "bullpen", "bullring", "bullseye", "bullwhip", "bully", "bunch", "bundle", "bungee", "bunion", "bunkbed", "bunkhouse", "bunkmate", "bunny", "bunt", "busboy", "bush", "busily", "busload", "bust", "busybody", "buzz", "cabana", "cabbage", "cabbie", "cabdriver", "cable", "caboose", "cache", "cackle", "cacti", "cactus", "caddie", "caddy", "cadet", "cadillac", "cadmium", "cage", "cahoots", "cake", "calamari", "calamity", "calcium", "calculate", "calculus", "caliber", "calibrate", "calm", "caloric", "calorie", "calzone", "camcorder", "cameo", "camera", "camisole", "camper", "campfire", "camping", "campsite", "campus", "canal", "canary", "cancel", "candied", "candle", "candy", "cane", "canine", "canister", "cannabis", "canned", "canning", "cannon", "cannot", "canola", "canon", "canopener", "canopy", "canteen", "canyon", "capable", "capably", "capacity", "cape", "capillary", "capital", "capitol", "capped", "capricorn", "capsize", "capsule", "caption", "captivate", "captive", "captivity", "capture", "caramel", "carat", "caravan", "carbon", "cardboard", "carded", "cardiac", "cardigan", "cardinal", "cardstock", "carefully", "caregiver", "careless", "caress", "caretaker", "cargo", "caring", "carless", "carload", "carmaker", "carnage", "carnation", "carnival", "carnivore", "carol", "carpenter", "carpentry", "carpool", "carport", "carried", "carrot", "carrousel", "carry", "cartel", "cartload", "carton", "cartoon", "cartridge", "cartwheel", "carve", "carving", "carwash", "cascade", "case", "cash", "casing", "casino", "casket", "cassette", "casually", "casualty", "catacomb", "catalog", "catalyst", "catalyze", "catapult", "cataract", "catatonic", "catcall", "catchable", "catcher", "catching", "catchy", "caterer", "catering", "catfight", "catfish", "cathedral", "cathouse", "catlike", "catnap", "catnip", "catsup", "cattail", "cattishly", "cattle", "catty", "catwalk", "caucasian", "caucus", "causal", "causation", "cause", "causing", "cauterize", "caution", "cautious", "cavalier", "cavalry", "caviar", "cavity", "cedar", "celery", "celestial", "celibacy", "celibate", "celtic", "cement", "census", "ceramics", "ceremony", "certainly", "certainty", "certified", "certify", "cesarean", "cesspool", "chafe", "chaffing", "chain", "chair", "chalice", "challenge", "chamber", "chamomile", "champion", "chance", "change", "channel", "chant", "chaos", "chaperone", "chaplain", "chapped", "chaps", "chapter", "character", "charbroil", "charcoal", "charger", "charging", "chariot", "charity", "charm", "charred", "charter", "charting", "chase", "chasing", "chaste", "chastise", "chastity", "chatroom", "chatter", "chatting", "chatty", "cheating", "cheddar", "cheek", "cheer", "cheese", "cheesy", "chef", "chemicals", "chemist", "chemo", "cherisher", "cherub", "chess", "chest", "chevron", "chevy", "chewable", "chewer", "chewing", "chewy", "chief", "chihuahua", "childcare", "childhood", "childish", "childless", "childlike", "chili", "chill", "chimp", "chip", "chirping", "chirpy", "chitchat", "chivalry", "chive", "chloride", "chlorine", "choice", "chokehold", "choking", "chomp", "chooser", "choosing", "choosy", "chop", "chosen", "chowder", "chowtime", "chrome", "chubby", "chuck", "chug", "chummy", "chump", "chunk", "churn", "chute", "cider", "cilantro", "cinch", "cinema", "cinnamon", "circle", "circling", "circular", "circulate", "circus", "citable", "citadel", "citation", "citizen", "citric", "citrus", "city", "civic", "civil", "clad", "claim", "clambake", "clammy", "clamor", "clamp", "clamshell", "clang", "clanking", "clapped", "clapper", "clapping", "clarify", "clarinet", "clarity", "clash", "clasp", "class", "clatter", "clause", "clavicle", "claw", "clay", "clean", "clear", "cleat", "cleaver", "cleft", "clench", "clergyman", "clerical", "clerk", "clever", "clicker", "client", "climate", "climatic", "cling", "clinic", "clinking", "clip", "clique", "cloak", "clobber", "clock", "clone", "cloning", "closable", "closure", "clothes", "clothing", "cloud", "clover", "clubbed", "clubbing", "clubhouse", "clump", "clumsily", "clumsy", "clunky", "clustered", "clutch", "clutter", "coach", "coagulant", "coastal", "coaster", "coasting", "coastland", "coastline", "coat", "coauthor", "cobalt", "cobbler", "cobweb", "cocoa", "coconut", "cod", "coeditor", "coerce", "coexist", "coffee", "cofounder", "cognition", "cognitive", "cogwheel", "coherence", "coherent", "cohesive", "coil", "coke", "cola", "cold", "coleslaw", "coliseum", "collage", "collapse", "collar", "collected", "collector", "collide", "collie", "collision", "colonial", "colonist", "colonize", "colony", "colossal", "colt", "coma", "come", "comfort", "comfy", "comic", "coming", "comma", "commence", "commend", "comment", "commerce", "commode", "commodity", "commodore", "common", "commotion", "commute", "commuting", "compacted", "compacter", "compactly", "compactor", "companion", "company", "compare", "compel", "compile", "comply", "component", "composed", "composer", "composite", "compost", "composure", "compound", "compress", "comprised", "computer", "computing", "comrade", "concave", "conceal", "conceded", "concept", "concerned", "concert", "conch", "concierge", "concise", "conclude", "concrete", "concur", "condense", "condiment", "condition", "condone", "conducive", "conductor", "conduit", "cone", "confess", "confetti", "confidant", "confident", "confider", "confiding", "configure", "confined", "confining", "confirm", "conflict", "conform", "confound", "confront", "confused", "confusing", "confusion", "congenial", "congested", "congrats", "congress", "conical", "conjoined", "conjure", "conjuror", "connected", "connector", "consensus", "consent", "console", "consoling", "consonant", "constable", "constant", "constrain", "constrict", "construct", "consult", "consumer", "consuming", "contact", "container", "contempt", "contend", "contented", "contently", "contents", "contest", "context", "contort", "contour", "contrite", "control", "contusion", "convene", "convent", "copartner", "cope", "copied", "copier", "copilot", "coping", "copious", "copper", "copy", "coral", "cork", "cornball", "cornbread", "corncob", "cornea", "corned", "corner", "cornfield", "cornflake", "cornhusk", "cornmeal", "cornstalk", "corny", "coronary", "coroner", "corporal", "corporate", "corral", "correct", "corridor", "corrode", "corroding", "corrosive", "corsage", "corset", "cortex", "cosigner", "cosmetics", "cosmic", "cosmos", "cosponsor", "cost", "cottage", "cotton", "couch", "cough", "could", "countable", "countdown", "counting", "countless", "country", "county", "courier", "covenant", "cover", "coveted", "coveting", "coyness", "cozily", "coziness", "cozy", "crabbing", "crabgrass", "crablike", "crabmeat", "cradle", "cradling", "crafter", "craftily", "craftsman", "craftwork", "crafty", "cramp", "cranberry", "crane", "cranial", "cranium", "crank", "crate", "crave", "craving", "crawfish", "crawlers", "crawling", "crayfish", "crayon", "crazed", "crazily", "craziness", "crazy", "creamed", "creamer", "creamlike", "crease", "creasing", "creatable", "create", "creation", "creative", "creature", "credible", "credibly", "credit", "creed", "creme", "creole", "crepe", "crept", "crescent", "crested", "cresting", "crestless", "crevice", "crewless", "crewman", "crewmate", "crib", "cricket", "cried", "crier", "crimp", "crimson", "cringe", "cringing", "crinkle", "crinkly", "crisped", "crisping", "crisply", "crispness", "crispy", "criteria", "critter", "croak", "crock", "crook", "croon", "crop", "cross", "crouch", "crouton", "crowbar", "crowd", "crown", "crucial", "crudely", "crudeness", "cruelly", "cruelness", "cruelty", "crumb", "crummiest", "crummy", "crumpet", "crumpled", "cruncher", "crunching", "crunchy", "crusader", "crushable", "crushed", "crusher", "crushing", "crust", "crux", "crying", "cryptic", "crystal", "cubbyhole", "cube", "cubical", "cubicle", "cucumber", "cuddle", "cuddly", "cufflink", "culinary", "culminate", "culpable", "culprit", "cultivate", "cultural", "culture", "cupbearer", "cupcake", "cupid", "cupped", "cupping", "curable", "curator", "curdle", "cure", "curfew", "curing", "curled", "curler", "curliness", "curling", "curly", "curry", "curse", "cursive", "cursor", "curtain", "curtly", "curtsy", "curvature", "curve", "curvy", "cushy", "cusp", "cussed", "custard", "custodian", "custody", "customary", "customer", "customize", "customs", "cut", "cycle", "cyclic", "cycling", "cyclist", "cylinder", "cymbal", "cytoplasm", "cytoplast", "dab", "dad", "daffodil", "dagger", "daily", "daintily", "dainty", "dairy", "daisy", "dallying", "dance", "dancing", "dandelion", "dander", "dandruff", "dandy", "danger", "dangle", "dangling", "daredevil", "dares", "daringly", "darkened", "darkening", "darkish", "darkness", "darkroom", "darling", "darn", "dart", "darwinism", "dash", "dastardly", "data", "datebook", "dating", "daughter", "daunting", "dawdler", "dawn", "daybed", "daybreak", "daycare", "daydream", "daylight", "daylong", "dayroom", "daytime", "dazzler", "dazzling", "deacon", "deafening", "deafness", "dealer", "dealing", "dealmaker", "dealt", "dean", "debatable", "debate", "debating", "debit", "debrief", "debtless", "debtor", "debug", "debunk", "decade", "decaf", "decal", "decathlon", "decay", "deceased", "deceit", "deceiver", "deceiving", "december", "decency", "decent", "deception", "deceptive", "decibel", "decidable", "decimal", "decimeter", "decipher", "deck", "declared", "decline", "decode", "decompose", "decorated", "decorator", "decoy", "decrease", "decree", "dedicate", "dedicator", "deduce", "deduct", "deed", "deem", "deepen", "deeply", "deepness", "deface", "defacing", "defame", "default", "defeat", "defection", "defective", "defendant", "defender", "defense", "defensive", "deferral", "deferred", "defiance", "defiant", "defile", "defiling", "define", "definite", "deflate", "deflation", "deflator", "deflected", "deflector", "defog", "deforest", "defraud", "defrost", "deftly", "defuse", "defy", "degraded", "degrading", "degrease", "degree", "dehydrate", "deity", "dejected", "delay", "delegate", "delegator", "delete", "deletion", "delicacy", "delicate", "delicious", "delighted", "delirious", "delirium", "deliverer", "delivery", "delouse", "delta", "deluge", "delusion", "deluxe", "demanding", "demeaning", "demeanor", "demise", "democracy", "democrat", "demote", "demotion", "demystify", "denatured", "deniable", "denial", "denim", "denote", "dense", "density", "dental", "dentist", "denture", "deny", "deodorant", "deodorize", "departed", "departure", "depict", "deplete", "depletion", "deplored", "deploy", "deport", "depose", "depraved", "depravity", "deprecate", "depress", "deprive", "depth", "deputize", "deputy", "derail", "deranged", "derby", "derived", "desecrate", "deserve", "deserving", "designate", "designed", "designer", "designing", "deskbound", "desktop", "deskwork", "desolate", "despair", "despise", "despite", "destiny", "destitute", "destruct", "detached", "detail", "detection", "detective", "detector", "detention", "detergent", "detest", "detonate", "detonator", "detoxify", "detract", "deuce", "devalue", "deviancy", "deviant", "deviate", "deviation", "deviator", "device", "devious", "devotedly", "devotee", "devotion", "devourer", "devouring", "devoutly", "dexterity", "dexterous", "diabetes", "diabetic", "diabolic", "diagnoses", "diagnosis", "diagram", "dial", "diameter", "diaper", "diaphragm", "diary", "dice", "dicing", "dictate", "dictation", "dictator", "difficult", "diffused", "diffuser", "diffusion", "diffusive", "dig", "dilation", "diligence", "diligent", "dill", "dilute", "dime", "diminish", "dimly", "dimmed", "dimmer", "dimness", "dimple", "diner", "dingbat", "dinghy", "dinginess", "dingo", "dingy", "dining", "dinner", "diocese", "dioxide", "diploma", "dipped", "dipper", "dipping", "directed", "direction", "directive", "directly", "directory", "direness", "dirtiness", "disabled", "disagree", "disallow", "disarm", "disarray", "disaster", "disband", "disbelief", "disburse", "discard", "discern", "discharge", "disclose", "discolor", "discount", "discourse", "discover", "discuss", "disdain", "disengage", "disfigure", "disgrace", "dish", "disinfect", "disjoin", "disk", "dislike", "disliking", "dislocate", "dislodge", "disloyal", "dismantle", "dismay", "dismiss", "dismount", "disobey", "disorder", "disown", "disparate", "disparity", "dispatch", "dispense", "dispersal", "dispersed", "disperser", "displace", "display", "displease", "disposal", "dispose", "disprove", "dispute", "disregard", "disrupt", "dissuade", "distance", "distant", "distaste", "distill", "distinct", "distort", "distract", "distress", "district", "distrust", "ditch", "ditto", "ditzy", "dividable", "divided", "dividend", "dividers", "dividing", "divinely", "diving", "divinity", "divisible", "divisibly", "division", "divisive", "divorcee", "dizziness", "dizzy", "doable", "docile", "dock", "doctrine", "document", "dodge", "dodgy", "doily", "doing", "dole", "dollar", "dollhouse", "dollop", "dolly", "dolphin", "domain", "domelike", "domestic", "dominion", "dominoes", "donated", "donation", "donator", "donor", "donut", "doodle", "doorbell", "doorframe", "doorknob", "doorman", "doormat", "doornail", "doorpost", "doorstep", "doorstop", "doorway", "doozy", "dork", "dormitory", "dorsal", "dosage", "dose", "dotted", "doubling", "douche", "dove", "down", "dowry", "doze", "drab", "dragging", "dragonfly", "dragonish", "dragster", "drainable", "drainage", "drained", "drainer", "drainpipe", "dramatic", "dramatize", "drank", "drapery", "drastic", "draw", "dreaded", "dreadful", "dreadlock", "dreamboat", "dreamily", "dreamland", "dreamless", "dreamlike", "dreamt", "dreamy", "drearily", "dreary", "drench", "dress", "drew", "dribble", "dried", "drier", "drift", "driller", "drilling", "drinkable", "drinking", "dripping", "drippy", "drivable", "driven", "driver", "driveway", "driving", "drizzle", "drizzly", "drone", "drool", "droop", "drop-down", "dropbox", "dropkick", "droplet", "dropout", "dropper", "drove", "drown", "drowsily", "drudge", "drum", "dry", "dubbed", "dubiously", "duchess", "duckbill", "ducking", "duckling", "ducktail", "ducky", "duct", "dude", "duffel", "dugout", "duh", "duke", "duller", "dullness", "duly", "dumping", "dumpling", "dumpster", "duo", "dupe", "duplex", "duplicate", "duplicity", "durable", "durably", "duration", "duress", "during", "dusk", "dust", "dutiful", "duty", "duvet", "dwarf", "dweeb", "dwelled", "dweller", "dwelling", "dwindle", "dwindling", "dynamic", "dynamite", "dynasty", "dyslexia", "dyslexic", "each", "eagle", "earache", "eardrum", "earflap", "earful", "earlobe", "early", "earmark", "earmuff", "earphone", "earpiece", "earplugs", "earring", "earshot", "earthen", "earthlike", "earthling", "earthly", "earthworm", "earthy", "earwig", "easeful", "easel", "easiest", "easily", "easiness", "easing", "eastbound", "eastcoast", "easter", "eastward", "eatable", "eaten", "eatery", "eating", "eats", "ebay", "ebony", "ebook", "ecard", "eccentric", "echo", "eclair", "eclipse", "ecologist", "ecology", "economic", "economist", "economy", "ecosphere", "ecosystem", "edge", "edginess", "edging", "edgy", "edition", "editor", "educated", "education", "educator", "eel", "effective", "effects", "efficient", "effort", "eggbeater", "egging", "eggnog", "eggplant", "eggshell", "egomaniac", "egotism", "egotistic", "either", "eject", "elaborate", "elastic", "elated", "elbow", "eldercare", "elderly", "eldest", "electable", "election", "elective", "elephant", "elevate", "elevating", "elevation", "elevator", "eleven", "elf", "eligible", "eligibly", "eliminate", "elite", "elitism", "elixir", "elk", "ellipse", "elliptic", "elm", "elongated", "elope", "eloquence", "eloquent", "elsewhere", "elude", "elusive", "elves", "email", "embargo", "embark", "embassy", "embattled", "embellish", "ember", "embezzle", "emblaze", "emblem", "embody", "embolism", "emboss", "embroider", "emcee", "emerald", "emergency", "emission", "emit", "emote", "emoticon", "emotion", "empathic", "empathy", "emperor", "emphases", "emphasis", "emphasize", "emphatic", "empirical", "employed", "employee", "employer", "emporium", "empower", "emptier", "emptiness", "empty", "emu", "enable", "enactment", "enamel", "enchanted", "enchilada", "encircle", "enclose", "enclosure", "encode", "encore", "encounter", "encourage", "encroach", "encrust", "encrypt", "endanger", "endeared", "endearing", "ended", "ending", "endless", "endnote", "endocrine", "endorphin", "endorse", "endowment", "endpoint", "endurable", "endurance", "enduring", "energetic", "energize", "energy", "enforced", "enforcer", "engaged", "engaging", "engine", "engorge", "engraved", "engraver", "engraving", "engross", "engulf", "enhance", "enigmatic", "enjoyable", "enjoyably", "enjoyer", "enjoying", "enjoyment", "enlarged", "enlarging", "enlighten", "enlisted", "enquirer", "enrage", "enrich", "enroll", "enslave", "ensnare", "ensure", "entail", "entangled", "entering", "entertain", "enticing", "entire", "entitle", "entity", "entomb", "entourage", "entrap", "entree", "entrench", "entrust", "entryway", "entwine", "enunciate", "envelope", "enviable", "enviably", "envious", "envision", "envoy", "envy", "enzyme", "epic", "epidemic", "epidermal", "epidermis", "epidural", "epilepsy", "epileptic", "epilogue", "epiphany", "episode", "equal", "equate", "equation", "equator", "equinox", "equipment", "equity", "equivocal", "eradicate", "erasable", "erased", "eraser", "erasure", "ergonomic", "errand", "errant", "erratic", "error", "erupt", "escalate", "escalator", "escapable", "escapade", "escapist", "escargot", "eskimo", "esophagus", "espionage", "espresso", "esquire", "essay", "essence", "essential", "establish", "estate", "esteemed", "estimate", "estimator", "estranged", "estrogen", "etching", "eternal", "eternity", "ethanol", "ether", "ethically", "ethics", "euphemism", "evacuate", "evacuee", "evade", "evaluate", "evaluator", "evaporate", "evasion", "evasive", "even", "everglade", "evergreen", "everybody", "everyday", "everyone", "evict", "evidence", "evident", "evil", "evoke", "evolution", "evolve", "exact", "exalted", "example", "excavate", "excavator", "exceeding", "exception", "excess", "exchange", "excitable", "exciting", "exclaim", "exclude", "excluding", "exclusion", "exclusive", "excretion", "excretory", "excursion", "excusable", "excusably", "excuse", "exemplary", "exemplify", "exemption", "exerciser", "exert", "exes", "exfoliate", "exhale", "exhaust", "exhume", "exile", "existing", "exit", "exodus", "exonerate", "exorcism", "exorcist", "expand", "expanse", "expansion", "expansive", "expectant", "expedited", "expediter", "expel", "expend", "expenses", "expensive", "expert", "expire", "expiring", "explain", "expletive", "explicit", "explode", "exploit", "explore", "exploring", "exponent", "exporter", "exposable", "expose", "exposure", "express", "expulsion", "exquisite", "extended", "extending", "extent", "extenuate", "exterior", "external", "extinct", "extortion", "extradite", "extras", "extrovert", "extrude", "extruding", "exuberant", "fable", "fabric", "fabulous", "facebook", "facecloth", "facedown", "faceless", "facelift", "faceplate", "faceted", "facial", "facility", "facing", "facsimile", "faction", "factoid", "factor", "factsheet", "factual", "faculty", "fade", "fading", "failing", "falcon", "fall", "false", "falsify", "fame", "familiar", "family", "famine", "famished", "fanatic", "fancied", "fanciness", "fancy", "fanfare", "fang", "fanning", "fantasize", "fantastic", "fantasy", "fascism", "fastball", "faster", "fasting", "fastness", "faucet", "favorable", "favorably", "favored", "favoring", "favorite", "fax", "feast", "federal", "fedora", "feeble", "feed", "feel", "feisty", "feline", "felt-tip", "feminine", "feminism", "feminist", "feminize", "femur", "fence", "fencing", "fender", "ferment", "fernlike", "ferocious", "ferocity", "ferret", "ferris", "ferry", "fervor", "fester", "festival", "festive", "festivity", "fetal", "fetch", "fever", "fiber", "fiction", "fiddle", "fiddling", "fidelity", "fidgeting", "fidgety", "fifteen", "fifth", "fiftieth", "fifty", "figment", "figure", "figurine", "filing", "filled", "filler", "filling", "film", "filter", "filth", "filtrate", "finale", "finalist", "finalize", "finally", "finance", "financial", "finch", "fineness", "finer", "finicky", "finished", "finisher", "finishing", "finite", "finless", "finlike", "fiscally", "fit", "five", "flaccid", "flagman", "flagpole", "flagship", "flagstick", "flagstone", "flail", "flakily", "flaky", "flame", "flammable", "flanked", "flanking", "flannels", "flap", "flaring", "flashback", "flashbulb", "flashcard", "flashily", "flashing", "flashy", "flask", "flatbed", "flatfoot", "flatly", "flatness", "flatten", "flattered", "flatterer", "flattery", "flattop", "flatware", "flatworm", "flavored", "flavorful", "flavoring", "flaxseed", "fled", "fleshed", "fleshy", "flick", "flier", "flight", "flinch", "fling", "flint", "flip", "flirt", "float", "flock", "flogging", "flop", "floral", "florist", "floss", "flounder", "flyable", "flyaway", "flyer", "flying", "flyover", "flypaper", "foam", "foe", "fog", "foil", "folic", "folk", "follicle", "follow", "fondling", "fondly", "fondness", "fondue", "font", "food", "fool", "footage", "football", "footbath", "footboard", "footer", "footgear", "foothill", "foothold", "footing", "footless", "footman", "footnote", "footpad", "footpath", "footprint", "footrest", "footsie", "footsore", "footwear", "footwork", "fossil", "foster", "founder", "founding", "fountain", "fox", "foyer", "fraction", "fracture", "fragile", "fragility", "fragment", "fragrance", "fragrant", "frail", "frame", "framing", "frantic", "fraternal", "frayed", "fraying", "frays", "freckled", "freckles", "freebase", "freebee", "freebie", "freedom", "freefall", "freehand", "freeing", "freeload", "freely", "freemason", "freeness", "freestyle", "freeware", "freeway", "freewill", "freezable", "freezing", "freight", "french", "frenzied", "frenzy", "frequency", "frequent", "fresh", "fretful", "fretted", "friction", "friday", "fridge", "fried", "friend", "frighten", "frightful", "frigidity", "frigidly", "frill", "fringe", "frisbee", "frisk", "fritter", "frivolous", "frolic", "from", "front", "frostbite", "frosted", "frostily", "frosting", "frostlike", "frosty", "froth", "frown", "frozen", "fructose", "frugality", "frugally", "fruit", "frustrate", "frying", "gab", "gaffe", "gag", "gainfully", "gaining", "gains", "gala", "gallantly", "galleria", "gallery", "galley", "gallon", "gallows", "gallstone", "galore", "galvanize", "gambling", "game", "gaming", "gamma", "gander", "gangly", "gangrene", "gangway", "gap", "garage", "garbage", "garden", "gargle", "garland", "garlic", "garment", "garnet", "garnish", "garter", "gas", "gatherer", "gathering", "gating", "gauging", "gauntlet", "gauze", "gave", "gawk", "gazing", "gear", "gecko", "geek", "geiger", "gem", "gender", "generic", "generous", "genetics", "genre", "gentile", "gentleman", "gently", "gents", "geography", "geologic", "geologist", "geology", "geometric", "geometry", "geranium", "gerbil", "geriatric", "germicide", "germinate", "germless", "germproof", "gestate", "gestation", "gesture", "getaway", "getting", "getup", "giant", "gibberish", "giblet", "giddily", "giddiness", "giddy", "gift", "gigabyte", "gigahertz", "gigantic", "giggle", "giggling", "giggly", "gigolo", "gilled", "gills", "gimmick", "girdle", "giveaway", "given", "giver", "giving", "gizmo", "gizzard", "glacial", "glacier", "glade", "gladiator", "gladly", "glamorous", "glamour", "glance", "glancing", "glandular", "glare", "glaring", "glass", "glaucoma", "glazing", "gleaming", "gleeful", "glider", "gliding", "glimmer", "glimpse", "glisten", "glitch", "glitter", "glitzy", "gloater", "gloating", "gloomily", "gloomy", "glorified", "glorifier", "glorify", "glorious", "glory", "gloss", "glove", "glowing", "glowworm", "glucose", "glue", "gluten", "glutinous", "glutton", "gnarly", "gnat", "goal", "goatskin", "goes", "goggles", "going", "goldfish", "goldmine", "goldsmith", "golf", "goliath", "gonad", "gondola", "gone", "gong", "good", "gooey", "goofball", "goofiness", "goofy", "google", "goon", "gopher", "gore", "gorged", "gorgeous", "gory", "gosling", "gossip", "gothic", "gotten", "gout", "gown", "grab", "graceful", "graceless", "gracious", "gradation", "graded", "grader", "gradient", "grading", "gradually", "graduate", "graffiti", "grafted", "grafting", "grain", "granddad", "grandkid", "grandly", "grandma", "grandpa", "grandson", "granite", "granny", "granola", "grant", "granular", "grape", "graph", "grapple", "grappling", "grasp", "grass", "gratified", "gratify", "grating", "gratitude", "gratuity", "gravel", "graveness", "graves", "graveyard", "gravitate", "gravity", "gravy", "gray", "grazing", "greasily", "greedily", "greedless", "greedy", "green", "greeter", "greeting", "grew", "greyhound", "grid", "grief", "grievance", "grieving", "grievous", "grill", "grimace", "grimacing", "grime", "griminess", "grimy", "grinch", "grinning", "grip", "gristle", "grit", "groggily", "groggy", "groin", "groom", "groove", "grooving", "groovy", "grope", "ground", "grouped", "grout", "grove", "grower", "growing", "growl", "grub", "grudge", "grudging", "grueling", "gruffly", "grumble", "grumbling", "grumbly", "grumpily", "grunge", "grunt", "guacamole", "guidable", "guidance", "guide", "guiding", "guileless", "guise", "gulf", "gullible", "gully", "gulp", "gumball", "gumdrop", "gumminess", "gumming", "gummy", "gurgle", "gurgling", "guru", "gush", "gusto", "gusty", "gutless", "guts", "gutter", "guy", "guzzler", "gyration", "habitable", "habitant", "habitat", "habitual", "hacked", "hacker", "hacking", "hacksaw", "had", "haggler", "haiku", "half", "halogen", "halt", "halved", "halves", "hamburger", "hamlet", "hammock", "hamper", "hamster", "hamstring", "handbag", "handball", "handbook", "handbrake", "handcart", "handclap", "handclasp", "handcraft", "handcuff", "handed", "handful", "handgrip", "handgun", "handheld", "handiness", "handiwork", "handlebar", "handled", "handler", "handling", "handmade", "handoff", "handpick", "handprint", "handrail", "handsaw", "handset", "handsfree", "handshake", "handstand", "handwash", "handwork", "handwoven", "handwrite", "handyman", "hangnail", "hangout", "hangover", "hangup", "hankering", "hankie", "hanky", "haphazard", "happening", "happier", "happiest", "happily", "happiness", "happy", "harbor", "hardcopy", "hardcore", "hardcover", "harddisk", "hardened", "hardener", "hardening", "hardhat", "hardhead", "hardiness", "hardly", "hardness", "hardship", "hardware", "hardwired", "hardwood", "hardy", "harmful", "harmless", "harmonica", "harmonics", "harmonize", "harmony", "harness", "harpist", "harsh", "harvest", "hash", "hassle", "haste", "hastily", "hastiness", "hasty", "hatbox", "hatchback", "hatchery", "hatchet", "hatching", "hatchling", "hate", "hatless", "hatred", "haunt", "haven", "hazard", "hazelnut", "hazily", "haziness", "hazing", "hazy", "headache", "headband", "headboard", "headcount", "headdress", "headed", "header", "headfirst", "headgear", "heading", "headlamp", "headless", "headlock", "headphone", "headpiece", "headrest", "headroom", "headscarf", "headset", "headsman", "headstand", "headstone", "headway", "headwear", "heap", "heat", "heave", "heavily", "heaviness", "heaving", "hedge", "hedging", "heftiness", "hefty", "helium", "helmet", "helper", "helpful", "helping", "helpless", "helpline", "hemlock", "hemstitch", "hence", "henchman", "henna", "herald", "herbal", "herbicide", "herbs", "heritage", "hermit", "heroics", "heroism", "herring", "herself", "hertz", "hesitancy", "hesitant", "hesitate", "hexagon", "hexagram", "hubcap", "huddle", "huddling", "huff", "hug", "hula", "hulk", "hull", "human", "humble", "humbling", "humbly", "humid", "humiliate", "humility", "humming", "hummus", "humongous", "humorist", "humorless", "humorous", "humpback", "humped", "humvee", "hunchback", "hundredth", "hunger", "hungrily", "hungry", "hunk", "hunter", "hunting", "huntress", "huntsman", "hurdle", "hurled", "hurler", "hurling", "hurray", "hurricane", "hurried", "hurry", "hurt", "husband", "hush", "husked", "huskiness", "hut", "hybrid", "hydrant", "hydrated", "hydration", "hydrogen", "hydroxide", "hyperlink", "hypertext", "hyphen", "hypnoses", "hypnosis", "hypnotic", "hypnotism", "hypnotist", "hypnotize", "hypocrisy", "hypocrite", "ibuprofen", "ice", "iciness", "icing", "icky", "icon", "icy", "idealism", "idealist", "idealize", "ideally", "idealness", "identical", "identify", "identity", "ideology", "idiocy", "idiom", "idly", "igloo", "ignition", "ignore", "iguana", "illicitly", "illusion", "illusive", "image", "imaginary", "imagines", "imaging", "imbecile", "imitate", "imitation", "immature", "immerse", "immersion", "imminent", "immobile", "immodest", "immorally", "immortal", "immovable", "immovably", "immunity", "immunize", "impaired", "impale", "impart", "impatient", "impeach", "impeding", "impending", "imperfect", "imperial", "impish", "implant", "implement", "implicate", "implicit", "implode", "implosion", "implosive", "imply", "impolite", "important", "importer", "impose", "imposing", "impotence", "impotency", "impotent", "impound", "imprecise", "imprint", "imprison", "impromptu", "improper", "improve", "improving", "improvise", "imprudent", "impulse", "impulsive", "impure", "impurity", "iodine", "iodize", "ion", "ipad", "iphone", "ipod", "irate", "irk", "iron", "irregular", "irrigate", "irritable", "irritably", "irritant", "irritate", "islamic", "islamist", "isolated", "isolating", "isolation", "isotope", "issue", "issuing", "italicize", "italics", "item", "itinerary", "itunes", "ivory", "ivy", "jab", "jackal", "jacket", "jackknife", "jackpot", "jailbird", "jailbreak", "jailer", "jailhouse", "jalapeno", "jam", "janitor", "january", "jargon", "jarring", "jasmine", "jaundice", "jaunt", "java", "jawed", "jawless", "jawline", "jaws", "jaybird", "jaywalker", "jazz", "jeep", "jeeringly", "jellied", "jelly", "jersey", "jester", "jet", "jiffy", "jigsaw", "jimmy", "jingle", "jingling", "jinx", "jitters", "jittery", "job", "jockey", "jockstrap", "jogger", "jogging", "john", "joining", "jokester", "jokingly", "jolliness", "jolly", "jolt", "jot", "jovial", "joyfully", "joylessly", "joyous", "joyride", "joystick", "jubilance", "jubilant", "judge", "judgingly", "judicial", "judiciary", "judo", "juggle", "juggling", "jugular", "juice", "juiciness", "juicy", "jujitsu", "jukebox", "july", "jumble", "jumbo", "jump", "junction", "juncture", "june", "junior", "juniper", "junkie", "junkman", "junkyard", "jurist", "juror", "jury", "justice", "justifier", "justify", "justly", "justness", "juvenile", "kabob", "kangaroo", "karaoke", "karate", "karma", "kebab", "keenly", "keenness", "keep", "keg", "kelp", "kennel", "kept", "kerchief", "kerosene", "kettle", "kick", "kiln", "kilobyte", "kilogram", "kilometer", "kilowatt", "kilt", "kimono", "kindle", "kindling", "kindly", "kindness", "kindred", "kinetic", "kinfolk", "king", "kinship", "kinsman", "kinswoman", "kissable", "kisser", "kissing", "kitchen", "kite", "kitten", "kitty", "kiwi", "kleenex", "knapsack", "knee", "knelt", "knickers", "knoll", "koala", "kooky", "kosher", "krypton", "kudos", "kung", "labored", "laborer", "laboring", "laborious", "labrador", "ladder", "ladies", "ladle", "ladybug", "ladylike", "lagged", "lagging", "lagoon", "lair", "lake", "lance", "landed", "landfall", "landfill", "landing", "landlady", "landless", "landline", "landlord", "landmark", "landmass", "landmine", "landowner", "landscape", "landside", "landslide", "language", "lankiness", "lanky", "lantern", "lapdog", "lapel", "lapped", "lapping", "laptop", "lard", "large", "lark", "lash", "lasso", "last", "latch", "late", "lather", "latitude", "latrine", "latter", "latticed", "launch", "launder", "laundry", "laurel", "lavender", "lavish", "laxative", "lazily", "laziness", "lazy", "lecturer", "left", "legacy", "legal", "legend", "legged", "leggings", "legible", "legibly", "legislate", "lego", "legroom", "legume", "legwarmer", "legwork", "lemon", "lend", "length", "lens", "lent", "leotard", "lesser", "letdown", "lethargic", "lethargy", "letter", "lettuce", "level", "leverage", "levers", "levitate", "levitator", "liability", "liable", "liberty", "librarian", "library", "licking", "licorice", "lid", "life", "lifter", "lifting", "liftoff", "ligament", "likely", "likeness", "likewise", "liking", "lilac", "lilly", "lily", "limb", "limeade", "limelight", "limes", "limit", "limping", "limpness", "line", "lingo", "linguini", "linguist", "lining", "linked", "linoleum", "linseed", "lint", "lion", "lip", "liquefy", "liqueur", "liquid", "lisp", "list", "litigate", "litigator", "litmus", "litter", "little", "livable", "lived", "lively", "liver", "livestock", "lividly", "living", "lizard", "lubricant", "lubricate", "lucid", "luckily", "luckiness", "luckless", "lucrative", "ludicrous", "lugged", "lukewarm", "lullaby", "lumber", "luminance", "luminous", "lumpiness", "lumping", "lumpish", "lunacy", "lunar", "lunchbox", "luncheon", "lunchroom", "lunchtime", "lung", "lurch", "lure", "luridness", "lurk", "lushly", "lushness", "luster", "lustfully", "lustily", "lustiness", "lustrous", "lusty", "luxurious", "luxury", "lying", "lyrically", "lyricism", "lyricist", "lyrics", "macarena", "macaroni", "macaw", "mace", "machine", "machinist", "magazine", "magenta", "maggot", "magical", "magician", "magma", "magnesium", "magnetic", "magnetism", "magnetize", "magnifier", "magnify", "magnitude", "magnolia", "mahogany", "maimed", "majestic", "majesty", "majorette", "majority", "makeover", "maker", "makeshift", "making", "malformed", "malt", "mama", "mammal", "mammary", "mammogram", "manager", "managing", "manatee", "mandarin", "mandate", "mandatory", "mandolin", "manger", "mangle", "mango", "mangy", "manhandle", "manhole", "manhood", "manhunt", "manicotti", "manicure", "manifesto", "manila", "mankind", "manlike", "manliness", "manly", "manmade", "manned", "mannish", "manor", "manpower", "mantis", "mantra", "manual", "many", "map", "marathon", "marauding", "marbled", "marbles", "marbling", "march", "mardi", "margarine", "margarita", "margin", "marigold", "marina", "marine", "marital", "maritime", "marlin", "marmalade", "maroon", "married", "marrow", "marry", "marshland", "marshy", "marsupial", "marvelous", "marxism", "mascot", "masculine", "mashed", "mashing", "massager", "masses", "massive", "mastiff", "matador", "matchbook", "matchbox", "matcher", "matching", "matchless", "material", "maternal", "maternity", "math", "mating", "matriarch", "matrimony", "matrix", "matron", "matted", "matter", "maturely", "maturing", "maturity", "mauve", "maverick", "maximize", "maximum", "maybe", "mayday", "mayflower", "moaner", "moaning", "mobile", "mobility", "mobilize", "mobster", "mocha", "mocker", "mockup", "modified", "modify", "modular", "modulator", "module", "moisten", "moistness", "moisture", "molar", "molasses", "mold", "molecular", "molecule", "molehill", "mollusk", "mom", "monastery", "monday", "monetary", "monetize", "moneybags", "moneyless", "moneywise", "mongoose", "mongrel", "monitor", "monkhood", "monogamy", "monogram", "monologue", "monopoly", "monorail", "monotone", "monotype", "monoxide", "monsieur", "monsoon", "monstrous", "monthly", "monument", "moocher", "moodiness", "moody", "mooing", "moonbeam", "mooned", "moonlight", "moonlike", "moonlit", "moonrise", "moonscape", "moonshine", "moonstone", "moonwalk", "mop", "morale", "morality", "morally", "morbidity", "morbidly", "morphine", "morphing", "morse", "mortality", "mortally", "mortician", "mortified", "mortify", "mortuary", "mosaic", "mossy", "most", "mothball", "mothproof", "motion", "motivate", "motivator", "motive", "motocross", "motor", "motto", "mountable", "mountain", "mounted", "mounting", "mourner", "mournful", "mouse", "mousiness", "moustache", "mousy", "mouth", "movable", "move", "movie", "moving", "mower", "mowing", "much", "muck", "mud", "mug", "mulberry", "mulch", "mule", "mulled", "mullets", "multiple", "multiply", "multitask", "multitude", "mumble", "mumbling", "mumbo", "mummified", "mummify", "mummy", "mumps", "munchkin", "mundane", "municipal", "muppet", "mural", "murkiness", "murky", "murmuring", "muscular", "museum", "mushily", "mushiness", "mushroom", "mushy", "music", "musket", "muskiness", "musky", "mustang", "mustard", "muster", "mustiness", "musty", "mutable", "mutate", "mutation", "mute", "mutilated", "mutilator", "mutiny", "mutt", "mutual", "muzzle", "myself", "myspace", "mystified", "mystify", "myth", "nacho", "nag", "nail", "name", "naming", "nanny", "nanometer", "nape", "napkin", "napped", "napping", "nappy", "narrow", "nastily", "nastiness", "national", "native", "nativity", "natural", "nature", "naturist", "nautical", "navigate", "navigator", "navy", "nearby", "nearest", "nearly", "nearness", "neatly", "neatness", "nebula", "nebulizer", "nectar", "negate", "negation", "negative", "neglector", "negligee", "negligent", "negotiate", "nemeses", "nemesis", "neon", "nephew", "nerd", "nervous", "nervy", "nest", "net", "neurology", "neuron", "neurosis", "neurotic", "neuter", "neutron", "never", "next", "nibble", "nickname", "nicotine", "niece", "nifty", "nimble", "nimbly", "nineteen", "ninetieth", "ninja", "nintendo", "ninth", "nuclear", "nuclei", "nucleus", "nugget", "nullify", "number", "numbing", "numbly", "numbness", "numeral", "numerate", "numerator", "numeric", "numerous", "nuptials", "nursery", "nursing", "nurture", "nutcase", "nutlike", "nutmeg", "nutrient", "nutshell", "nuttiness", "nutty", "nuzzle", "nylon", "oaf", "oak", "oasis", "oat", "obedience", "obedient", "obituary", "object", "obligate", "obliged", "oblivion", "oblivious", "oblong", "obnoxious", "oboe", "obscure", "obscurity", "observant", "observer", "observing", "obsessed", "obsession", "obsessive", "obsolete", "obstacle", "obstinate", "obstruct", "obtain", "obtrusive", "obtuse", "obvious", "occultist", "occupancy", "occupant", "occupier", "occupy", "ocean", "ocelot", "octagon", "octane", "october", "octopus", "ogle", "oil", "oink", "ointment", "okay", "old", "olive", "olympics", "omega", "omen", "ominous", "omission", "omit", "omnivore", "onboard", "oncoming", "ongoing", "onion", "online", "onlooker", "only", "onscreen", "onset", "onshore", "onslaught", "onstage", "onto", "onward", "onyx", "oops", "ooze", "oozy", "opacity", "opal", "open", "operable", "operate", "operating", "operation", "operative", "operator", "opium", "opossum", "opponent", "oppose", "opposing", "opposite", "oppressed", "oppressor", "opt", "opulently", "osmosis", "other", "otter", "ouch", "ought", "ounce", "outage", "outback", "outbid", "outboard", "outbound", "outbreak", "outburst", "outcast", "outclass", "outcome", "outdated", "outdoors", "outer", "outfield", "outfit", "outflank", "outgoing", "outgrow", "outhouse", "outing", "outlast", "outlet", "outline", "outlook", "outlying", "outmatch", "outmost", "outnumber", "outplayed", "outpost", "outpour", "output", "outrage", "outrank", "outreach", "outright", "outscore", "outsell", "outshine", "outshoot", "outsider", "outskirts", "outsmart", "outsource", "outspoken", "outtakes", "outthink", "outward", "outweigh", "outwit", "oval", "ovary", "oven", "overact", "overall", "overarch", "overbid", "overbill", "overbite", "overblown", "overboard", "overbook", "overbuilt", "overcast", "overcoat", "overcome", "overcook", "overcrowd", "overdraft", "overdrawn", "overdress", "overdrive", "overdue", "overeager", "overeater", "overexert", "overfed", "overfeed", "overfill", "overflow", "overfull", "overgrown", "overhand", "overhang", "overhaul", "overhead", "overhear", "overheat", "overhung", "overjoyed", "overkill", "overlabor", "overlaid", "overlap", "overlay", "overload", "overlook", "overlord", "overlying", "overnight", "overpass", "overpay", "overplant", "overplay", "overpower", "overprice", "overrate", "overreach", "overreact", "override", "overripe", "overrule", "overrun", "overshoot", "overshot", "oversight", "oversized", "oversleep", "oversold", "overspend", "overstate", "overstay", "overstep", "overstock", "overstuff", "oversweet", "overtake", "overthrow", "overtime", "overtly", "overtone", "overture", "overturn", "overuse", "overvalue", "overview", "overwrite", "owl", "oxford", "oxidant", "oxidation", "oxidize", "oxidizing", "oxygen", "oxymoron", "oyster", "ozone", "paced", "pacemaker", "pacific", "pacifier", "pacifism", "pacifist", "pacify", "padded", "padding", "paddle", "paddling", "padlock", "pagan", "pager", "paging", "pajamas", "palace", "palatable", "palm", "palpable", "palpitate", "paltry", "pampered", "pamperer", "pampers", "pamphlet", "panama", "pancake", "pancreas", "panda", "pandemic", "pang", "panhandle", "panic", "panning", "panorama", "panoramic", "panther", "pantomime", "pantry", "pants", "pantyhose", "paparazzi", "papaya", "paper", "paprika", "papyrus", "parabola", "parachute", "parade", "paradox", "paragraph", "parakeet", "paralegal", "paralyses", "paralysis", "paralyze", "paramedic", "parameter", "paramount", "parasail", "parasite", "parasitic", "parcel", "parched", "parchment", "pardon", "parish", "parka", "parking", "parkway", "parlor", "parmesan", "parole", "parrot", "parsley", "parsnip", "partake", "parted", "parting", "partition", "partly", "partner", "partridge", "party", "passable", "passably", "passage", "passcode", "passenger", "passerby", "passing", "passion", "passive", "passivism", "passover", "passport", "password", "pasta", "pasted", "pastel", "pastime", "pastor", "pastrami", "pasture", "pasty", "patchwork", "patchy", "paternal", "paternity", "path", "patience", "patient", "patio", "patriarch", "patriot", "patrol", "patronage", "patronize", "pauper", "pavement", "paver", "pavestone", "pavilion", "paving", "pawing", "payable", "payback", "paycheck", "payday", "payee", "payer", "paying", "payment", "payphone", "payroll", "pebble", "pebbly", "pecan", "pectin", "peculiar", "peddling", "pediatric", "pedicure", "pedigree", "pedometer", "pegboard", "pelican", "pellet", "pelt", "pelvis", "penalize", "penalty", "pencil", "pendant", "pending", "penholder", "penknife", "pennant", "penniless", "penny", "penpal", "pension", "pentagon", "pentagram", "pep", "perceive", "percent", "perch", "percolate", "perennial", "perfected", "perfectly", "perfume", "periscope", "perish", "perjurer", "perjury", "perkiness", "perky", "perm", "peroxide", "perpetual", "perplexed", "persecute", "persevere", "persuaded", "persuader", "pesky", "peso", "pessimism", "pessimist", "pester", "pesticide", "petal", "petite", "petition", "petri", "petroleum", "petted", "petticoat", "pettiness", "petty", "petunia", "phantom", "phobia", "phoenix", "phonebook", "phoney", "phonics", "phoniness", "phony", "phosphate", "photo", "phrase", "phrasing", "placard", "placate", "placidly", "plank", "planner", "plant", "plasma", "plaster", "plastic", "plated", "platform", "plating", "platinum", "platonic", "platter", "platypus", "plausible", "plausibly", "playable", "playback", "player", "playful", "playgroup", "playhouse", "playing", "playlist", "playmaker", "playmate", "playoff", "playpen", "playroom", "playset", "plaything", "playtime", "plaza", "pleading", "pleat", "pledge", "plentiful", "plenty", "plethora", "plexiglas", "pliable", "plod", "plop", "plot", "plow", "ploy", "pluck", "plug", "plunder", "plunging", "plural", "plus", "plutonium", "plywood", "poach", "pod", "poem", "poet", "pogo", "pointed", "pointer", "pointing", "pointless", "pointy", "poise", "poison", "poker", "poking", "polar", "police", "policy", "polio", "polish", "politely", "polka", "polo", "polyester", "polygon", "polygraph", "polymer", "poncho", "pond", "pony", "popcorn", "pope", "poplar", "popper", "poppy", "popsicle", "populace", "popular", "populate", "porcupine", "pork", "porous", "porridge", "portable", "portal", "portfolio", "porthole", "portion", "portly", "portside", "poser", "posh", "posing", "possible", "possibly", "possum", "postage", "postal", "postbox", "postcard", "posted", "poster", "posting", "postnasal", "posture", "postwar", "pouch", "pounce", "pouncing", "pound", "pouring", "pout", "powdered", "powdering", "powdery", "power", "powwow", "pox", "praising", "prance", "prancing", "pranker", "prankish", "prankster", "prayer", "praying", "preacher", "preaching", "preachy", "preamble", "precinct", "precise", "precision", "precook", "precut", "predator", "predefine", "predict", "preface", "prefix", "preflight", "preformed", "pregame", "pregnancy", "pregnant", "preheated", "prelaunch", "prelaw", "prelude", "premiere", "premises", "premium", "prenatal", "preoccupy", "preorder", "prepaid", "prepay", "preplan", "preppy", "preschool", "prescribe", "preseason", "preset", "preshow", "president", "presoak", "press", "presume", "presuming", "preteen", "pretended", "pretender", "pretense", "pretext", "pretty", "pretzel", "prevail", "prevalent", "prevent", "preview", "previous", "prewar", "prewashed", "prideful", "pried", "primal", "primarily", "primary", "primate", "primer", "primp", "princess", "print", "prior", "prism", "prison", "prissy", "pristine", "privacy", "private", "privatize", "prize", "proactive", "probable", "probably", "probation", "probe", "probing", "probiotic", "problem", "procedure", "process", "proclaim", "procreate", "procurer", "prodigal", "prodigy", "produce", "product", "profane", "profanity", "professed", "professor", "profile", "profound", "profusely", "progeny", "prognosis", "program", "progress", "projector", "prologue", "prolonged", "promenade", "prominent", "promoter", "promotion", "prompter", "promptly", "prone", "prong", "pronounce", "pronto", "proofing", "proofread", "proofs", "propeller", "properly", "property", "proponent", "proposal", "propose", "props", "prorate", "protector", "protegee", "proton", "prototype", "protozoan", "protract", "protrude", "proud", "provable", "proved", "proven", "provided", "provider", "providing", "province", "proving", "provoke", "provoking", "provolone", "prowess", "prowler", "prowling", "proximity", "proxy", "prozac", "prude", "prudishly", "prune", "pruning", "pry", "psychic", "public", "publisher", "pucker", "pueblo", "pug", "pull", "pulmonary", "pulp", "pulsate", "pulse", "pulverize", "puma", "pumice", "pummel", "punch", "punctual", "punctuate", "punctured", "pungent", "punisher", "punk", "pupil", "puppet", "puppy", "purchase", "pureblood", "purebred", "purely", "pureness", "purgatory", "purge", "purging", "purifier", "purify", "purist", "puritan", "purity", "purple", "purplish", "purposely", "purr", "purse", "pursuable", "pursuant", "pursuit", "purveyor", "pushcart", "pushchair", "pusher", "pushiness", "pushing", "pushover", "pushpin", "pushup", "pushy", "putdown", "putt", "puzzle", "puzzling", "pyramid", "pyromania", "python", "quack", "quadrant", "quail", "quaintly", "quake", "quaking", "qualified", "qualifier", "qualify", "quality", "qualm", "quantum", "quarrel", "quarry", "quartered", "quarterly", "quarters", "quartet", "quench", "query", "quicken", "quickly", "quickness", "quicksand", "quickstep", "quiet", "quill", "quilt", "quintet", "quintuple", "quirk", "quit", "quiver", "quizzical", "quotable", "quotation", "quote", "rabid", "race", "racing", "racism", "rack", "racoon", "radar", "radial", "radiance", "radiantly", "radiated", "radiation", "radiator", "radio", "radish", "raffle", "raft", "rage", "ragged", "raging", "ragweed", "raider", "railcar", "railing", "railroad", "railway", "raisin", "rake", "raking", "rally", "ramble", "rambling", "ramp", "ramrod", "ranch", "rancidity", "random", "ranged", "ranger", "ranging", "ranked", "ranking", "ransack", "ranting", "rants", "rare", "rarity", "rascal", "rash", "rasping", "ravage", "raven", "ravine", "raving", "ravioli", "ravishing", "reabsorb", "reach", "reacquire", "reaction", "reactive", "reactor", "reaffirm", "ream", "reanalyze", "reappear", "reapply", "reappoint", "reapprove", "rearrange", "rearview", "reason", "reassign", "reassure", "reattach", "reawake", "rebalance", "rebate", "rebel", "rebirth", "reboot", "reborn", "rebound", "rebuff", "rebuild", "rebuilt", "reburial", "rebuttal", "recall", "recant", "recapture", "recast", "recede", "recent", "recess", "recharger", "recipient", "recital", "recite", "reckless", "reclaim", "recliner", "reclining", "recluse", "reclusive", "recognize", "recoil", "recollect", "recolor", "reconcile", "reconfirm", "reconvene", "recopy", "record", "recount", "recoup", "recovery", "recreate", "rectal", "rectangle", "rectified", "rectify", "recycled", "recycler", "recycling", "reemerge", "reenact", "reenter", "reentry", "reexamine", "referable", "referee", "reference", "refill", "refinance", "refined", "refinery", "refining", "refinish", "reflected", "reflector", "reflex", "reflux", "refocus", "refold", "reforest", "reformat", "reformed", "reformer", "reformist", "refract", "refrain", "refreeze", "refresh", "refried", "refueling", "refund", "refurbish", "refurnish", "refusal", "refuse", "refusing", "refutable", "refute", "regain", "regalia", "regally", "reggae", "regime", "region", "register", "registrar", "registry", "regress", "regretful", "regroup", "regular", "regulate", "regulator", "rehab", "reheat", "rehire", "rehydrate", "reimburse", "reissue", "reiterate", "rejoice", "rejoicing", "rejoin", "rekindle", "relapse", "relapsing", "relatable", "related", "relation", "relative", "relax", "relay", "relearn", "release", "relenting", "reliable", "reliably", "reliance", "reliant", "relic", "relieve", "relieving", "relight", "relish", "relive", "reload", "relocate", "relock", "reluctant", "rely", "remake", "remark", "remarry", "rematch", "remedial", "remedy", "remember", "reminder", "remindful", "remission", "remix", "remnant", "remodeler", "remold", "remorse", "remote", "removable", "removal", "removed", "remover", "removing", "rename", "renderer", "rendering", "rendition", "renegade", "renewable", "renewably", "renewal", "renewed", "renounce", "renovate", "renovator", "rentable", "rental", "rented", "renter", "reoccupy", "reoccur", "reopen", "reorder", "repackage", "repacking", "repaint", "repair", "repave", "repaying", "repayment", "repeal", "repeated", "repeater", "repent", "rephrase", "replace", "replay", "replica", "reply", "reporter", "repose", "repossess", "repost", "repressed", "reprimand", "reprint", "reprise", "reproach", "reprocess", "reproduce", "reprogram", "reps", "reptile", "reptilian", "repugnant", "repulsion", "repulsive", "repurpose", "reputable", "reputably", "request", "require", "requisite", "reroute", "rerun", "resale", "resample", "rescuer", "reseal", "research", "reselect", "reseller", "resemble", "resend", "resent", "reset", "reshape", "reshoot", "reshuffle", "residence", "residency", "resident", "residual", "residue", "resigned", "resilient", "resistant", "resisting", "resize", "resolute", "resolved", "resonant", "resonate", "resort", "resource", "respect", "resubmit", "result", "resume", "resupply", "resurface", "resurrect", "retail", "retainer", "retaining", "retake", "retaliate", "retention", "rethink", "retinal", "retired", "retiree", "retiring", "retold", "retool", "retorted", "retouch", "retrace", "retract", "retrain", "retread", "retreat", "retrial", "retrieval", "retriever", "retry", "return", "retying", "retype", "reunion", "reunite", "reusable", "reuse", "reveal", "reveler", "revenge", "revenue", "reverb", "revered", "reverence", "reverend", "reversal", "reverse", "reversing", "reversion", "revert", "revisable", "revise", "revision", "revisit", "revivable", "revival", "reviver", "reviving", "revocable", "revoke", "revolt", "revolver", "revolving", "reward", "rewash", "rewind", "rewire", "reword", "rework", "rewrap", "rewrite", "rhyme", "ribbon", "ribcage", "rice", "riches", "richly", "richness", "rickety", "ricotta", "riddance", "ridden", "ride", "riding", "rifling", "rift", "rigging", "rigid", "rigor", "rimless", "rimmed", "rind", "rink", "rinse", "rinsing", "riot", "ripcord", "ripeness", "ripening", "ripping", "ripple", "rippling", "riptide", "rise", "rising", "risk", "risotto", "ritalin", "ritzy", "rival", "riverbank", "riverbed", "riverboat", "riverside", "riveter", "riveting", "roamer", "roaming", "roast", "robbing", "robe", "robin", "robotics", "robust", "rockband", "rocker", "rocket", "rockfish", "rockiness", "rocking", "rocklike", "rockslide", "rockstar", "rocky", "rogue", "roman", "romp", "rope", "roping", "roster", "rosy", "rotten", "rotting", "rotunda", "roulette", "rounding", "roundish", "roundness", "roundup", "roundworm", "routine", "routing", "rover", "roving", "royal", "rubbed", "rubber", "rubbing", "rubble", "rubdown", "ruby", "ruckus", "rudder", "rug", "ruined", "rule", "rumble", "rumbling", "rummage", "rumor", "runaround", "rundown", "runner", "running", "runny", "runt", "runway", "rupture", "rural", "ruse", "rush", "rust", "rut", "sabbath", "sabotage", "sacrament", "sacred", "sacrifice", "sadden", "saddlebag", "saddled", "saddling", "sadly", "sadness", "safari", "safeguard", "safehouse", "safely", "safeness", "saffron", "saga", "sage", "sagging", "saggy", "said", "saint", "sake", "salad", "salami", "salaried", "salary", "saline", "salon", "saloon", "salsa", "salt", "salutary", "salute", "salvage", "salvaging", "salvation", "same", "sample", "sampling", "sanction", "sanctity", "sanctuary", "sandal", "sandbag", "sandbank", "sandbar", "sandblast", "sandbox", "sanded", "sandfish", "sanding", "sandlot", "sandpaper", "sandpit", "sandstone", "sandstorm", "sandworm", "sandy", "sanitary", "sanitizer", "sank", "santa", "sapling", "sappiness", "sappy", "sarcasm", "sarcastic", "sardine", "sash", "sasquatch", "sassy", "satchel", "satiable", "satin", "satirical", "satisfied", "satisfy", "saturate", "saturday", "sauciness", "saucy", "sauna", "savage", "savanna", "saved", "savings", "savior", "savor", "saxophone", "say", "scabbed", "scabby", "scalded", "scalding", "scale", "scaling", "scallion", "scallop", "scalping", "scam", "scandal", "scanner", "scanning", "scant", "scapegoat", "scarce", "scarcity", "scarecrow", "scared", "scarf", "scarily", "scariness", "scarring", "scary", "scavenger", "scenic", "schedule", "schematic", "scheme", "scheming", "schilling", "schnapps", "scholar", "science", "scientist", "scion", "scoff", "scolding", "scone", "scoop", "scooter", "scope", "scorch", "scorebook", "scorecard", "scored", "scoreless", "scorer", "scoring", "scorn", "scorpion", "scotch", "scoundrel", "scoured", "scouring", "scouting", "scouts", "scowling", "scrabble", "scraggly", "scrambled", "scrambler", "scrap", "scratch", "scrawny", "screen", "scribble", "scribe", "scribing", "scrimmage", "script", "scroll", "scrooge", "scrounger", "scrubbed", "scrubber", "scruffy", "scrunch", "scrutiny", "scuba", "scuff", "sculptor", "sculpture", "scurvy", "scuttle", "secluded", "secluding", "seclusion", "second", "secrecy", "secret", "sectional", "sector", "secular", "securely", "security", "sedan", "sedate", "sedation", "sedative", "sediment", "seduce", "seducing", "segment", "seismic", "seizing", "seldom", "selected", "selection", "selective", "selector", "self", "seltzer", "semantic", "semester", "semicolon", "semifinal", "seminar", "semisoft", "semisweet", "senate", "senator", "send", "senior", "senorita", "sensation", "sensitive", "sensitize", "sensually", "sensuous", "sepia", "september", "septic", "septum", "sequel", "sequence", "sequester", "series", "sermon", "serotonin", "serpent", "serrated", "serve", "service", "serving", "sesame", "sessions", "setback", "setting", "settle", "settling", "setup", "sevenfold", "seventeen", "seventh", "seventy", "severity", "shabby", "shack", "shaded", "shadily", "shadiness", "shading", "shadow", "shady", "shaft", "shakable", "shakily", "shakiness", "shaking", "shaky", "shale", "shallot", "shallow", "shame", "shampoo", "shamrock", "shank", "shanty", "shape", "shaping", "share", "sharpener", "sharper", "sharpie", "sharply", "sharpness", "shawl", "sheath", "shed", "sheep", "sheet", "shelf", "shell", "shelter", "shelve", "shelving", "sherry", "shield", "shifter", "shifting", "shiftless", "shifty", "shimmer", "shimmy", "shindig", "shine", "shingle", "shininess", "shining", "shiny", "ship", "shirt", "shivering", "shock", "shone", "shoplift", "shopper", "shopping", "shoptalk", "shore", "shortage", "shortcake", "shortcut", "shorten", "shorter", "shorthand", "shortlist", "shortly", "shortness", "shorts", "shortwave", "shorty", "shout", "shove", "showbiz", "showcase", "showdown", "shower", "showgirl", "showing", "showman", "shown", "showoff", "showpiece", "showplace", "showroom", "showy", "shrank", "shrapnel", "shredder", "shredding", "shrewdly", "shriek", "shrill", "shrimp", "shrine", "shrink", "shrivel", "shrouded", "shrubbery", "shrubs", "shrug", "shrunk", "shucking", "shudder", "shuffle", "shuffling", "shun", "shush", "shut", "shy", "siamese", "siberian", "sibling", "siding", "sierra", "siesta", "sift", "sighing", "silenced", "silencer", "silent", "silica", "silicon", "silk", "silliness", "silly", "silo", "silt", "silver", "similarly", "simile", "simmering", "simple", "simplify", "simply", "sincere", "sincerity", "singer", "singing", "single", "singular", "sinister", "sinless", "sinner", "sinuous", "sip", "siren", "sister", "sitcom", "sitter", "sitting", "situated", "situation", "sixfold", "sixteen", "sixth", "sixties", "sixtieth", "sixtyfold", "sizable", "sizably", "size", "sizing", "sizzle", "sizzling", "skater", "skating", "skedaddle", "skeletal", "skeleton", "skeptic", "sketch", "skewed", "skewer", "skid", "skied", "skier", "skies", "skiing", "skilled", "skillet", "skillful", "skimmed", "skimmer", "skimming", "skimpily", "skincare", "skinhead", "skinless", "skinning", "skinny", "skintight", "skipper", "skipping", "skirmish", "skirt", "skittle", "skydiver", "skylight", "skyline", "skype", "skyrocket", "skyward", "slab", "slacked", "slacker", "slacking", "slackness", "slacks", "slain", "slam", "slander", "slang", "slapping", "slapstick", "slashed", "slashing", "slate", "slather", "slaw", "sled", "sleek", "sleep", "sleet", "sleeve", "slept", "sliceable", "sliced", "slicer", "slicing", "slick", "slider", "slideshow", "sliding", "slighted", "slighting", "slightly", "slimness", "slimy", "slinging", "slingshot", "slinky", "slip", "slit", "sliver", "slobbery", "slogan", "sloped", "sloping", "sloppily", "sloppy", "slot", "slouching", "slouchy", "sludge", "slug", "slum", "slurp", "slush", "sly", "small", "smartly", "smartness", "smasher", "smashing", "smashup", "smell", "smelting", "smile", "smilingly", "smirk", "smite", "smith", "smitten", "smock", "smog", "smoked", "smokeless", "smokiness", "smoking", "smoky", "smolder", "smooth", "smother", "smudge", "smudgy", "smuggler", "smuggling", "smugly", "smugness", "snack", "snagged", "snaking", "snap", "snare", "snarl", "snazzy", "sneak", "sneer", "sneeze", "sneezing", "snide", "sniff", "snippet", "snipping", "snitch", "snooper", "snooze", "snore", "snoring", "snorkel", "snort", "snout", "snowbird", "snowboard", "snowbound", "snowcap", "snowdrift", "snowdrop", "snowfall", "snowfield", "snowflake", "snowiness", "snowless", "snowman", "snowplow", "snowshoe", "snowstorm", "snowsuit", "snowy", "snub", "snuff", "snuggle", "snugly", "snugness", "speak", "spearfish", "spearhead", "spearman", "spearmint", "species", "specimen", "specked", "speckled", "specks", "spectacle", "spectator", "spectrum", "speculate", "speech", "speed", "spellbind", "speller", "spelling", "spendable", "spender", "spending", "spent", "spew", "sphere", "spherical", "sphinx", "spider", "spied", "spiffy", "spill", "spilt", "spinach", "spinal", "spindle", "spinner", "spinning", "spinout", "spinster", "spiny", "spiral", "spirited", "spiritism", "spirits", "spiritual", "splashed", "splashing", "splashy", "splatter", "spleen", "splendid", "splendor", "splice", "splicing", "splinter", "splotchy", "splurge", "spoilage", "spoiled", "spoiler", "spoiling", "spoils", "spoken", "spokesman", "sponge", "spongy", "sponsor", "spoof", "spookily", "spooky", "spool", "spoon", "spore", "sporting", "sports", "sporty", "spotless", "spotlight", "spotted", "spotter", "spotting", "spotty", "spousal", "spouse", "spout", "sprain", "sprang", "sprawl", "spray", "spree", "sprig", "spring", "sprinkled", "sprinkler", "sprint", "sprite", "sprout", "spruce", "sprung", "spry", "spud", "spur", "sputter", "spyglass", "squabble", "squad", "squall", "squander", "squash", "squatted", "squatter", "squatting", "squeak", "squealer", "squealing", "squeamish", "squeegee", "squeeze", "squeezing", "squid", "squiggle", "squiggly", "squint", "squire", "squirt", "squishier", "squishy", "stability", "stabilize", "stable", "stack", "stadium", "staff", "stage", "staging", "stagnant", "stagnate", "stainable", "stained", "staining", "stainless", "stalemate", "staleness", "stalling", "stallion", "stamina", "stammer", "stamp", "stand", "stank", "staple", "stapling", "starboard", "starch", "stardom", "stardust", "starfish", "stargazer", "staring", "stark", "starless", "starlet", "starlight", "starlit", "starring", "starry", "starship", "starter", "starting", "startle", "startling", "startup", "starved", "starving", "stash", "state", "static", "statistic", "statue", "stature", "status", "statute", "statutory", "staunch", "stays", "steadfast", "steadier", "steadily", "steadying", "steam", "steed", "steep", "steerable", "steering", "steersman", "stegosaur", "stellar", "stem", "stench", "stencil", "step", "stereo", "sterile", "sterility", "sterilize", "sterling", "sternness", "sternum", "stew", "stick", "stiffen", "stiffly", "stiffness", "stifle", "stifling", "stillness", "stilt", "stimulant", "stimulate", "stimuli", "stimulus", "stinger", "stingily", "stinging", "stingray", "stingy", "stinking", "stinky", "stipend", "stipulate", "stir", "stitch", "stock", "stoic", "stoke", "stole", "stomp", "stonewall", "stoneware", "stonework", "stoning", "stony", "stood", "stooge", "stool", "stoop", "stoplight", "stoppable", "stoppage", "stopped", "stopper", "stopping", "stopwatch", "storable", "storage", "storeroom", "storewide", "storm", "stout", "stove", "stowaway", "stowing", "straddle", "straggler", "strained", "strainer", "straining", "strangely", "stranger", "strangle", "strategic", "strategy", "stratus", "straw", "stray", "streak", "stream", "street", "strength", "strenuous", "strep", "stress", "stretch", "strewn", "stricken", "strict", "stride", "strife", "strike", "striking", "strive", "striving", "strobe", "strode", "stroller", "strongbox", "strongly", "strongman", "struck", "structure", "strudel", "struggle", "strum", "strung", "strut", "stubbed", "stubble", "stubbly", "stubborn", "stucco", "stuck", "student", "studied", "studio", "study", "stuffed", "stuffing", "stuffy", "stumble", "stumbling", "stump", "stung", "stunned", "stunner", "stunning", "stunt", "stupor", "sturdily", "sturdy", "styling", "stylishly", "stylist", "stylized", "stylus", "suave", "subarctic", "subatomic", "subdivide", "subdued", "subduing", "subfloor", "subgroup", "subheader", "subject", "sublease", "sublet", "sublevel", "sublime", "submarine", "submerge", "submersed", "submitter", "subpanel", "subpar", "subplot", "subprime", "subscribe", "subscript", "subsector", "subside", "subsiding", "subsidize", "subsidy", "subsoil", "subsonic", "substance", "subsystem", "subtext", "subtitle", "subtly", "subtotal", "subtract", "subtype", "suburb", "subway", "subwoofer", "subzero", "succulent", "such", "suction", "sudden", "sudoku", "suds", "sufferer", "suffering", "suffice", "suffix", "suffocate", "suffrage", "sugar", "suggest", "suing", "suitable", "suitably", "suitcase", "suitor", "sulfate", "sulfide", "sulfite", "sulfur", "sulk", "sullen", "sulphate", "sulphuric", "sultry", "superbowl", "superglue", "superhero", "superior", "superjet", "superman", "supermom", "supernova", "supervise", "supper", "supplier", "supply", "support", "supremacy", "supreme", "surcharge", "surely", "sureness", "surface", "surfacing", "surfboard", "surfer", "surgery", "surgical", "surging", "surname", "surpass", "surplus", "surprise", "surreal", "surrender", "surrogate", "surround", "survey", "survival", "survive", "surviving", "survivor", "sushi", "suspect", "suspend", "suspense", "sustained", "sustainer", "swab", "swaddling", "swagger", "swampland", "swan", "swapping", "swarm", "sway", "swear", "sweat", "sweep", "swell", "swept", "swerve", "swifter", "swiftly", "swiftness", "swimmable", "swimmer", "swimming", "swimsuit", "swimwear", "swinger", "swinging", "swipe", "swirl", "switch", "swivel", "swizzle", "swooned", "swoop", "swoosh", "swore", "sworn", "swung", "sycamore", "sympathy", "symphonic", "symphony", "symptom", "synapse", "syndrome", "synergy", "synopses", "synopsis", "synthesis", "synthetic", "syrup", "system", "t-shirt", "tabasco", "tabby", "tableful", "tables", "tablet", "tableware", "tabloid", "tackiness", "tacking", "tackle", "tackling", "tacky", "taco", "tactful", "tactical", "tactics", "tactile", "tactless", "tadpole", "taekwondo", "tag", "tainted", "take", "taking", "talcum", "talisman", "tall", "talon", "tamale", "tameness", "tamer", "tamper", "tank", "tanned", "tannery", "tanning", "tantrum", "tapeless", "tapered", "tapering", "tapestry", "tapioca", "tapping", "taps", "tarantula", "target", "tarmac", "tarnish", "tarot", "tartar", "tartly", "tartness", "task", "tassel", "taste", "tastiness", "tasting", "tasty", "tattered", "tattle", "tattling", "tattoo", "taunt", "tavern", "thank", "that", "thaw", "theater", "theatrics", "thee", "theft", "theme", "theology", "theorize", "thermal", "thermos", "thesaurus", "these", "thesis", "thespian", "thicken", "thicket", "thickness", "thieving", "thievish", "thigh", "thimble", "thing", "think", "thinly", "thinner", "thinness", "thinning", "thirstily", "thirsting", "thirsty", "thirteen", "thirty", "thong", "thorn", "those", "thousand", "thrash", "thread", "threaten", "threefold", "thrift", "thrill", "thrive", "thriving", "throat", "throbbing", "throng", "throttle", "throwaway", "throwback", "thrower", "throwing", "thud", "thumb", "thumping", "thursday", "thus", "thwarting", "thyself", "tiara", "tibia", "tidal", "tidbit", "tidiness", "tidings", "tidy", "tiger", "tighten", "tightly", "tightness", "tightrope", "tightwad", "tigress", "tile", "tiling", "till", "tilt", "timid", "timing", "timothy", "tinderbox", "tinfoil", "tingle", "tingling", "tingly", "tinker", "tinkling", "tinsel", "tinsmith", "tint", "tinwork", "tiny", "tipoff", "tipped", "tipper", "tipping", "tiptoeing", "tiptop", "tiring", "tissue", "trace", "tracing", "track", "traction", "tractor", "trade", "trading", "tradition", "traffic", "tragedy", "trailing", "trailside", "train", "traitor", "trance", "tranquil", "transfer", "transform", "translate", "transpire", "transport", "transpose", "trapdoor", "trapeze", "trapezoid", "trapped", "trapper", "trapping", "traps", "trash", "travel", "traverse", "travesty", "tray", "treachery", "treading", "treadmill", "treason", "treat", "treble", "tree", "trekker", "tremble", "trembling", "tremor", "trench", "trend", "trespass", "triage", "trial", "triangle", "tribesman", "tribunal", "tribune", "tributary", "tribute", "triceps", "trickery", "trickily", "tricking", "trickle", "trickster", "tricky", "tricolor", "tricycle", "trident", "tried", "trifle", "trifocals", "trillion", "trilogy", "trimester", "trimmer", "trimming", "trimness", "trinity", "trio", "tripod", "tripping", "triumph", "trivial", "trodden", "trolling", "trombone", "trophy", "tropical", "tropics", "trouble", "troubling", "trough", "trousers", "trout", "trowel", "truce", "truck", "truffle", "trump", "trunks", "trustable", "trustee", "trustful", "trusting", "trustless", "truth", "try", "tubby", "tubeless", "tubular", "tucking", "tuesday", "tug", "tuition", "tulip", "tumble", "tumbling", "tummy", "turban", "turbine", "turbofan", "turbojet", "turbulent", "turf", "turkey", "turmoil", "turret", "turtle", "tusk", "tutor", "tutu", "tux", "tweak", "tweed", "tweet", "tweezers", "twelve", "twentieth", "twenty", "twerp", "twice", "twiddle", "twiddling", "twig", "twilight", "twine", "twins", "twirl", "twistable", "twisted", "twister", "twisting", "twisty", "twitch", "twitter", "tycoon", "tying", "tyke", "udder", "ultimate", "ultimatum", "ultra", "umbilical", "umbrella", "umpire", "unabashed", "unable", "unadorned", "unadvised", "unafraid", "unaired", "unaligned", "unaltered", "unarmored", "unashamed", "unaudited", "unawake", "unaware", "unbaked", "unbalance", "unbeaten", "unbend", "unbent", "unbiased", "unbitten", "unblended", "unblessed", "unblock", "unbolted", "unbounded", "unboxed", "unbraided", "unbridle", "unbroken", "unbuckled", "unbundle", "unburned", "unbutton", "uncanny", "uncapped", "uncaring", "uncertain", "unchain", "unchanged", "uncharted", "uncheck", "uncivil", "unclad", "unclaimed", "unclamped", "unclasp", "uncle", "unclip", "uncloak", "unclog", "unclothed", "uncoated", "uncoiled", "uncolored", "uncombed", "uncommon", "uncooked", "uncork", "uncorrupt", "uncounted", "uncouple", "uncouth", "uncover", "uncross", "uncrown", "uncrushed", "uncured", "uncurious", "uncurled", "uncut", "undamaged", "undated", "undaunted", "undead", "undecided", "undefined", "underage", "underarm", "undercoat", "undercook", "undercut", "underdog", "underdone", "underfed", "underfeed", "underfoot", "undergo", "undergrad", "underhand", "underline", "underling", "undermine", "undermost", "underpaid", "underpass", "underpay", "underrate", "undertake", "undertone", "undertook", "undertow", "underuse", "underwear", "underwent", "underwire", "undesired", "undiluted", "undivided", "undocked", "undoing", "undone", "undrafted", "undress", "undrilled", "undusted", "undying", "unearned", "unearth", "unease", "uneasily", "uneasy", "uneatable", "uneaten", "unedited", "unelected", "unending", "unengaged", "unenvied", "unequal", "unethical", "uneven", "unexpired", "unexposed", "unfailing", "unfair", "unfasten", "unfazed", "unfeeling", "unfiled", "unfilled", "unfitted", "unfitting", "unfixable", "unfixed", "unflawed", "unfocused", "unfold", "unfounded", "unframed", "unfreeze", "unfrosted", "unfrozen", "unfunded", "unglazed", "ungloved", "unglue", "ungodly", "ungraded", "ungreased", "unguarded", "unguided", "unhappily", "unhappy", "unharmed", "unhealthy", "unheard", "unhearing", "unheated", "unhelpful", "unhidden", "unhinge", "unhitched", "unholy", "unhook", "unicorn", "unicycle", "unified", "unifier", "uniformed", "uniformly", "unify", "unimpeded", "uninjured", "uninstall", "uninsured", "uninvited", "union", "uniquely", "unisexual", "unison", "unissued", "unit", "universal", "universe", "unjustly", "unkempt", "unkind", "unknotted", "unknowing", "unknown", "unlaced", "unlatch", "unlawful", "unleaded", "unlearned", "unleash", "unless", "unleveled", "unlighted", "unlikable", "unlimited", "unlined", "unlinked", "unlisted", "unlit", "unlivable", "unloaded", "unloader", "unlocked", "unlocking", "unlovable", "unloved", "unlovely", "unloving", "unluckily", "unlucky", "unmade", "unmanaged", "unmanned", "unmapped", "unmarked", "unmasked", "unmasking", "unmatched", "unmindful", "unmixable", "unmixed", "unmolded", "unmoral", "unmovable", "unmoved", "unmoving", "unnamable", "unnamed", "unnatural", "unneeded", "unnerve", "unnerving", "unnoticed", "unopened", "unopposed", "unpack", "unpadded", "unpaid", "unpainted", "unpaired", "unpaved", "unpeeled", "unpicked", "unpiloted", "unpinned", "unplanned", "unplanted", "unpleased", "unpledged", "unplowed", "unplug", "unpopular", "unproven", "unquote", "unranked", "unrated", "unraveled", "unreached", "unread", "unreal", "unreeling", "unrefined", "unrelated", "unrented", "unrest", "unretired", "unrevised", "unrigged", "unripe", "unrivaled", "unroasted", "unrobed", "unroll", "unruffled", "unruly", "unrushed", "unsaddle", "unsafe", "unsaid", "unsalted", "unsaved", "unsavory", "unscathed", "unscented", "unscrew", "unsealed", "unseated", "unsecured", "unseeing", "unseemly", "unseen", "unselect", "unselfish", "unsent", "unsettled", "unshackle", "unshaken", "unshaved", "unshaven", "unsheathe", "unshipped", "unsightly", "unsigned", "unskilled", "unsliced", "unsmooth", "unsnap", "unsocial", "unsoiled", "unsold", "unsolved", "unsorted", "unspoiled", "unspoken", "unstable", "unstaffed", "unstamped", "unsteady", "unsterile", "unstirred", "unstitch", "unstopped", "unstuck", "unstuffed", "unstylish", "unsubtle", "unsubtly", "unsuited", "unsure", "unsworn", "untagged", "untainted", "untaken", "untamed", "untangled", "untapped", "untaxed", "unthawed", "unthread", "untidy", "untie", "until", "untimed", "untimely", "untitled", "untoasted", "untold", "untouched", "untracked", "untrained", "untreated", "untried", "untrimmed", "untrue", "untruth", "unturned", "untwist", "untying", "unusable", "unused", "unusual", "unvalued", "unvaried", "unvarying", "unveiled", "unveiling", "unvented", "unviable", "unvisited", "unvocal", "unwanted", "unwarlike", "unwary", "unwashed", "unwatched", "unweave", "unwed", "unwelcome", "unwell", "unwieldy", "unwilling", "unwind", "unwired", "unwitting", "unwomanly", "unworldly", "unworn", "unworried", "unworthy", "unwound", "unwoven", "unwrapped", "unwritten", "unzip", "upbeat", "upchuck", "upcoming", "upcountry", "update", "upfront", "upgrade", "upheaval", "upheld", "uphill", "uphold", "uplifted", "uplifting", "upload", "upon", "upper", "upright", "uprising", "upriver", "uproar", "uproot", "upscale", "upside", "upstage", "upstairs", "upstart", "upstate", "upstream", "upstroke", "upswing", "uptake", "uptight", "uptown", "upturned", "upward", "upwind", "uranium", "urban", "urchin", "urethane", "urgency", "urgent", "urging", "urologist", "urology", "usable", "usage", "useable", "used", "uselessly", "user", "usher", "usual", "utensil", "utility", "utilize", "utmost", "utopia", "utter", "vacancy", "vacant", "vacate", "vacation", "vagabond", "vagrancy", "vagrantly", "vaguely", "vagueness", "valiant", "valid", "valium", "valley", "valuables", "value", "vanilla", "vanish", "vanity", "vanquish", "vantage", "vaporizer", "variable", "variably", "varied", "variety", "various", "varmint", "varnish", "varsity", "varying", "vascular", "vaseline", "vastly", "vastness", "veal", "vegan", "veggie", "vehicular", "velcro", "velocity", "velvet", "vendetta", "vending", "vendor", "veneering", "vengeful", "venomous", "ventricle", "venture", "venue", "venus", "verbalize", "verbally", "verbose", "verdict", "verify", "verse", "version", "versus", "vertebrae", "vertical", "vertigo", "very", "vessel", "vest", "veteran", "veto", "vexingly", "viability", "viable", "vibes", "vice", "vicinity", "victory", "video", "viewable", "viewer", "viewing", "viewless", "viewpoint", "vigorous", "village", "villain", "vindicate", "vineyard", "vintage", "violate", "violation", "violator", "violet", "violin", "viper", "viral", "virtual", "virtuous", "virus", "visa", "viscosity", "viscous", "viselike", "visible", "visibly", "vision", "visiting", "visitor", "visor", "vista", "vitality", "vitalize", "vitally", "vitamins", "vivacious", "vividly", "vividness", "vixen", "vocalist", "vocalize", "vocally", "vocation", "voice", "voicing", "void", "volatile", "volley", "voltage", "volumes", "voter", "voting", "voucher", "vowed", "vowel", "voyage", "wackiness", "wad", "wafer", "waffle", "waged", "wager", "wages", "waggle", "wagon", "wake", "waking", "walk", "walmart", "walnut", "walrus", "waltz", "wand", "wannabe", "wanted", "wanting", "wasabi", "washable", "washbasin", "washboard", "washbowl", "washcloth", "washday", "washed", "washer", "washhouse", "washing", "washout", "washroom", "washstand", "washtub", "wasp", "wasting", "watch", "water", "waviness", "waving", "wavy", "whacking", "whacky", "wham", "wharf", "wheat", "whenever", "whiff", "whimsical", "whinny", "whiny", "whisking", "whoever", "whole", "whomever", "whoopee", "whooping", "whoops", "why", "wick", "widely", "widen", "widget", "widow", "width", "wieldable", "wielder", "wife", "wifi", "wikipedia", "wildcard", "wildcat", "wilder", "wildfire", "wildfowl", "wildland", "wildlife", "wildly", "wildness", "willed", "willfully", "willing", "willow", "willpower", "wilt", "wimp", "wince", "wincing", "wind", "wing", "winking", "winner", "winnings", "winter", "wipe", "wired", "wireless", "wiring", "wiry", "wisdom", "wise", "wish", "wisplike", "wispy", "wistful", "wizard", "wobble", "wobbling", "wobbly", "wok", "wolf", "wolverine", "womanhood", "womankind", "womanless", "womanlike", "womanly", "womb", "woof", "wooing", "wool", "woozy", "word", "work", "worried", "worrier", "worrisome", "worry", "worsening", "worshiper", "worst", "wound", "woven", "wow", "wrangle", "wrath", "wreath", "wreckage", "wrecker", "wrecking", "wrench", "wriggle", "wriggly", "wrinkle", "wrinkly", "wrist", "writing", "written", "wrongdoer", "wronged", "wrongful", "wrongly", "wrongness", "wrought", "xbox", "xerox", "yahoo", "yam", "yanking", "yapping", "yard", "yarn", "yeah", "yearbook", "yearling", "yearly", "yearning", "yeast", "yelling", "yelp", "yen", "yesterday", "yiddish", "yield", "yin", "yippee", "yo-yo", "yodel", "yoga", "yogurt", "yonder", "yoyo", "yummy", "zap", "zealous", "zebra", "zen", "zeppelin", "zero", "zestfully", "zesty", "zigzagged", "zipfile", "zipping", "zippy", "zips", "zit", "zodiac", "zombie", "zone", "zoning", "zookeeper", "zoologist", "zoology", "zoom"]),
    $7e = Object.freeze(I7e.filter(t => !t.includes("-")));

function S7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M17.982 18.725A7.488 7.488 0 0 0 12 15.75a7.488 7.488 0 0 0-5.982 2.975m11.963 0a9 9 0 1 0-11.963 0m11.963 0A8.966 8.966 0 0 1 12 21a8.966 8.966 0 0 1-5.982-2.275M15 9.75a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"
    }))
}
const i8 = v.forwardRef(S7e);

function T7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M21.75 6.75v10.5a2.25 2.25 0 0 1-2.25 2.25h-15a2.25 2.25 0 0 1-2.25-2.25V6.75m19.5 0A2.25 2.25 0 0 0 19.5 4.5h-15a2.25 2.25 0 0 0-2.25 2.25m19.5 0v.243a2.25 2.25 0 0 1-1.07 1.916l-7.5 4.615a2.25 2.25 0 0 1-2.36 0L3.32 8.91a2.25 2.25 0 0 1-1.07-1.916V6.75"
    }))
}
const Ld = v.forwardRef(T7e);

function P7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        fillRule: "evenodd",
        d: "M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z",
        clipRule: "evenodd"
    }))
}
const N7e = v.forwardRef(P7e);

function O7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M21 12a2.25 2.25 0 0 0-2.25-2.25H15a3 3 0 1 1-6 0H5.25A2.25 2.25 0 0 0 3 12m18 0v6a2.25 2.25 0 0 1-2.25 2.25H5.25A2.25 2.25 0 0 1 3 18v-6m18 0V9M3 12V9m18 0a2.25 2.25 0 0 0-2.25-2.25H5.25A2.25 2.25 0 0 0 3 9m18 0V6a2.25 2.25 0 0 0-2.25-2.25H5.25A2.25 2.25 0 0 0 3 6v3"
    }))
}
const P0 = v.forwardRef(O7e);

function j7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"
    }))
}
const Wy = v.forwardRef(j7e);

function R7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"
    }))
}
const c4 = v.forwardRef(R7e);

function M7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        fillRule: "evenodd",
        d: "M9 1.5H5.625c-1.036 0-1.875.84-1.875 1.875v17.25c0 1.035.84 1.875 1.875 1.875h12.75c1.035 0 1.875-.84 1.875-1.875V12.75A3.75 3.75 0 0 0 16.5 9h-1.875a1.875 1.875 0 0 1-1.875-1.875V5.25A3.75 3.75 0 0 0 9 1.5Zm6.61 10.936a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 14.47a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z",
        clipRule: "evenodd"
    }), v.createElement("path", {
        d: "M12.971 1.816A5.23 5.23 0 0 1 14.25 5.25v1.875c0 .207.168.375.375.375H16.5a5.23 5.23 0 0 1 3.434 1.279 9.768 9.768 0 0 0-6.963-6.963Z"
    }))
}
const D7e = v.forwardRef(M7e);

function L7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        fillRule: "evenodd",
        d: "M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25Zm-1.72 6.97a.75.75 0 1 0-1.06 1.06L10.94 12l-1.72 1.72a.75.75 0 1 0 1.06 1.06L12 13.06l1.72 1.72a.75.75 0 1 0 1.06-1.06L13.06 12l1.72-1.72a.75.75 0 1 0-1.06-1.06L12 10.94l-1.72-1.72Z",
        clipRule: "evenodd"
    }))
}
const zy = v.forwardRef(L7e);

function U7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        fillRule: "evenodd",
        d: "M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12Zm13.36-1.814a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z",
        clipRule: "evenodd"
    }))
}
const vd = v.forwardRef(U7e);

function F7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"
    }))
}
const B7e = v.forwardRef(F7e);

function W7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99"
    }))
}
const z7e = v.forwardRef(W7e);

function q7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M8.25 9V5.25A2.25 2.25 0 0 1 10.5 3h6a2.25 2.25 0 0 1 2.25 2.25v13.5A2.25 2.25 0 0 1 16.5 21h-6a2.25 2.25 0 0 1-2.25-2.25V15M12 9l3 3m0 0-3 3m3-3H2.25"
    }))
}
const H7e = v.forwardRef(q7e);

function V7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
    }))
}
const gc = v.forwardRef(V7e);

function G7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "m8.25 4.5 7.5 7.5-7.5 7.5"
    }))
}
const s8 = v.forwardRef(G7e);

function K7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M11.35 3.836c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75 2.25 2.25 0 0 0-.1-.664m-5.8 0A2.251 2.251 0 0 1 13.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m8.9-4.414c.376.023.75.05 1.124.08 1.131.094 1.976 1.057 1.976 2.192V16.5A2.25 2.25 0 0 1 18 18.75h-2.25m-7.5-10.5H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V18.75m-7.5-10.5h6.375c.621 0 1.125.504 1.125 1.125v9.375m-8.25-3 1.5 1.5 3-3.75"
    }))
}
const DL = v.forwardRef(K7e);

function Y7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M8.25 7.5V6.108c0-1.135.845-2.098 1.976-2.192.373-.03.748-.057 1.123-.08M15.75 18H18a2.25 2.25 0 0 0 2.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 0 0-1.123-.08M15.75 18.75v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5A3.375 3.375 0 0 0 6.375 7.5H5.25m11.9-3.664A2.251 2.251 0 0 0 15 2.25h-1.5a2.251 2.251 0 0 0-2.15 1.586m5.8 0c.065.21.1.433.1.664v.75h-6V4.5c0-.231.035-.454.1-.664M6.75 7.5H4.875c-.621 0-1.125.504-1.125 1.125v12c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V16.5a9 9 0 0 0-9-9Z"
    }))
}
const Z7e = v.forwardRef(Y7e);

function J7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
    }))
}
const LL = v.forwardRef(J7e);

function Q7e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M12 16.5V9.75m0 0 3 3m-3-3-3 3M6.75 19.5a4.5 4.5 0 0 1-1.41-8.775 5.25 5.25 0 0 1 10.233-2.33 3 3 0 0 1 3.758 3.848A3.752 3.752 0 0 1 18 19.5H6.75Z"
    }))
}
const X7e = v.forwardRef(Q7e);

function e_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M2.25 8.25h19.5M2.25 9h19.5m-16.5 5.25h6m-6 2.25h3m-3.75 3h15a2.25 2.25 0 0 0 2.25-2.25V6.75A2.25 2.25 0 0 0 19.5 4.5h-15a2.25 2.25 0 0 0-2.25 2.25v10.5A2.25 2.25 0 0 0 4.5 19.5Z"
    }))
}
const t_e = v.forwardRef(e_e);

function r_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"
    }))
}
const n_e = v.forwardRef(r_e);

function i_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M3.98 8.223A10.477 10.477 0 0 0 1.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.451 10.451 0 0 1 12 4.5c4.756 0 8.773 3.162 10.065 7.498a10.522 10.522 0 0 1-4.293 5.774M6.228 6.228 3 3m3.228 3.228 3.65 3.65m7.894 7.894L21 21m-3.228-3.228-3.65-3.65m0 0a3 3 0 1 0-4.243-4.243m4.242 4.242L9.88 9.88"
    }))
}
const s_e = v.forwardRef(i_e);

function a_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M2.036 12.322a1.012 1.012 0 0 1 0-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178Z"
    }), v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"
    }))
}
const o_e = v.forwardRef(a_e);

function c_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M12 21a9.004 9.004 0 0 0 8.716-6.747M12 21a9.004 9.004 0 0 1-8.716-6.747M12 21c2.485 0 4.5-4.03 4.5-9S14.485 3 12 3m0 18c-2.485 0-4.5-4.03-4.5-9S9.515 3 12 3m0 0a8.997 8.997 0 0 1 7.843 4.582M12 3a8.997 8.997 0 0 0-7.843 4.582m15.686 0A11.953 11.953 0 0 1 12 10.5c-2.998 0-5.74-1.1-7.843-2.918m15.686 0A8.959 8.959 0 0 1 21 12c0 .778-.099 1.533-.284 2.253m0 0A17.919 17.919 0 0 1 12 16.5c-3.162 0-6.133-.815-8.716-2.247m0 0A9.015 9.015 0 0 1 3 12c0-1.605.42-3.113 1.157-4.418"
    }))
}
const UL = v.forwardRef(c_e);

function l_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z"
    }))
}
const d_e = v.forwardRef(l_e);

function u_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M15.75 5.25a3 3 0 0 1 3 3m3 0a6 6 0 0 1-7.029 5.912c-.563-.097-1.159.026-1.563.43L10.5 17.25H8.25v2.25H6v2.25H2.25v-2.818c0-.597.237-1.17.659-1.591l6.499-6.499c.404-.404.527-1 .43-1.563A6 6 0 1 1 21.75 8.25Z"
    }))
}
const h_e = v.forwardRef(u_e);

function f_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M16.5 10.5V6.75a4.5 4.5 0 1 0-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z"
    }))
}
const FL = v.forwardRef(f_e);

function p_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z"
    }))
}
const g_e = v.forwardRef(p_e);

function m_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M15 12H9m12 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
    }))
}
const Bb = v.forwardRef(m_e);

function y_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M18.364 18.364A9 9 0 0 0 5.636 5.636m12.728 12.728A9 9 0 0 1 5.636 5.636m12.728 12.728L5.636 5.636"
    }))
}
const w_e = v.forwardRef(y_e);

function b_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10"
    }))
}
const v_e = v.forwardRef(b_e);

function x_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M3.75 4.875c0-.621.504-1.125 1.125-1.125h4.5c.621 0 1.125.504 1.125 1.125v4.5c0 .621-.504 1.125-1.125 1.125h-4.5A1.125 1.125 0 0 1 3.75 9.375v-4.5ZM3.75 14.625c0-.621.504-1.125 1.125-1.125h4.5c.621 0 1.125.504 1.125 1.125v4.5c0 .621-.504 1.125-1.125 1.125h-4.5a1.125 1.125 0 0 1-1.125-1.125v-4.5ZM13.5 4.875c0-.621.504-1.125 1.125-1.125h4.5c.621 0 1.125.504 1.125 1.125v4.5c0 .621-.504 1.125-1.125 1.125h-4.5A1.125 1.125 0 0 1 13.5 9.375v-4.5Z"
    }), v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M6.75 6.75h.75v.75h-.75v-.75ZM6.75 16.5h.75v.75h-.75v-.75ZM16.5 6.75h.75v.75h-.75v-.75ZM13.5 13.5h.75v.75h-.75v-.75ZM13.5 19.5h.75v.75h-.75v-.75ZM19.5 13.5h.75v.75h-.75v-.75ZM19.5 19.5h.75v.75h-.75v-.75ZM16.5 16.5h.75v.75h-.75v-.75Z"
    }))
}
const E_e = v.forwardRef(x_e);

function __e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0"
    }))
}
const C_e = v.forwardRef(__e);
var bu = {},
    Wb, _I;

function A_e() {
    return _I || (_I = 1, Wb = function() {
        return typeof Promise == "function" && Promise.prototype && Promise.prototype.then
    }), Wb
}
var zb = {},
    Nc = {},
    CI;

function Ud() {
    if (CI) return Nc;
    CI = 1;
    let t;
    const e = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
    return Nc.getSymbolSize = function(n) {
        if (!n) throw new Error('"version" cannot be null or undefined');
        if (n < 1 || n > 40) throw new Error('"version" should be in range from 1 to 40');
        return n * 4 + 17
    }, Nc.getSymbolTotalCodewords = function(n) {
        return e[n]
    }, Nc.getBCHDigit = function(r) {
        let n = 0;
        for (; r !== 0;) n++, r >>>= 1;
        return n
    }, Nc.setToSJISFunction = function(n) {
        if (typeof n != "function") throw new Error('"toSJISFunc" is not a valid function.');
        t = n
    }, Nc.isKanjiModeEnabled = function() {
        return typeof t < "u"
    }, Nc.toSJIS = function(n) {
        return t(n)
    }, Nc
}
var qb = {},
    AI;

function a8() {
    return AI || (AI = 1, function(t) {
        t.L = {
            bit: 1
        }, t.M = {
            bit: 0
        }, t.Q = {
            bit: 3
        }, t.H = {
            bit: 2
        };

        function e(r) {
            if (typeof r != "string") throw new Error("Param is not a string");
            switch (r.toLowerCase()) {
                case "l":
                case "low":
                    return t.L;
                case "m":
                case "medium":
                    return t.M;
                case "q":
                case "quartile":
                    return t.Q;
                case "h":
                case "high":
                    return t.H;
                default:
                    throw new Error("Unknown EC Level: " + r)
            }
        }
        t.isValid = function(n) {
            return n && typeof n.bit < "u" && n.bit >= 0 && n.bit < 4
        }, t.from = function(n, i) {
            if (t.isValid(n)) return n;
            try {
                return e(n)
            } catch {
                return i
            }
        }
    }(qb)), qb
}
var Hb, kI;

function k_e() {
    if (kI) return Hb;
    kI = 1;

    function t() {
        this.buffer = [], this.length = 0
    }
    return t.prototype = {
        get: function(e) {
            const r = Math.floor(e / 8);
            return (this.buffer[r] >>> 7 - e % 8 & 1) === 1
        },
        put: function(e, r) {
            for (let n = 0; n < r; n++) this.putBit((e >>> r - n - 1 & 1) === 1)
        },
        getLengthInBits: function() {
            return this.length
        },
        putBit: function(e) {
            const r = Math.floor(this.length / 8);
            this.buffer.length <= r && this.buffer.push(0), e && (this.buffer[r] |= 128 >>> this.length % 8), this.length++
        }
    }, Hb = t, Hb
}
var Vb, II;

function I_e() {
    if (II) return Vb;
    II = 1;

    function t(e) {
        if (!e || e < 1) throw new Error("BitMatrix size must be defined and greater than 0");
        this.size = e, this.data = new Uint8Array(e * e), this.reservedBit = new Uint8Array(e * e)
    }
    return t.prototype.set = function(e, r, n, i) {
        const s = e * this.size + r;
        this.data[s] = n, i && (this.reservedBit[s] = !0)
    }, t.prototype.get = function(e, r) {
        return this.data[e * this.size + r]
    }, t.prototype.xor = function(e, r, n) {
        this.data[e * this.size + r] ^= n
    }, t.prototype.isReserved = function(e, r) {
        return this.reservedBit[e * this.size + r]
    }, Vb = t, Vb
}
var Gb = {},
    $I;

function $_e() {
    return $I || ($I = 1, function(t) {
        const e = Ud().getSymbolSize;
        t.getRowColCoords = function(n) {
            if (n === 1) return [];
            const i = Math.floor(n / 7) + 2,
                s = e(n),
                a = s === 145 ? 26 : Math.ceil((s - 13) / (2 * i - 2)) * 2,
                o = [s - 7];
            for (let c = 1; c < i - 1; c++) o[c] = o[c - 1] - a;
            return o.push(6), o.reverse()
        }, t.getPositions = function(n) {
            const i = [],
                s = t.getRowColCoords(n),
                a = s.length;
            for (let o = 0; o < a; o++)
                for (let c = 0; c < a; c++) o === 0 && c === 0 || o === 0 && c === a - 1 || o === a - 1 && c === 0 || i.push([s[o], s[c]]);
            return i
        }
    }(Gb)), Gb
}
var Kb = {},
    SI;

function S_e() {
    if (SI) return Kb;
    SI = 1;
    const t = Ud().getSymbolSize,
        e = 7;
    return Kb.getPositions = function(n) {
        const i = t(n);
        return [
            [0, 0],
            [i - e, 0],
            [0, i - e]
        ]
    }, Kb
}
var Yb = {},
    TI;

function T_e() {
    return TI || (TI = 1, function(t) {
        t.Patterns = {
            PATTERN000: 0,
            PATTERN001: 1,
            PATTERN010: 2,
            PATTERN011: 3,
            PATTERN100: 4,
            PATTERN101: 5,
            PATTERN110: 6,
            PATTERN111: 7
        };
        const e = {
            N1: 3,
            N2: 3,
            N3: 40,
            N4: 10
        };
        t.isValid = function(i) {
            return i != null && i !== "" && !isNaN(i) && i >= 0 && i <= 7
        }, t.from = function(i) {
            return t.isValid(i) ? parseInt(i, 10) : void 0
        }, t.getPenaltyN1 = function(i) {
            const s = i.size;
            let a = 0,
                o = 0,
                c = 0,
                l = null,
                u = null;
            for (let h = 0; h < s; h++) {
                o = c = 0, l = u = null;
                for (let f = 0; f < s; f++) {
                    let p = i.get(h, f);
                    p === l ? o++ : (o >= 5 && (a += e.N1 + (o - 5)), l = p, o = 1), p = i.get(f, h), p === u ? c++ : (c >= 5 && (a += e.N1 + (c - 5)), u = p, c = 1)
                }
                o >= 5 && (a += e.N1 + (o - 5)), c >= 5 && (a += e.N1 + (c - 5))
            }
            return a
        }, t.getPenaltyN2 = function(i) {
            const s = i.size;
            let a = 0;
            for (let o = 0; o < s - 1; o++)
                for (let c = 0; c < s - 1; c++) {
                    const l = i.get(o, c) + i.get(o, c + 1) + i.get(o + 1, c) + i.get(o + 1, c + 1);
                    (l === 4 || l === 0) && a++
                }
            return a * e.N2
        }, t.getPenaltyN3 = function(i) {
            const s = i.size;
            let a = 0,
                o = 0,
                c = 0;
            for (let l = 0; l < s; l++) {
                o = c = 0;
                for (let u = 0; u < s; u++) o = o << 1 & 2047 | i.get(l, u), u >= 10 && (o === 1488 || o === 93) && a++, c = c << 1 & 2047 | i.get(u, l), u >= 10 && (c === 1488 || c === 93) && a++
            }
            return a * e.N3
        }, t.getPenaltyN4 = function(i) {
            let s = 0;
            const a = i.data.length;
            for (let c = 0; c < a; c++) s += i.data[c];
            return Math.abs(Math.ceil(s * 100 / a / 5) - 10) * e.N4
        };

        function r(n, i, s) {
            switch (n) {
                case t.Patterns.PATTERN000:
                    return (i + s) % 2 === 0;
                case t.Patterns.PATTERN001:
                    return i % 2 === 0;
                case t.Patterns.PATTERN010:
                    return s % 3 === 0;
                case t.Patterns.PATTERN011:
                    return (i + s) % 3 === 0;
                case t.Patterns.PATTERN100:
                    return (Math.floor(i / 2) + Math.floor(s / 3)) % 2 === 0;
                case t.Patterns.PATTERN101:
                    return i * s % 2 + i * s % 3 === 0;
                case t.Patterns.PATTERN110:
                    return (i * s % 2 + i * s % 3) % 2 === 0;
                case t.Patterns.PATTERN111:
                    return (i * s % 3 + (i + s) % 2) % 2 === 0;
                default:
                    throw new Error("bad maskPattern:" + n)
            }
        }
        t.applyMask = function(i, s) {
            const a = s.size;
            for (let o = 0; o < a; o++)
                for (let c = 0; c < a; c++) s.isReserved(c, o) || s.xor(c, o, r(i, c, o))
        }, t.getBestMask = function(i, s) {
            const a = Object.keys(t.Patterns).length;
            let o = 0,
                c = 1 / 0;
            for (let l = 0; l < a; l++) {
                s(l), t.applyMask(l, i);
                const u = t.getPenaltyN1(i) + t.getPenaltyN2(i) + t.getPenaltyN3(i) + t.getPenaltyN4(i);
                t.applyMask(l, i), u < c && (c = u, o = l)
            }
            return o
        }
    }(Yb)), Yb
}
var Tg = {},
    PI;

function BL() {
    if (PI) return Tg;
    PI = 1;
    const t = a8(),
        e = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81],
        r = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
    return Tg.getBlocksCount = function(i, s) {
        switch (s) {
            case t.L:
                return e[(i - 1) * 4 + 0];
            case t.M:
                return e[(i - 1) * 4 + 1];
            case t.Q:
                return e[(i - 1) * 4 + 2];
            case t.H:
                return e[(i - 1) * 4 + 3];
            default:
                return
        }
    }, Tg.getTotalCodewordsCount = function(i, s) {
        switch (s) {
            case t.L:
                return r[(i - 1) * 4 + 0];
            case t.M:
                return r[(i - 1) * 4 + 1];
            case t.Q:
                return r[(i - 1) * 4 + 2];
            case t.H:
                return r[(i - 1) * 4 + 3];
            default:
                return
        }
    }, Tg
}
var Zb = {},
    df = {},
    NI;

function P_e() {
    if (NI) return df;
    NI = 1;
    const t = new Uint8Array(512),
        e = new Uint8Array(256);
    return function() {
        let n = 1;
        for (let i = 0; i < 255; i++) t[i] = n, e[n] = i, n <<= 1, n & 256 && (n ^= 285);
        for (let i = 255; i < 512; i++) t[i] = t[i - 255]
    }(), df.log = function(n) {
        if (n < 1) throw new Error("log(" + n + ")");
        return e[n]
    }, df.exp = function(n) {
        return t[n]
    }, df.mul = function(n, i) {
        return n === 0 || i === 0 ? 0 : t[e[n] + e[i]]
    }, df
}
var OI;

function N_e() {
    return OI || (OI = 1, function(t) {
        const e = P_e();
        t.mul = function(n, i) {
            const s = new Uint8Array(n.length + i.length - 1);
            for (let a = 0; a < n.length; a++)
                for (let o = 0; o < i.length; o++) s[a + o] ^= e.mul(n[a], i[o]);
            return s
        }, t.mod = function(n, i) {
            let s = new Uint8Array(n);
            for (; s.length - i.length >= 0;) {
                const a = s[0];
                for (let c = 0; c < i.length; c++) s[c] ^= e.mul(i[c], a);
                let o = 0;
                for (; o < s.length && s[o] === 0;) o++;
                s = s.slice(o)
            }
            return s
        }, t.generateECPolynomial = function(n) {
            let i = new Uint8Array([1]);
            for (let s = 0; s < n; s++) i = t.mul(i, new Uint8Array([1, e.exp(s)]));
            return i
        }
    }(Zb)), Zb
}
var Jb, jI;

function O_e() {
    if (jI) return Jb;
    jI = 1;
    const t = N_e();

    function e(r) {
        this.genPoly = void 0, this.degree = r, this.degree && this.initialize(this.degree)
    }
    return e.prototype.initialize = function(n) {
        this.degree = n, this.genPoly = t.generateECPolynomial(this.degree)
    }, e.prototype.encode = function(n) {
        if (!this.genPoly) throw new Error("Encoder not initialized");
        const i = new Uint8Array(n.length + this.degree);
        i.set(n);
        const s = t.mod(i, this.genPoly),
            a = this.degree - s.length;
        if (a > 0) {
            const o = new Uint8Array(this.degree);
            return o.set(s, a), o
        }
        return s
    }, Jb = e, Jb
}
var Qb = {},
    Xb = {},
    ev = {},
    RI;

function WL() {
    return RI || (RI = 1, ev.isValid = function(e) {
        return !isNaN(e) && e >= 1 && e <= 40
    }), ev
}
var qa = {},
    MI;

function zL() {
    if (MI) return qa;
    MI = 1;
    const t = "[0-9]+",
        e = "[A-Z $%*+\\-./:]+";
    let r = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    r = r.replace(/u/g, "\\u");
    const n = "(?:(?![A-Z0-9 $%*+\\-./:]|" + r + `)(?:.|[\r
]))+`;
    qa.KANJI = new RegExp(r, "g"), qa.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g"), qa.BYTE = new RegExp(n, "g"), qa.NUMERIC = new RegExp(t, "g"), qa.ALPHANUMERIC = new RegExp(e, "g");
    const i = new RegExp("^" + r + "$"),
        s = new RegExp("^" + t + "$"),
        a = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    return qa.testKanji = function(c) {
        return i.test(c)
    }, qa.testNumeric = function(c) {
        return s.test(c)
    }, qa.testAlphanumeric = function(c) {
        return a.test(c)
    }, qa
}
var DI;

function Fd() {
    return DI || (DI = 1, function(t) {
        const e = WL(),
            r = zL();
        t.NUMERIC = {
            id: "Numeric",
            bit: 1,
            ccBits: [10, 12, 14]
        }, t.ALPHANUMERIC = {
            id: "Alphanumeric",
            bit: 2,
            ccBits: [9, 11, 13]
        }, t.BYTE = {
            id: "Byte",
            bit: 4,
            ccBits: [8, 16, 16]
        }, t.KANJI = {
            id: "Kanji",
            bit: 8,
            ccBits: [8, 10, 12]
        }, t.MIXED = {
            bit: -1
        }, t.getCharCountIndicator = function(s, a) {
            if (!s.ccBits) throw new Error("Invalid mode: " + s);
            if (!e.isValid(a)) throw new Error("Invalid version: " + a);
            return a >= 1 && a < 10 ? s.ccBits[0] : a < 27 ? s.ccBits[1] : s.ccBits[2]
        }, t.getBestModeForData = function(s) {
            return r.testNumeric(s) ? t.NUMERIC : r.testAlphanumeric(s) ? t.ALPHANUMERIC : r.testKanji(s) ? t.KANJI : t.BYTE
        }, t.toString = function(s) {
            if (s && s.id) return s.id;
            throw new Error("Invalid mode")
        }, t.isValid = function(s) {
            return s && s.bit && s.ccBits
        };

        function n(i) {
            if (typeof i != "string") throw new Error("Param is not a string");
            switch (i.toLowerCase()) {
                case "numeric":
                    return t.NUMERIC;
                case "alphanumeric":
                    return t.ALPHANUMERIC;
                case "kanji":
                    return t.KANJI;
                case "byte":
                    return t.BYTE;
                default:
                    throw new Error("Unknown mode: " + i)
            }
        }
        t.from = function(s, a) {
            if (t.isValid(s)) return s;
            try {
                return n(s)
            } catch {
                return a
            }
        }
    }(Xb)), Xb
}
var LI;

function j_e() {
    return LI || (LI = 1, function(t) {
        const e = Ud(),
            r = BL(),
            n = a8(),
            i = Fd(),
            s = WL(),
            a = 7973,
            o = e.getBCHDigit(a);

        function c(f, p, g) {
            for (let m = 1; m <= 40; m++)
                if (p <= t.getCapacity(m, g, f)) return m
        }

        function l(f, p) {
            return i.getCharCountIndicator(f, p) + 4
        }

        function u(f, p) {
            let g = 0;
            return f.forEach(function(m) {
                const y = l(m.mode, p);
                g += y + m.getBitsLength()
            }), g
        }

        function h(f, p) {
            for (let g = 1; g <= 40; g++)
                if (u(f, g) <= t.getCapacity(g, p, i.MIXED)) return g
        }
        t.from = function(p, g) {
            return s.isValid(p) ? parseInt(p, 10) : g
        }, t.getCapacity = function(p, g, m) {
            if (!s.isValid(p)) throw new Error("Invalid QR Code version");
            typeof m > "u" && (m = i.BYTE);
            const y = e.getSymbolTotalCodewords(p),
                w = r.getTotalCodewordsCount(p, g),
                x = (y - w) * 8;
            if (m === i.MIXED) return x;
            const E = x - l(m, p);
            switch (m) {
                case i.NUMERIC:
                    return Math.floor(E / 10 * 3);
                case i.ALPHANUMERIC:
                    return Math.floor(E / 11 * 2);
                case i.KANJI:
                    return Math.floor(E / 13);
                case i.BYTE:
                default:
                    return Math.floor(E / 8)
            }
        }, t.getBestVersionForData = function(p, g) {
            let m;
            const y = n.from(g, n.M);
            if (Array.isArray(p)) {
                if (p.length > 1) return h(p, y);
                if (p.length === 0) return 1;
                m = p[0]
            } else m = p;
            return c(m.mode, m.getLength(), y)
        }, t.getEncodedBits = function(p) {
            if (!s.isValid(p) || p < 7) throw new Error("Invalid QR Code version");
            let g = p << 12;
            for (; e.getBCHDigit(g) - o >= 0;) g ^= a << e.getBCHDigit(g) - o;
            return p << 12 | g
        }
    }(Qb)), Qb
}
var tv = {},
    UI;

function R_e() {
    if (UI) return tv;
    UI = 1;
    const t = Ud(),
        e = 1335,
        r = 21522,
        n = t.getBCHDigit(e);
    return tv.getEncodedBits = function(s, a) {
        const o = s.bit << 3 | a;
        let c = o << 10;
        for (; t.getBCHDigit(c) - n >= 0;) c ^= e << t.getBCHDigit(c) - n;
        return (o << 10 | c) ^ r
    }, tv
}
var rv = {},
    nv, FI;

function M_e() {
    if (FI) return nv;
    FI = 1;
    const t = Fd();

    function e(r) {
        this.mode = t.NUMERIC, this.data = r.toString()
    }
    return e.getBitsLength = function(n) {
        return 10 * Math.floor(n / 3) + (n % 3 ? n % 3 * 3 + 1 : 0)
    }, e.prototype.getLength = function() {
        return this.data.length
    }, e.prototype.getBitsLength = function() {
        return e.getBitsLength(this.data.length)
    }, e.prototype.write = function(n) {
        let i, s, a;
        for (i = 0; i + 3 <= this.data.length; i += 3) s = this.data.substr(i, 3), a = parseInt(s, 10), n.put(a, 10);
        const o = this.data.length - i;
        o > 0 && (s = this.data.substr(i), a = parseInt(s, 10), n.put(a, o * 3 + 1))
    }, nv = e, nv
}
var iv, BI;

function D_e() {
    if (BI) return iv;
    BI = 1;
    const t = Fd(),
        e = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];

    function r(n) {
        this.mode = t.ALPHANUMERIC, this.data = n
    }
    return r.getBitsLength = function(i) {
        return 11 * Math.floor(i / 2) + 6 * (i % 2)
    }, r.prototype.getLength = function() {
        return this.data.length
    }, r.prototype.getBitsLength = function() {
        return r.getBitsLength(this.data.length)
    }, r.prototype.write = function(i) {
        let s;
        for (s = 0; s + 2 <= this.data.length; s += 2) {
            let a = e.indexOf(this.data[s]) * 45;
            a += e.indexOf(this.data[s + 1]), i.put(a, 11)
        }
        this.data.length % 2 && i.put(e.indexOf(this.data[s]), 6)
    }, iv = r, iv
}
var sv, WI;

function L_e() {
    if (WI) return sv;
    WI = 1;
    const t = Fd();

    function e(r) {
        this.mode = t.BYTE, typeof r == "string" ? this.data = new TextEncoder().encode(r) : this.data = new Uint8Array(r)
    }
    return e.getBitsLength = function(n) {
        return n * 8
    }, e.prototype.getLength = function() {
        return this.data.length
    }, e.prototype.getBitsLength = function() {
        return e.getBitsLength(this.data.length)
    }, e.prototype.write = function(r) {
        for (let n = 0, i = this.data.length; n < i; n++) r.put(this.data[n], 8)
    }, sv = e, sv
}
var av, zI;

function U_e() {
    if (zI) return av;
    zI = 1;
    const t = Fd(),
        e = Ud();

    function r(n) {
        this.mode = t.KANJI, this.data = n
    }
    return r.getBitsLength = function(i) {
        return i * 13
    }, r.prototype.getLength = function() {
        return this.data.length
    }, r.prototype.getBitsLength = function() {
        return r.getBitsLength(this.data.length)
    }, r.prototype.write = function(n) {
        let i;
        for (i = 0; i < this.data.length; i++) {
            let s = e.toSJIS(this.data[i]);
            if (s >= 33088 && s <= 40956) s -= 33088;
            else if (s >= 57408 && s <= 60351) s -= 49472;
            else throw new Error("Invalid SJIS character: " + this.data[i] + `
Make sure your charset is UTF-8`);
            s = (s >>> 8 & 255) * 192 + (s & 255), n.put(s, 13)
        }
    }, av = r, av
}
var ov = {
        exports: {}
    },
    qI;

function F_e() {
    return qI || (qI = 1, function(t) {
        var e = {
            single_source_shortest_paths: function(r, n, i) {
                var s = {},
                    a = {};
                a[n] = 0;
                var o = e.PriorityQueue.make();
                o.push(n, 0);
                for (var c, l, u, h, f, p, g, m, y; !o.empty();) {
                    c = o.pop(), l = c.value, h = c.cost, f = r[l] || {};
                    for (u in f) f.hasOwnProperty(u) && (p = f[u], g = h + p, m = a[u], y = typeof a[u] > "u", (y || m > g) && (a[u] = g, o.push(u, g), s[u] = l))
                }
                if (typeof i < "u" && typeof a[i] > "u") {
                    var w = ["Could not find a path from ", n, " to ", i, "."].join("");
                    throw new Error(w)
                }
                return s
            },
            extract_shortest_path_from_predecessor_list: function(r, n) {
                for (var i = [], s = n; s;) i.push(s), r[s], s = r[s];
                return i.reverse(), i
            },
            find_path: function(r, n, i) {
                var s = e.single_source_shortest_paths(r, n, i);
                return e.extract_shortest_path_from_predecessor_list(s, i)
            },
            PriorityQueue: {
                make: function(r) {
                    var n = e.PriorityQueue,
                        i = {},
                        s;
                    r = r || {};
                    for (s in n) n.hasOwnProperty(s) && (i[s] = n[s]);
                    return i.queue = [], i.sorter = r.sorter || n.default_sorter, i
                },
                default_sorter: function(r, n) {
                    return r.cost - n.cost
                },
                push: function(r, n) {
                    var i = {
                        value: r,
                        cost: n
                    };
                    this.queue.push(i), this.queue.sort(this.sorter)
                },
                pop: function() {
                    return this.queue.shift()
                },
                empty: function() {
                    return this.queue.length === 0
                }
            }
        };
        t.exports = e
    }(ov)), ov.exports
}
var HI;

function B_e() {
    return HI || (HI = 1, function(t) {
        const e = Fd(),
            r = M_e(),
            n = D_e(),
            i = L_e(),
            s = U_e(),
            a = zL(),
            o = Ud(),
            c = F_e();

        function l(w) {
            return unescape(encodeURIComponent(w)).length
        }

        function u(w, x, E) {
            const _ = [];
            let b;
            for (;
                (b = w.exec(E)) !== null;) _.push({
                data: b[0],
                index: b.index,
                mode: x,
                length: b[0].length
            });
            return _
        }

        function h(w) {
            const x = u(a.NUMERIC, e.NUMERIC, w),
                E = u(a.ALPHANUMERIC, e.ALPHANUMERIC, w);
            let _, b;
            return o.isKanjiModeEnabled() ? (_ = u(a.BYTE, e.BYTE, w), b = u(a.KANJI, e.KANJI, w)) : (_ = u(a.BYTE_KANJI, e.BYTE, w), b = []), x.concat(E, _, b).sort(function(I, T) {
                return I.index - T.index
            }).map(function(I) {
                return {
                    data: I.data,
                    mode: I.mode,
                    length: I.length
                }
            })
        }

        function f(w, x) {
            switch (x) {
                case e.NUMERIC:
                    return r.getBitsLength(w);
                case e.ALPHANUMERIC:
                    return n.getBitsLength(w);
                case e.KANJI:
                    return s.getBitsLength(w);
                case e.BYTE:
                    return i.getBitsLength(w)
            }
        }

        function p(w) {
            return w.reduce(function(x, E) {
                const _ = x.length - 1 >= 0 ? x[x.length - 1] : null;
                return _ && _.mode === E.mode ? (x[x.length - 1].data += E.data, x) : (x.push(E), x)
            }, [])
        }

        function g(w) {
            const x = [];
            for (let E = 0; E < w.length; E++) {
                const _ = w[E];
                switch (_.mode) {
                    case e.NUMERIC:
                        x.push([_, {
                            data: _.data,
                            mode: e.ALPHANUMERIC,
                            length: _.length
                        }, {
                            data: _.data,
                            mode: e.BYTE,
                            length: _.length
                        }]);
                        break;
                    case e.ALPHANUMERIC:
                        x.push([_, {
                            data: _.data,
                            mode: e.BYTE,
                            length: _.length
                        }]);
                        break;
                    case e.KANJI:
                        x.push([_, {
                            data: _.data,
                            mode: e.BYTE,
                            length: l(_.data)
                        }]);
                        break;
                    case e.BYTE:
                        x.push([{
                            data: _.data,
                            mode: e.BYTE,
                            length: l(_.data)
                        }])
                }
            }
            return x
        }

        function m(w, x) {
            const E = {},
                _ = {
                    start: {}
                };
            let b = ["start"];
            for (let A = 0; A < w.length; A++) {
                const I = w[A],
                    T = [];
                for (let C = 0; C < I.length; C++) {
                    const $ = I[C],
                        P = "" + A + C;
                    T.push(P), E[P] = {
                        node: $,
                        lastCount: 0
                    }, _[P] = {};
                    for (let N = 0; N < b.length; N++) {
                        const R = b[N];
                        E[R] && E[R].node.mode === $.mode ? (_[R][P] = f(E[R].lastCount + $.length, $.mode) - f(E[R].lastCount, $.mode), E[R].lastCount += $.length) : (E[R] && (E[R].lastCount = $.length), _[R][P] = f($.length, $.mode) + 4 + e.getCharCountIndicator($.mode, x))
                    }
                }
                b = T
            }
            for (let A = 0; A < b.length; A++) _[b[A]].end = 0;
            return {
                map: _,
                table: E
            }
        }

        function y(w, x) {
            let E;
            const _ = e.getBestModeForData(w);
            if (E = e.from(x, _), E !== e.BYTE && E.bit < _.bit) throw new Error('"' + w + '" cannot be encoded with mode ' + e.toString(E) + `.
 Suggested mode is: ` + e.toString(_));
            switch (E === e.KANJI && !o.isKanjiModeEnabled() && (E = e.BYTE), E) {
                case e.NUMERIC:
                    return new r(w);
                case e.ALPHANUMERIC:
                    return new n(w);
                case e.KANJI:
                    return new s(w);
                case e.BYTE:
                    return new i(w)
            }
        }
        t.fromArray = function(x) {
            return x.reduce(function(E, _) {
                return typeof _ == "string" ? E.push(y(_, null)) : _.data && E.push(y(_.data, _.mode)), E
            }, [])
        }, t.fromString = function(x, E) {
            const _ = h(x, o.isKanjiModeEnabled()),
                b = g(_),
                A = m(b, E),
                I = c.find_path(A.map, "start", "end"),
                T = [];
            for (let C = 1; C < I.length - 1; C++) T.push(A.table[I[C]].node);
            return t.fromArray(p(T))
        }, t.rawSplit = function(x) {
            return t.fromArray(h(x, o.isKanjiModeEnabled()))
        }
    }(rv)), rv
}
var VI;

function W_e() {
    if (VI) return zb;
    VI = 1;
    const t = Ud(),
        e = a8(),
        r = k_e(),
        n = I_e(),
        i = $_e(),
        s = S_e(),
        a = T_e(),
        o = BL(),
        c = O_e(),
        l = j_e(),
        u = R_e(),
        h = Fd(),
        f = B_e();

    function p(A, I) {
        const T = A.size,
            C = s.getPositions(I);
        for (let $ = 0; $ < C.length; $++) {
            const P = C[$][0],
                N = C[$][1];
            for (let R = -1; R <= 7; R++)
                if (!(P + R <= -1 || T <= P + R))
                    for (let D = -1; D <= 7; D++) N + D <= -1 || T <= N + D || (R >= 0 && R <= 6 && (D === 0 || D === 6) || D >= 0 && D <= 6 && (R === 0 || R === 6) || R >= 2 && R <= 4 && D >= 2 && D <= 4 ? A.set(P + R, N + D, !0, !0) : A.set(P + R, N + D, !1, !0))
        }
    }

    function g(A) {
        const I = A.size;
        for (let T = 8; T < I - 8; T++) {
            const C = T % 2 === 0;
            A.set(T, 6, C, !0), A.set(6, T, C, !0)
        }
    }

    function m(A, I) {
        const T = i.getPositions(I);
        for (let C = 0; C < T.length; C++) {
            const $ = T[C][0],
                P = T[C][1];
            for (let N = -2; N <= 2; N++)
                for (let R = -2; R <= 2; R++) N === -2 || N === 2 || R === -2 || R === 2 || N === 0 && R === 0 ? A.set($ + N, P + R, !0, !0) : A.set($ + N, P + R, !1, !0)
        }
    }

    function y(A, I) {
        const T = A.size,
            C = l.getEncodedBits(I);
        let $, P, N;
        for (let R = 0; R < 18; R++) $ = Math.floor(R / 3), P = R % 3 + T - 8 - 3, N = (C >> R & 1) === 1, A.set($, P, N, !0), A.set(P, $, N, !0)
    }

    function w(A, I, T) {
        const C = A.size,
            $ = u.getEncodedBits(I, T);
        let P, N;
        for (P = 0; P < 15; P++) N = ($ >> P & 1) === 1, P < 6 ? A.set(P, 8, N, !0) : P < 8 ? A.set(P + 1, 8, N, !0) : A.set(C - 15 + P, 8, N, !0), P < 8 ? A.set(8, C - P - 1, N, !0) : P < 9 ? A.set(8, 15 - P - 1 + 1, N, !0) : A.set(8, 15 - P - 1, N, !0);
        A.set(C - 8, 8, 1, !0)
    }

    function x(A, I) {
        const T = A.size;
        let C = -1,
            $ = T - 1,
            P = 7,
            N = 0;
        for (let R = T - 1; R > 0; R -= 2)
            for (R === 6 && R--;;) {
                for (let D = 0; D < 2; D++)
                    if (!A.isReserved($, R - D)) {
                        let S = !1;
                        N < I.length && (S = (I[N] >>> P & 1) === 1), A.set($, R - D, S), P--, P === -1 && (N++, P = 7)
                    }
                if ($ += C, $ < 0 || T <= $) {
                    $ -= C, C = -C;
                    break
                }
            }
    }

    function E(A, I, T) {
        const C = new r;
        T.forEach(function(D) {
            C.put(D.mode.bit, 4), C.put(D.getLength(), h.getCharCountIndicator(D.mode, A)), D.write(C)
        });
        const $ = t.getSymbolTotalCodewords(A),
            P = o.getTotalCodewordsCount(A, I),
            N = ($ - P) * 8;
        for (C.getLengthInBits() + 4 <= N && C.put(0, 4); C.getLengthInBits() % 8 !== 0;) C.putBit(0);
        const R = (N - C.getLengthInBits()) / 8;
        for (let D = 0; D < R; D++) C.put(D % 2 ? 17 : 236, 8);
        return _(C, A, I)
    }

    function _(A, I, T) {
        const C = t.getSymbolTotalCodewords(I),
            $ = o.getTotalCodewordsCount(I, T),
            P = C - $,
            N = o.getBlocksCount(I, T),
            R = C % N,
            D = N - R,
            S = Math.floor(C / N),
            O = Math.floor(P / N),
            M = O + 1,
            U = S - O,
            k = new c(U);
        let F = 0;
        const q = new Array(N),
            W = new Array(N);
        let K = 0;
        const H = new Uint8Array(A.buffer);
        for (let ne = 0; ne < N; ne++) {
            const ae = ne < D ? O : M;
            q[ne] = H.slice(F, F + ae), W[ne] = k.encode(q[ne]), F += ae, K = Math.max(K, ae)
        }
        const j = new Uint8Array(C);
        let V = 0,
            Y, X;
        for (Y = 0; Y < K; Y++)
            for (X = 0; X < N; X++) Y < q[X].length && (j[V++] = q[X][Y]);
        for (Y = 0; Y < U; Y++)
            for (X = 0; X < N; X++) j[V++] = W[X][Y];
        return j
    }

    function b(A, I, T, C) {
        let $;
        if (Array.isArray(A)) $ = f.fromArray(A);
        else if (typeof A == "string") {
            let S = I;
            if (!S) {
                const O = f.rawSplit(A);
                S = l.getBestVersionForData(O, T)
            }
            $ = f.fromString(A, S || 40)
        } else throw new Error("Invalid data");
        const P = l.getBestVersionForData($, T);
        if (!P) throw new Error("The amount of data is too big to be stored in a QR Code");
        if (!I) I = P;
        else if (I < P) throw new Error(`
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + P + `.
`);
        const N = E(I, T, $),
            R = t.getSymbolSize(I),
            D = new n(R);
        return p(D, I), g(D), m(D, I), w(D, T, 0), I >= 7 && y(D, I), x(D, N), isNaN(C) && (C = a.getBestMask(D, w.bind(null, D, T))), a.applyMask(C, D), w(D, T, C), {
            modules: D,
            version: I,
            errorCorrectionLevel: T,
            maskPattern: C,
            segments: $
        }
    }
    return zb.create = function(I, T) {
        if (typeof I > "u" || I === "") throw new Error("No input text");
        let C = e.M,
            $, P;
        return typeof T < "u" && (C = e.from(T.errorCorrectionLevel, e.M), $ = l.from(T.version), P = a.from(T.maskPattern), T.toSJISFunc && t.setToSJISFunction(T.toSJISFunc)), b(I, $, C, P)
    }, zb
}
var cv = {},
    lv = {},
    GI;

function qL() {
    return GI || (GI = 1, function(t) {
        function e(r) {
            if (typeof r == "number" && (r = r.toString()), typeof r != "string") throw new Error("Color should be defined as hex string");
            let n = r.slice().replace("#", "").split("");
            if (n.length < 3 || n.length === 5 || n.length > 8) throw new Error("Invalid hex color: " + r);
            (n.length === 3 || n.length === 4) && (n = Array.prototype.concat.apply([], n.map(function(s) {
                return [s, s]
            }))), n.length === 6 && n.push("F", "F");
            const i = parseInt(n.join(""), 16);
            return {
                r: i >> 24 & 255,
                g: i >> 16 & 255,
                b: i >> 8 & 255,
                a: i & 255,
                hex: "#" + n.slice(0, 6).join("")
            }
        }
        t.getOptions = function(n) {
            n || (n = {}), n.color || (n.color = {});
            const i = typeof n.margin > "u" || n.margin === null || n.margin < 0 ? 4 : n.margin,
                s = n.width && n.width >= 21 ? n.width : void 0,
                a = n.scale || 4;
            return {
                width: s,
                scale: s ? 4 : a,
                margin: i,
                color: {
                    dark: e(n.color.dark || "#000000ff"),
                    light: e(n.color.light || "#ffffffff")
                },
                type: n.type,
                rendererOpts: n.rendererOpts || {}
            }
        }, t.getScale = function(n, i) {
            return i.width && i.width >= n + i.margin * 2 ? i.width / (n + i.margin * 2) : i.scale
        }, t.getImageWidth = function(n, i) {
            const s = t.getScale(n, i);
            return Math.floor((n + i.margin * 2) * s)
        }, t.qrToImageData = function(n, i, s) {
            const a = i.modules.size,
                o = i.modules.data,
                c = t.getScale(a, s),
                l = Math.floor((a + s.margin * 2) * c),
                u = s.margin * c,
                h = [s.color.light, s.color.dark];
            for (let f = 0; f < l; f++)
                for (let p = 0; p < l; p++) {
                    let g = (f * l + p) * 4,
                        m = s.color.light;
                    if (f >= u && p >= u && f < l - u && p < l - u) {
                        const y = Math.floor((f - u) / c),
                            w = Math.floor((p - u) / c);
                        m = h[o[y * a + w] ? 1 : 0]
                    }
                    n[g++] = m.r, n[g++] = m.g, n[g++] = m.b, n[g] = m.a
                }
        }
    }(lv)), lv
}
var KI;

function z_e() {
    return KI || (KI = 1, function(t) {
        const e = qL();

        function r(i, s, a) {
            i.clearRect(0, 0, s.width, s.height), s.style || (s.style = {}), s.height = a, s.width = a, s.style.height = a + "px", s.style.width = a + "px"
        }

        function n() {
            try {
                return document.createElement("canvas")
            } catch {
                throw new Error("You need to specify a canvas element")
            }
        }
        t.render = function(s, a, o) {
            let c = o,
                l = a;
            typeof c > "u" && (!a || !a.getContext) && (c = a, a = void 0), a || (l = n()), c = e.getOptions(c);
            const u = e.getImageWidth(s.modules.size, c),
                h = l.getContext("2d"),
                f = h.createImageData(u, u);
            return e.qrToImageData(f.data, s, c), r(h, l, u), h.putImageData(f, 0, 0), l
        }, t.renderToDataURL = function(s, a, o) {
            let c = o;
            typeof c > "u" && (!a || !a.getContext) && (c = a, a = void 0), c || (c = {});
            const l = t.render(s, a, c),
                u = c.type || "image/png",
                h = c.rendererOpts || {};
            return l.toDataURL(u, h.quality)
        }
    }(cv)), cv
}
var dv = {},
    YI;

function q_e() {
    if (YI) return dv;
    YI = 1;
    const t = qL();

    function e(i, s) {
        const a = i.a / 255,
            o = s + '="' + i.hex + '"';
        return a < 1 ? o + " " + s + '-opacity="' + a.toFixed(2).slice(1) + '"' : o
    }

    function r(i, s, a) {
        let o = i + s;
        return typeof a < "u" && (o += " " + a), o
    }

    function n(i, s, a) {
        let o = "",
            c = 0,
            l = !1,
            u = 0;
        for (let h = 0; h < i.length; h++) {
            const f = Math.floor(h % s),
                p = Math.floor(h / s);
            !f && !l && (l = !0), i[h] ? (u++, h > 0 && f > 0 && i[h - 1] || (o += l ? r("M", f + a, .5 + p + a) : r("m", c, 0), c = 0, l = !1), f + 1 < s && i[h + 1] || (o += r("h", u), u = 0)) : c++
        }
        return o
    }
    return dv.render = function(s, a, o) {
        const c = t.getOptions(a),
            l = s.modules.size,
            u = s.modules.data,
            h = l + c.margin * 2,
            f = c.color.light.a ? "<path " + e(c.color.light, "fill") + ' d="M0 0h' + h + "v" + h + 'H0z"/>' : "",
            p = "<path " + e(c.color.dark, "stroke") + ' d="' + n(u, l, c.margin) + '"/>',
            g = 'viewBox="0 0 ' + h + " " + h + '"',
            y = '<svg xmlns="http://www.w3.org/2000/svg" ' + (c.width ? 'width="' + c.width + '" height="' + c.width + '" ' : "") + g + ' shape-rendering="crispEdges">' + f + p + `</svg>
`;
        return typeof o == "function" && o(null, y), y
    }, dv
}
var ZI;

function H_e() {
    if (ZI) return bu;
    ZI = 1;
    const t = A_e(),
        e = W_e(),
        r = z_e(),
        n = q_e();

    function i(s, a, o, c, l) {
        const u = [].slice.call(arguments, 1),
            h = u.length,
            f = typeof u[h - 1] == "function";
        if (!f && !t()) throw new Error("Callback required as last argument");
        if (f) {
            if (h < 2) throw new Error("Too few arguments provided");
            h === 2 ? (l = o, o = a, a = c = void 0) : h === 3 && (a.getContext && typeof l > "u" ? (l = c, c = void 0) : (l = c, c = o, o = a, a = void 0))
        } else {
            if (h < 1) throw new Error("Too few arguments provided");
            return h === 1 ? (o = a, a = c = void 0) : h === 2 && !a.getContext && (c = o, o = a, a = void 0), new Promise(function(p, g) {
                try {
                    const m = e.create(o, c);
                    p(s(m, a, c))
                } catch (m) {
                    g(m)
                }
            })
        }
        try {
            const p = e.create(o, c);
            l(null, s(p, a, c))
        } catch (p) {
            l(p)
        }
    }
    return bu.create = e.create, bu.toCanvas = i.bind(null, r.render), bu.toDataURL = i.bind(null, r.renderToDataURL), bu.toString = i.bind(null, function(s, a, o) {
        return n.render(s, o)
    }), bu
}
var V_e = H_e();
const G_e = Oa(V_e);

function K_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        fillRule: "evenodd",
        d: "M15.97 2.47a.75.75 0 0 1 1.06 0l4.5 4.5a.75.75 0 0 1 0 1.06l-4.5 4.5a.75.75 0 1 1-1.06-1.06l3.22-3.22H7.5a.75.75 0 0 1 0-1.5h11.69l-3.22-3.22a.75.75 0 0 1 0-1.06Zm-7.94 9a.75.75 0 0 1 0 1.06l-3.22 3.22H16.5a.75.75 0 0 1 0 1.5H4.81l3.22 3.22a.75.75 0 1 1-1.06 1.06l-4.5-4.5a.75.75 0 0 1 0-1.06l4.5-4.5a.75.75 0 0 1 1.06 0Z",
        clipRule: "evenodd"
    }))
}
const qy = v.forwardRef(K_e);

function Y_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        fillRule: "evenodd",
        d: "M12 1.5a5.25 5.25 0 0 0-5.25 5.25v3a3 3 0 0 0-3 3v6.75a3 3 0 0 0 3 3h10.5a3 3 0 0 0 3-3v-6.75a3 3 0 0 0-3-3v-3c0-2.9-2.35-5.25-5.25-5.25Zm3.75 8.25v-3a3.75 3.75 0 1 0-7.5 0v3h7.5Z",
        clipRule: "evenodd"
    }))
}
const HL = v.forwardRef(Y_e);

function Z_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        fillRule: "evenodd",
        d: "M8.603 3.799A4.49 4.49 0 0 1 12 2.25c1.357 0 2.573.6 3.397 1.549a4.49 4.49 0 0 1 3.498 1.307 4.491 4.491 0 0 1 1.307 3.497A4.49 4.49 0 0 1 21.75 12a4.49 4.49 0 0 1-1.549 3.397 4.491 4.491 0 0 1-1.307 3.497 4.491 4.491 0 0 1-3.497 1.307A4.49 4.49 0 0 1 12 21.75a4.49 4.49 0 0 1-3.397-1.549 4.49 4.49 0 0 1-3.498-1.306 4.491 4.491 0 0 1-1.307-3.498A4.49 4.49 0 0 1 2.25 12c0-1.357.6-2.573 1.549-3.397a4.49 4.49 0 0 1 1.307-3.497 4.49 4.49 0 0 1 3.497-1.307Zm7.007 6.387a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z",
        clipRule: "evenodd"
    }))
}
const VL = v.forwardRef(Z_e);

function J_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        fillRule: "evenodd",
        d: "M4.5 3.75a3 3 0 0 0-3 3v10.5a3 3 0 0 0 3 3h15a3 3 0 0 0 3-3V6.75a3 3 0 0 0-3-3h-15Zm4.125 3a2.25 2.25 0 1 0 0 4.5 2.25 2.25 0 0 0 0-4.5Zm-3.873 8.703a4.126 4.126 0 0 1 7.746 0 .75.75 0 0 1-.351.92 7.47 7.47 0 0 1-3.522.877 7.47 7.47 0 0 1-3.522-.877.75.75 0 0 1-.351-.92ZM15 8.25a.75.75 0 0 0 0 1.5h3.75a.75.75 0 0 0 0-1.5H15ZM14.25 12a.75.75 0 0 1 .75-.75h3.75a.75.75 0 0 1 0 1.5H15a.75.75 0 0 1-.75-.75Zm.75 2.25a.75.75 0 0 0 0 1.5h3.75a.75.75 0 0 0 0-1.5H15Z",
        clipRule: "evenodd"
    }))
}
const Q_e = v.forwardRef(J_e);

function X_e({
    title: t,
    titleId: e,
    ...r
}, n) {
    return v.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: n,
        "aria-labelledby": e
    }, r), t ? v.createElement("title", {
        id: e
    }, t) : null, v.createElement("path", {
        fillRule: "evenodd",
        d: "M12.516 2.17a.75.75 0 0 0-1.032 0 11.209 11.209 0 0 1-7.877 3.08.75.75 0 0 0-.722.515A12.74 12.74 0 0 0 2.25 9.75c0 5.942 4.064 10.933 9.563 12.348a.749.749 0 0 0 .374 0c5.499-1.415 9.563-6.406 9.563-12.348 0-1.39-.223-2.73-.635-3.985a.75.75 0 0 0-.722-.516l-.143.001c-2.996 0-5.717-1.17-7.734-3.08Zm3.094 8.016a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z",
        clipRule: "evenodd"
    }))
}
const e9e = v.forwardRef(X_e);

function Wp(t) {
    return t ? {
        "privy-ui": "t"
    } : void 0
}
class Pu {
    async authenticate() {
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!this.meta.email || !this.meta.emailCode) throw new J("Email and email code must be set prior to calling authenticate.");
        try {
            return await this.api.post(Eie, {
                email: this.meta.email,
                code: this.meta.emailCode,
                mode: this.meta.disableSignup ? "no-signup" : "login-or-sign-up"
            })
        } catch (e) {
            throw qt(e)
        }
    }
    async link() {
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!this.meta.email || !this.meta.emailCode) throw new J("Email and email code must be set prior to calling authenticate.");
        try {
            return await this.api.post(_ie, {
                email: this.meta.email,
                code: this.meta.emailCode
            })
        } catch (e) {
            throw qt(e)
        }
    }
    async sendCodeEmail({
        email: e,
        captchaToken: r,
        withPrivyUi: n
    }) {
        if (!this.api) throw new J("Auth flow has no API instance");
        if (e && (this.meta.email = e), r && (this.meta.captchaToken = r), !this.meta.email) throw new J("Email must be set when initialzing authentication.");
        let i = Wp(n);
        try {
            return await this.api.post(xie, {
                email: this.meta.email,
                token: this.meta.captchaToken
            }, {
                headers: { ...i
                }
            })
        } catch (s) {
            throw qt(s)
        }
    }
    constructor({
        email: e,
        captchaToken: r,
        disableSignup: n
    }) {
        this.meta = {
            email: e,
            captchaToken: r,
            disableSignup: n ? ? !1
        }
    }
}
class t9e extends Pu {
    async link() {
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!this.meta.email || !this.meta.emailCode || !this.meta.oldAddress) throw new J("Email, email code, and an old email address must be set prior to calling update.");
        try {
            return await this.api.post(Aie, {
                oldAddress: this.meta.oldAddress,
                newAddress: this.meta.email,
                code: this.meta.emailCode
            })
        } catch (e) {
            throw qt(e)
        }
    }
    constructor(e, r, n) {
        super({
            email: r,
            captchaToken: n
        }), this.meta = {
            email: r,
            captchaToken: n,
            oldAddress: e,
            disableSignup: !1
        }
    }
}
class GL {
    get(e) {
        let r = localStorage.getItem(e);
        return r === null ? void 0 : JSON.parse(r)
    }
    put(e, r) {
        r !== void 0 ? localStorage.setItem(e, JSON.stringify(r)) : this.del(e)
    }
    del(e) {
        localStorage.removeItem(e)
    }
    getKeys() {
        return Object.entries(localStorage).map(([e]) => e)
    }
}

function l4() {
    try {
        let t = "privy:__session_storage__test",
            e = new GL;
        return e.put(t, "blobby"), e.del(t), !0
    } catch {
        return !1
    }
}
var rt = typeof window < "u" && window.localStorage ? new GL : new class {
    get(t) {
        return this._cache[t]
    }
    put(t, e) {
        e !== void 0 ? this._cache[t] = e : this.del(t)
    }
    del(t) {
        delete this._cache[t]
    }
    getKeys() {
        return Object.keys(this._cache)
    }
    constructor() {
        this._cache = {}
    }
};
const r9e = ["c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96", "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0", "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f", "1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369", "c03dfee351b6fcc421b4494ea33b9d4b92a984f87aa76d1663bb28705e95034a", "ecc4036f814562b41a5268adc86270fba1365471402006302e70169465b7ac18", "bc949c5d968ae81310268bf9193f9c9fb7bb4e1283e1284af8f2bd4992535fd6", "74f8092562bd79675e276d8b2062a83601a4106d30202f2d509195e30e19673d", "afbd95522f4041c71dd4f1a065f971fd32372865b416f95a0b1db759ae33f2a7", "f2436c67184f158d1beda5df53298ee84abfc367581e4505134b5bcf5f46697d", "84b43e8ddfcd18e5fcb5d21e7277733f9cccef76f7d92c836d0e481db0c70c04", "0b415a746fb9ee99cce155c2ceca0c6f6061b1dbca2d722b3ba16381d0562150", "38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662", "9414d5a85c8f4eabc1b5b15ebe0cd399e1a2a9d35643ab0ad22a6e4a32f596f0", "c286eebc742a537cd1d6818363e9dc53b21759a1e8e5d9b263d0c03ec7703576", "8a0ee50d1f22f6651afcae7eb4253e52a3310b90af5daef78a8c4929a9bb99d4", "e9ff15be73584489ca4a66f64d32c4537711797e30b6660dbcb71ea72a42b1f4", "f5b4eeb6015d66be3f5940a895cbaa49ef3439e518cd771270e6b553b48f31d2", "138f51c8d00ac7b9ac9d8dc75344d096a7dfe370a568aa167eabc0a21830ed98", "47bb07617af518642f3413a201ec5859faa63acb1dd175ca95085d35d38afb83", "7674bb4e353bf52886768a3ddc2a4562ce2f4191c80831291218ebd90f5f5e26", "8308656f4548bb81b3508afe355cfbb7f0cb6253d1cc7f998080601f838ecee3", "031f0187049b7f96c6f039d1c9c8138ff7a17fd75d38b34350c7182232cc29aa", "2c81da3add65899baeac53758a07e652eea46dbb5195b8074772c62a77bbf568", "dd43441a6368ec9046540c46c5fdc58f79926d17ce61a176444568ca7c970dcd", "2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01", "b956da9052132e3dabdcd78feb596d5194c99b7345d8c4bd7a47cabdcb69a25f", "0e4915107da5b3408b38e248f7a710f4529d54cd30e9d12ff0eb886d45c18e92", "719bd888109f5e8dd23419b20e749900ce4d2fc6858cf588395f19c82fd036b3", "942d0e22a7e6b520b0a03abcafc4dbe156a1fc151876e3c4a842f914277278ef", "8ff6eccefefa7506339201bc33346f92a43118d6ff7d6e71d499d8187a1c56a2", "07f99a5d9849bb049d74830012b286f8b238e72b0337933ef22b84947409db80", "8821748c25de9dbc4f72a691b25a6ddad9d7df12fa23333fd9c8b5fdc14cc819", "bdc9433ffdaee55d31737d83b931caa1f17e30666f5b8e03eea794bac960eb4a", "cbe13eb482c76f1fa401ff4c84d9acd0b8bc9af311ca0620a0b192fb28359b4e", "94f785c0c8fb8c4f38cd9cd704416430bcaa2137f27e1468782d624bcd155a43", "2cca8c1b0bea04ba37dee4017991d348cdb7b826804ab2bd31073254f345b715", "14e5d957c6eb62d3ee8fc6239703ac2d537d7e3552154836ca0beef775f630bc", "576c90ceaea34f29ff0104837cf2b2e23d201be43be1433feeb18d375430e1fd", "49bb9d698dbdf2c3d4627d66f99dd9fe90bba1eec84b143f56c64a51473c60bd", "19418ecfd44963883e4d6abca1adeb2036f3b5ffb9bee0ec61f267a9641f878b", "5b8e33346dfb2a532748c247876db8d596734da8977905a27b947ba1e2cf465b", "d23de318f0f56038c5edb730a083216ff0cce00c1514e619ab32231cc9ec484b", "50df7da345f84e5a79aaf617df5167335a4b6751626df2e8a38f07029b3dde7b", "9751385960bca290c13b443155288f892f62ee920337eda8c5a8874135daaea8", "6464873279d46030c0b6b005b33da6be5ed57a752be3ef1f857dc10eaf8028aa", "41f20106359ff63cf732adf1f7dc1a157176c9b02fd266b50da6dcc1e9b86071", "14e7176536cb3706e221daaa3cfd7b88b7da8c7dfb64d1d241044164802c6bdd", "a0e04f1086aac204d4ebdd5f985c12ed226cd0006323fd8143715f9324da58d1", "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709", "18388be9ac2d02726dbac9777c96efaac06d744b2f6d580fccdd4127a6d01fd1", "15c8b91ade1a4e58f3ce4e7a0dd7f42b47db0c8df7e0d84f63eb39bcb96c4e0f", "541d5dcd4ede02f3afaf75bf8e3e4c4f1fb09edb5fa6c4377ebf31c2785d9adf"];

function JI(t) {
    var e;
    return {
        name: ((e = t.metadata) == null ? void 0 : e.shortName) || t.name || "",
        universalLink: t.mobile.universal,
        deepLink: t.mobile.native
    }
}
let QI = "WALLETCONNECT_DEEPLINK_CHOICE";

function KL(t) {
    return t.startsWith("http://") || t.startsWith("https://")
}

function YL(t, e) {
    if (KL(t)) return d4(t, e);
    let r = t;
    return r.includes("://") || (r = t.replaceAll("/", "").replaceAll(":", ""), r = `${r}://`), r.endsWith("/") || (r = `${r}/`), {
        redirect: `${r}wc?uri=${encodeURIComponent(e)}`,
        href: r
    }
}

function d4(t, e) {
    if (!KL(t)) return YL(t, e);
    let r = t;
    return r.endsWith("/") || (r = `${r}/`), {
        redirect: `${r}wc?uri=${encodeURIComponent(e)}`,
        href: r
    }
}

function ZL(t, e) {
    window.open(t, e, "noreferrer noopener")
}
class di {
    execute(e) {
        return this.promise === null && (this.promise = (async () => {
            try {
                return await this.fn(e)
            } finally {
                this.promise = null
            }
        })()), this.promise
    }
    constructor(e) {
        this.promise = null, this.fn = e
    }
}
class XI {
    get meta() {
        return this._meta
    }
    async authenticate() {
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!this.meta.channelToken) throw new J("Auth flow must be initialized first");
        try {
            let e = await this.api.post(mie, {
                channel_token: this.meta.channelToken,
                message: this.message,
                signature: this.signature,
                fid: this.fid,
                mode: this.meta.disableSignup ? "no-signup" : "login-or-sign-up"
            });
            if (!e) throw new J("No response from authentication");
            return e
        } catch (e) {
            throw qt(e)
        }
    }
    async link() {
        if (!this.api) throw new J("Auth flow has no API instance");
        try {
            return await this.api.post(yie, {
                channel_token: this.meta.channelToken,
                message: this.message,
                signature: this.signature,
                fid: this.fid
            })
        } catch (e) {
            throw qt(e)
        }
    }
    async _startChannelOnce() {
        if (!this.api) throw new J("Auth flow has no API instance");
        let e = await this.api.post(gie, {
            token: this.captchaToken
        });
        gr.isMobile && !gr.isIOS && e.connect_uri && ZL(e.connect_uri, "_blank"), this._meta = { ...this._meta,
            connectUri: e.connect_uri,
            channelToken: e.channel_token
        }
    }
    async initializeFarcasterConnect() {
        if (!this.api) throw new J("Auth flow has no API instance");
        await this.startChannelOnce.execute()
    }
    async _pollForReady() {
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!this.meta.channelToken) throw new J("Auth flow must be initialized first");
        let e = await this.api.get(wie, {
            headers: {
                "farcaster-channel-token": this.meta.channelToken
            }
        });
        return e.state === "completed" && (this.message = e.message, this.signature = e.signature, this.fid = e.fid, !0)
    }
    constructor(e, r = !1) {
        this._meta = {
            disableSignup: !1
        }, this.captchaToken = e, this.startChannelOnce = new di(this._startChannelOnce.bind(this)), this.pollForReady = new di(this._pollForReady.bind(this)), this._meta.disableSignup = r
    }
}
const u4 = "https://auth.privy.io",
    Ir = 1400,
    o8 = 2500,
    Hy = 4e3,
    n9e = "2.21.0",
    Nu = "privy:token",
    e$ = "privy-token",
    uv = "privy:refresh_token",
    sm = "privy:pat",
    t$ = "privy:id_token",
    r$ = "privy-id-token",
    hv = "privy-session",
    h4 = "privy:caid",
    JL = t => `privy:guest:${t}`,
    Pg = t => `privy:cross-app:${t}`,
    a1 = "privy:state_code",
    uf = "privy:code_verifier",
    o1 = "privy:headless_oauth",
    Jf = "privy:oauth_disable_signup",
    fv = t => `privy:wallet:${t}`,
    n$ = "privy:connectors",
    QL = "privy:connections",
    Vy = 12e4,
    XL = 3e4,
    i9e = "https://api.moonpay.com/v1",
    s9e = "https://api.moonpay.com/v1",
    a9e = "pk_live_hirbpu0cVcLHrjktC9l7fbc9ctjv0SL",
    o9e = "pk_test_fqWjXZMSFwloh7orvJsRfjiUHXJqFzI";

function f4(t) {
    return crypto.getRandomValues(new Uint8Array(t))
}

function Gy() {
    return dd(f4(36))
}

function c8() {
    return Gy()
}
async function l8(t, e = "S256") {
    if (e != "S256") return t; {
        let r = await async function(n) {
            let i = new TextEncoder().encode(n);
            return new Uint8Array(await crypto.subtle.digest("SHA-256", i))
        }(t);
        return dd(r)
    }
}
class Au {
    addCaptchaToken(e) {
        this.meta.captchaToken = e
    }
    isActive() {
        return !!(this.meta.authorizationCode && this.meta.stateCode && this.meta.provider)
    }
    async authenticate() {
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!this.meta.authorizationCode || !this.meta.stateCode) throw new J("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenticate.");
        if (this.meta.authorizationCode === "undefined") throw new J("User denied confirmation during OAuth flow");
        let e = function() {
            let r = rt.get(uf);
            if (!r) throw new J("Authentication error.");
            return r
        }();
        try {
            let r = await this.api.post(oO, {
                authorization_code: this.meta.authorizationCode,
                state_code: this.meta.stateCode,
                code_verifier: e,
                mode: this.meta.disableSignup ? "no-signup" : "login-or-sign-up"
            });
            return rt.del(uf), rt.del(o1), rt.del(Jf), r
        } catch (r) {
            let n = qt(r);
            throw n.privyErrorCode ? new J(n.message || "Invalid code during OAuth flow.", void 0, n.privyErrorCode) : n.message === "User denied confirmation during OAuth flow" ? new J("Invalid code during oauth flow.", void 0, ee.OAUTH_USER_DENIED) : new J("Invalid code during OAuth flow.", void 0, ee.UNKNOWN_AUTH_ERROR)
        }
    }
    async link() {
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!this.meta.authorizationCode || !this.meta.stateCode) throw new J("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling link.");
        if (this.meta.authorizationCode === "undefined") throw new J("User denied confirmation during OAuth flow");
        let e = rt.get(uf);
        if (!e) throw new J("Authentication error.");
        try {
            let r = await this.api.post(cO, {
                authorization_code: this.meta.authorizationCode,
                state_code: this.meta.stateCode,
                code_verifier: e
            });
            return rt.del(uf), r
        } catch (r) {
            throw qt(r)
        }
    }
    async getAuthorizationUrl() {
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!this.meta.provider) throw new J("Provider must be set when initializing OAuth authentication.");
        let e = Gy();
        rt.put(uf, e);
        let r = c8();
        rt.put(a1, r);
        let n = await l8(e);
        this.meta.withPrivyUi || rt.put(o1, !0), this.meta.disableSignup ? rt.put(Jf, !0) : rt.del(Jf);
        let i = Wp(this.meta.withPrivyUi);
        try {
            return await this.api.post(aO, {
                provider: this.meta.provider,
                redirect_to: window.location.href,
                token: this.meta.captchaToken,
                code_challenge: n,
                state_code: r
            }, {
                headers: { ...i
                }
            })
        } catch (s) {
            throw qt(s)
        }
    }
    constructor(e) {
        this.meta = e
    }
}

function eU(t) {
    return t.charAt(0).toUpperCase() + t.slice(1)
}
const tU = ({
        style: t,
        ...e
    }) => d.jsxs("svg", {
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg",
        x: "0px",
        y: "0px",
        viewBox: "0 0 24 24",
        style: {
            height: "24px",
            ...t
        },
        ...e,
        children: [d.jsx("path", {
            d: "M17.0722 11.6888C17.0471 8.90571 19.3263 7.56847 19.429 7.50274C18.1466 5.60938 16.153 5.35154 15.4417 5.3212C13.7461 5.14678 12.1306 6.32982 11.269 6.32982C10.4074 6.32982 9.08004 5.34648 7.67246 5.37429C5.82158 5.40209 4.11595 6.45874 3.16171 8.13218C1.24068 11.4942 2.6708 16.4817 4.54423 19.2143C5.46091 20.549 6.55041 22.0531 7.98554 21.9975C9.36803 21.9419 9.88905 21.095 11.5571 21.095C13.2251 21.095 13.696 21.9975 15.1537 21.9697C16.6389 21.9393 17.5806 20.6046 18.4897 19.2648C19.5392 17.7153 19.9725 16.2137 19.9975 16.1354C19.965 16.1228 17.1022 15.0155 17.0722 11.6888Z",
            fill: "currentColor"
        }), d.jsx("path", {
            d: "M14.3295 3.51373C15.0909 2.58347 15.6043 1.28921 15.4641 0C14.3671 0.0455014 13.0396 0.738135 12.2532 1.66838C11.5494 2.48994 10.9307 3.80695 11.0986 5.07089C12.3183 5.16694 13.5681 4.44145 14.3295 3.51373Z",
            fill: "currentColor"
        })]
    }),
    rU = ({
        style: t,
        ...e
    }) => d.jsxs("svg", {
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg",
        x: "0px",
        y: "0px",
        viewBox: "0 0 71 55",
        style: {
            height: "24px",
            ...t
        },
        ...e,
        children: [d.jsx("g", {
            clipPath: "url(#clip0)",
            children: d.jsx("path", {
                d: "M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z",
                fill: "#5865F2"
            })
        }), d.jsx("defs", {
            children: d.jsx("clipPath", {
                id: "clip0",
                children: d.jsx("rect", {
                    width: "71",
                    height: "55",
                    fill: "white"
                })
            })
        })]
    }),
    nU = ({
        style: t,
        ...e
    }) => d.jsx("svg", {
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg",
        x: "24",
        y: "24",
        viewBox: "0 0 98 96",
        style: {
            height: "24px",
            ...t
        },
        ...e,
        children: d.jsx("path", {
            d: "M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z",
            fill: "currentColor"
        })
    }),
    c9e = ({
        style: t
    }) => d.jsx(UL, {
        style: {
            color: "var(--privy-color-error)",
            ...t
        }
    }),
    iU = ({
        style: t,
        ...e
    }) => d.jsxs("svg", {
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: {
            height: "26px",
            width: "26px",
            ...t
        },
        ...e,
        children: [d.jsx("path", {
            d: "M22.56 12.25C22.56 11.47 22.49 10.72 22.36 10H12V14.255H17.92C17.665 15.63 16.89 16.795 15.725 17.575V20.335H19.28C21.36 18.42 22.56 15.6 22.56 12.25Z",
            fill: "#4285F4"
        }), d.jsx("path", {
            d: "M12 23C14.97 23 17.46 22.015 19.28 20.335L15.725 17.575C14.74 18.235 13.48 18.625 12 18.625C9.13504 18.625 6.71004 16.69 5.84504 14.09H2.17004V16.94C3.98004 20.535 7.70004 23 12 23Z",
            fill: "#34A853"
        }), d.jsx("path", {
            d: "M5.845 14.09C5.625 13.43 5.5 12.725 5.5 12C5.5 11.275 5.625 10.57 5.845 9.91V7.06H2.17C1.4 8.59286 0.999321 10.2846 1 12C1 13.775 1.425 15.455 2.17 16.94L5.845 14.09Z",
            fill: "#FBBC05"
        }), d.jsx("path", {
            d: "M12 5.375C13.615 5.375 15.065 5.93 16.205 7.02L19.36 3.865C17.455 2.09 14.965 1 12 1C7.70004 1 3.98004 3.465 2.17004 7.06L5.84504 9.91C6.71004 7.31 9.13504 5.375 12 5.375Z",
            fill: "#EA4335"
        })]
    });

function sU(t) {
    return d.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        width: 26,
        height: 26,
        viewBox: "0 0 140 140",
        x: "0px",
        y: "0px",
        fill: "none",
        ...t,
        children: [d.jsxs("defs", {
            children: [d.jsxs("linearGradient", {
                id: "b",
                children: [d.jsx("stop", {
                    offset: "0",
                    stopColor: "#3771c8"
                }), d.jsx("stop", {
                    stopColor: "#3771c8",
                    offset: ".128"
                }), d.jsx("stop", {
                    offset: "1",
                    stopColor: "#60f",
                    stopOpacity: "0"
                })]
            }), d.jsxs("linearGradient", {
                id: "a",
                children: [d.jsx("stop", {
                    offset: "0",
                    stopColor: "#fd5"
                }), d.jsx("stop", {
                    offset: ".1",
                    stopColor: "#fd5"
                }), d.jsx("stop", {
                    offset: ".5",
                    stopColor: "#ff543e"
                }), d.jsx("stop", {
                    offset: "1",
                    stopColor: "#c837ab"
                })]
            }), d.jsx("radialGradient", {
                id: "c",
                cx: "158.429",
                cy: "578.088",
                r: "65",
                xlinkHref: "#a",
                gradientUnits: "userSpaceOnUse",
                gradientTransform: "matrix(0 -1.98198 1.8439 0 -1031.402 454.004)",
                fx: "158.429",
                fy: "578.088"
            }), d.jsx("radialGradient", {
                id: "d",
                cx: "147.694",
                cy: "473.455",
                r: "65",
                xlinkHref: "#b",
                gradientUnits: "userSpaceOnUse",
                gradientTransform: "matrix(.17394 .86872 -3.5818 .71718 1648.348 -458.493)",
                fx: "147.694",
                fy: "473.455"
            })]
        }), d.jsx("path", {
            fill: "url(#c)",
            d: "M65.03 0C37.888 0 29.95.028 28.407.156c-5.57.463-9.036 1.34-12.812 3.22-2.91 1.445-5.205 3.12-7.47 5.468C4 13.126 1.5 18.394.595 24.656c-.44 3.04-.568 3.66-.594 19.188-.01 5.176 0 11.988 0 21.125 0 27.12.03 35.05.16 36.59.45 5.42 1.3 8.83 3.1 12.56 3.44 7.14 10.01 12.5 17.75 14.5 2.68.69 5.64 1.07 9.44 1.25 1.61.07 18.02.12 34.44.12 16.42 0 32.84-.02 34.41-.1 4.4-.207 6.955-.55 9.78-1.28 7.79-2.01 14.24-7.29 17.75-14.53 1.765-3.64 2.66-7.18 3.065-12.317.088-1.12.125-18.977.125-36.81 0-17.836-.04-35.66-.128-36.78-.41-5.22-1.305-8.73-3.127-12.44-1.495-3.037-3.155-5.305-5.565-7.624C116.9 4 111.64 1.5 105.372.596 102.335.157 101.73.027 86.19 0H65.03z",
            transform: "translate(1.004 1)"
        }), d.jsx("path", {
            fill: "url(#d)",
            d: "M65.03 0C37.888 0 29.95.028 28.407.156c-5.57.463-9.036 1.34-12.812 3.22-2.91 1.445-5.205 3.12-7.47 5.468C4 13.126 1.5 18.394.595 24.656c-.44 3.04-.568 3.66-.594 19.188-.01 5.176 0 11.988 0 21.125 0 27.12.03 35.05.16 36.59.45 5.42 1.3 8.83 3.1 12.56 3.44 7.14 10.01 12.5 17.75 14.5 2.68.69 5.64 1.07 9.44 1.25 1.61.07 18.02.12 34.44.12 16.42 0 32.84-.02 34.41-.1 4.4-.207 6.955-.55 9.78-1.28 7.79-2.01 14.24-7.29 17.75-14.53 1.765-3.64 2.66-7.18 3.065-12.317.088-1.12.125-18.977.125-36.81 0-17.836-.04-35.66-.128-36.78-.41-5.22-1.305-8.73-3.127-12.44-1.495-3.037-3.155-5.305-5.565-7.624C116.9 4 111.64 1.5 105.372.596 102.335.157 101.73.027 86.19 0H65.03z",
            transform: "translate(1.004 1)"
        }), d.jsx("path", {
            fill: "#fff",
            d: "M66.004 18c-13.036 0-14.672.057-19.792.29-5.11.234-8.598 1.043-11.65 2.23-3.157 1.226-5.835 2.866-8.503 5.535-2.67 2.668-4.31 5.346-5.54 8.502-1.19 3.053-2 6.542-2.23 11.65C18.06 51.327 18 52.964 18 66s.058 14.667.29 19.787c.235 5.11 1.044 8.598 2.23 11.65 1.227 3.157 2.867 5.835 5.536 8.503 2.667 2.67 5.345 4.314 8.5 5.54 3.054 1.187 6.543 1.996 11.652 2.23 5.12.233 6.755.29 19.79.29 13.037 0 14.668-.057 19.788-.29 5.11-.234 8.602-1.043 11.656-2.23 3.156-1.226 5.83-2.87 8.497-5.54 2.67-2.668 4.31-5.346 5.54-8.502 1.18-3.053 1.99-6.542 2.23-11.65.23-5.12.29-6.752.29-19.788 0-13.036-.06-14.672-.29-19.792-.24-5.11-1.05-8.598-2.23-11.65-1.23-3.157-2.87-5.835-5.54-8.503-2.67-2.67-5.34-4.31-8.5-5.535-3.06-1.187-6.55-1.996-11.66-2.23-5.12-.233-6.75-.29-19.79-.29zm-4.306 8.65c1.278-.002 2.704 0 4.306 0 12.816 0 14.335.046 19.396.276 4.68.214 7.22.996 8.912 1.653 2.24.87 3.837 1.91 5.516 3.59 1.68 1.68 2.72 3.28 3.592 5.52.657 1.69 1.44 4.23 1.653 8.91.23 5.06.28 6.58.28 19.39s-.05 14.33-.28 19.39c-.214 4.68-.996 7.22-1.653 8.91-.87 2.24-1.912 3.835-3.592 5.514-1.68 1.68-3.275 2.72-5.516 3.59-1.69.66-4.232 1.44-8.912 1.654-5.06.23-6.58.28-19.396.28-12.817 0-14.336-.05-19.396-.28-4.68-.216-7.22-.998-8.913-1.655-2.24-.87-3.84-1.91-5.52-3.59-1.68-1.68-2.72-3.276-3.592-5.517-.657-1.69-1.44-4.23-1.653-8.91-.23-5.06-.276-6.58-.276-19.398s.046-14.33.276-19.39c.214-4.68.996-7.22 1.653-8.912.87-2.24 1.912-3.84 3.592-5.52 1.68-1.68 3.28-2.72 5.52-3.592 1.692-.66 4.233-1.44 8.913-1.655 4.428-.2 6.144-.26 15.09-.27zm29.928 7.97c-3.18 0-5.76 2.577-5.76 5.758 0 3.18 2.58 5.76 5.76 5.76 3.18 0 5.76-2.58 5.76-5.76 0-3.18-2.58-5.76-5.76-5.76zm-25.622 6.73c-13.613 0-24.65 11.037-24.65 24.65 0 13.613 11.037 24.645 24.65 24.645C79.617 90.645 90.65 79.613 90.65 66S79.616 41.35 66.003 41.35zm0 8.65c8.836 0 16 7.163 16 16 0 8.836-7.164 16-16 16-8.837 0-16-7.164-16-16 0-8.837 7.163-16 16-16z"
        })]
    })
}

function aU(t) {
    return d.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 320 320",
        width: 24,
        height: 24,
        ...t,
        children: d.jsx("g", {
            children: d.jsxs("g", {
                children: [d.jsx("rect", {
                    fill: "#06c755",
                    width: "320",
                    height: "320",
                    rx: "72.14"
                }), d.jsx("path", {
                    fill: "#fff",
                    d: "M266.66,144.92c0-47.74-47.86-86.58-106.69-86.58S53.28,97.18,53.28,144.92c0,42.8,38,78.65,89.22,85.42,3.48.75,8.21,2.29,9.4,5.26,1.08,2.7.71,6.93.35,9.65,0,0-1.25,7.53-1.52,9.13-.47,2.7-2.15,10.55,9.24,5.76s61.44-36.18,83.82-61.95h0C259.25,181.24,266.66,164,266.66,144.92Z"
                }), d.jsx("path", {
                    fill: "#06c755",
                    d: "M231.16,172.49h-30a2,2,0,0,1-2-2v0h0V123.94h0v0a2,2,0,0,1,2-2h30a2,2,0,0,1,2,2v7.57a2,2,0,0,1-2,2H210.79v7.85h20.37a2,2,0,0,1,2,2V151a2,2,0,0,1-2,2H210.79v7.86h20.37a2,2,0,0,1,2,2v7.56A2,2,0,0,1,231.16,172.49Z"
                }), d.jsx("path", {
                    fill: "#06c755",
                    d: "M120.29,172.49a2,2,0,0,0,2-2v-7.56a2,2,0,0,0-2-2H99.92v-37a2,2,0,0,0-2-2H90.32a2,2,0,0,0-2,2v46.53h0v0a2,2,0,0,0,2,2h30Z"
                }), d.jsx("rect", {
                    fill: "#06c755",
                    x: "128.73",
                    y: "121.85",
                    width: "11.64",
                    height: "50.64",
                    rx: "2.04"
                }), d.jsx("path", {
                    fill: "#06c755",
                    d: "M189.84,121.85h-7.56a2,2,0,0,0-2,2v27.66l-21.3-28.77a1.2,1.2,0,0,0-.17-.21v0l-.12-.12,0,0-.11-.09-.06,0-.11-.08-.06,0-.11-.06-.07,0-.11,0-.07,0-.12,0-.08,0-.12,0h-.08l-.11,0h-7.71a2,2,0,0,0-2,2v46.56a2,2,0,0,0,2,2h7.57a2,2,0,0,0,2-2V142.81l21.33,28.8a2,2,0,0,0,.52.52h0l.12.08.06,0,.1.05.1,0,.07,0,.14,0h0a2.42,2.42,0,0,0,.54.07h7.52a2,2,0,0,0,2-2V123.89A2,2,0,0,0,189.84,121.85Z"
                })]
            })
        })
    })
}

function oU({
    style: t,
    ...e
}) {
    return d.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        viewBox: "0,0,256,256",
        style: {
            height: "26px",
            width: "26px",
            ...t
        },
        ...e,
        children: d.jsx("g", {
            fill: "#0077b5",
            strokeWidth: "1",
            strokeLinecap: "butt",
            strokeLinejoin: "miter",
            strokeMiterlimit: "10",
            style: {
                mixBlendMode: "normal"
            },
            children: d.jsx("g", {
                transform: "scale(5.12,5.12)",
                children: d.jsx("path", {
                    d: "M41,4h-32c-2.76,0 -5,2.24 -5,5v32c0,2.76 2.24,5 5,5h32c2.76,0 5,-2.24 5,-5v-32c0,-2.76 -2.24,-5 -5,-5zM17,20v19h-6v-19zM11,14.47c0,-1.4 1.2,-2.47 3,-2.47c1.8,0 2.93,1.07 3,2.47c0,1.4 -1.12,2.53 -3,2.53c-1.8,0 -3,-1.13 -3,-2.53zM39,39h-6c0,0 0,-9.26 0,-10c0,-2 -1,-4 -3.5,-4.04h-0.08c-2.42,0 -3.42,2.06 -3.42,4.04c0,0.91 0,10 0,10h-6v-19h6v2.56c0,0 1.93,-2.56 5.81,-2.56c3.97,0 7.19,2.73 7.19,8.26z"
                })
            })
        })
    })
}

function cU(t) {
    return d.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 496 512",
        ...t,
        children: [d.jsx("path", {
            fill: "#1ed760",
            d: "M248 8C111.1 8 0 119.1 0 256s111.1 248 248 248 248-111.1 248-248S384.9 8 248 8Z"
        }), d.jsx("path", {
            d: "M406.6 231.1c-5.2 0-8.4-1.3-12.9-3.9-71.2-42.5-198.5-52.7-280.9-29.7-3.6 1-8.1 2.6-12.9 2.6-13.2 0-23.3-10.3-23.3-23.6 0-13.6 8.4-21.3 17.4-23.9 35.2-10.3 74.6-15.2 117.5-15.2 73 0 149.5 15.2 205.4 47.8 7.8 4.5 12.9 10.7 12.9 22.6 0 13.6-11 23.3-23.2 23.3zm-31 76.2c-5.2 0-8.7-2.3-12.3-4.2-62.5-37-155.7-51.9-238.6-29.4-4.8 1.3-7.4 2.6-11.9 2.6-10.7 0-19.4-8.7-19.4-19.4s5.2-17.8 15.5-20.7c27.8-7.8 56.2-13.6 97.8-13.6 64.9 0 127.6 16.1 177 45.5 8.1 4.8 11.3 11 11.3 19.7-.1 10.8-8.5 19.5-19.4 19.5zm-26.9 65.6c-4.2 0-6.8-1.3-10.7-3.6-62.4-37.6-135-39.2-206.7-24.5-3.9 1-9 2.6-11.9 2.6-9.7 0-15.8-7.7-15.8-15.8 0-10.3 6.1-15.2 13.6-16.8 81.9-18.1 165.6-16.5 237 26.2 6.1 3.9 9.7 7.4 9.7 16.5s-7.1 15.4-15.2 15.4z"
        })]
    })
}

function lU(t) {
    return d.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fillRule: "evenodd",
        clipRule: "evenodd",
        imageRendering: "optimizeQuality",
        shapeRendering: "geometricPrecision",
        textRendering: "geometricPrecision",
        viewBox: "0 0 293768 333327",
        width: 24,
        height: 24,
        ...t,
        children: [d.jsx("path", {
            fill: "#26f4ee",
            d: "M204958 0c5369 45832 32829 78170 77253 81022v43471l-287 27V87593c-44424-2850-69965-30183-75333-76015l-47060-1v192819c6791 86790-60835 89368-86703 56462 30342 18977 79608 6642 73766-68039V0h58365zM78515 319644c-26591-5471-50770-21358-64969-44588-34496-56437-3401-148418 96651-157884v54345l-164 27v-40773C17274 145544 7961 245185 33650 286633c9906 15984 26169 27227 44864 33011z"
        }), d.jsx("path", {
            fill: "#fb2c53",
            d: "M218434 11587c3505 29920 15609 55386 35948 70259-27522-10602-43651-34934-47791-70262l11843 3zm63489 82463c3786 804 7734 1348 11844 1611v51530c-25770 2537-48321-5946-74600-21749l4034 88251c0 28460 106 41467-15166 67648-34260 58734-95927 63376-137628 35401 54529 22502 137077-4810 136916-103049v-96320c26279 15803 48830 24286 74600 21748V94050zm-171890 37247c5390-1122 11048-1985 16998-2548v54345c-21666 3569-35427 10222-41862 22528-20267 38754 5827 69491 35017 74111-33931 5638-73721-28750-49999-74111 6434-12304 18180-18959 39846-22528v-51797zm64479-119719h1808-1808z"
        }), d.jsx("path", {
            d: "M206590 11578c5369 45832 30910 73164 75333 76015v51528c-25770 2539-48321-5945-74600-21748v96320c206 125717-135035 135283-173673 72939-25688-41449-16376-141089 76383-155862v52323c-21666 3569-33412 10224-39846 22528-39762 76035 98926 121273 89342-1225V11577l47060 1z",
            fill: "#000000"
        })]
    })
}
const dU = ({
    style: t,
    ...e
}) => d.jsx("svg", {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    style: {
        height: "24px",
        width: "24px",
        ...t
    },
    ...e,
    children: d.jsx("path", {
        d: "M 14.285156 10.171875 L 23.222656 0 L 21.105469 0 L 13.34375 8.832031 L 7.148438 0 L 0 0 L 9.371094 13.355469 L 0 24.019531 L 2.117188 24.019531 L 10.308594 14.691406 L 16.851562 24.019531 L 24 24.019531 M 2.878906 1.5625 L 6.132812 1.5625 L 21.101562 22.535156 L 17.851562 22.535156",
        fill: "currentColor"
    })
});
let i$ = {
    google: {
        name: "Google",
        component: iU
    },
    discord: {
        name: "Discord",
        component: rU
    },
    github: {
        name: "Github",
        component: nU
    },
    linkedin: {
        name: "LinkedIn",
        component: oU
    },
    twitter: {
        name: "Twitter",
        component: dU
    },
    spotify: {
        name: "Spotify",
        component: cU
    },
    instagram: {
        name: "Instagram",
        component: sU
    },
    tiktok: {
        name: "Tiktok",
        component: lU
    },
    line: {
        name: "LINE",
        component: aU
    },
    apple: {
        name: "Apple",
        component: tU
    }
};
const pv = t => t in i$ ? i$[t] : {
    name: "Unknown",
    component: c9e
};

function l9e() {
    let t = new URLSearchParams(window.location.search),
        e = t.get("privy_oauth_code"),
        r = t.get("privy_oauth_state"),
        n = t.get("privy_oauth_provider");
    if (!e || !r || !n) return {
        inProgress: !1
    };
    let i = !1;
    try {
        i = !!window.opener.location.origin
    } catch {}
    return {
        inProgress: !0,
        authorizationCode: e,
        stateCode: r,
        provider: n,
        withPrivyUi: !rt.get(o1),
        popupFlow: window.opener !== null && i,
        disableSignup: !!rt.get(Jf)
    }
}

function p4() {
    let t = new URL(window.location.href);
    t.searchParams.delete("privy_oauth_code"), t.searchParams.delete("privy_oauth_provider"), t.searchParams.delete("privy_oauth_state"), rt.del(a1), window.history.replaceState({}, "", t)
}
class vu {
    async initRegisterFlow(e) {
        if (!this.api) throw new J("Auth flow has no API instance");
        this.authenticateForRegistration = !0, this.meta.initRegisterResponse = await this.initRegisterOnce.execute(e)
    }
    async initAuthenticationFlow(e) {
        if (!this.api) throw new J("Auth flow has no API instance");
        this.authenticateForRegistration = !1, this.meta.initAuthenticateResponse = await this.initAuthenticateOnce.execute(e)
    }
    async initLinkFlow() {
        if (!this.api) throw new J("Auth flow has no API instance");
        this.meta.initLinkResponse = await this.initLinkOnce.execute()
    }
    async register() {
        var r, n;
        let e = await ma(() =>
            import ("./index-CFBQExMV.js"), []);
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!e.browserSupportsWebAuthn()) throw new J("WebAuthn is not supported in this browser");
        this.meta.initRegisterResponse || (this.meta.initRegisterResponse = await this.initRegisterOnce.execute());
        try {
            let i = this.meta.initRegisterResponse.options,
                s = await e.startRegistration(this._transformInitLinkOptionsToCamelCase(i));
            return (n = (r = this.meta).setPasskeyAuthState) == null || n.call(r, {
                status: "submitting-response"
            }), await this.api.post(zie, {
                relying_party: this.meta.initRegisterResponse.relying_party,
                authenticator_response: this._transformRegistrationResponseToSnakeCase(s)
            })
        } catch (i) {
            throw i.name === "NotAllowedError" ? new J("Passkey request timed out or rejected by user.", void 0, ee.PASSKEY_NOT_ALLOWED) : qt(i)
        }
    }
    async authenticate() {
        var n, i, s;
        if (this.authenticateForRegistration) return this.register();
        let e = await ma(() =>
            import ("./index-CFBQExMV.js"), []);
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!e.browserSupportsWebAuthn()) throw new J("WebAuthn is not supported in this browser");
        this.meta.initAuthenticateResponse || (this.meta.initAuthenticateResponse = await this.initAuthenticateOnce.execute());
        let r = ((n = this.meta.allowedCredentialsIds) == null ? void 0 : n.map(a => ({
            type: "public-key",
            id: a
        }))) ? ? this.meta.initAuthenticateResponse.options.allow_credentials;
        try {
            let a = await e.startAuthentication(this._transformInitAuthenticateOptionsToCamelCase({ ...this.meta.initAuthenticateResponse.options,
                allow_credentials: r
            }));
            return (s = (i = this.meta).setPasskeyAuthState) == null || s.call(i, {
                status: "submitting-response"
            }), await this.api.post(Wie, {
                relying_party: this.meta.initAuthenticateResponse.relying_party,
                challenge: this.meta.initAuthenticateResponse.options.challenge,
                authenticator_response: this._transformAuthenticationResponseToSnakeCase(a)
            })
        } catch (a) {
            throw a.name === "NotAllowedError" ? new J("Passkey request timed out or rejected by user.", void 0, ee.PASSKEY_NOT_ALLOWED) : qt(a)
        }
    }
    async link() {
        var r, n;
        let e = await ma(() =>
            import ("./index-CFBQExMV.js"), []);
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!e.browserSupportsWebAuthn()) throw new J("WebAuthn is not supported in this browser");
        this.meta.initLinkResponse || (this.meta.initLinkResponse = await this.initLinkOnce.execute());
        try {
            let i = this.meta.initLinkResponse.options,
                s = await e.startRegistration(this._transformInitLinkOptionsToCamelCase(i));
            return (n = (r = this.meta).setPasskeyAuthState) == null || n.call(r, {
                status: "submitting-response"
            }), await this.api.post(Bie, {
                relying_party: this.meta.initLinkResponse.relying_party,
                authenticator_response: this._transformRegistrationResponseToSnakeCase(s)
            })
        } catch (i) {
            throw i.name === "NotAllowedError" ? new J("Passkey request timed out or rejected by user.", void 0, ee.PASSKEY_NOT_ALLOWED) : qt(i)
        }
    }
    async _initRegisterOnce(e) {
        if (!this.api) throw new J("Auth flow has no API instance");
        let r = Wp(e);
        return await this.api.post(Fie, {
            token: this.meta.captchaToken
        }, {
            headers: { ...r
            }
        })
    }
    async _initAuthenticateOnce(e) {
        if (!this.api) throw new J("Auth flow has no API instance");
        let r = Wp(e);
        return await this.api.post(Uie, {
            token: this.meta.captchaToken
        }, {
            headers: { ...r
            }
        })
    }
    async _initLinkOnce() {
        if (!this.api) throw new J("Auth flow has no API instance");
        return await this.api.post(Lie, {})
    }
    _transformInitLinkOptionsToCamelCase(e) {
        var r, n, i, s, a, o, c, l, u;
        return {
            rp: e.rp,
            user: {
                id: e.user.id,
                name: e.user.name,
                displayName: e.user.display_name
            },
            challenge: e.challenge,
            pubKeyCredParams: e.pub_key_cred_params.map(h => ({
                type: h.type,
                alg: h.alg
            })),
            timeout: e.timeout,
            excludeCredentials: (r = e.exclude_credentials) == null ? void 0 : r.map(h => ({
                id: h.id,
                type: h.type,
                transports: h.transports
            })),
            authenticatorSelection: {
                authenticatorAttachment: (n = e.authenticator_selection) == null ? void 0 : n.authenticator_attachment,
                requireResidentKey: (i = e.authenticator_selection) == null ? void 0 : i.require_resident_key,
                residentKey: (s = e.authenticator_selection) == null ? void 0 : s.resident_key,
                userVerification: (a = e.authenticator_selection) == null ? void 0 : a.user_verification
            },
            attestation: e.attestation,
            extensions: {
                appid: (o = e.extensions) == null ? void 0 : o.app_id,
                credProps: (l = (c = e.extensions) == null ? void 0 : c.cred_props) == null ? void 0 : l.rk,
                hmacCreateSecret: (u = e.extensions) == null ? void 0 : u.hmac_create_secret
            }
        }
    }
    _transformRegistrationResponseToSnakeCase(e) {
        return {
            id: e.id,
            raw_id: e.rawId,
            response: {
                client_data_json: e.response.clientDataJSON,
                attestation_object: e.response.attestationObject,
                authenticator_data: e.response.authenticatorData
            },
            authenticator_attachment: e.authenticatorAttachment,
            client_extension_results: {
                app_id: e.clientExtensionResults.appid,
                cred_props: e.clientExtensionResults.credProps,
                hmac_create_secret: e.clientExtensionResults.hmacCreateSecret
            },
            type: e.type
        }
    }
    _transformInitAuthenticateOptionsToCamelCase(e) {
        var r, n, i, s;
        return {
            rpId: e.rp_id,
            challenge: e.challenge,
            allowCredentials: ((r = e.allow_credentials) == null ? void 0 : r.map(a => ({
                id: a.id,
                type: a.type,
                transports: a.transports
            }))) || [],
            timeout: e.timeout,
            extensions: {
                appid: (n = e.extensions) == null ? void 0 : n.app_id,
                credProps: (i = e.extensions) == null ? void 0 : i.cred_props,
                hmacCreateSecret: (s = e.extensions) == null ? void 0 : s.hmac_create_secret
            },
            userVerification: e.user_verification
        }
    }
    _transformAuthenticationResponseToSnakeCase(e) {
        return {
            id: e.id,
            raw_id: e.rawId,
            response: {
                client_data_json: e.response.clientDataJSON,
                authenticator_data: e.response.authenticatorData,
                signature: e.response.signature,
                user_handle: e.response.userHandle
            },
            authenticator_attachment: e.authenticatorAttachment,
            client_extension_results: {
                app_id: e.clientExtensionResults.appid,
                cred_props: e.clientExtensionResults.credProps,
                hmac_create_secret: e.clientExtensionResults.hmacCreateSecret
            },
            type: e.type
        }
    }
    constructor({
        captchaToken: e,
        setPasskeyAuthState: r
    }) {
        this.authenticateForRegistration = !1, this.initRegisterOnce = new di(this._initRegisterOnce.bind(this)), this.initAuthenticateOnce = new di(this._initAuthenticateOnce.bind(this)), this.initLinkOnce = new di(this._initLinkOnce.bind(this)), this.meta = {
            captchaToken: e,
            setPasskeyAuthState: r
        }
    }
}
const g4 = ({
    address: t,
    chainId: e,
    nonce: r
}) => `${window.location.host} wants you to sign in with your Ethereum account:
${t}

By signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.

URI: ${window.location.origin}
Version: 1
Chain ID: ${e}
Nonce: ${r}
Issued At: ${new Date().toISOString()}
Resources:
- https://privy.io`;
class qu {
    get meta() {
        var e, r, n, i;
        return {
            connectorType: (e = this.wallet) == null ? void 0 : e.connectorType,
            walletClientType: (r = this.wallet) == null ? void 0 : r.walletClientType,
            chainId: (n = this.wallet) == null ? void 0 : n.chainId,
            address: (i = this.wallet) == null ? void 0 : i.address,
            disableSignup: this._meta.disableSignup
        }
    }
    async authenticate() {
        var e, r, n;
        if (!this.client) throw new J("SiweFlow has no client instance");
        try {
            if (this.preparedMessage && this.signature) return await this.client.authenticateWithSiweInternal({
                message: this.preparedMessage,
                signature: this.signature,
                chainId: (e = this.wallet) == null ? void 0 : e.chainId,
                walletClientType: (r = this.wallet) == null ? void 0 : r.walletClientType,
                connectorType: (n = this.wallet) == null ? void 0 : n.connectorType,
                mode: this._meta.disableSignup ? "no-signup" : "login-or-sign-up"
            });
            if (!this.wallet) throw new J("SiweFlow has no wallet instance");
            let {
                message: i,
                signature: s
            } = await this.sign();
            return await this.client.authenticateWithSiweInternal({
                message: i,
                signature: s,
                chainId: this.wallet.chainId,
                walletClientType: this.wallet.walletClientType,
                connectorType: this.wallet.connectorType,
                mode: this.meta.disableSignup ? "no-signup" : "login-or-sign-up"
            })
        } catch (i) {
            throw qt(i)
        }
    }
    async link() {
        if (!this.client) throw new J("SiweFlow has no client instance");
        try {
            if (!this.wallet) throw new J("SiweFlow has no wallet instance");
            let {
                message: e,
                signature: r
            } = await this.sign();
            return await this.client.linkWithSiweInternal({
                message: e,
                signature: r,
                chainId: this.wallet.chainId,
                walletClientType: this.wallet.walletClientType,
                connectorType: this.wallet.connectorType
            })
        } catch (e) {
            throw qt(e)
        }
    }
    async sign() {
        if (!this.client) throw new J("SiweFlow has no client instance");
        if (await this.buildMessage(), !this.preparedMessage) throw new J("Could not prepare SIWE message");
        if (!this.wallet) throw new J("SiweFlow has no wallet instance");
        let e = await this.wallet.sign(this.preparedMessage);
        return {
            message: this.preparedMessage,
            signature: e
        }
    }
    async _getNonceOnce() {
        if (!this.client) throw new J("SiweFlow has no client instance");
        if (!this.wallet) throw new J("UI SiweFlow has no wallet instance");
        return await this.client.generateSiweNonce({
            address: this.wallet.address,
            captchaToken: this.captchaToken
        })
    }
    async buildMessage() {
        if (!this.client) throw new J("SiweFlow has no client instance");
        if (!this.wallet) throw new J("SiweFlow has no wallet instance");
        let e = this.wallet.address,
            r = this.wallet.chainId.replace("eip155:", "");
        return this.nonce || (this.nonce = await this.getNonceOnce.execute()), this.preparedMessage = g4({
            address: e,
            chainId: r,
            nonce: this.nonce
        }), this.preparedMessage
    }
    constructor(e, r, n, i = !1, s) {
        this._meta = {
            disableSignup: !1
        }, this.getNonceOnce = new di(this._getNonceOnce.bind(this)), this.wallet = r, this.captchaToken = n, this.client = e, this._meta.disableSignup = i, this.preparedMessage = s == null ? void 0 : s.message, this.signature = s == null ? void 0 : s.signature
    }
}
const On = (...t) => {
        if (typeof Ve > "u") throw new J("Buffer is not defined.", void 0, ee.BUFFER_NOT_DEFINED);
        return Ve.from(...t)
    },
    d9e = ({
        address: t,
        nonce: e
    }) => `${window.location.host} wants you to sign in with your Solana account:
${t}

${`You are proving you own ${t}.`}

URI: ${window.location.origin}
Version: 1
Chain ID: mainnet
Nonce: ${e}
Issued At: ${new Date().toISOString()}
Resources:
- https://privy.io`;
class c1 {
    get meta() {
        var e;
        return {
            connectorType: this.wallet.connectorType,
            walletClientType: this.wallet.walletClientType,
            disableSignup: this._meta.disableSignup,
            messageType: this._meta.messageType,
            address: (e = this.wallet) == null ? void 0 : e.address
        }
    }
    set messageType(e) {
        this._meta.messageType = e
    }
    async authenticate() {
        if (!this.client) throw new J("SiwsFlow has no client instance");
        try {
            let {
                message: e,
                signature: r
            } = await this.sign();
            return await this.client.authenticateWithSiwsInternal({
                message: e,
                signature: r,
                walletClientType: this.wallet.walletClientType,
                connectorType: this.wallet.connectorType,
                mode: this.meta.disableSignup ? "no-signup" : "login-or-sign-up",
                messageType: this.meta.messageType
            })
        } catch (e) {
            throw qt(e)
        }
    }
    async link() {
        if (!this.client) throw new J("SiwsFlow has no client instance");
        try {
            let {
                message: e,
                signature: r
            } = await this.sign();
            return await this.client.linkWithSiwsInternal({
                message: e,
                signature: r,
                walletClientType: this.wallet.walletClientType,
                connectorType: this.wallet.connectorType,
                messageType: this.meta.messageType
            })
        } catch (e) {
            throw qt(e)
        }
    }
    async sign() {
        var i;
        let e, r;
        if (!this.client) throw new J("SiwsFlow has no client instance");
        await this.buildMessage();
        let n = this.meta.messageType === "transaction";
        if (!this.preparedMessage) throw new J("Could not prepare SIWS message");
        if (!n && !this.wallet.signMessage || n && !this.wallet.signTransaction) throw new J("Wallet does not support the necessary signing methods");
        if (n && this._siwsTransactionMethods) {
            let s = await this.wallet.signTransaction(this._siwsTransactionMethods.deserializeTransactionFromB64String(this.preparedMessage));
            e = s.serialize().toString("base64"), r = On(((i = s.signatures[0]) == null ? void 0 : i.signature) ? ? Ve.from("missing signature")).toString("base64")
        } else e = this.preparedMessage, r = On(await this.wallet.signMessage(On(this.preparedMessage))).toString("base64");
        return {
            message: e,
            signature: r
        }
    }
    async _getNonceOnce() {
        if (!this.client) throw new J("SiwsFlow has no client instance");
        return await this.client.generateSiwsNonce({
            address: this.wallet.address,
            captchaToken: this.captchaToken
        })
    }
    async buildMessage() {
        if (!this.client) throw new J("SiwsFlow has no client instance");
        let e = this.wallet.address;
        return this.nonce || (this.nonce = await this.getNonceOnce.execute()), this.meta.messageType === "transaction" && this._siwsTransactionMethods ? this.preparedMessage = this._siwsTransactionMethods.prepareSiwsTransactionWithMemo({
            address: e,
            nonce: this.nonce
        }) : this.preparedMessage = d9e({
            address: e,
            nonce: this.nonce
        }), this.preparedMessage
    }
    constructor(e, r, n, i = !1, s = "plain", a) {
        this._meta = {
            disableSignup: !1,
            messageType: "plain"
        }, this.getNonceOnce = new di(this._getNonceOnce.bind(this)), this.wallet = e, this.captchaToken = n, this.client = r, this._meta.disableSignup = i, this._meta.messageType = s, this._siwsTransactionMethods = a
    }
}
class Ou {
    async authenticate() {
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!this.meta.phoneNumber || !this.meta.smsCode) throw new J("phone number and sms code must be set prior to calling authenticate.");
        try {
            return await this.api.post(Tie, {
                phoneNumber: this.meta.phoneNumber,
                code: this.meta.smsCode,
                mode: this.meta.disableSignup ? "no-signup" : "login-or-sign-up"
            })
        } catch (e) {
            throw qt(e)
        }
    }
    async link() {
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!this.meta.phoneNumber || !this.meta.smsCode) throw new J("phone number and sms code must be set prior to calling authenticate.");
        try {
            return await this.api.post($ie, {
                phoneNumber: this.meta.phoneNumber,
                code: this.meta.smsCode
            })
        } catch (e) {
            throw qt(e)
        }
    }
    async sendSmsCode({
        phoneNumber: e,
        captchaToken: r,
        withPrivyUi: n
    }) {
        if (!this.api) throw new J("Auth flow has no API instance");
        if (e && (this.meta.phoneNumber = e), r && (this.meta.captchaToken = r), !this.meta.phoneNumber) throw new J("phone nNumber must be set when initialzing authentication.");
        let i = Wp(n);
        try {
            return await this.api.post(Iie, {
                phoneNumber: this.meta.phoneNumber,
                token: this.meta.captchaToken
            }, {
                headers: { ...i
                }
            })
        } catch (s) {
            throw qt(s)
        }
    }
    constructor({
        phoneNumber: e,
        captchaToken: r,
        disableSignup: n
    }) {
        this.meta = {
            phoneNumber: e,
            captchaToken: r,
            disableSignup: n ? ? !1
        }
    }
}
class u9e extends Ou {
    async link() {
        if (!this.api) throw new J("Auth flow has no API instance");
        if (!this.meta.phoneNumber || !this.meta.smsCode || !this.meta.oldPhoneNumber) throw new J("Phone number, sms code, and an old phone number must be set prior to calling update.");
        try {
            return await this.api.post(Pie, {
                old_phone_number: this.meta.oldPhoneNumber,
                new_phone_number: this.meta.phoneNumber,
                code: this.meta.smsCode
            })
        } catch (e) {
            throw qt(e)
        }
    }
    constructor(e, r, n) {
        super({
            phoneNumber: r,
            captchaToken: n
        }), this.meta = {
            phoneNumber: r,
            captchaToken: n,
            oldPhoneNumber: e,
            disableSignup: !1
        }
    }
}
const uU = t => t.isApexWallet ? "Apex Wallet" : t.isAvalanche ? "Core Wallet" : t.isBackpack ? "Backpack" : t.isBifrost ? "Bifrost Wallet" : t.isBitKeep ? "BitKeep" : t.isBitski ? "Bitski" : t.isBlockWallet ? "BlockWallet" : t.isBraveWallet ? "Brave Wallet" : t.isClover ? "Clover" : t.isCoin98 ? "Coin98 Wallet" : t.isCoinbaseWallet ? "Coinbase Wallet" : t.isDawn ? "Dawn Wallet" : t.isDefiant ? "Defiant" : t.isDesig ? "Desig Wallet" : t.isEnkrypt ? "Enkrypt" : t.isExodus ? "Exodus" : t.isFordefi ? "Fordefi" : t.isFrame ? "Frame" : t.isFrontier ? "Frontier Wallet" : t.isGamestop ? "GameStop Wallet" : t.isHaqqWallet ? "HAQQ Wallet" : t.isHyperPay ? "HyperPay Wallet" : t.isImToken ? "ImToken" : t.isHaloWallet ? "Halo Wallet" : t.isKuCoinWallet ? "KuCoin Wallet" : t.isMathWallet ? "MathWallet" : t.isNovaWallet ? "Nova Wallet" : t.isOkxWallet || t.isOKExWallet ? "OKX Wallet" : t.isOneInchIOSWallet || t.isOneInchAndroidWallet ? "1inch Wallet" : t.isOneKey ? "OneKey Wallet" : t.isOpera ? "Opera" : t.isPhantom || "isPhantom" in t ? "Phantom" : t.isPortal ? "Ripio Portal" : t.isRabby ? "Rabby Wallet" : t.isRainbow ? "Rainbow" : t.isSafePal ? "SafePal Wallet" : t.isStatus ? "Status" : t.isSubWallet ? "SubWallet" : t.isTalisman ? "Talisman" : t.isTally || t.isTaho ? "Taho" : t.isTokenPocket ? "TokenPocket" : t.isTokenary ? "Tokenary" : t.isTrust || t.isTrustWallet ? "Trust Wallet" : t.isTTWallet ? "TTWallet" : t.isXDEFI ? "XDEFI Wallet" : t.isZeal ? "Zeal" : t.isZerion ? "Zerion" : t.isMetaMask ? "MetaMask" : void 0,
    hU = (t, e) => {
        if (!t.isMetaMask) return !1;
        if (t.isMetaMask && !e) return !0;
        if (t.isBraveWallet && !t._events && !t._state || uU(t) !== "MetaMask") return !1;
        if (t.providers) {
            for (let r of t.providers)
                if (!hU(r)) return !1
        }
        return !0
    },
    fU = () => {
        let t = window;
        if (!t.ethereum) return !1;
        if (t.ethereum.isCoinbaseWallet) return !0;
        if (t.ethereum.providers) {
            for (let e of t.ethereum.providers)
                if (e && e.isCoinbaseWallet) return !0
        }
        return !1
    },
    oh = (t, e, r, n) => {
        let i = Number(t),
            s = e.find(a => a.id === i);
        if (!s) throw new br(`Unsupported chainId ${t}`, 4901);
        return nc({
            transport: rc(cc(s, r, n.appId)),
            chain: s
        })
    },
    cc = (t, e, r) => {
        var a, o, c;
        let n, i = t.id,
            s = Number(t.id);
        if (t.rpcUrls.privyWalletOverride && t.rpcUrls.privyWalletOverride.http[0]) n = t.rpcUrls.privyWalletOverride.http[0];
        else if (e.rpcUrls && e.rpcUrls[s]) n = e.rpcUrls[s];
        else if ((a = t.rpcUrls.privy) != null && a.http[0]) {
            let l = new URL(t.rpcUrls.privy.http[0]);
            l.searchParams.append("privyAppId", r), n = l.toString()
        } else n = (o = t.rpcUrls.public) != null && o.http[0] ? t.rpcUrls.public.http[0] : (c = t.rpcUrls.default) == null ? void 0 : c.http[0];
        if (!n) throw new br(`No RPC url found for ${i}`);
        return n
    },
    pU = t => !!String(t).toLowerCase().match(/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/),
    Yn = (t, e = 3, r = 4, n = "ethereum") => {
        if (!t) return "";
        let i = n === "ethereum" ? 2 : 0;
        return e + r + i + 3 >= t.length ? t : `${t.slice(0,i+e)}...${t.slice(t.length-r,t.length)}`
    },
    gv = (t, e = 3, r = 4) => Yn(t, e, r, "solana"),
    l1 = t => new Promise(e => setTimeout(e, t)),
    m4 = (t, e = {}) => {
        let r = e.delayMs || 150,
            n = e.maxAttempts || 270;
        return new Promise(async (i, s) => {
            var c;
            let a = !1,
                o = 0;
            for (; !a && o < n;) {
                if ((c = e.abortSignal) != null && c.aborted) return;
                t().then(l => {
                    a = !0, i(l)
                }, (...l) => {
                    a = !0, s(...l)
                }), o += 1, await l1(r)
            }
            a || s(Error("Exceeded max attempts before resolving function"))
        })
    },
    gU = (t, e, r = {}, n = {}) => {
        let i = new URL(e, t);
        for (let [a, o] of Object.entries(r)) o !== void 0 && i.searchParams.set(a, o);
        let s = Object.entries(n);
        if (s.length > 0) {
            let a = new URLSearchParams;
            for (let [o, c] of s) a.append(o, c);
            i.hash = a.toString()
        }
        return i.href
    },
    h9e = t => t.replace(/([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g, ""),
    y4 = t => typeof t == "string" ? t : "0x" + t.toString(16);
async function f9e({
    store: t,
    walletList: e,
    externalWalletConfig: r,
    walletChainType: n,
    timeout: i = 3e3
}) {
    let s = !1,
        a = window;
    return new Promise(o => {
        function c() {
            if (s) return;
            s = !0, window.removeEventListener("ethereum#initialized", c);
            let l = t.getProviders();
            console.debug("Detected injected providers:", l.map(h => h.info));
            let u = [];
            for (let h of l) e.includes("coinbase_wallet") && h.info.rdns === "com.coinbase.wallet" || n === "solana-only" && h.info.rdns === "app.phantom" || u.push({
                type: h.info.name.toLowerCase().replace(/\s/g, "_"),
                eip6963InjectedProvider: h
            });
            if (n !== "solana-only")
                for (let h of function() {
                        var m;
                        let f = window,
                            p = f.ethereum;
                        if (!p) return [];
                        let g = [];
                        if ((m = p.providers) != null && m.length)
                            for (let y of p.providers) y && g.push(y);
                        return g.push(f.ethereum), g
                    }()) {
                    let f = uU(h);
                    if (!l.some(p => p.info.name === f)) {
                        if (hU(h, !0) && !u.find(p => p.type === "metamask")) {
                            u.push({
                                type: "metamask",
                                legacyInjectedProvider: h
                            });
                            continue
                        }
                        if (f === "Phantom" && !u.find(p => p.type === "phantom")) {
                            u.push({
                                type: "phantom",
                                legacyInjectedProvider: h
                            });
                            continue
                        }
                        if (f === "Coinbase Wallet" && !u.find(p => {
                                var g, m, y;
                                return p.type === "coinbase_wallet" && ((y = (m = (g = r.coinbaseWallet) == null ? void 0 : g.config) == null ? void 0 : m.preference) == null ? void 0 : y.options) !== "smartWalletOnly"
                            })) {
                            u.push({
                                type: "coinbase_wallet",
                                legacyInjectedProvider: h
                            });
                            continue
                        }
                        u.find(p => p.type === "unknown_browser_extension") || u.push({
                            type: "unknown_browser_extension",
                            legacyInjectedProvider: h
                        })
                    }
                }
            o(u)
        }
        a.ethereum ? c() : (window.addEventListener("ethereum#initialized", c, {
            once: !0
        }), setTimeout(() => {
            c()
        }, i))
    })
}

function am(t) {
    return `eip155:${String(Number(t))}`
}
const p9e = (t, e, r, n) => {
        let i = Number(t),
            s = e.find(a => a.id === i);
        if (!s) throw new br(`Unsupported chainId ${t}`, 4901);
        return cc(s, r, n)
    },
    om = t => {
        let e = {
                name: "string",
                version: "string",
                chainId: "uint256",
                verifyingContract: "address",
                salt: "bytes32"
            },
            r = t.types.EIP712Domain ? ? Object.entries(t.domain).map(([n, i]) => {
                if (i != null && typeof n == "string" && n in e) return {
                    name: n,
                    type: e[n]
                }
            }).filter(n => n !== void 0);
        return { ...t,
            types: { ...t.types,
                EIP712Domain: r
            }
        }
    },
    mU = v.createContext({
        siteKey: "",
        enabled: !1,
        appId: void 0,
        token: void 0,
        error: void 0,
        status: "disabled",
        setToken: le,
        setError: le,
        setExecuting: le,
        waitForResult: () => Promise.resolve(""),
        ref: {
            current: null
        },
        remove: le,
        reset: le,
        execute: le
    });
class Ky extends Qn {
    constructor(e, r, n) {
        super(e || "Captcha failed"), this.type = "Captcha", r instanceof Error && (this.cause = r), this.privyErrorCode = n
    }
}
const g9e = ({
        children: t,
        id: e,
        captchaSiteKey: r,
        captchaEnabled: n
    }) => {
        let i = v.useRef(null),
            [s, a] = v.useState(),
            [o, c] = v.useState(),
            [l, u] = v.useState(!1),
            h = v.useMemo(() => n ? l || s || o ? !l || s || o ? s && !o ? {
                status: "success",
                token: s
            } : o ? {
                status: "error",
                error: o
            } : {
                status: "ready"
            } : {
                status: "loading"
            } : {
                status: "ready"
            } : {
                status: "disabled"
            }, [n, s, o, l]);
        return d.jsx(mU.Provider, {
            value: { ...h,
                ref: i,
                enabled: n,
                siteKey: r,
                appId: e,
                setToken: a,
                setError: c,
                setExecuting: u,
                remove() {
                    var f;
                    n && ((f = i.current) == null || f.remove(), u(!1), c(void 0), a(void 0))
                },
                reset() {
                    var f;
                    n && ((f = i.current) == null || f.reset(), u(!1), c(void 0), a(void 0))
                },
                execute() {
                    var f;
                    n && (u(!0), (f = i.current) == null || f.execute())
                },
                async waitForResult() {
                    if (!n) return "";
                    try {
                        return await
                        function(f, {
                            interval: p = 100,
                            timeout: g = 5e3
                        } = {}) {
                            return new Promise((m, y) => {
                                let w, x = 0,
                                    E = () => {
                                        x >= g ? y("Max attempts reached without result") : (w = f(), x += p, w == null ? setTimeout(E, p) : m(w))
                                    };
                                E()
                            })
                        }(() => {
                            var f;
                            return (f = i.current) == null ? void 0 : f.getResponse()
                        }, {
                            interval: 200,
                            timeout: 2e4
                        })
                    } catch {
                        throw new Ky("Captcha failed", null, ee.CAPTCHA_TIMEOUT)
                    }
                }
            },
            children: t
        })
    },
    qi = () => v.useContext(mU);
class hf {
    async authenticate() {
        if (!this.api) throw new J("Auth flow has no API instance");
        try {
            return await this.api.post(qie, {
                captcha_token: this.meta.captchaToken,
                telegram_auth_result: this.meta.telegramAuthResult,
                telegram_web_app_data: this.meta.telegramWebAppData,
                mode: this.meta.disableSignup ? "no-signup" : "login-or-sign-up"
            })
        } catch (e) {
            throw qt(e)
        }
    }
    async link() {
        if (!this.api) throw new J("Auth flow has no API instance");
        try {
            return await this.api.post(Hie, {
                telegram_auth_result: this.meta.telegramAuthResult,
                telegram_web_app_data: this.meta.telegramWebAppData
            })
        } catch (e) {
            throw qt(e)
        }
    }
    constructor(e, r = !1) {
        this.meta = {
            disableSignup: !1
        }, this.meta = {
            captchaToken: e,
            disableSignup: !1
        }, this.meta.disableSignup = r
    }
}

function s$(t) {
    let e = {
        detail: "",
        retryable: !1
    };
    return (t == null ? void 0 : t.privyErrorCode) === ee.LINKED_TO_ANOTHER_USER && (e.detail = "This account has already been linked to another user."), (t == null ? void 0 : t.privyErrorCode) === ee.DISALLOWED_LOGIN_METHOD && (e.detail = "Login with Telegram not allowed."), (t == null ? void 0 : t.privyErrorCode) === ee.INVALID_DATA && (e.retryable = !0, e.detail = "Something went wrong. Try again."), (t == null ? void 0 : t.privyErrorCode) === ee.CANNOT_LINK_MORE_OF_TYPE && (e.retryable = !0, e.detail = "Something went wrong. Try again."), (t == null ? void 0 : t.privyErrorCode) === ee.INVALID_CREDENTIALS && (e.retryable = !0, e.detail = "Something went wrong. Try again."), (t == null ? void 0 : t.privyErrorCode) === ee.TOO_MANY_REQUESTS && (e.detail = "Too many requests. Please wait before trying again."), (t == null ? void 0 : t.privyErrorCode) === ee.TOO_MANY_REQUESTS && t.message.includes("rate limit") && (e.detail = "Request limit reached for Telegram. Please wait a moment and try again."), t instanceof Ky && (e.retryable = !0, e.detail = "Something went wrong. Try again."), e
}

function a$(t) {
    return Object.fromEntries(decodeURIComponent(t).split("&").map(e => e.split("=").map(decodeURIComponent)))
}

function o$() {
    let t = new URL(window.location.href);
    t.searchParams.delete("id"), t.searchParams.delete("hash"), t.searchParams.delete("auth_date"), t.searchParams.delete("first_name"), t.searchParams.delete("last_name"), t.searchParams.delete("username"), t.searchParams.delete("photo_url"), t.hash = "", window.history.replaceState({}, "", t)
}
class qc {
    static parse(e) {
        try {
            return new qc(e)
        } catch {
            return null
        }
    }
    static throwIfNotWellFormedJwt(e) {
        return _3(e), e
    }
    get subject() {
        return this._decoded.sub
    }
    get expiration() {
        return this._decoded.exp
    }
    get issuer() {
        return this._decoded.iss
    }
    get audience() {
        return this._decoded.aud
    }
    isExpired(e = 0) {
        return Date.now() >= 1e3 * (this.expiration - e)
    }
    constructor(e) {
        this.value = e, this._decoded = _3(e)
    }
}
class d8 extends qc {
    static parse(e) {
        try {
            return new d8(e)
        } catch {
            return null
        }
    }
    get appId() {
        return this._decoded.aid ? this._decoded.aid : this.audience
    }
}
let c$ = t => {
    if (t.chainType === "ethereum") return {
        entropyId: t.address,
        entropyIdVerifier: "ethereum-address-verifier"
    };
    if (t.chainType === "solana") return {
        entropyId: t.address,
        entropyIdVerifier: "solana-address-verifier"
    };
    throw Error("Failed to get account entropy details")
};
const Sn = (t, e) => {
        if (e != null && e.imported) return c$(e);
        let r = Rs(t);
        if (!r) throw Error("Failed to find primary wallet");
        return c$(r)
    },
    m9e = ({
        style: t,
        ...e
    }) => d.jsxs("svg", {
        viewBox: "0 0 1024 1024",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: {
            height: "28px",
            width: "28px",
            ...t
        },
        ...e,
        children: [d.jsx("rect", {
            width: "1024",
            height: "1024",
            fill: "#0052FF",
            rx: 100,
            ry: 100
        }), d.jsx("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z",
            fill: "white"
        })]
    }),
    yU = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PScwIDAgMTAyNCAxMDI0JyBmaWxsPSdub25lJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHN0eWxlPSdoZWlnaHQ6MjhweDt3aWR0aDoyOHB4Jz48cmVjdCB3aWR0aD0nMTAyNCcgaGVpZ2h0PScxMDI0JyBmaWxsPScjMDA1MkZGJyByeD0nMTAwJyByeT0nMTAwJz48L3JlY3Q+PHBhdGggZmlsbC1ydWxlPSdldmVub2RkJyBjbGlwLXJ1bGU9J2V2ZW5vZGQnIGQ9J00xNTIgNTEyQzE1MiA3MTAuODIzIDMxMy4xNzcgODcyIDUxMiA4NzJDNzEwLjgyMyA4NzIgODcyIDcxMC44MjMgODcyIDUxMkM4NzIgMzEzLjE3NyA3MTAuODIzIDE1MiA1MTIgMTUyQzMxMy4xNzcgMTUyIDE1MiAzMTMuMTc3IDE1MiA1MTJaTTQyMCAzOTZDNDA2Ljc0NSAzOTYgMzk2IDQwNi43NDUgMzk2IDQyMFY2MDRDMzk2IDYxNy4yNTUgNDA2Ljc0NSA2MjggNDIwIDYyOEg2MDRDNjE3LjI1NSA2MjggNjI4IDYxNy4yNTUgNjI4IDYwNFY0MjBDNjI4IDQwNi43NDUgNjE3LjI1NSAzOTYgNjA0IDM5Nkg0MjBaJyBmaWxsPSd3aGl0ZSc+PC9wYXRoPjwvc3ZnPg==",
    wU = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAALZJREFUaEPtmjEOhDAMBNc/O14GvOzys3CAKK6eAlmaVGl2Zc+kTOU685vkc9/bnD2prZK5/TZY24z9P+g4F5hNh7/GdoG37WlAA5CATwgCxHENYISwQAMQII5rACOEBRqAAHFcAxghLNAABIjjGsAIYYEGIEAc1wBGCAs0AAHiuAYwQligAQgQxzWAEcICDUCAOK4BjBAWaAACxHENYISwQAMQII6fBjr+VHkW3+u+tfyxMpJaDgYzYxb/ALZVAAAAAElFTkSuQmCC";
class bU extends br {
    constructor() {
        super("Wallet timeout"), this.type = "wallet_error"
    }
}
class vU extends br {
    constructor() {
        super("User rejected connection"), this.type = "wallet_error"
    }
}
const hl = t => t instanceof br ? t : t != null && t.code ? new ni(t) : new br("Unknown connector error", t);
class Hu extends Qn {
    constructor(e, r, n) {
        super(e), this.type = "provider_error", this.code = r, this.data = n
    }
}
class ni extends Hu {
    constructor(e) {
        var n, i, s;
        super(e.message, e.code, e.data);
        let r = Object.values(da).find(a => a.eipCode === e.code);
        this.details = r || da.UNKNOWN_ERROR, e.code === -32002 && ((n = e.message) != null && n.includes("already pending for origin") ? (i = e.message) != null && i.includes("wallet_requestPermissions") ? this.details = da.E32002_CONNECTION_ALREADY_PENDING : this.details = da.E32002_REQUEST_ALREADY_PENDING : (s = e.message) != null && s.includes("Already processing") && e.message.includes("eth_requestAccounts") && (this.details = da.E32002_WALLET_LOCKED))
    }
}
const Hc = {
    ERROR_USER_EXISTS: {
        message: "User already exists for this address",
        detail: "Try another address!",
        retryable: !1
    },
    ERROR_TIMED_OUT: {
        message: "Wallet request timed out",
        detail: "Please try connecting again.",
        retryable: !0
    },
    ERROR_WALLET_CONNECTION: {
        message: "Could not log in with wallet",
        detail: "Please try connecting again.",
        retryable: !0
    },
    ERROR_USER_REJECTED_CONNECTION: {
        message: "You rejected the request",
        detail: "Please try connecting again.",
        retryable: !0
    },
    ERROR_USER_LIMIT_REACHED: {
        message: "Unable to link",
        detail: "You've reached the maximum number of linked wallets.",
        retryable: !1
    },
    ...da
};

function Uo(t) {
    return t.type === "ethereum"
}

function w4(t, e) {
    if (t.length !== e.length) return !1;
    for (let r = 0; r < t.length; r++) {
        let n = t[r],
            i = e[r];
        if ((n == null ? void 0 : n.address) !== (i == null ? void 0 : i.address) || n && i && Uo(n) && Uo(i) && (n == null ? void 0 : n.chainId) !== (i == null ? void 0 : i.chainId) || (n == null ? void 0 : n.connectorType) !== (i == null ? void 0 : i.connectorType) || (n == null ? void 0 : n.connectedAt) !== (i == null ? void 0 : i.connectedAt) || (n == null ? void 0 : n.walletClientType) !== (i == null ? void 0 : i.walletClientType) || (n == null ? void 0 : n.isConnected) !== (i == null ? void 0 : i.isConnected) || (n == null ? void 0 : n.linked) !== (i == null ? void 0 : i.linked)) return !1
    }
    return !0
}
class xU extends Ed {
    constructor(e) {
        super(), this.walletClientType = e, this.connected = !1, this.initialized = !1
    }
}
const u8 = (t, e) => t.rpcTimeouts && t.rpcTimeouts[e] || Vy;
let xu, ff;

function pf(t) {
    return t.chainType === "ethereum"
}
class Bd extends xU {
    buildConnectedWallet(e, r, n, i) {
        let s = async () => !!this.wallets.find(a => Zr(a.address) === Zr(e));
        return {
            type: "ethereum",
            address: Zr(e),
            chainId: r,
            meta: n,
            imported: i,
            switchChain: async a => {
                var f, p, g, m;
                let o, c;
                if (!s) throw new br("Wallet is not currently connected.");
                let l = (f = this.wallets.find(y => Zr(y.address) === Zr(e))) == null ? void 0 : f.chainId;
                if (!l) throw new br("Unable to determine current chainId.");
                if (typeof a == "number" ? (o = `0x${a.toString(16)}`, c = a) : (o = a, c = Number(a)), l === am(o)) return;
                let u = this.chains.find(y => y.id === c);
                if (!u) throw new br(`Unsupported chainId: ${a}`);
                let h = async () => {
                    await this.proxyProvider.request({
                        method: "wallet_switchEthereumChain",
                        params: [{
                            chainId: o
                        }]
                    })
                };
                try {
                    return await h()
                } catch (y) {
                    if (((w, x) => {
                            var E;
                            switch (x) {
                                case "coinbase_wallet":
                                case "base_account":
                                    return w.message.includes("addEthereumChain");
                                case "rabby_wallet":
                                    return w.message.includes("Unrecognized chain ID");
                                default:
                                    return w.code === 4902 || ((E = w.message) == null ? void 0 : E.includes("4902"))
                            }
                        })(y, this.walletClientType)) return this.walletClientType === "rabby_wallet" && await l1(300), await this.proxyProvider.request({
                        method: "wallet_addEthereumChain",
                        params: [{
                            chainId: o,
                            chainName: u.name,
                            nativeCurrency: u.nativeCurrency,
                            rpcUrls: [((p = u.rpcUrls.default) == null ? void 0 : p.http[0]) ? ? ""],
                            blockExplorerUrls: [((g = u.blockExplorers) == null ? void 0 : g.default.url) ? ? ""]
                        }]
                    }), h();
                    throw this.walletClientType === "rainbow" && ((m = y.message) != null && m.includes("wallet_switchEthereumChain")) ? new br(`Rainbow does not support the chainId ${r}`) : y
                }
            },
            connectedAt: Date.now(),
            walletClientType: this.walletClientType,
            connectorType: this.connectorType,
            isConnected: s,
            getEthereumProvider: async () => {
                if (!await s()) throw new br("Wallet is not currently connected.");
                return this.proxyProvider
            },
            sign: async a => {
                if (!await s()) throw new br("Wallet is not currently connected.");
                return await this.sign(a)
            },
            disconnect: () => {
                this.disconnect()
            }
        }
    }
    async syncAccounts(e) {
        let r, n = e;
        try {
            if (n === void 0) {
                let c = await m4(() => this.proxyProvider.request({
                    method: "eth_accounts"
                }), {
                    maxAttempts: 10,
                    delayMs: 500
                });
                console.debug(`eth_accounts for ${this.walletClientType}:`, c), Array.isArray(c) && (n = c)
            }
        } catch (c) {
            console.debug("Wallet did not respond to eth_accounts. Defaulting to prefetched accounts.", c)
        }
        if (!n || !Array.isArray(n) || n.length <= 0 || !n[0]) return;
        let i = n[0],
            s = Zr(i),
            a = [];
        if (this.walletClientType === "privy") {
            let c = rt.get(fv(s));
            this.chains.find(l => l.id === Number(c)) || (rt.del(fv(s)), c = null), r = c || `0x${this.defaultChain.id.toString(16)}`;
            try {
                await this.proxyProvider.request({
                    method: "wallet_switchEthereumChain",
                    params: [{
                        chainId: r
                    }]
                })
            } catch {
                console.warn(`Unable to switch embedded wallet to chain ID ${r} on initialization`)
            }
        } else try {
            let c = await m4(() => this.proxyProvider.request({
                method: "eth_chainId"
            }), {
                maxAttempts: 10,
                delayMs: 500
            });
            if (console.debug(`eth_chainId for ${this.walletClientType}:`, c), typeof c == "string") r = c;
            else {
                if (typeof c != "number") throw Error("Invalid chainId returned from provider");
                r = `0x${c.toString(16)}`
            }
        } catch (c) {
            console.warn("Failed to get chainId from provider, defaulting to 0x1", c), r = "0x1"
        }
        let o = am(r);
        if (!a.find(c => Zr(c.address) === s)) {
            let c = {
                name: this.walletBranding.name,
                icon: typeof this.walletBranding.icon == "string" ? this.walletBranding.icon : void 0,
                id: this.walletBranding.id
            };
            a.push(this.buildConnectedWallet(Zr(i), o, c, this.connectorType === "embedded_imported"))
        }
        w4(a, this.wallets) || (this.wallets = a, this.emit("walletsUpdated"))
    }
    async getConnectedWallet() {
        let e = await this.proxyProvider.request({
            method: "eth_accounts"
        });
        return this.wallets.sort((r, n) => n.connectedAt - r.connectedAt).find(r => e.find(n => Zr(n) === Zr(r.address))) || null
    }
    async isConnected() {
        let e = await this.proxyProvider.request({
            method: "eth_accounts"
        });
        return Array.isArray(e) && e.length > 0
    }
    async sign(e) {
        var r;
        return await this.connect({
            showPrompt: !1
        }), this.proxyProvider.request({
            method: "personal_sign",
            params: [cn(e), (r = this.wallets[0]) == null ? void 0 : r.address]
        })
    }
    subscribeListeners() {
        this.proxyProvider.on("accountsChanged", this.onAccountsChanged), this.proxyProvider.on("chainChanged", this.onChainChanged), this.proxyProvider.on("disconnect", this.onDisconnect), this.proxyProvider.on("connect", this.onConnect)
    }
    unsubscribeListeners() {
        this.proxyProvider.removeListener("accountsChanged", this.onAccountsChanged), this.proxyProvider.removeListener("chainChanged", this.onChainChanged), this.proxyProvider.removeListener("disconnect", this.onDisconnect), this.proxyProvider.removeListener("connect", this.onConnect)
    }
    constructor(e, r, n, i) {
        super(e), this.chainType = "ethereum", this.onAccountsChanged = s => {
            s.length === 0 ? this.onDisconnect() : this.syncAccounts(s)
        }, this.onChainChanged = s => {
            this.wallets.forEach(a => {
                a.chainId = am(s), this.walletClientType === "privy" && rt.put(fv(a.address), s)
            }), this.emit("walletsUpdated")
        }, this.onDisconnect = () => {
            this.connected = !1, this.wallets = [], this.emit("walletsUpdated")
        }, this.onConnect = async () => {
            this.connectorType === "base_account" && this.connected || (this.connected = !0, this.connectorType === "coinbase_wallet" && await l1(500), this.syncAccounts())
        }, this.wallets = [], this.walletClientType = e, this.chains = r, this.defaultChain = n, this.rpcConfig = i, this.rpcTimeoutDuration = u8(i, e), this.connected = !1, this.initialized = !1
    }
}
class fl {
    on(e, r) {
        if (this.walletProvider) return this.walletProvider.on(e, r);
        this._subscriptions.push({
            eventName: e,
            listener: r
        })
    }
    async request(e) {
        if (!this.walletProvider) throw new br(`A wallet request of type ${e.method} was made before setting a wallet provider.`);
        return Promise.race([this.walletProvider.request(e), this.walletTimeout()]).catch(r => {
            throw hl(r)
        })
    }
    constructor(e, r) {
        this.removeListener = (n, i) => {
            if (this.walletProvider) try {
                return this.walletProvider.removeListener(n, i)
            } catch {
                console.warn("Unable to remove wallet provider listener")
            }
        }, this.walletTimeout = (n = new bU, i = this.rpcTimeoutDuration) => new Promise((s, a) => setTimeout(() => {
            a(n)
        }, i)), this.setWalletProvider = n => {
            this.walletProvider && this._subscriptions.forEach(i => {
                this.removeListener(i.eventName, i.listener)
            }), this.walletProvider = n, this._subscriptions.forEach(i => {
                var s;
                (s = this.walletProvider) == null || s.on(i.eventName, i.listener)
            })
        }, this.walletProvider = e, this.rpcTimeoutDuration = r || Vy, this._subscriptions = []
    }
}
class y9e extends Bd {
    async initialize() {
        await this.importPromise, await this.syncAccounts(), this.initialized = !0, this.emit("initialized")
    }
    async connect(e) {
        return e.showPrompt && await this.promptConnection(), await this.isConnected() ? this.getConnectedWallet() : null
    }
    disconnect() {
        this.proxyProvider.walletProvider.disconnect(), this.onDisconnect()
    }
    get walletBranding() {
        return {
            name: this.displayName,
            icon: wU,
            id: "com.coinbase.wallet"
        }
    }
    async promptConnection() {
        try {
            await this.importPromise;
            let e = await this.proxyProvider.request({
                method: "eth_requestAccounts"
            });
            if (!e || e.length === 0 || !e[0]) throw new br("Unable to retrieve accounts");
            this.connected = !0, await this.syncAccounts([e[0]])
        } catch (e) {
            throw hl(e)
        }
    }
    constructor(e, r, n, i, s) {
        super("base_account", e, r, n), this.connectorType = "base_account", this.walletClientType = "base_account", this.displayName = "Base", this.setBaseAccountSdk = s, this.proxyProvider = new fl(void 0, this.rpcTimeoutDuration), this.subscribeListeners(), this.baseAccountConfig = { ...i,
            appChainIds: [r.id].concat(e.map(a => a.id))
        }, xu ? (this.proxyProvider.setWalletProvider(xu.getProvider()), this.setBaseAccountSdk(xu), console.log("Base Account SDK Initialized")) : this.importPromise = ma(() =>
            import ("./index-Zw94n4Z1.js"), __vite__mapDeps([5, 0, 1, 6, 3, 7, 8])).then(({
            createBaseAccountSDK: a
        }) => {
            xu = a(this.baseAccountConfig), this.proxyProvider.setWalletProvider(xu.getProvider()), this.setBaseAccountSdk(xu), console.log("Base Account SDK Initialized")
        }).catch(console.error)
    }
}
let w9e = [1, 11155111, 137, 10, 8453, 84532, 42161, 7777777, 43114, 56];
class b9e extends Bd {
    async initialize() {
        await this.syncAccounts(), this.initialized = !0, this.emit("initialized")
    }
    async connect(e) {
        return e.showPrompt && await this.promptConnection(), await this.isConnected() ? this.getConnectedWallet() : null
    }
    disconnect() {
        this.proxyProvider.walletProvider.disconnect(), this.onDisconnect()
    }
    get walletBranding() {
        return {
            name: this.displayName,
            icon: yU,
            id: "com.coinbase.wallet"
        }
    }
    async promptConnection() {
        try {
            let e = await this.proxyProvider.request({
                method: "eth_requestAccounts"
            });
            if (!e || e.length === 0 || !e[0]) throw new br("Unable to retrieve accounts");
            this.connected = !0, await this.syncAccounts([e[0]])
        } catch (e) {
            throw hl(e)
        }
    }
    updateConnectionPreference(e) {
        this.coinbaseWalletConfig = { ...this.coinbaseWalletConfig,
            preference: { ...this.coinbaseWalletConfig.preference,
                options: e
            }
        }, this.walletClientType = e === "smartWalletOnly" ? "coinbase_smart_wallet" : "coinbase_wallet", ff = d9({ ...this.coinbaseWalletConfig
        }), this.proxyProvider.setWalletProvider(ff.getProvider())
    }
    constructor(e, r, n, i) {
        var s, a;
        if (super("coinbase_wallet", e, r, n), this.connectorType = "coinbase_wallet", this.displayName = "Coinbase Wallet", this.proxyProvider = new fl(void 0, this.rpcTimeoutDuration), this.subscribeListeners(), this.coinbaseWalletConfig = { ...i,
                appChainIds: [r.id].concat(e.map(o => o.id))
            }, this.walletClientType = ((s = this.coinbaseWalletConfig.preference) == null ? void 0 : s.options) === "smartWalletOnly" ? "coinbase_smart_wallet" : "coinbase_wallet", this.walletClientType === "coinbase_smart_wallet" && (this.displayName = "Coinbase Smart Wallet"), !ff) {
            let o = ((a = this.coinbaseWalletConfig.preference) == null ? void 0 : a.options) !== "eoaOnly" ? (this.coinbaseWalletConfig.appChainIds ? ? []).filter(c => !w9e.includes(c)) : [];
            o.length > 0 && !o.every(c => JP.has(c)) && console.info(`The configured chains are not supported by Coinbase Smart Wallet: ${o.join(", ")}`), ff = d9(this.coinbaseWalletConfig)
        }
        this.proxyProvider.setWalletProvider(ff.getProvider())
    }
}
const EU = ({ ...t
}) => d.jsx("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...t,
    children: d.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M2.37126 11.0323C2.37126 12.696 3.90598 13.4421 5.40654 13.4468C8.91753 13.4468 12.8021 11.2897 12.7819 7.67984C12.7673 5.07728 10.3748 2.86167 7.54357 2.88296C4.8495 2.88296 2.21821 4.6411 2.21803 7.03628C2.21803 7.67951 2.58722 8.30178 3.55231 8.37184C2.74763 9.16826 2.37126 10.1225 2.37126 11.0323ZM7.55283 8.68012C8.11562 8.68012 8.57186 8.13217 8.57186 7.45624C8.57186 6.78032 8.11562 6.23237 7.55283 6.23237C6.99003 6.23237 6.53379 6.78032 6.53379 7.45624C6.53379 8.13217 6.99003 8.68012 7.55283 8.68012ZM10.4747 8.68012C11.0375 8.68012 11.4937 8.13217 11.4937 7.45625C11.4937 6.78032 11.0375 6.23237 10.4747 6.23237C9.91186 6.23237 9.45562 6.78032 9.45562 7.45625C9.45562 8.13217 9.91186 8.68012 10.4747 8.68012Z",
        fill: t.color || "var(--privy-color-foreground-3)"
    })
});
class l$ extends Bd {
    async initialize() {
        await this.syncAccounts(), this.initialized = !0, this.emit("initialized")
    }
    async connect(e) {
        return await this.isConnected() ? (await this.proxyProvider.request({
            method: "wallet_switchEthereumChain",
            params: [y4((e == null ? void 0 : e.chainId) || "0x1")]
        }), this.getConnectedWallet()) : null
    }
    get walletBranding() {
        return {
            name: "Privy Wallet",
            icon: EU,
            id: "io.privy.wallet"
        }
    }
    disconnect() {
        this.connected = !1
    }
    async promptConnection() {}
    constructor({
        provider: e,
        chains: r,
        defaultChain: n,
        rpcConfig: i,
        imported: s,
        walletIndex: a
    }) {
        super("privy", r, n, i), this.connectorType = "embedded", this.proxyProvider = e, this.walletIndex = a, s && (this.connectorType = "embedded_imported"), this.subscribeListeners()
    }
}
const v9e = ["eth_sign", "eth_populateTransactionRequest", "eth_signTransaction", "personal_sign", "eth_signTypedData_v4", "csw_signUserOperation", "secp256k1_sign"];
class Xs extends Error {
    constructor(e, r, n) {
        super(e), this.code = r, this.data = n
    }
}
class d$ extends Ed {
    async handleSendTransaction(e) {
        if (!e.params || !Array.isArray(e.params)) throw new Xs(`Invalid params for ${e.method}`, 4200);
        let r = e.params[0];
        if (!await ir() || !this.address) throw new Xs("Disconnected", 4900);
        let {
            hash: n
        } = await TPe(r, {
            address: this.address
        });
        return n
    }
    async handleSignTransaction(e) {
        if (!e.params || !Array.isArray(e.params)) throw new Xs(`Invalid params for ${e.method}`, 4200);
        let r = e.params[0];
        if (!await ir() || !this.address) throw new Xs("Disconnected", 4900);
        let {
            signature: n
        } = await SPe(r, {
            address: this.address
        });
        return n
    }
    handleSwitchEthereumChain(e) {
        let r;
        if (!e.params || !Array.isArray(e.params)) throw new Xs(`Invalid params for ${e.method}`, 4200);
        if (typeof e.params[0] == "string") r = e.params[0];
        else {
            if (!("chainId" in e.params[0]) || typeof e.params[0].chainId != "string") throw new Xs(`Invalid params for ${e.method}`, 4200);
            r = e.params[0].chainId
        }
        this.chainId = Number(r), this.publicClient = oh(this.chainId, this.chains, this.rpcConfig, {
            appId: this.appId
        }), this.emit("chainChanged", r)
    }
    async handlePersonalSign(e) {
        if (!e.params || !Array.isArray(e.params)) throw Error("Invalid params for personal_sign");
        let r = e.params[0],
            n = e.params[1],
            {
                signature: i
            } = await IPe({
                message: r
            }, {
                address: n
            });
        return i
    }
    async handleSignedTypedData(e) {
        if (!e.params || !Array.isArray(e.params)) throw Error("Invalid params for eth_signTypedData_v4");
        let r = e.params[0],
            n = typeof e.params[1] == "string" ? JSON.parse(e.params[1]) : e.params[1],
            {
                signature: i
            } = await $Pe(om(n), {
                address: r
            });
        return i
    }
    async handleEstimateGas(e) {
        if (!e.params || !Array.isArray(e.params)) throw Error("Invalid params for eth_estimateGas");
        delete e.params[0].gasPrice, delete e.params[0].maxFeePerGas, delete e.params[0].maxPriorityFeePerGas;
        let r = { ...e.params[0],
            chainId: y4(this.chainId)
        };
        return await this.publicClient.estimateGas({
            account: r.from ? ? this.address,
            ...ZO(r)
        })
    }
    async request(e) {
        switch (console.debug("Embedded1193Provider.request() called with args", e), e.method) {
            case "eth_accounts":
            case "eth_requestAccounts":
                return this.address ? [this.address] : [];
            case "eth_chainId":
                return y4(this.chainId);
            case "eth_estimateGas":
                return this.handleEstimateGas(e);
            case "eth_sendTransaction":
                return this.handleSendTransaction(e);
            case "eth_signTransaction":
                return this.handleSignTransaction(e);
            case "wallet_switchEthereumChain":
                return this.handleSwitchEthereumChain(e);
            case "personal_sign":
                return this.handlePersonalSign(e);
            case "eth_signTypedData_v4":
                return this.handleSignedTypedData(e)
        }
        if (!(r => v9e.includes(r))(e.method)) return this.publicClient.request({
            method: e.method,
            params: e.params
        }); {
            let r = await ir();
            if (await PPe({
                    address: this.address
                }), !r || !this.address) throw new Xs("Disconnected", 4900);
            try {
                let n = {
                        method: e.method,
                        params: e.params
                    },
                    i = this.walletAccount;
                return i && fn(i) ? this.handleWalletApiRequest(n, i, r) : (await this.walletProxy.rpc({
                    accessToken: r,
                    entropyId: this.entropyId,
                    entropyIdVerifier: this.entropyIdVerifier,
                    chainType: "ethereum",
                    hdWalletIndex: this.walletIndex,
                    request: n
                })).response.data
            } catch (n) {
                throw console.error(n), new Xs("Disconnected", 4900)
            }
        }
    }
    async handleWalletApiRequest(e, r, n) {
        let i = this.privyClient;
        if (!i) throw new Xs("Disconnected", 4900);
        if (e.method === "secp256k1_sign") {
            let s = await Ni(i, async ({
                message: a
            }) => this.walletProxy.signWithUserSigner({
                accessToken: n,
                message: a
            }), {
                chain_type: "ethereum",
                method: "secp256k1_sign",
                wallet_id: r.id,
                params: {
                    hash: e.params[0]
                }
            });
            if (s.method !== "secp256k1_sign") throw new Xs(`Invalid params for ${e.method}`, 4200);
            return s.data.signature
        }
        throw new Xs(`Method not supported: ${e.method}`, 4200)
    }
    constructor({
        walletProxy: e,
        address: r,
        entropyId: n,
        entropyIdVerifier: i,
        rpcConfig: s,
        chains: a,
        appId: o,
        chainId: c = 1,
        walletIndex: l,
        privyClient: u,
        walletAccount: h
    }) {
        super(), this.walletProxy = e, this.address = r, this.entropyId = n, this.entropyIdVerifier = i, this.chainId = c, this.rpcConfig = s, this.chains = a, this.publicClient = oh(c, this.chains, s, {
            appId: o
        }), this.rpcTimeoutDuration = u8(s, "privy"), this.appId = o, this.walletIndex = l, this.privyClient = u, this.walletAccount = h
    }
}
class h8 extends Bd {
    get walletBranding() {
        return {
            id: this.id,
            name: this.name,
            icon: this.icon
        }
    }
    async initialize() {
        this.initialized = !0, this.emit("initialized")
    }
    async connect() {
        throw Error("connect called for an uninstalled wallet via the EthereumNullConnector")
    }
    disconnect() {
        throw Error("disconnect called for an uninstalled wallet via the EthereumNullConnector")
    }
    promptConnection(e) {
        throw Error(`promptConnection called for an uninstalled wallet via the EthereumNullConnector for ${e}`)
    }
    constructor({
        id: e,
        name: r,
        icon: n,
        walletClientType: i,
        defaultChain: s
    }) {
        super(i, [], s, {}), this.connectorType = "null", this.proxyProvider = new fl(void 0, Vy), this.id = e, this.name = r, this.icon = n, this.connectorType = i
    }
}
const f8 = ({
        style: t,
        ...e
    }) => d.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: 1.5,
        viewBox: "0 0 24 24",
        style: { ...t
        },
        ...e,
        children: d.jsx("path", {
            strokeLinecap: "round",
            strokeLinejoin: "round",
            d: "M9 17.25v1.007a3 3 0 01-.879 2.122L7.5 21h9l-.621-.621A3 3 0 0115 18.257V17.25m6-12V15a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 15V5.25m18 0A2.25 2.25 0 0018.75 3H5.25A2.25 2.25 0 003 5.25m18 0V12a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 12V5.25"
        })
    }),
    x9e = ({
        style: t,
        ...e
    }) => d.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        xmlSpace: "preserve",
        x: 0,
        y: 0,
        viewBox: "0 0 318.6 318.6",
        width: "28",
        height: "28",
        style: {
            height: "28px",
            width: "28px",
            ...t
        },
        ...e,
        children: [d.jsx("style", {
            children: ".s1{stroke-linecap:round;stroke-linejoin:round}.s2{fill:#e4761b;stroke:#e4761b}.s3{fill:#f6851b;stroke:#f6851b}"
        }), d.jsx("path", {
            fill: "#e2761b",
            stroke: "#e2761b",
            className: "s1",
            d: "m274.1 35.5-99.5 73.9L193 65.8z"
        }), d.jsx("path", {
            d: "m44.4 35.5 98.7 74.6-17.5-44.3zm193.9 171.3-26.5 40.6 56.7 15.6 16.3-55.3zm-204.4.9L50.1 263l56.7-15.6-26.5-40.6z",
            className: "s1 s2"
        }), d.jsx("path", {
            d: "m103.6 138.2-15.8 23.9 56.3 2.5-2-60.5zm111.3 0-39-34.8-1.3 61.2 56.2-2.5zM106.8 247.4l33.8-16.5-29.2-22.8zm71.1-16.5 33.9 16.5-4.7-39.3z",
            className: "s1 s2"
        }), d.jsx("path", {
            fill: "#d7c1b3",
            stroke: "#d7c1b3",
            className: "s1",
            d: "m211.8 247.4-33.9-16.5 2.7 22.1-.3 9.3zm-105 0 31.5 14.9-.2-9.3 2.5-22.1z"
        }), d.jsx("path", {
            fill: "#233447",
            stroke: "#233447",
            className: "s1",
            d: "m138.8 193.5-28.2-8.3 19.9-9.1zm40.9 0 8.3-17.4 20 9.1z"
        }), d.jsx("path", {
            fill: "#cd6116",
            stroke: "#cd6116",
            className: "s1",
            d: "m106.8 247.4 4.8-40.6-31.3.9zM207 206.8l4.8 40.6 26.5-39.7zm23.8-44.7-56.2 2.5 5.2 28.9 8.3-17.4 20 9.1zm-120.2 23.1 20-9.1 8.2 17.4 5.3-28.9-56.3-2.5z"
        }), d.jsx("path", {
            fill: "#e4751f",
            stroke: "#e4751f",
            className: "s1",
            d: "m87.8 162.1 23.6 46-.8-22.9zm120.3 23.1-1 22.9 23.7-46zm-64-20.6-5.3 28.9 6.6 34.1 1.5-44.9zm30.5 0-2.7 18 1.2 45 6.7-34.1z"
        }), d.jsx("path", {
            d: "m179.8 193.5-6.7 34.1 4.8 3.3 29.2-22.8 1-22.9zm-69.2-8.3.8 22.9 29.2 22.8 4.8-3.3-6.6-34.1z",
            className: "s3"
        }), d.jsx("path", {
            fill: "#c0ad9e",
            stroke: "#c0ad9e",
            className: "s1",
            d: "m180.3 262.3.3-9.3-2.5-2.2h-37.7l-2.3 2.2.2 9.3-31.5-14.9 11 9 22.3 15.5h38.3l22.4-15.5 11-9z"
        }), d.jsx("path", {
            fill: "#161616",
            stroke: "#161616",
            className: "s1",
            d: "m177.9 230.9-4.8-3.3h-27.7l-4.8 3.3-2.5 22.1 2.3-2.2h37.7l2.5 2.2z"
        }), d.jsx("path", {
            fill: "#763d16",
            stroke: "#763d16",
            className: "s1",
            d: "m278.3 114.2 8.5-40.8-12.7-37.9-96.2 71.4 37 31.3 52.3 15.3 11.6-13.5-5-3.6 8-7.3-6.2-4.8 8-6.1zM31.8 73.4l8.5 40.8-5.4 4 8 6.1-6.1 4.8 8 7.3-5 3.6 11.5 13.5 52.3-15.3 37-31.3-96.2-71.4z"
        }), d.jsx("path", {
            d: "m267.2 153.5-52.3-15.3 15.9 23.9-23.7 46 31.2-.4h46.5zm-163.6-15.3-52.3 15.3-17.4 54.2h46.4l31.1.4-23.6-46zm71 26.4 3.3-57.7 15.2-41.1h-67.5l15 41.1 3.5 57.7 1.2 18.2.1 44.8h27.7l.2-44.8z",
            className: "s3"
        })]
    }),
    _U = ({
        style: t,
        ...e
    }) => d.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "108",
        height: "108",
        viewBox: "0 0 108 108",
        fill: "none",
        style: {
            height: "28px",
            width: "28px",
            ...t
        },
        ...e,
        children: [d.jsx("rect", {
            width: "108",
            height: "108",
            rx: "23",
            fill: "#AB9FF2"
        }), d.jsx("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M46.5267 69.9229C42.0054 76.8509 34.4292 85.6182 24.348 85.6182C19.5824 85.6182 15 83.6563 15 75.1342C15 53.4305 44.6326 19.8327 72.1268 19.8327C87.768 19.8327 94 30.6846 94 43.0079C94 58.8258 83.7355 76.9122 73.5321 76.9122C70.2939 76.9122 68.7053 75.1342 68.7053 72.314C68.7053 71.5783 68.8275 70.7812 69.0719 69.9229C65.5893 75.8699 58.8685 81.3878 52.5754 81.3878C47.993 81.3878 45.6713 78.5063 45.6713 74.4598C45.6713 72.9884 45.9768 71.4556 46.5267 69.9229ZM83.6761 42.5794C83.6761 46.1704 81.5575 47.9658 79.1875 47.9658C76.7816 47.9658 74.6989 46.1704 74.6989 42.5794C74.6989 38.9885 76.7816 37.1931 79.1875 37.1931C81.5575 37.1931 83.6761 38.9885 83.6761 42.5794ZM70.2103 42.5795C70.2103 46.1704 68.0916 47.9658 65.7216 47.9658C63.3157 47.9658 61.233 46.1704 61.233 42.5795C61.233 38.9885 63.3157 37.1931 65.7216 37.1931C68.0916 37.1931 70.2103 38.9885 70.2103 42.5795Z",
            fill: "#FFFDF8"
        })]
    });

function mv(t, e) {
    if (!Object.prototype.hasOwnProperty.call(t, e)) throw TypeError("attempted to use private field on non-instance");
    return t
}
var E9e = 0;
class CU extends Bd {
    async initialize() {
        await this.syncAccounts(), this.initialized = !0, this.emit("initialized")
    }
    async connect(e) {
        return e.showPrompt && await this.promptConnection(), await this.isConnected() ? this.getConnectedWallet() : null
    }
    get walletBranding() {
        return {
            name: this.providerDetail.info.name,
            icon: this.providerDetail.info.icon,
            id: this.providerDetail.info.rdns
        }
    }
    disconnect() {
        console.warn(`Programmatic disconnect with ${this.providerDetail.info.name} is not yet supported.`)
    }
    async promptConnection() {
        try {
            let e = await this.proxyProvider.request({
                method: "eth_requestAccounts"
            });
            if (!e || e.length === 0 || !e[0]) throw new br("Unable to retrieve accounts");
            await this.syncAccounts([e[0]])
        } catch (e) {
            throw hl(e)
        }
    }
    constructor(e, r, n, i, s) {
        super(s || "unknown", e, r, n), this.connectorType = "injected", this.proxyProvider = new fl(void 0, this.rpcTimeoutDuration), this.subscribeListeners(), this.providerDetail = i;
        let a = i.provider;
        this.proxyProvider.setWalletProvider(a)
    }
}
var kl = "__private_" + E9e++ + "__walletBranding";
class yv extends Bd {
    async initialize() {
        await this.syncAccounts(), this.initialized = !0, this.emit("initialized")
    }
    async connect(e) {
        return e.showPrompt && await this.promptConnection(), await this.isConnected() ? this.getConnectedWallet() : null
    }
    get walletBranding() {
        return mv(this, kl)[kl] ? ? {
            name: "Browser Extension",
            icon: f8,
            id: "extension"
        }
    }
    disconnect() {
        console.warn("Programmatic disconnect with browser wallets is not yet supported.")
    }
    async promptConnection() {
        try {
            let e = await this.proxyProvider.request({
                method: "eth_requestAccounts"
            });
            if (!e || e.length === 0 || !e[0]) throw new br("Unable to retrieve accounts");
            await this.syncAccounts([e[0]])
        } catch (e) {
            throw hl(e)
        }
    }
    constructor(e, r, n, i, s) {
        super(s ? ? "unknown", e, r, n), Object.defineProperty(this, kl, {
            writable: !0,
            value: void 0
        }), this.connectorType = "injected", this.proxyProvider = new fl(void 0, this.rpcTimeoutDuration), this.subscribeListeners(), this.proxyProvider.setWalletProvider(i), s === "metamask" ? mv(this, kl)[kl] = {
            name: "MetaMask",
            icon: x9e,
            id: "io.metamask"
        } : s === "phantom" && (mv(this, kl)[kl] = {
            name: "Phantom",
            icon: _U,
            id: "phantom"
        })
    }
}
class _9e extends CU {
    disconnect() {
        console.warn("MetaMask does not support programmatic disconnect.")
    }
    async promptConnection() {
        try {
            gr.isMobile || await this.proxyProvider.request({
                method: "wallet_requestPermissions",
                params: [{
                    eth_accounts: {}
                }]
            });
            let e = await this.proxyProvider.request({
                method: "eth_requestAccounts"
            });
            if (!e || e.length === 0 || !e[0]) throw new br("Unable to retrieve accounts");
            await this.syncAccounts([e[0]])
        } catch (e) {
            throw hl(e)
        }
    }
}
const C9e = ["metamask", "phantom", "brave_wallet", "rainbow", "uniswap_wallet_extension", "uniswap_extension", "rabby_wallet", "bybit_wallet", "ronin_wallet", "haha_wallet", "crypto.com_wallet_extension", "crypto.com_onchain", "binance", "coinbase_wallet", "coinbase_smart_wallet", "base_account", "metamask", "trust", "safe", "rainbow", "uniswap", "zerion", "argent", "spot", "omni", "cryptocom", "blockchain", "safepal", "bitkeep", "zengo", "1inch", "binance", "exodus", "mew_wallet", "alphawallet", "keyring_pro", "mathwallet", "unstoppable", "obvious", "ambire", "internet_money_wallet", "coin98", "abc_wallet", "arculus_wallet", "haha", "cling_wallet", "broearn", "copiosa", "burrito_wallet", "enjin_wallet", "plasma_wallet", "avacus", "bee", "pitaka", "pltwallet", "minerva", "kryptogo", "prema", "slingshot", "kriptonio", "timeless", "secux", "bitizen", "blocto", "okx_wallet", "safemoon", "rabby_wallet", "bybit_wallet", "ronin_wallet", "haha_wallet", "privy", "unknown", "phantom", "solflare", "glow", "backpack"],
    p8 = Object.freeze({
        phantom: {
            client: "phantom",
            name: "Phantom",
            installLink: gr.isFirefox ? "https://addons.mozilla.org/en-US/firefox/addon/phantom-app/" : "https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa?hl=en",
            chainTypes: ["ethereum", "solana"],
            get isInstalled() {
                var t, e, r, n, i, s;
                if ("phantom" in window) {
                    let a = window;
                    if ((e = (t = a == null ? void 0 : a.phantom) == null ? void 0 : t.ethereum) != null && e.isPhantom && ((n = (r = a == null ? void 0 : a.phantom) == null ? void 0 : r.ethereum) != null && n.chainId) || (s = (i = a == null ? void 0 : a.phantom) == null ? void 0 : i.solana) != null && s.isPhantom) return !0
                }
                return !1
            },
            getMobileRedirect({
                useUniversalLink: t,
                isSolana: e,
                connectOnly: r
            }) {
                let n = Ng({
                    client: this.client,
                    isSolana: e,
                    connectOnly: r
                });
                return `${t?"phantom://":"https://phantom.app/ul/"}browse/${n}?ref=${n}`
            }
        },
        solflare: {
            client: "solflare",
            name: "Solflare",
            installLink: gr.isFirefox ? "https://addons.mozilla.org/es/firefox/addon/solflare-wallet/" : "https://chromewebstore.google.com/detail/solflare-wallet/bhhhlbepdkbapadjdnnojkbgioiodbic",
            chainTypes: ["solana"],
            get isInstalled() {
                var t;
                return "solflare" in window && !!((t = window == null ? void 0 : window.solflare) != null && t.isSolflare)
            },
            getMobileRedirect({
                useUniversalLink: t,
                isSolana: e,
                connectOnly: r
            }) {
                let n = Ng({
                    client: this.client,
                    isSolana: e,
                    connectOnly: r
                });
                return `${t?"solflare://ul/v1/":"https://solflare.com/ul/v1/"}browse/${n}?ref=${n}`
            }
        },
        backpack: {
            client: "backpack",
            name: "Backpack",
            installLink: "https://chromewebstore.google.com/detail/backpack/aflkmfhebedbjioipglgcbcmnbpgliof",
            chainTypes: ["ethereum", "solana"],
            get isInstalled() {
                var t, e, r, n;
                return !(!("backpack" in window) || !((e = (t = window == null ? void 0 : window.backpack) == null ? void 0 : t.ethereum) != null && e.isBackpack) && !((n = (r = window == null ? void 0 : window.backpack) == null ? void 0 : r.solana) != null && n.isBackpack))
            },
            getMobileRedirect({
                useUniversalLink: t,
                isSolana: e,
                connectOnly: r
            }) {
                let n = Ng({
                    client: this.client,
                    isSolana: e,
                    connectOnly: r
                });
                return `${t?"backpack://ul/v1/":"https://backpack.com/ul/v1/"}browse/${n}?ref=${n}`
            }
        },
        okx_wallet: {
            client: "okx_wallet",
            name: "OKX Wallet",
            installLink: "https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge",
            chainTypes: ["solana"],
            get isInstalled() {
                var t;
                return "okxwallet" in window && !!((t = window == null ? void 0 : window.okxwallet) != null && t.isOkxWallet)
            },
            getMobileRedirect({
                isSolana: t,
                connectOnly: e
            }) {
                return "https://www.okx.com/download?deeplink=" + encodeURIComponent("okx://wallet/dapp/url?dappUrl=" + Ng({
                    client: this.client,
                    isSolana: t,
                    connectOnly: e
                }))
            }
        }
    });

function AU({
    connectorType: t,
    walletClientType: e
}) {
    for (let r of C9e)
        if (t === r || e === r) return p8[r]
}

function Ng({
    client: t,
    isSolana: e,
    connectOnly: r
}) {
    let n = new URL(window.location.href);
    return n.searchParams.set("privy_connector", e ? "solana_adapter" : "injected"), n.searchParams.set("privy_wallet_client", t), n.searchParams.set("privy_connect_only", String(r)), encodeURIComponent(n.href.replace(/\/$/g, ""))
}
const cm = () => {
    let t = rt.get(QL);
    return t && Array.isArray(t) && t.map(e => (r => r && typeof r.address == "string" && typeof r.connectorType == "string" && typeof r.walletClientType == "string" && typeof r.connectedAt == "number")(e)).every(Boolean) ? t : []
};
let A9e = ["phantom", "glow", "solflare", "backpack", "okx_wallet", "walletconnect"];

function k9e(t) {
    return t.chainType === "solana"
}

function u$(t) {
    return t.type === "solana"
}
class I9e extends xU {
    get isInstalled() {
        return this.adapter.readyState === "Installed"
    }
    get wallet() {
        return this.adapter.wallet
    }
    buildConnectedWallet(e, r) {
        let n, i, s, a;
        if (e.readyState !== "Installed" || !e.publicKey) throw Error("Wallet is not connected.");
        return "signMessage" in e && (n = async (...o) => {
            if (!e.connected) throw Error("Wallet is not connected.");
            return await e.signMessage(o[0])
        }), "sendTransaction" in e && (i = async (...o) => await e.sendTransaction(o[0], o[1], o[2])), "signTransaction" in e && (s = async o => await e.signTransaction(o)), "signAllTransactions" in e && (a = async o => await e.signAllTransactions(o)), {
            type: "solana",
            address: e.publicKey.toBase58(),
            meta: r,
            imported: !1,
            connectedAt: Date.now(),
            walletClientType: this.walletClientType,
            connectorType: this.connectorType,
            isConnected: async () => e.connected,
            disconnect: () => {
                try {
                    e.disconnect()
                } catch {
                    console.error("Wallet does not support programmatic disconnect")
                }
            },
            getProvider: Hh(`${this.walletClientType||""} wallet does not support 'getProvider'`),
            signMessage: n ? ? Hh(`${this.walletClientType||""} wallet does not support 'signMessage'`),
            sendTransaction: i ? ? Hh(`${this.walletClientType||""} wallet does not support 'sendTransaction'`),
            signTransaction: s ? ? Hh(`${this.walletClientType||""} wallet does not support 'signTransaction'`),
            signAllTransactions: a ? ? Hh(`${this.walletClientType||""} wallet does not support 'signAllTransactions'`)
        }
    }
    async syncAccounts() {
        if (this.adapter.readyState === "Installed" && this.adapter.publicKey) {
            let e = {
                name: this.walletBranding.name,
                icon: typeof this.walletBranding.icon == "string" ? this.walletBranding.icon : void 0,
                id: this.walletBranding.id
            };
            this.wallets.find(r => this.adapter.publicKey && r.address === this.adapter.publicKey.toBase58()) || (this.wallets = [this.buildConnectedWallet(this.adapter, e)], this.emit("walletsUpdated"))
        } else this.wallets.length > 0 && (this.wallets = [], this.emit("walletsUpdated"))
    }
    get walletBranding() {
        return {
            id: this.adapter.name,
            name: this.adapter.name,
            icon: this.adapter.icon
        }
    }
    async initialize() {
        this.subscribeListeners(), await this.syncAccounts(), this.shouldAttemptAutoConnect() && await this.adapter.autoConnect().catch(() => {}), this.initialized = !0, this.emit("initialized")
    }
    async connect(e) {
        return e.showPrompt && await this.promptConnection(), await this.isConnected() ? this.getConnectedWallet() : null
    }
    async getConnectedWallet() {
        return this.wallets.sort((e, r) => r.connectedAt - e.connectedAt)[0] || null
    }
    async isConnected() {
        return this.adapter.connected && ["Installed"].includes(this.adapter.readyState)
    }
    subscribeListeners() {
        this.adapter.addListener("disconnect", this.onDisconnect), this.adapter.addListener("connect", this.onConnect), this.adapter.addListener("error", this.onError), this.adapter.addListener("readyStateChange", this.onReadyStateChange)
    }
    unsubscribeListeners() {
        this.adapter.removeAllListeners()
    }
    shouldAttemptAutoConnect() {
        return !(!this.autoConnectEnabled || !A9e.includes(this.walletClientType)) && (this.walletClientType !== "phantom" || cm().some(({
            walletClientType: e
        }) => e === "phantom"))
    }
    constructor(e, r) {
        super(function(n) {
            return n.name.toLowerCase().split(" ").join("_")
        }(e)), this.chainType = "solana", this.connectorType = "solana_adapter", this.disconnect = () => {
            this.adapter.disconnect().then(() => this.onDisconnect()).catch(n => console.error("Error disconnecting", n))
        }, this.promptConnection = async () => {
            try {
                await this.adapter.connect()
            } catch (n) {
                throw hl(n)
            }
        }, this.onDisconnect = () => {
            this.syncAccounts()
        }, this.onConnect = n => {
            this.syncAccounts()
        }, this.onError = n => {
            this.syncAccounts()
        }, this.onReadyStateChange = n => {
            n !== "Installed" && (this.connected = !1), this.syncAccounts()
        }, this.adapter = e, this.autoConnectEnabled = r, this.wallets = []
    }
}
class g8 extends I9e {
    get walletBranding() {
        return {
            id: this.id,
            name: this.name,
            icon: this.icon
        }
    }
    async initialize() {
        this.initialized = !0, this.emit("initialized")
    }
    async connect() {
        throw Error("connect called for an uninstalled wallet via the SolanaNullConnector")
    }
    constructor({
        id: e,
        name: r,
        icon: n
    }) {
        super({
            name: r
        }, !1), this.connectorType = "null", this.proxyProvider = new fl(void 0, Vy), this.disconnect = async () => {
            throw Error("disconnect called for an uninstalled wallet via the SolanaNullConnector")
        }, this.promptConnection = async () => {
            throw Error("promptConnection called for an uninstalled wallet via the SolanaNullConnector")
        }, this.id = e, this.name = r, this.icon = n
    }
}
const N0 = vh(() => ({
        listings: []
    })),
    $9e = N0.setState,
    wv = t => {
        let e;
        try {
            e = new URL(t).hostname
        } catch {
            return
        }
        return N0.getState().listings.find(({
            homepage: r
        }) => {
            let n;
            try {
                n = new URL(r).hostname
            } catch {
                return !1
            }
            return e.includes(n)
        })
    },
    mc = t => N0(({
        listings: e
    }) => e.find(({
        slug: r
    }) => d1(r) === d1(t)));

function d1(t) {
    return t === "cryptocom" ? "cryptocom-defi" : t === "binance" ? "binance-defi" : t.replace(/[-_]wallet$/, "")
}

function S9e({
    src: t,
    ...e
}) {
    return d.jsx("img", {
        src: t,
        ...e,
        style: {
            display: "none"
        }
    })
}
const ea = {
    appearance: {
        landingHeader: "Log in or sign up",
        theme: "light",
        accentColor: "#676FFF",
        walletList: ["detected_wallets", "metamask", "coinbase_wallet", "rainbow", "wallet_connect"]
    },
    walletConnectCloudProjectId: "34357d3c125c2bcf2ce2bc3309d98715",
    externalWallets: {
        coinbaseWallet: {
            connectionOptions: "all"
        }
    },
    captchaEnabled: !1,
    _render: {
        standalone: !1
    },
    fundingMethodConfig: {
        moonpay: {
            useSandbox: !1
        }
    }
};
let T9e = new Set(["coinbase_wallet", "base_account", "cryptocom", "metamask", "okx_wallet", "phantom", "rainbow", "uniswap", "zerion", "universal_profile", "bybit_wallet", "ronin_wallet", "haha_wallet", "wallet_connect", "detected_wallets", "detected_solana_wallets", "detected_ethereum_wallets", "rabby_wallet", "safe", "solflare", "backpack", "binance"]),
    h$ = t => T9e.has(t),
    f$ = (t, e, r) => r.indexOf(t) === e;
const b4 = 792703809,
    v4 = "11111111111111111111111111111111";

function Nh(t) {
    return t.includes("testnet") ? "testnet" : t.includes("devnet") ? "devnet" : "mainnet-beta"
}

function P9e(t, e) {
    return `https://explorer.solana.com/account/${t}?cluster=${e}`
}
let p$ = "#FFFFFF";

function ki(t, e) {
    let r = Math.max(0, Math.min(1, t.toHsl().l + e));
    return tt({ ...t.toHsl(),
        l: r
    })
}

function N9e({
    backgroundTheme: t,
    accentHex: e
}) {
    let r;
    switch (t) {
        case "light":
            r = p$;
            break;
        case "dark":
            r = "#1E1E1D";
            break;
        default:
            r = t
    }
    let n = tt(r),
        i = tt(e),
        s = tt("#51BA81"),
        a = tt("#FFB74D"),
        o = tt("#EC6351"),
        c = function(T) {
            return T < .8 && T > .2 && console.warn("Background color is not light or dark enough, which could lead to accessibility issues."), T > .5 ? "light" : "dark"
        }(n.getLuminance()),
        l = ki(n, c === "light" ? -.04 : .11),
        u = ki(n, c === "light" ? -.08 : .16),
        h = ki(n, c === "light" ? -.88 : .87),
        f = ki(n, c === "light" ? -.7 : .75),
        p = ki(n, c === "light" ? -.43 : .45).desaturate(c === "light" ? 60 : 20),
        g = ki(n, c === "light" ? -.08 : .25).desaturate(c === "light" ? 60 : 20),
        m = ki(i, .15),
        y = ki(i, .25),
        w = ki(i, -.06),
        x = ki(i, -.6),
        E = ki(o, .3),
        _ = ki(a, .3),
        b = tt(i.getLuminance() > .5 ? "#040217" : p$),
        A = ki(s, -.16),
        I = ki(s, .4);
    return {
        colorScheme: c,
        background: n.toHslString(),
        background2: l.toHslString(),
        background3: u.toHslString(),
        foreground: h.toHslString(),
        foreground2: f.toHslString(),
        foreground3: p.toHslString(),
        foreground4: g.toHslString(),
        accent: i.toHslString(),
        accentLight: m.toHslString(),
        accentLightest: y.toHslString(),
        accentDark: w.toHslString(),
        accentDarkest: x.toHslString(),
        foregroundAccent: b.toHslString(),
        success: s.toHslString(),
        successDark: A.toHslString(),
        successLight: I.toHslString(),
        error: o.toHslString(),
        errorLight: E.toHslString(),
        warn: a.toHslString(),
        warnLight: _.toHslString()
    }
}

function kU(t, e, r, n) {
    var Y, X, ne, ae, ue, he, fe, de, ye, Be, ce, Ie, xe, ie, Ee, ft, Ae, Le, Te, Ue, De, We, dt, He, ut, Ye, we, vt, Lt, _t, tr, dr, Yt, Ot, mt, ur, Vr, pt, Un, ei, ti, Fn, L, B, Q, G, re, se, me, ve, Ze, kt, Re, ct, it, lt, Se, yt, It, Mt, jt, sr;
    let i, s, a, o, c, l, u, h, f, p, g, m, y, w, x, E, _ = r ? console.warn : () => {};
    e != null && e.loginMethods ? (i = e.loginMethods.includes("email"), s = e.loginMethods.includes("sms"), o = e.loginMethods.includes("wallet"), c = e.loginMethods.includes("google"), l = e.loginMethods.includes("twitter"), u = e.loginMethods.includes("discord"), p = e.loginMethods.includes("spotify"), g = e.loginMethods.includes("instagram"), h = e.loginMethods.includes("tiktok"), f = e.loginMethods.includes("line"), y = e.loginMethods.includes("github"), m = e.loginMethods.includes("linkedin"), w = e.loginMethods.includes("apple"), x = e.loginMethods.includes("farcaster"), E = e.loginMethods.includes("telegram"), a = e.loginMethods.includes("passkey")) : (i = t.email_auth, s = t.sms_auth, o = t.wallet_auth || t.solana_wallet_auth, c = t.google_oauth, l = t.twitter_oauth, u = t.discord_oauth, y = t.github_oauth, p = t.spotify_oauth, g = t.instagram_oauth, h = t.tiktok_oauth, f = t.line_oauth, m = t.linkedin_oauth, w = t.apple_oauth, x = t.farcaster_auth, E = t.telegram_auth, a = t.passkey_auth), t.passkey_auth && (a = !0), typeof window < "u" && typeof window.PublicKeyCredential != "function" && (a = !1);
    let b = [i, s].filter(Boolean),
        A = [c, l, u, y, p, g, h, f, m, w, x, E].filter(Boolean),
        I = [o].filter(Boolean),
        T = ((Y = e == null ? void 0 : e.loginMethods) == null ? void 0 : Y.includes("passkey")) ? ? !1,
        C = t.passkeys_for_signup_enabled ? ? !1,
        $ = [a && (C || T)].filter(Boolean);
    if (b.length + A.length + I.length + $.length === 0) throw Error("You must enable at least one login method");
    let P = ((X = e == null ? void 0 : e.appearance) == null ? void 0 : X.showWalletLoginFirst) !== void 0 ? (ne = e == null ? void 0 : e.appearance) == null ? void 0 : ne.showWalletLoginFirst : t.show_wallet_login_first;
    P && I.length === 0 ? (_("You should only enable `showWalletLoginFirst` when `wallet` logins are also enabled. `showWalletLoginFirst` has been set to false"), P = !1) : P || A.length + b.length !== 0 || (_("You should only disable `showWalletLoginFirst` when `email`, `sms`, or social logins are also enabled. `showWalletLoginFirst` has been set to true"), P = !0);
    let N = ((ue = (ae = e == null ? void 0 : e.externalWallets) == null ? void 0 : ae.walletConnect) == null ? void 0 : ue.enabled) ? ? !0;
    e != null && e.loginMethods && e.loginMethodsAndOrder && _("You should only configure one of `loginMethods` or `loginMethodsAndOrder`");
    let R = (({
            input: bt,
            overrides: St
        }) => St ? St.primary.concat(St.overflow ? ? []).filter(h$).filter(f$) : bt ? bt.filter(h$).filter(f$) : ea.appearance.walletList)({
            input: (he = e == null ? void 0 : e.appearance) == null ? void 0 : he.walletList,
            overrides: e == null ? void 0 : e.loginMethodsAndOrder
        }),
        D = (({
            input: bt
        }) => {
            if (!bt || !bt.primary[0]) return;
            let St = [bt.primary[0]],
                Ge = [];
            for (let Xe of (bt.primary.length > 4 && console.warn("You should not specify greater than 4 login methods in `loginMethodsAndOrder.primary`"), bt.primary.slice(1))) St.includes(Xe) ? console.warn(`Duplicated login method: ${Xe}`) : St.push(Xe);
            for (let Xe of bt.overflow ? ? []) St.includes(Xe) || Ge.includes(Xe) ? console.warn(`Duplicated login method: ${Xe}`) : Ge.push(Xe);
            return {
                primary: St,
                overflow: Ge
            }
        })({
            input: e == null ? void 0 : e.loginMethodsAndOrder
        }),
        S = ((fe = e == null ? void 0 : e.intl) == null ? void 0 : fe.defaultCountry) ? ? "US",
        {
            chains: O,
            defaultChain: M
        } = function({
            supportedChains: bt,
            defaultChainFromConfig: St
        }) {
            let Ge;
            if (bt) {
                if (bt.length === 0) throw Error("`supportedChains` must contain at least one chain");
                Ge = QP(bt)
            } else Ge = [...s0];
            let Xe = bt ? Ge[0] : Bs,
                mr = St ? ? Xe;
            if (!Ge.find(Ut => Ut.id === mr.id)) throw Error("`defaultChain` must be included in `supportedChains`");
            return {
                chains: Ge,
                defaultChain: mr
            }
        }({
            supportedChains: e == null ? void 0 : e.supportedChains,
            defaultChainFromConfig: e == null ? void 0 : e.defaultChain
        }),
        U = !!(e != null && e.defaultChain),
        k = ((de = e == null ? void 0 : e.customAuth) == null ? void 0 : de.getCustomAccessToken) && ((ye = e == null ? void 0 : e.customAuth) == null ? void 0 : ye.enabled) !== !1,
        F = (Be = e == null ? void 0 : e.embeddedWallets) == null ? void 0 : Be.requireUserPasswordOnCreate,
        q = (ce = e == null ? void 0 : e.embeddedWallets) == null ? void 0 : ce.createOnLogin,
        W = k ? "all-users" : t.embedded_wallet_config.ethereum.create_on_login,
        K = t.embedded_wallet_config.solana.create_on_login,
        H = {
            "mainnet-beta": {
                rpcUrl: "https://api.mainnet-beta.solana.com",
                blockExplorerUrl: "https://explorer.solana.com"
            },
            testnet: {
                rpcUrl: "https://api.testnet.solana.com",
                blockExplorerUrl: "https://explorer.solana.com/?cluster=testnet"
            },
            devnet: {
                rpcUrl: "https://api.devnet.solana.com",
                blockExplorerUrl: "https://explorer.solana.com/?cluster=devnet"
            }
        };
    if (e != null && e.solanaClusters)
        for (let bt of e.solanaClusters) {
            let {
                name: St,
                rpcUrl: Ge,
                blockExplorerUrl: Xe
            } = bt;
            H[St] = {
                rpcUrl: Ge ? ? H[St].rpcUrl,
                blockExplorerUrl: Xe ? ? H[St].blockExplorerUrl
            }
        }
    t.solana_wallet_auth && !((xe = (Ie = e == null ? void 0 : e.externalWallets) == null ? void 0 : Ie.solana) != null && xe.connectors) && console.warn("App configuration has Solana wallet login enabled, but no Solana wallet connectors have been passed to Privy. Make sure to pass Solana connectors to the `config.externalWallets.solana.connectors` field of the `PrivyProvider`");
    let j = t.telegram_auth_config ? {
            botId: t.telegram_auth_config.bot_id,
            botName: t.telegram_auth_config.bot_name,
            linkEnabled: t.telegram_auth_config.link_enabled,
            seamlessAuthEnabled: t.telegram_auth_config.seamless_auth_enabled
        } : void 0,
        V = t.funding_config ? {
            methods: t.funding_config.methods,
            options: t.funding_config.options,
            defaultRecommendedAmount: t.funding_config.default_recommended_amount,
            defaultRecommendedCurrency: t.funding_config.default_recommended_currency,
            promptFundingOnWalletCreation: t.funding_config.prompt_funding_on_wallet_creation,
            crossChainBridgingEnabled: t.funding_config.cross_chain_bridging_enabled
        } : void 0;
    return {
        id: t.id,
        name: t.name,
        allowlistConfig: {
            errorTitle: t.allowlist_config.error_title,
            errorDetail: t.allowlist_config.error_detail,
            errorCtaText: t.allowlist_config.cta_text,
            errorCtaLink: t.allowlist_config.cta_link
        },
        legacyWalletUiConfig: t.legacy_wallet_ui_config,
        appearance: {
            logo: ((ie = e == null ? void 0 : e.appearance) == null ? void 0 : ie.logo) ? ? t.logo_url ? ? void 0,
            landingHeader: ((Ee = e == null ? void 0 : e.appearance) == null ? void 0 : Ee.landingHeader) ? ? ea.appearance.landingHeader,
            loginMessage: typeof((ft = e == null ? void 0 : e.appearance) == null ? void 0 : ft.loginMessage) == "string" ? (Ae = e == null ? void 0 : e.appearance) == null ? void 0 : Ae.loginMessage.slice(0, 100) : (Le = e == null ? void 0 : e.appearance) == null ? void 0 : Le.loginMessage,
            footerLogo: (Te = e == null ? void 0 : e.appearance) == null ? void 0 : Te.footerLogo,
            palette: N9e({
                backgroundTheme: ((Ue = e == null ? void 0 : e.appearance) == null ? void 0 : Ue.theme) ? ? ea.appearance.theme,
                accentHex: ((De = e == null ? void 0 : e.appearance) == null ? void 0 : De.accentColor) ? ? t.accent_color ? ? ea.appearance.accentColor
            }),
            loginGroupPriority: P ? "web3-first" : "web2-first",
            hideDirectWeb2Inputs: !!((We = e == null ? void 0 : e.appearance) != null && We.hideDirectWeb2Inputs),
            walletList: R,
            walletChainType: ((dt = e == null ? void 0 : e.appearance) == null ? void 0 : dt.walletChainType) ? ? (({
                evmWalletAuth: bt,
                solanaWalletAuth: St
            }) => bt && St ? "ethereum-and-solana" : bt ? "ethereum-only" : St ? "solana-only" : "ethereum-only")({
                evmWalletAuth: t.wallet_auth ? ? !1,
                solanaWalletAuth: t.solana_wallet_auth ? ? !1
            })
        },
        loginMethods: {
            wallet: o,
            email: i,
            sms: s,
            passkey: a,
            google: c,
            twitter: l,
            discord: u,
            github: y,
            spotify: p,
            instagram: g,
            tiktok: h,
            line: f,
            linkedin: m,
            apple: w,
            farcaster: x,
            telegram: E
        },
        disablePlusEmails: t.disable_plus_emails,
        loginMethodsAndOrder: D,
        legal: {
            termsAndConditionsUrl: ((He = e == null ? void 0 : e.legal) == null ? void 0 : He.termsAndConditionsUrl) ? ? t.terms_and_conditions_url,
            privacyPolicyUrl: ((ut = e == null ? void 0 : e.legal) == null ? void 0 : ut.privacyPolicyUrl) ? ? t.privacy_policy_url,
            requireUsersAcceptTerms: t.require_users_accept_terms ? ? !1
        },
        walletConnectCloudProjectId: (e == null ? void 0 : e.walletConnectCloudProjectId) ? ? t.wallet_connect_cloud_project_id ? ? ea.walletConnectCloudProjectId,
        rpcConfig: {
            rpcUrls: {},
            rpcTimeouts: ((Ye = e == null ? void 0 : e.externalWallets) == null ? void 0 : Ye.signatureRequestTimeouts) ? ? {}
        },
        chains: O,
        solanaClusters: H,
        defaultChain: M,
        intl: {
            defaultCountry: S
        },
        shouldEnforceDefaultChainOnConnect: U,
        captchaEnabled: t.captcha_enabled ? ? ea.captchaEnabled,
        captchaSiteKey: t.captcha_site_key,
        externalWallets: {
            coinbaseWallet: {
                config: {
                    appName: t.name,
                    appLogoUrl: t.logo_url,
                    preference: {
                        options: ((vt = (we = e == null ? void 0 : e.externalWallets) == null ? void 0 : we.coinbaseWallet) == null ? void 0 : vt.connectionOptions) ? ? ea.externalWallets.coinbaseWallet.connectionOptions,
                        ...(tr = (_t = (Lt = e == null ? void 0 : e.externalWallets) == null ? void 0 : Lt.coinbaseWallet) == null ? void 0 : _t.config) == null ? void 0 : tr.preference
                    },
                    ...(Yt = (dr = e == null ? void 0 : e.externalWallets) == null ? void 0 : dr.coinbaseWallet) == null ? void 0 : Yt.config
                }
            },
            baseAccount: {
                config: {
                    appName: t.name,
                    appLogoUrl: t.logo_url,
                    ...(mt = (Ot = e == null ? void 0 : e.externalWallets) == null ? void 0 : Ot.baseAccount) == null ? void 0 : mt.config,
                    preference: { ...(pt = (Vr = (ur = e == null ? void 0 : e.externalWallets) == null ? void 0 : ur.baseAccount) == null ? void 0 : Vr.config) == null ? void 0 : pt.preference,
                        telemetry: !1
                    }
                }
            },
            walletConnect: {
                enabled: N,
                appKit: (ei = (Un = e == null ? void 0 : e.externalWallets) == null ? void 0 : Un.walletConnect) == null ? void 0 : ei.appKit
            },
            solana: {
                connectors: (Fn = (ti = e == null ? void 0 : e.externalWallets) == null ? void 0 : ti.solana) == null ? void 0 : Fn.connectors
            },
            disableAllExternalWallets: ((L = e == null ? void 0 : e.externalWallets) == null ? void 0 : L.disableAllExternalWallets) ? ? !1
        },
        embeddedWallets: {
            requireUserOwnedRecoveryOnCreate: F ? ? (!k && (t.embedded_wallet_config.require_user_owned_recovery_on_create ? ? !1)),
            userOwnedRecoveryOptions: k ? ["user-passcode"] : t.embedded_wallet_config.user_owned_recovery_options,
            priceDisplay: ((B = e == null ? void 0 : e.embeddedWallets) == null ? void 0 : B.priceDisplay) ? ? {
                primary: "fiat-currency",
                secondary: "native-token"
            },
            ethereum: {
                createOnLogin: q ? ? ((G = (Q = e == null ? void 0 : e.embeddedWallets) == null ? void 0 : Q.ethereum) == null ? void 0 : G.createOnLogin) ? ? W
            },
            solana: {
                createOnLogin: ((se = (re = e == null ? void 0 : e.embeddedWallets) == null ? void 0 : re.solana) == null ? void 0 : se.createOnLogin) ? ? K
            },
            disableAutomaticMigration: ((me = e == null ? void 0 : e.embeddedWallets) == null ? void 0 : me.disableAutomaticMigration) ? ? !1,
            mode: t.embedded_wallet_config.mode,
            showWalletUIs: ((ve = e == null ? void 0 : e.embeddedWallets) == null ? void 0 : ve.showWalletUIs) ? ? t.enforce_wallet_uis ? ? !0,
            extendedCalldataDecoding: ((Ze = e == null ? void 0 : e.embeddedWallets) == null ? void 0 : Ze.extendedCalldataDecoding) ? ? !1,
            transactionScanning: {
                enabled: ((Re = (kt = e == null ? void 0 : e.embeddedWallets) == null ? void 0 : kt.transactionScanning) == null ? void 0 : Re.enabled) ? ? !1,
                domain: ((it = (ct = e == null ? void 0 : e.embeddedWallets) == null ? void 0 : ct.transactionScanning) == null ? void 0 : it.domain) ? ? n ? ? "https://auth.privy.io"
            }
        },
        mfa: {
            methods: t.mfa_methods ? ? [],
            noPromptOnMfaRequired: ((lt = e == null ? void 0 : e.mfa) == null ? void 0 : lt.noPromptOnMfaRequired) ? ? !1
        },
        passkeys: {
            shouldUnlinkOnUnenrollMfa: (Se = e == null ? void 0 : e.passkeys) == null ? void 0 : Se.shouldUnlinkOnUnenrollMfa,
            shouldUnenrollMfaOnUnlink: (yt = e == null ? void 0 : e.passkeys) == null ? void 0 : yt.shouldUnenrollMfaOnUnlink
        },
        customAuth: k ? {
            enabled: !0,
            ...e.customAuth
        } : void 0,
        loginConfig: {
            telegramAuthConfiguration: j,
            passkeysForSignupEnabled: t.passkeys_for_signup_enabled
        },
        headless: !!(e != null && e.headless),
        render: {
            standalone: ((It = e == null ? void 0 : e._render) == null ? void 0 : It.standalone) ? ? ea._render.standalone
        },
        fundingConfig: V,
        fundingMethodConfig: { ...(e == null ? void 0 : e.fundingMethodConfig) ? ? ea.fundingMethodConfig,
            moonpay : { ...((Mt = e == null ? void 0 : e.fundingMethodConfig) == null ? void 0 : Mt.moonpay) ? ? ea.fundingMethodConfig.moonpay,
                useSandbox : ((jt = e == null ? void 0 : e.fundingMethodConfig) == null ? void 0 : jt.moonpay.useSandbox) ? ? ((sr = e == null ? void 0 : e.fiatOnRamp) == null ? void 0 : sr.useSandbox) ? ? ea.fundingMethodConfig.moonpay.useSandbox
            }
        },
        whatsAppEnabled: !!t.whatsapp_enabled
    }
}
const IU = {
        show_wallet_login_first: !0,
        allowlist_config: {
            error_title: null,
            error_detail: null,
            cta_text: null,
            cta_link: null
        },
        wallet_auth: !0,
        email_auth: !0,
        sms_auth: !1,
        google_oauth: !1,
        twitter_oauth: !1,
        discord_oauth: !1,
        github_oauth: !1,
        linkedin_oauth: !1,
        apple_oauth: !1,
        disable_plus_emails: !1,
        terms_and_conditions_url: null,
        privacy_policy_url: null,
        embedded_wallet_config: {
            create_on_login: "off",
            ethereum: {
                create_on_login: "off"
            },
            solana: {
                create_on_login: "off"
            },
            require_user_owned_recovery_on_create: !1,
            user_owned_recovery_options: ["user-passcode"],
            mode: "user-controlled-server-wallets-only"
        },
        captcha_enabled: !1,
        captcha_site_key: "",
        enforce_wallet_uis: !1,
        legacy_wallet_ui_config: !1,
        id: "",
        name: "",
        passkeys_for_signup_enabled: !1,
        whatsapp_enabled: !1
    },
    $U = kU(IU, void 0, !1);
let m8 = v.createContext({
    appConfig: $U,
    isServerConfigLoaded: !1
});
const O9e = ({
        children: t,
        client: e,
        legacyClient: r,
        clientConfig: n
    }) => {
        let [i, s] = v.useState(null), a = v.useMemo(() => kU(i ? ? IU, n, !!i, typeof window < "u" ? window.location.origin : void 0), [i, n]);
        return v.useEffect(() => {
            if (!i) return;
            let o = function(u) {
                    var y, w;
                    if (!u) return {};
                    let {
                        appearance: h,
                        supportedChains: f,
                        defaultChain: p,
                        externalWallets: g,
                        ...m
                    } = u;
                    return { ...m,
                        ...f ? {
                            supportedChains: f.map(x => x.id)
                        } : void 0,
                        ...p ? {
                            defaultChain: p.id
                        } : void 0,
                        ...g ? {
                            walletConnect: g.walletConnect ? {
                                enabled: g.walletConnect.enabled
                            } : void 0,
                            coinbaseWallet: g.coinbaseWallet,
                            solana: {
                                connectors: (w = (y = g.solana) == null ? void 0 : y.connectors) == null ? void 0 : w.get().map(x => x.walletClientType)
                            }
                        } : void 0
                    }
                }(n),
                c = function(u, h = 0) {
                    let f = 3735928559 ^ h,
                        p = 1103547991 ^ h;
                    for (let g, m = 0; m < u.length; m++) f = Math.imul(f ^ (g = u.charCodeAt(m)), 2654435761), p = Math.imul(p ^ g, 1597334677);
                    return f = Math.imul(f ^ f >>> 16, 2246822507) ^ Math.imul(p ^ p >>> 13, 3266489909), 4294967296 * (2097151 & (p = Math.imul(p ^ p >>> 16, 2246822507) ^ Math.imul(f ^ f >>> 13, 3266489909))) + (f >>> 0)
                }(JSON.stringify(o)).toString(),
                l = `privy:sent:${i.id}:${c}`;
            localStorage.getItem(l) || (r.createAnalyticsEvent({
                eventName: "sdk_initialize",
                payload: o
            }), localStorage.setItem(l, "t"))
        }, [n, i]), v.useEffect(() => {
            i || (async () => {
                try {
                    await e.initialize();
                    let o = e.app.getConfig();
                    o.custom_api_url && r.updateApiUrl(o.custom_api_url), s(o)
                } catch (o) {
                    console.warn("Error generating app config: ", o)
                }
            })()
        }, []), d.jsx(m8.Provider, {
            value: {
                appConfig: a,
                isServerConfigLoaded: !!i
            },
            children: t
        })
    },
    Gt = () => {
        let {
            appConfig: t
        } = v.useContext(m8);
        return t
    },
    SU = () => {
        let {
            isServerConfigLoaded: t
        } = v.useContext(m8);
        return t
    },
    TU = v.createContext({
        app: $U,
        currentScreen: null,
        lastScreen: null,
        navigate: le,
        navigateBack: le,
        resetNavigation: le,
        setModalData: le,
        onUserCloseViaDialogOrKeybindRef: void 0
    }),
    j9e = t => {
        var o;
        let e = Gt(),
            r = t.authenticated,
            [n, i] = v.useState(t.initialScreen);
        v.useEffect(() => {
            r || !t.initialScreen || t.initialScreen.isUnauthenticatedScreem || t.setInitialScreen(null)
        }, [r]);
        let s = v.useRef(null);
        v.useEffect(() => {
            t.open || (s.current = null)
        }, [t.open]), v.useEffect(() => {
            s.current = null
        }, [t.initialScreen]);
        let a = {
            app: e,
            data: t.data,
            setModalData: t.setModalData,
            currentScreen: t.initialScreen,
            lastScreen: n,
            navigate: (c, l = !0) => {
                t.setInitialScreen(c), l && i(t.initialScreen)
            },
            navigateBack: () => {
                t.setInitialScreen(n)
            },
            resetNavigation: () => {
                t.setInitialScreen(null), i(null)
            },
            onUserCloseViaDialogOrKeybindRef: s
        };
        return d.jsxs(TU.Provider, {
            value: a,
            children: [(typeof e.appearance.logo == "string" || ((o = e.appearance.logo) == null ? void 0 : o.type) === "img") && d.jsx(S9e, {
                src: typeof e.appearance.logo == "string" ? e.appearance.logo : e.appearance.logo.props.src
            }), t.children]
        })
    },
    Ne = () => v.useContext(TU),
    R9e = ({
        style: t,
        ...e
    }) => {
        let {
            app: r
        } = Ne();
        return d.jsxs("svg", {
            width: "28",
            height: "28",
            viewBox: "0 0 28 28",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            style: {
                height: "28px",
                width: "28px",
                ...t
            },
            ...e,
            children: [d.jsx("rect", {
                width: "28",
                height: "28",
                rx: "3",
                fill: (r == null ? void 0 : r.appearance.palette.colorScheme) === "dark" ? "#3396ff" : "#141414"
            }), d.jsx("g", {
                clipPath: "url(#clip0_1765_9946)",
                children: d.jsx("path", {
                    d: "M8.09448 10.3941C11.3558 7.20196 16.6442 7.20196 19.9055 10.3941L20.2982 10.7782C20.3369 10.8157 20.3677 10.8606 20.3887 10.9102C20.4097 10.9599 20.4206 11.0132 20.4206 11.0671C20.4206 11.121 20.4097 11.1744 20.3887 11.224C20.3677 11.2737 20.3369 11.3186 20.2982 11.3561L18.9554 12.6702C18.9158 12.7086 18.8628 12.7301 18.8077 12.7301C18.7526 12.7301 18.6996 12.7086 18.66 12.6702L18.1198 12.1415C15.8448 9.91503 12.1557 9.91503 9.88015 12.1415L9.30167 12.7075C9.26207 12.7459 9.20909 12.7673 9.15395 12.7673C9.0988 12.7673 9.04582 12.7459 9.00622 12.7075L7.66346 11.3934C7.62475 11.3559 7.59397 11.3109 7.57295 11.2613C7.55193 11.2117 7.5411 11.1583 7.5411 11.1044C7.5411 11.0505 7.55193 10.9971 7.57295 10.9475C7.59397 10.8979 7.62475 10.8529 7.66346 10.8154L8.09448 10.3941ZM22.6829 13.1115L23.8776 14.2814C23.9163 14.319 23.9471 14.3639 23.9681 14.4135C23.9892 14.4632 24 14.5165 24 14.5704C24 14.6243 23.9892 14.6777 23.9681 14.7273C23.9471 14.777 23.9163 14.8219 23.8776 14.8594L18.4893 20.1332C18.4102 20.2101 18.3042 20.2531 18.1938 20.2531C18.0835 20.2531 17.9775 20.2101 17.8984 20.1332L14.0743 16.3901C14.0545 16.3708 14.0279 16.36 14.0003 16.36C13.9726 16.36 13.9461 16.3708 13.9263 16.3901L10.1021 20.1332C10.023 20.2101 9.91703 20.2531 9.8067 20.2531C9.69636 20.2531 9.59038 20.2101 9.51124 20.1332L4.12236 14.8594C4.08365 14.8219 4.05287 14.777 4.03185 14.7273C4.01083 14.6777 4 14.6243 4 14.5704C4 14.5165 4.01083 14.4632 4.03185 14.4135C4.05287 14.3639 4.08365 14.319 4.12236 14.2814L5.31767 13.1115C5.39678 13.0348 5.50265 12.9919 5.61285 12.9919C5.72305 12.9919 5.82892 13.0348 5.90803 13.1115L9.73216 16.8546C9.75194 16.874 9.7785 16.8848 9.80616 16.8848C9.83381 16.8848 9.86037 16.874 9.88015 16.8546L13.7043 13.1115C13.7834 13.0346 13.8894 12.9916 13.9997 12.9916C14.1101 12.9916 14.216 13.0346 14.2952 13.1115L18.1198 16.8546C18.1396 16.874 18.1662 16.8848 18.1938 16.8848C18.2215 16.8848 18.2481 16.874 18.2678 16.8546L22.092 13.1115C22.1711 13.0346 22.2771 12.9916 22.3874 12.9916C22.4977 12.9916 22.6037 13.0346 22.6829 13.1115Z",
                    fill: "white"
                })
            }), d.jsx("defs", {
                children: d.jsx("clipPath", {
                    id: "clip0_1765_9946",
                    children: d.jsx("rect", {
                        width: "20",
                        height: "12.2531",
                        fill: "white",
                        transform: "translate(4 8)"
                    })
                })
            })]
        })
    };
class Vu extends Bd {
    async initialize() {
        var n, i, s, a, o;
        let e = await this.createProvider();
        this.provider = e, this.proxyProvider.setWalletProvider(e), this.subscribeListeners(), e.session && ((i = (n = this.walletProvider) == null ? void 0 : n.session) != null && i.peer.metadata.url && (this.walletEntry = wv((a = (s = this.walletProvider) == null ? void 0 : s.session) == null ? void 0 : a.peer.metadata.url), this.walletClientType = ((o = this.walletEntry) == null ? void 0 : o.slug) || "unknown"), this.connected = !0, await this.syncAccounts()), this.initialized = !0, this.emit("initialized");
        let {
            createAppKit: r
        } = await ma(() =>
            import ("./index-t-8BKzI0.js").then(c => c.a3), __vite__mapDeps([9, 3, 0, 1, 4]));
        this.modal ? ? (this.modal = r({
            projectId: this.walletConnectCloudProjectId,
            themeVariables: {
                "--w3m-z-index": 1e6
            },
            networks: this.chains,
            includeWalletIds: r9e,
            allowUnsupportedChain: !0
        })), this.modal.subscribeState(c => {
            var l;
            c.open || (l = this.walletProvider) != null && l.session || !this.onQrModalClosed || this.onQrModalClosed()
        })
    }
    async connect(e) {
        return e.showPrompt && await this.promptConnection(), this.getConnectedWallet()
    }
    async isConnected() {
        var e;
        return !!((e = this.walletProvider) != null && e.connected)
    }
    get walletBranding() {
        var r, n, i, s, a, o, c;
        let e = (i = (n = (r = this.walletProvider) == null ? void 0 : r.session) == null ? void 0 : n.peer.metadata.icons) == null ? void 0 : i[0];
        return {
            name: h9e(((a = (s = this.walletProvider) == null ? void 0 : s.session) == null ? void 0 : a.peer.metadata.name) || "") || "WalletConnect",
            icon: typeof e == "string" ? e : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAHdElNRQfoDAIVODUC+w+GAAAGsUlEQVRYw6WXbYwWVxXHf+fOLAtCXYS2QJdIaClipGCTknXXNqBQMVHbfmhItH4Aral+IAEaG03UxJgYKQJGTUxtDWjaxDSNtcZqIGDwpRuW1oYiVqpdpZSlpC3qysu+PHPP3w/3mXnmeXZbPzjJZO7cefn/z/mfe865xlscq3dGDIguGiHLaMQVLja4s87FShcLo5jtApdddnHexUmHIy475JmdUkPRAQMu7gzT4ljnxJpdk0QPmMFkyAKN2OfOFpc2uuh1J3MZDrjAvXmVEQUuoosRxw642FcEG7IoDxiFxNiu8NYE+vcUYIFYRKKs113bXWx2Z34CoQZsVHOiCZ7mopdzdsFhv8NexEgRDHMxUSNREbh1bwNZwBsFblmfu/a4a6AEENYO5i3AOoEWeEUCF4MOOxBDMQAOk99OJALA2u80sBCwWGBZWG/yRwMaCAbBIAsQTJT3gea1OWfNeaPzvjoHEI85rA8ObtB1v7cIdJkIHgkh9AXpocy0LJjIKvB2wPpZB0v3wkrw5jdNEjeYeMhFX3BAyfn2ke9NUrgB9LrrcZcGJFCld4fWNddXbvbWfWzGR6xJFZsBGh0cBh3bBIxIEGTQ3W0h4NuDaSAzyAxCmGq11Vzf5uaa1aG8p+WFtrEYQGwvjICJkAEqvC+YNmcmMlMNvEaCdrcbyUvQAWDTjVuESHObM6cPGWHmzDwLaEtmzG9Z3qF1zUpXmuuZBb1z4bqeNC6f0WE1NtUTwHzEloiy3BvFisy0sYoLlQtT6XW15md2Qf9SY+2Ngfdca/TMSm/9ewz+/Boc/It45h/i4kSTsKw90SQJsPTvjSZbkWemDW7qTRZ0JEYJWSKxZJ7xmf6M224MzMzbX1s8F1YugjtvMg6eErt/4/z1jUrz1rXUKxnZC2zIg2mdBTK1mFUOKC1fOt/48kdzVixIz86Nij+eEacvpJWyZJ5xy7th8VzjjpuMJfMCW58QL73ekXPVlhsyE+vyzFiplJyauEIyrGIquruMq7qTxk+dcB495rzyTzFepCUWLIFv/kBg081Gd55WUk1IDGFTS89K++TDYxddzKnWcbluHd450xgdh7EGrOo1rr868PMTzqWJRGZ2d8oB/xpL33Xnxl2rjeNn4blXRXduzJ4B5y+28kWscAwXl+yeR654FFZPHoUb710YuPeDOUdPO48di1xptKpeEeHqOcYXNwQKGd88EDk3mqxtxPSfGRlsXRtYt8z4ytPOH/7eqpg1Aso7fYKgK4NPrMpYvsC4/poMA34yVJIQC3sCD9yecdsNyaV5yPj6ryJnR1PAvSNP4J+/1cgDfLbfePaMGGtM7Qdyl12WmKOmXgKKAp54vmBRTxfLrjE+tSYjBPjRM5FrrzIeuD2jf2lLzw8vN4JlfPVp581LsO1DgXv7jSzAiXPw/d+JiYLpjsu26Yfjf5O0rF5WoxsNT9G/bX0XKxakmPjlSee6HlizJJXSX7/oRDc+vjKR+f2wODcKd78/gR8/C9uedF44myJxmhh4OY/ipMQyqaWxmjn95TfEroMFOzbkvG+RceeqViPx1Aln1yEnOow1AnffHCpJAJ5/Vex4UvzptZRdY/O/1dJIS/NkcNmR6MTYah6qzseA4TfFtw4UvHBW1bc/O+7sPhwZHYf/jMODh5yfPudVbXj2TAJ/8XxrOZagNamj4Ei2/GNfuyRxh8t6BG2l15up+MIVODEiFr8rcPS0+O6RBF6mrrEGHHtFzOo2Lo7Dl37hvPQ6mNV6R9JYKgnYWcE37K5HlE2OT/5A0udaPUBHH+BQOMzuNsYLuDyZflTW+fTcmJFDHhJhaZqewMuewXDxcDR9IYyPN6Jj+6K4MF2vV8qBtZJScqVRNi6lpGONVJis5mpKi1WbgwsY+zIsBpcR8mzIZfuTRVZrtdu9odrptR/Xx5XONXJqBmCN0P6YMUQq9WJiwt0Je102WHdbpxSqydMObBWYdwDWLVcqcIMYe3NPjg0Ht84od0Ajju1w2XCr9e6QoqM9V23ZtnmI6cfAMMb9AY0YEHdb6oobEh4y3H3Ize6LsmGvN5IdUnhttdQ9UVrfLk/ljWEZ9wXsqAdQk1EA+O22GcgdZTke/bAs3OPY4HSdcB20HhvVtTMu0jmI8ekAhz2IICj2hKpNqI60NcuIRUHEej1quzubXa2tmZhenrfZmv3YYQ9ipDAIgvHptmblccuDjdRcmjFpWbDi/9ycZjZkRbk5jYztai/AUwiUx+qdEQB/m+25i9lxyvbcjrg45Lmd0uT/3p7/Fw6ODf+WO019AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDI0LTEyLTAyVDIxOjU2OjQ4KzAwOjAwMVpslgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyNC0xMi0wMlQyMTo1Njo0OCswMDowMEAH1CoAAAAodEVYdGRhdGU6dGltZXN0YW1wADIwMjQtMTItMDJUMjE6NTY6NTMrMDA6MDDZv6GRAAAAAElFTkSuQmCC",
            id: ((c = (o = this.walletProvider) == null ? void 0 : o.session) == null ? void 0 : c.peer.metadata.name.toLowerCase()) || "wallet_connect_v2"
        }
    }
    async resetConnection(e) {
        this.walletProvider && this.walletProvider.connected && (await this.walletProvider.disconnect(), this.walletProvider.signer.session = void 0, this.walletClientType = e, this.redirectUri = void 0, this.fallbackUniversalRedirectUri = void 0, function() {
            try {
                localStorage.removeItem(QI)
            } catch {}
        }(), this.onDisconnect())
    }
    async promptConnection() {
        if (this.provider) return new Promise((e, r) => {
            this.onQrModalClosed = () => {
                r(new vU)
            }, (async () => {
                var s, a, o, c, l, u;
                let n = "",
                    i = await Promise.race([(s = this.walletProvider) == null ? void 0 : s.enable(), this.proxyProvider.walletTimeout()]);
                if (i != null && i.length && (n = i[0]), !n || n === "") throw new br("Unable to retrieve address");
                (o = (a = this.walletProvider) == null ? void 0 : a.session) != null && o.peer.metadata.url && (this.walletEntry = wv((l = (c = this.walletProvider) == null ? void 0 : c.session) == null ? void 0 : l.peer.metadata.url), this.walletClientType = ((u = this.walletEntry) == null ? void 0 : u.slug) || "unknown", this.proxyProvider.rpcTimeoutDuration = u8(this.rpcConfig, this.walletClientType)), this.connected = !0, await this.syncAccounts(i), e()
            })().catch(n => {
                r(n ? hl(n) : new br("Unknown error during connection"))
            }).finally(() => {
                var n;
                return (n = this.modal) == null ? void 0 : n.close()
            })
        })
    }
    disconnect() {
        var e;
        (e = this.walletProvider) == null || e.disconnect().then(() => this.onDisconnect()).catch(() => console.warn("Unable to disconnect WalletConnect provider"))
    }
    get walletProvider() {
        return this.proxyProvider.walletProvider
    }
    setWalletProvider(e) {
        this.proxyProvider.setWalletProvider(e)
    }
    async createProvider() {
        let e = {};
        for (let s of this.chains) {
            let a = p9e(s.id, this.chains, this.rpcConfig, this.privyAppId);
            a && (e[s.id] = a)
        }
        let r = this.shouldEnforceDefaultChainOnConnect ? [this.defaultChain.id] : [],
            n = this.chains.map(s => s.id),
            i = await o7e.init({
                projectId: this.walletConnectCloudProjectId,
                chains: r,
                optionalChains: n,
                optionalEvents: OL,
                optionalMethods: NL,
                rpcMap: e,
                showQrModal: !1,
                metadata: {
                    description: this.privyAppName,
                    name: this.privyAppName,
                    url: window.location.origin,
                    icons: []
                }
            });
        return i.on("display_uri", s => {
            var a, o, c, l, u;
            if (i.signer.abortPairingAttempt(), this.walletEntry) {
                let {
                    redirect: h,
                    href: f
                } = function(g, m) {
                    let y = JI(m);
                    if (y.deepLink) return YL(y.deepLink, g);
                    if (y.universalLink) return d4(y.universalLink, g);
                    throw new J(`Unsupported wallet ${m.id}`)
                }(s, this.walletEntry);
                (function({
                    href: g,
                    name: m
                }) {
                    try {
                        localStorage.setItem(QI, JSON.stringify({
                            href: g,
                            name: m
                        }))
                    } catch {}
                })({
                    href: f,
                    name: ((a = this.walletEntry.metadata) == null ? void 0 : a.shortName) || this.walletEntry.name
                }), this.redirectUri = h;
                let p = function(g, m) {
                    let y = JI(m);
                    if (y.universalLink) return d4(y.universalLink, g)
                }(s, this.walletEntry);
                p != null && p.redirect && (this.fallbackUniversalRedirectUri = p.redirect), gr.isMobile ? (ZL(h, "_self"), (o = this.showPrivyQrModal) == null || o.call(this, {
                    native: h,
                    universal: this.fallbackUniversalRedirectUri
                })) : this.showPrivyQrModal ? (c = this.showPrivyQrModal) == null || c.call(this, {
                    native: h,
                    universal: this.fallbackUniversalRedirectUri
                }) : (l = this.modal) == null || l.open({
                    uri: s
                })
            } else(u = this.modal) == null || u.open({
                uri: s
            })
        }), i.on("connect", () => {
            var s, a, o, c;
            (s = this.modal) == null || s.close(), (a = i.session) != null && a.peer.metadata.url && (this.walletEntry = wv((o = i.session) == null ? void 0 : o.peer.metadata.url), this.walletClientType = ((c = this.walletEntry) == null ? void 0 : c.slug) || "unknown")
        }), i
    }
    async enableProvider() {
        var e, r;
        return (e = this.walletProvider) != null && e.connected ? Promise.resolve(this.walletProvider.accounts) : await ((r = this.walletProvider) == null ? void 0 : r.enable())
    }
    setWalletEntry(e, r) {
        this.walletEntry = e, this.showPrivyQrModal = r
    }
    constructor({
        walletConnectCloudProjectId: e,
        rpcConfig: r,
        chains: n,
        defaultChain: i,
        shouldEnforceDefaultChainOnConnect: s,
        privyAppId: a,
        privyAppName: o,
        walletClientType: c,
        appKit: l
    }) {
        super(c || "unknown", n, i, r), this.connectorType = "wallet_connect_v2", this.privyAppId = a, this.privyAppName = o, this.walletConnectCloudProjectId = e, this.rpcConfig = r, this.shouldEnforceDefaultChainOnConnect = s, this.proxyProvider = new fl(void 0, this.rpcTimeoutDuration), this.modal = l, c && (this.walletEntry = (u => N0.getState().listings.find(({
            slug: h
        }) => d1(h) === d1(u)))(c), this.walletClientType = c)
    }
}
class M9e extends Ed {
    get wallets() {
        let e = new Set,
            r = this.walletConnectors.flatMap(i => i.wallets).sort((i, s) => i.connectedAt && s.connectedAt ? s.connectedAt - i.connectedAt : 0).filter(i => {
                let s = `${i.address}${i.walletClientType}${i.connectorType}${i.meta.id}`;
                return !e.has(s) && (e.add(s), !0)
            }),
            n = r.findIndex(i => i.address === (this.activeWallet ? this.activeWallet : "unknown"));
        return n >= 0 && r.unshift(r.splice(n, 1)[0]), r
    }
    async initialize(e) {
        var n, i, s;
        if (this.initialized && !e || (e && this.removeAllConnectors(), rt.get(n$) && (rt.getKeys().forEach(a => {
                a.startsWith("walletconnect") && rt.del(a)
            }), rt.del(n$)), this.externalWalletConfig.disableAllExternalWallets)) return;
        let r = f9e({
            store: this.store,
            walletList: this.walletList,
            externalWalletConfig: this.externalWalletConfig,
            walletChainType: this.walletChainType
        }).then(a => {
            a.forEach(({
                type: o,
                eip6963InjectedProvider: c,
                legacyInjectedProvider: l
            }) => {
                this.createEthereumWalletConnector({
                    connectorType: "injected",
                    walletClientType: o,
                    providers: {
                        eip6963InjectedProvider: c,
                        legacyInjectedProvider: l
                    }
                })
            })
        });
        for (let a of (this.walletList.includes("coinbase_wallet") && this.createEthereumWalletConnector({
                connectorType: "coinbase_wallet",
                walletClientType: "coinbase_wallet"
            }), this.walletList.includes("base_account") && this.createEthereumWalletConnector({
                connectorType: "base_account",
                walletClientType: "base_account"
            }), Object.values(p8))) !a.isInstalled && this.walletList.includes(a.client) && (["ethereum-only", "ethereum-and-solana"].includes(this.walletChainType) && a.chainTypes.includes("ethereum") && this.createEthereumWalletConnector({
            connectorType: "null",
            walletClientType: a.client,
            walletConfig: a
        }), ["ethereum-and-solana", "solana-only"].includes(this.walletChainType) && a.chainTypes.includes("solana") && this.addSolanaWalletConnector(new g8({
            id: a.client,
            name: a.name
        })));
        this.externalWalletConfig.walletConnect.enabled && this.createEthereumWalletConnector({
            connectorType: "wallet_connect_v2",
            walletClientType: "unknown"
        }), (n = this.externalWalletConfig.solana.connectors) == null || n.get().forEach(this.addSolanaWalletConnector), (s = (i = this.externalWalletConfig.solana.connectors) == null ? void 0 : i._setOnConnectorsUpdated) == null || s.call(i, a => {
            a == null || a.forEach(this.addSolanaWalletConnector)
        }), await r, this.initialized = !0
    }
    findWalletConnector(e, r) {
        return e === "wallet_connect_v2" ? this.walletConnectors.filter(pf).find(n => n.connectorType === e) ? ? null : this.walletConnectors.filter(pf).find(n => n.connectorType === e && n.walletClientType === r) ? ? null
    }
    findSolanaWalletConnector(e) {
        return this.walletConnectors.filter(k9e).find(r => r.walletClientType === "unknown" ? r.walletBranding.id === e : r.walletClientType === e) ? ? null
    }
    findEmbeddedWalletConnectors() {
        return this.walletConnectors.filter(e => e.connectorType === "embedded")
    }
    onInitialized(e) {
        e.wallets.forEach(r => {
            let n = this.storedConnections.find(i => i.address === r.address && i.connectorType === r.connectorType && (r.type === "solana" && i.walletClientType === "unknown" && r.walletClientType === "unknown" ? r.meta.id === i.id : i.walletClientType === r.walletClientType));
            n && (r.connectedAt = n.connectedAt)
        }), this.emit("walletsUpdated"), this.emit("connectorInitialized")
    }
    onWalletsUpdated(e) {
        e.initialized && this.emit("walletsUpdated")
    }
    addEmbeddedWalletConnectors({
        walletProxy: e,
        user: r,
        embeddedWallets: n,
        defaultChain: i,
        appId: s,
        privyClient: a
    }) {
        let {
            entropyId: o,
            entropyIdVerifier: c
        } = Sn(r);
        for (let l of n) {
            let u = this.findEmbeddedWalletConnectors().find(h => h.walletIndex === l.walletIndex);
            if (u && pf(u)) u.proxyProvider.walletProxy = e;
            else {
                let h = new l$({
                    provider: new d$({
                        walletProxy: e,
                        address: l.address,
                        entropyId: o,
                        entropyIdVerifier: c,
                        rpcConfig: this.rpcConfig,
                        chains: this.chains,
                        appId: s,
                        chainId: i.id,
                        walletIndex: l.walletIndex,
                        privyClient: a,
                        walletAccount: l
                    }),
                    chains: this.chains,
                    defaultChain: i,
                    rpcConfig: this.rpcConfig,
                    imported: !1,
                    walletIndex: l.walletIndex
                });
                this.addWalletConnector(h)
            }
        }
    }
    addImportedWalletConnector(e, r, n, i) {
        let s = this.findWalletConnector("embedded_imported", "privy");
        if (s && pf(s)) s.proxyProvider.walletProxy = e;
        else {
            let a = new l$({
                provider: new d$({
                    walletProxy: e,
                    address: r,
                    entropyId: r,
                    entropyIdVerifier: "ethereum-address-verifier",
                    walletIndex: 0,
                    rpcConfig: this.rpcConfig,
                    chains: this.chains,
                    appId: i,
                    chainId: n.id
                }),
                chains: this.chains,
                walletIndex: 0,
                defaultChain: n,
                rpcConfig: this.rpcConfig,
                imported: !0
            });
            this.addWalletConnector(a)
        }
    }
    removeEmbeddedWalletConnectors() {
        this.walletConnectors = this.walletConnectors.filter(e => e.connectorType !== "embedded"), this.storedConnections = cm(), this.emit("walletsUpdated")
    }
    removeImportedWalletConnector() {
        let e = this.findWalletConnector("embedded_imported", "privy");
        if (e) {
            let r = this.walletConnectors.indexOf(e);
            this.walletConnectors.splice(r, 1), this.storedConnections = cm(), this.emit("walletsUpdated")
        }
    }
    async createEthereumWalletConnector({
        connectorType: e,
        walletClientType: r,
        providers: n,
        walletConfig: i
    }) {
        let s = this.findWalletConnector(e, r);
        if (s && pf(s)) return s instanceof Vu && s.resetConnection(r), s;
        let a = e !== "injected" ? e === "coinbase_wallet" ? new b9e(this.chains, this.defaultChain, this.rpcConfig, this.externalWalletConfig.coinbaseWallet.config) : e === "base_account" ? new y9e(this.chains, this.defaultChain, this.rpcConfig, this.externalWalletConfig.baseAccount.config, this.setBaseAccountSdk) : e !== "null" ? new Vu({
            walletConnectCloudProjectId: this.walletConnectCloudProjectId,
            rpcConfig: this.rpcConfig,
            chains: this.chains,
            defaultChain: this.defaultChain,
            shouldEnforceDefaultChainOnConnect: this.shouldEnforceDefaultChainOnConnect,
            privyAppId: this.privyAppId,
            privyAppName: this.privyAppName,
            walletClientType: r,
            appKit: this.appKit
        }) : i ? new h8({
            id: i.client,
            name: i.name,
            defaultChain: this.defaultChain,
            walletClientType: i.client
        }) : null : r === "metamask" && (n != null && n.eip6963InjectedProvider) ? new _9e(this.chains, this.defaultChain, this.rpcConfig, n == null ? void 0 : n.eip6963InjectedProvider, "metamask") : r === "metamask" && (n != null && n.legacyInjectedProvider) ? new yv(this.chains, this.defaultChain, this.rpcConfig, n == null ? void 0 : n.legacyInjectedProvider, "metamask") : r === "phantom" && (n != null && n.legacyInjectedProvider) ? new yv(this.chains, this.defaultChain, this.rpcConfig, n == null ? void 0 : n.legacyInjectedProvider, "phantom") : n != null && n.legacyInjectedProvider && r === "unknown_browser_extension" ? new yv(this.chains, this.defaultChain, this.rpcConfig, n == null ? void 0 : n.legacyInjectedProvider) : n != null && n.eip6963InjectedProvider ? new CU(this.chains, this.defaultChain, this.rpcConfig, n == null ? void 0 : n.eip6963InjectedProvider, r) : void 0;
        return a && this.addWalletConnector(a), a || null
    }
    addWalletConnector(e) {
        this.walletConnectors.push(e), e.on("initialized", () => this.onInitialized(e)), e.on("walletsUpdated", () => this.onWalletsUpdated(e)), e.initialize().catch(r => {
            console.debug("Failed to initialize connector", r)
        })
    }
    async activeWalletSign(e) {
        let r = this.wallets,
            n = r.length > 0 ? r[0] : null;
        return n && Uo(n) ? n.sign(e) : null
    }
    setActiveWallet(e) {
        this.activeWallet = Zr(e), this.emit("walletsUpdated")
    }
    setWalletList(e) {
        this.walletList = e, this.initialized && this.initialize(!0).catch(console.error)
    }
    removeAllConnectors() {
        for (let e of this.walletConnectors) e.removeAllListeners();
        this.walletConnectors = []
    }
    constructor(e, r, n, i, s, a, o, c, l, u, h, f, p) {
        super(), this.addSolanaWalletConnector = async g => {
            let m = this.findSolanaWalletConnector(g.walletClientType);
            if (!m || m.connectorType === "null") {
                if ((m == null ? void 0 : m.connectorType) === "null") {
                    let y = this.walletConnectors.indexOf(m);
                    this.walletConnectors.splice(y, 1)
                }
                this.addWalletConnector(g)
            }
        }, this.getEthereumProvider = () => {
            let g = this.wallets[0],
                m = this.walletConnectors.find(y => y.wallets.find(w => w.address === (g == null ? void 0 : g.address)));
            return g && m ? m.proxyProvider : new fl
        }, this.privyAppId = e, this.walletConnectCloudProjectId = r, this.rpcConfig = n, this.chains = i, this.defaultChain = s, this.walletConnectors = [], this.initialized = !1, this.store = a, this.walletList = o, this.shouldEnforceDefaultChainOnConnect = c, this.externalWalletConfig = l, this.privyAppName = u, this.walletChainType = f || "ethereum-only", this.appKit = p, this.setBaseAccountSdk = h, this.storedConnections = cm()
    }
}
let D9e = [iO, sO, lO];
class L9e {
    async get(e, r) {
        try {
            return await this.baseFetch(e, r)
        } catch (n) {
            throw qt(n)
        }
    }
    async post(e, r, n) {
        try {
            return await this.baseFetch(e, {
                method: "POST",
                ...r ? {
                    body: r
                } : {},
                ...n
            })
        } catch (i) {
            throw qt(i)
        }
    }
    async delete(e, r) {
        try {
            return await this.baseFetch(e, {
                method: "DELETE",
                ...r
            })
        } catch (n) {
            throw qt(n)
        }
    }
    constructor({
        appId: e,
        appClientId: r,
        client: n,
        defaults: i
    }) {
        this.appId = e, this.appClientId = r, this.clientAnalyticsId = n.clientAnalyticsId, this.sdkVersion = n9e, this.client = n, this.defaults = i, this.fallbackApiUrl = n.fallbackApiUrl, this.baseFetch = nO.create({
            baseURL: this.defaults.baseURL,
            timeout: this.defaults.timeout,
            retry: 3,
            retryDelay: 500,
            retryStatusCodes: [408, 409, 425, 500, 502, 503, 504],
            credentials: "include",
            onRequest: async ({
                request: s,
                options: a
            }) => {
                let o = new Headers(a.headers);
                o.set("privy-app-id", this.appId), this.appClientId && o.set("privy-client-id", this.appClientId), o.set("privy-ca-id", this.clientAnalyticsId || ""), o.set("privy-client", `react-auth:${this.sdkVersion}`);
                let c = D9e.includes(s.toString());
                if (!o.has("authorization")) {
                    let l = await this.client.getAccessToken({
                        disableAutoRefresh: c
                    });
                    l !== null && o.set("authorization", `Bearer ${l}`)
                }
                a.headers = o, a.retryDelay && typeof a.retryDelay == "number" && (a.retryDelay = 3 * a.retryDelay)
            },
            onRequestError: ({
                error: s
            }) => {
                if (s instanceof DOMException && s.name === "AbortError") throw new rie
            }
        })
    }
}
let U9e = /paymaster\.biconomy\.io\/api/i,
    F9e = {
        mode: "SPONSORED",
        calculateGasLimits: !0,
        expiryDuration: 300,
        sponsorshipInfo: {
            webhookData: {},
            smartAccountInfo: {
                name: "BICONOMY",
                version: "2.0.0"
            }
        }
    };
const B9e = (t, e) => t && U9e.test(t) ? F9e : e && e.policy_id ? {
        policyId: e.policy_id
    } : void 0,
    W9e = t => {
        var e, r, n, i;
        return {
            rpId: t.rp_id,
            challenge: t.challenge,
            allowCredentials: ((e = t.allow_credentials) == null ? void 0 : e.map(s => ({
                id: s.id,
                type: s.type,
                transports: s.transports
            }))) || [],
            timeout: t.timeout,
            extensions: {
                appid: (r = t.extensions) == null ? void 0 : r.app_id,
                credProps: (n = t.extensions) == null ? void 0 : n.cred_props,
                hmacCreateSecret: (i = t.extensions) == null ? void 0 : i.hmac_create_secret
            },
            userVerification: t.user_verification
        }
    };
class PU {
    async authenticate() {
        if (!this.api) throw new J("Auth flow has no API instance");
        try {
            return await this.api.post(Jie, {
                token: this.meta.token
            })
        } catch (e) {
            throw qt(e)
        }
    }
    async link() {
        if (!this.api) throw new J("Auth flow has no API instance");
        try {
            return await this.api.post(Qie, {
                token: this.meta.token
            })
        } catch (e) {
            throw qt(e)
        }
    }
    constructor(e) {
        this.meta = {
            token: e
        }
    }
}
class z9e {
    getOrCreateGuestCredential(e) {
        let r = JL(e);
        if (l4()) {
            if (rt.get(r)) return rt.get(r); {
                let n = dd(f4(32));
                return rt.put(r, n), n
            }
        }
        return dd(f4(32))
    }
    async authenticate() {
        if (!this.api) throw new J("Auth flow has no API instance");
        try {
            return await this.api.post(Xie, {
                guest_credential: this.meta.guestCredential
            })
        } catch (e) {
            throw qt(e)
        }
    }
    async link() {
        throw Error("Linking is not supported for the guest flow")
    }
    constructor(e) {
        this.meta = {
            guestCredential: this.getOrCreateGuestCredential(e)
        }
    }
}

function bv() {
    return !(gr.isSafari && window.location.origin.startsWith("http://localhost"))
}
const g$ = vh(() => ({
    identityToken: null
}));
var vv, m$ = ((vv = {}).PRIVY = "privy_access_token", vv.CUSTOMER = "customer_access_token", vv);
class q9e {
    get token() {
        return this.privyAccessToken || this.customerAccessToken
    }
    getToken(e) {
        return e === "privy_access_token" ? this.privyAccessToken : this.customerAccessToken
    }
    get customerAccessToken() {
        return this._getToken(Nu)
    }
    get privyAccessToken() {
        return this._getToken(sm)
    }
    _getToken(e) {
        try {
            let r = rt.get(e);
            return typeof r == "string" ? qc.throwIfNotWellFormedJwt(r) : null
        } catch (r) {
            return console.error(r), this.destroyLocalState(), null
        }
    }
    get refreshToken() {
        try {
            let e = rt.get(uv);
            return typeof e == "string" ? e : null
        } catch (e) {
            return console.error(e), this.destroyLocalState(), null
        }
    }
    getProviderAccessToken(e) {
        try {
            let r = rt.get(Pg(e));
            if (typeof r != "string") return null; {
                let n = new qc(r);
                return n.isExpired() ? (rt.del(Pg(e)), null) : n.value
            }
        } catch (r) {
            return console.error(r), null
        }
    }
    get mightHaveServerCookies() {
        try {
            let e = Ur.get(hv);
            return e !== void 0 && e.length > 0
        } catch (e) {
            console.error(e)
        }
        return !1
    }
    hasRefreshCredentials(e = "privy_access_token") {
        let r = typeof this.getToken(e) == "string",
            n = typeof this.refreshToken == "string" && this.refreshToken !== "deprecated";
        return this.mightHaveServerCookies || r && n
    }
    hasActiveAccessToken(e) {
        let r = qc.parse(this.getToken(e));
        return r !== null && !r.isExpired(30)
    }
    authenticate(e) {
        return this.authenticateOnce.execute(e)
    }
    link(e) {
        return this.linkOnce.execute(e)
    }
    refresh() {
        return this.refreshOnce.execute()
    }
    destroy() {
        return this.destroyOnce.execute()
    }
    storeProviderAccessToken(e, r) {
        typeof r == "string" ? rt.put(Pg(e), r) : rt.del(Pg(e))
    }
    updateIdentityToken(e) {
        typeof e == "string" ? this.storeIdentityToken(e) : this.clearIdentityToken()
    }
    async _authenticate(e) {
        try {
            let r = await e.authenticate(),
                {
                    user: n,
                    is_new_user: i,
                    oauth_tokens: s
                } = r;
            this.handleTokenResponse(r);
            let a = s ? {
                provider: s.provider,
                accessToken: s.access_token,
                accessTokenExpiresInSeconds: s.access_token_expires_in_seconds,
                refreshToken: s.refresh_token,
                refreshTokenExpiresInSeconds: s.refresh_token_expires_in_seconds,
                scopes: s.scopes
            } : void 0;
            return this._trackAuthenticateEvents(e, i), {
                user: Vn(n),
                isNewUser: i,
                oAuthTokens: a
            }
        } catch (r) {
            throw console.warn("Error authenticating session"), xr(r)
        }
    }
    _trackAuthenticateEvents(e, r) {
        let n = function(i) {
            return i instanceof Pu ? "email" : i instanceof Ou ? "sms" : i instanceof qu ? "siwe" : i instanceof z9e ? "guest" : i instanceof PU ? "custom_auth" : i instanceof Au ? i.meta.provider : null
        }(e);
        n && this.client && this.client.createAnalyticsEvent({
            eventName: "sdk_authenticate",
            payload: {
                method: n,
                isNewUser: r
            }
        }), n === "siwe" && this.client && this.client.createAnalyticsEvent({
            eventName: "sdk_authenticate_siwe",
            payload: {
                connectorType: e.meta.connectorType,
                walletClientType: e.meta.walletClientType
            }
        })
    }
    async _link(e) {
        try {
            let r = await e.link(),
                n = r.oauth_tokens,
                i = n ? {
                    provider: n.provider,
                    accessToken: n.access_token,
                    accessTokenExpiresInSeconds: n.access_token_expires_in_seconds,
                    refreshToken: n.refresh_token,
                    refreshTokenExpiresInSeconds: n.refresh_token_expires_in_seconds,
                    scopes: n.scopes
                } : void 0;
            return {
                user: Vn(r),
                oAuthTokens: i
            }
        } catch (r) {
            throw console.warn("Error linking account"), xr(r)
        }
    }
    async _refresh() {
        if (!this.api) throw new J("Session has no API instance");
        if (!this.client) throw new J("Session has no PrivyClient instance");
        await this.client.getAccessToken({
            disableAutoRefresh: !0
        });
        let e = this.token,
            r = this.refreshToken;
        if (this.client.useServerCookies && !this.mightHaveServerCookies && this.token && window.location.origin === this.client.apiUrl) return this.destroyLocalState(), null;
        try {
            let n;
            if (!(e && r || this.mightHaveServerCookies)) return null; {
                let i = {};
                e && (i.authorization = `Bearer ${e}`), n = await this.api.post(iO, r ? {
                    refresh_token: r
                } : {}, {
                    headers: i
                })
            }
            return this.handleTokenResponse(n), Vn(n.user)
        } catch (n) {
            if (n instanceof es && n.privyErrorCode === ee.MISSING_OR_INVALID_TOKEN) return console.warn("Unable to refresh tokens - token is missing or no longer valid"), this.destroyLocalState(), null;
            throw xr(n)
        }
    }
    handleTokenResponse(e) {
        e.session_update_action && e.session_update_action !== "set" ? e.session_update_action === "clear" ? this.destroyLocalState() : e.session_update_action === "ignore" && (e.token && (this.storeCustomerAccessToken(e.token), this.storePrivyAccessToken(e.privy_access_token)), e.identity_token && this.storeIdentityToken(e.identity_token)) : this._storeAllTokens(e)
    }
    _storeAllTokens(e) {
        this.storeRefreshToken(e.refresh_token), this.storeCustomerAccessToken(e.token), this.storePrivyAccessToken(e.privy_access_token), e.identity_token && this.storeIdentityToken(e.identity_token)
    }
    async _destroy() {
        var e;
        try {
            await ((e = this.api) == null ? void 0 : e.post(sO, {
                refresh_token: this.refreshToken
            }))
        } catch {
            console.warn("Error destroying session")
        }
        this.destroyLocalState()
    }
    destroyLocalState() {
        this.storeRefreshToken(null), this.storeCustomerAccessToken(null), this.storePrivyAccessToken(null), this.clearIdentityToken()
    }
    storeCustomerAccessToken(e) {
        var r, n, i, s, a, o;
        if (typeof e == "string") {
            let c = rt.get(Nu);
            if (rt.put(Nu, e), !((r = this.client) != null && r.useServerCookies)) {
                let l = (n = qc.parse(e)) == null ? void 0 : n.expiration;
                Ur.set(e$, e, {
                    sameSite: "Strict",
                    secure: bv(),
                    expires: l ? new Date(1e3 * l) : void 0
                })
            }
            c !== e && ((s = (i = this.client) == null ? void 0 : i.onStoreCustomerAccessToken) == null || s.call(i, e))
        } else rt.del(Nu), Ur.remove(e$), (o = (a = this.client) == null ? void 0 : a.onDeleteCustomerAccessToken) == null || o.call(a)
    }
    storeRefreshToken(e) {
        var r;
        typeof e == "string" ? (rt.put(uv, e), (r = this.client) != null && r.useServerCookies || Ur.set(hv, "t", {
            sameSite: "Strict",
            secure: bv(),
            expires: 30
        })) : (rt.del(uv), Ur.remove("privy-refresh-token"), Ur.remove(hv))
    }
    storePrivyAccessToken(e) {
        typeof e == "string" ? rt.put(sm, e) : rt.del(sm)
    }
    storeIdentityToken(e) {
        var n, i;
        if (g$.setState({
                identityToken: e
            }), (n = this.client) == null ? void 0 : n.useServerCookies) return;
        rt.put(t$, e);
        let r = (i = qc.parse(e)) == null ? void 0 : i.expiration;
        Ur.set(r$, e, {
            sameSite: "Strict",
            secure: bv(),
            expires: r ? new Date(1e3 * r) : void 0
        })
    }
    clearIdentityToken() {
        rt.del(t$), g$.setState({
            identityToken: null
        }), Ur.remove(r$)
    }
    constructor() {
        this.authenticateOnce = new di(async e => this._authenticate(e)), this.linkOnce = new di(async e => this._link(e)), this.refreshOnce = new di(this._refresh.bind(this)), this.destroyOnce = new di(this._destroy.bind(this))
    }
}
let xv;
var H9e = 0,
    Ev = "__private_" + H9e++ + "__getOrGenerateClientAnalyticsId";
class V9e {
    getAppId() {
        return this.appId
    }
    initializeConnectorManager({
        walletConnectCloudProjectId: e,
        rpcConfig: r,
        chains: n,
        defaultChain: i,
        store: s,
        walletList: a,
        shouldEnforceDefaultChainOnConnect: o,
        externalWalletConfig: c,
        appName: l,
        walletChainType: u,
        setBaseAccountSdk: h,
        appKit: f
    }) {
        this.connectors || (this.connectors = new M9e(this.appId, e, r, n, i, s, a, o, c, l, h, u, f))
    }
    generateApi() {
        let e = new L9e({
            appId: this.appId,
            appClientId: this.appClientId,
            client: this,
            defaults: {
                baseURL: this.apiUrl,
                timeout: this.timeout
            }
        });
        return this.session.api = e, e
    }
    updateApiUrl(e) {
        this.apiUrl = e || this.fallbackApiUrl, this.api = this.generateApi(), e && (this.useServerCookies = !0)
    }
    authenticate() {
        if (!this.authFlow) throw new J("No auth flow in progress.");
        return this.session.authenticate(this.authFlow)
    }
    async link() {
        if (!this.authFlow) throw new J("No auth flow in progress.");
        let {
            oAuthTokens: e
        } = await this.session.link(this.authFlow);
        return {
            user: await this.getAuthenticatedUser(),
            oAuthTokens: e
        }
    }
    storeProviderAccessToken(e, r) {
        this.session.storeProviderAccessToken(e, r)
    }
    getProviderAccessToken(e) {
        return this.session.getProviderAccessToken(e)
    }
    async logout() {
        await this.session.destroy(), this.authFlow = void 0
    }
    clearProviderAcccessTokens(e) {
        e.linkedAccounts.filter(r => r.type === "cross_app").forEach(r => {
            this.storeProviderAccessToken(r.providerApp.id, null)
        })
    }
    startAuthFlow(e) {
        return e.api = this.api, this.authFlow = e, this.authFlow
    }
    async initMfaSmsVerification() {
        try {
            await this.api.post(Kie, {
                action: "verify"
            })
        } catch (e) {
            throw qt(e)
        }
    }
    async initMfaPasskeyVerification() {
        try {
            let e = await this.api.post(Yie, {});
            return W9e(e.options)
        } catch (e) {
            throw qt(e)
        }
    }
    async getCrossAppProviderDetails(e) {
        try {
            return this._cachedProviderAppDetails[e] || (this._cachedProviderAppDetails[e] = await this.api.get(`/api/v1/apps/${e}/cross-app/details`)), this._cachedProviderAppDetails[e]
        } catch (r) {
            console.error("Error fetching cross app provider details", r)
        }
    }
    async acceptTerms() {
        try {
            let e = await this.api.post(Zie, {});
            return Vn(e)
        } catch (e) {
            throw xr(e)
        }
    }
    async unlinkEmail(e) {
        try {
            let r = await this.api.post(Cie, {
                address: e
            });
            return await this.getAuthenticatedUser() ? ? Vn(r)
        } catch (r) {
            throw xr(r)
        }
    }
    async unlinkPhone(e) {
        try {
            let r = await this.api.post(Sie, {
                phoneNumber: e
            });
            return await this.getAuthenticatedUser() ? ? Vn(r)
        } catch (r) {
            throw xr(r)
        }
    }
    async unlinkEthereumWallet(e) {
        try {
            let r = await this.api.post(cie, {
                address: e
            });
            return await this.getAuthenticatedUser() ? ? Vn(r)
        } catch (r) {
            throw xr(r)
        }
    }
    async unlinkSolanaWallet(e) {
        try {
            let r = await this.api.post(fie, {
                address: e
            });
            return await this.getAuthenticatedUser() ? ? Vn(r)
        } catch (r) {
            throw xr(r)
        }
    }
    async unlinkOAuth(e, r) {
        try {
            let n = await this.api.post(Oie, {
                provider: e,
                subject: r
            });
            return await this.getAuthenticatedUser() ? ? Vn(n)
        } catch (n) {
            throw xr(n)
        }
    }
    async unlinkFarcaster(e) {
        try {
            let r = await this.api.post(bie, {
                fid: e
            });
            return await this.getAuthenticatedUser() ? ? Vn(r)
        } catch (r) {
            throw xr(r)
        }
    }
    async unlinkTelegram(e) {
        try {
            let r = await this.api.post(Vie, {
                telegram_user_id: e
            });
            return await this.getAuthenticatedUser() ? ? Vn(r)
        } catch (r) {
            throw xr(r)
        }
    }
    async revokeDelegatedWallet() {
        try {
            await this.api.post(nse, {})
        } catch (e) {
            throw xr(e)
        }
    }
    async createAnalyticsEvent({
        eventName: e,
        payload: r,
        timestamp: n,
        options: i
    }) {
        if (typeof window < "u") try {
            this.clientAnalyticsId || console.warn("No client analytics id set, refusing to send analytics event"), await this.api.post(lO, {
                event_name: e,
                client_id: this.clientAnalyticsId,
                payload: { ...r || {},
                    clientTimestamp: n ? n.toISOString() : new Date().toISOString()
                }
            }, {
                retry: -1,
                keepalive: (i == null ? void 0 : i.keepAlive) ? ? !1
            })
        } catch {
            console.log("Unable to submit event. This is not an issue.")
        }
    }
    async signMoonpayOnRampUrl(e) {
        try {
            return this.api.post(ese, e)
        } catch (r) {
            throw xr(r)
        }
    }
    async initCoinbaseOnRamp(e) {
        try {
            return this.api.post(tse, e)
        } catch (r) {
            throw xr(r)
        }
    }
    async getCoinbaseOnRampStatus({
        partnerUserId: e
    }) {
        try {
            return this.api.get(`${rse}?partnerUserId=${e}`)
        } catch (r) {
            throw xr(r)
        }
    }
    async getAuthenticatedUser() {
        return this.session.hasRefreshCredentials() ? this.session.refresh() : null
    }
    async getAccessToken(e) {
        return await this.getPrivyAccessToken(e) || await this.getCustomerAccessToken(e)
    }
    async getCustomerAccessToken(e) {
        return await this._getToken(m$.CUSTOMER, e)
    }
    async getPrivyAccessToken(e) {
        return await this._getToken(m$.PRIVY, e)
    }
    async _getToken(e, r) {
        var n;
        return this.session.getToken(e) ? this.session.hasActiveAccessToken(e) ? this.session.hasRefreshCredentials(e) ? ((n = d8.parse(this.session.getToken(e))) == null ? void 0 : n.appId) !== this.appId ? (await this.logout(), null) : this.session.getToken(e) : (this.session.destroyLocalState(), null) : !(r != null && r.disableAutoRefresh) && this.session.hasRefreshCredentials(e) ? (await this.session.refresh(), this.session.getToken(e)) : null : null
    }
    async getSmartWalletsConfig() {
        try {
            let e = {},
                r = this.session.token;
            r && (e.authorization = `Bearer ${r}`);
            let n = await this.api.get(`/api/v1/apps/${this.appId}/smart_wallets`, {
                baseURL: this.fallbackApiUrl,
                headers: e
            });
            return n.enabled ? {
                enabled: n.enabled,
                smartWalletVersion: n.smart_wallet_version,
                smartWalletType: n.smart_wallet_type,
                configuredNetworks: n.configured_networks.map(i => ({
                    chainId: i.chain_id,
                    bundlerUrl: i.bundler_url,
                    paymasterUrl: i.paymaster_url,
                    paymasterContext: B9e(i.paymaster_url, i.paymaster_context)
                }))
            } : {
                enabled: n.enabled
            }
        } catch (e) {
            throw xr(e)
        }
    }
    async getUsdTokenPrice(e) {
        try {
            return (await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd
        } catch {
            return void console.error(`Unable to fetch token price for chain with id ${e.id}`)
        }
    }
    async getUsdPriceForSol() {
        try {
            return (await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd
        } catch {
            return void console.error("Unable to fetch token price for SOL")
        }
    }
    async getSplTokenMetadata({
        mintAddress: e,
        cluster: r
    }) {
        try {
            return await this.api.get(`/api/v1/spl_token_info?mint_address=${e}&cluster=${r}`)
        } catch {
            return void console.error(`Unable to fetch token metadata for ${r}:${e}`)
        }
    }
    async requestFarcasterSignerStatus(e) {
        try {
            return await this.api.post("/api/v1/farcaster/signer/status", {
                ed25519_public_key: e
            })
        } catch (r) {
            throw console.error("Unable to fetch Farcaster signer status"), r
        }
    }
    async generateSiweNonce({
        address: e,
        captchaToken: r
    }) {
        try {
            return (await this.api.post(iie, {
                address: e,
                token: r
            })).nonce
        } catch (n) {
            throw xr(n)
        }
    }
    async authenticateWithSiweInternal({
        message: e,
        signature: r,
        chainId: n,
        walletClientType: i,
        connectorType: s,
        mode: a
    }) {
        return await this.api.post(sie, {
            message: e,
            signature: r,
            chainId: n,
            walletClientType: i,
            connectorType: s,
            mode: a
        })
    }
    async linkWithSiweInternal({
        message: e,
        signature: r,
        chainId: n,
        walletClientType: i,
        connectorType: s
    }) {
        return await this.api.post(aie, {
            message: e,
            signature: r,
            chainId: n,
            walletClientType: i,
            connectorType: s
        })
    }
    async linkSmartWallet({
        message: e,
        signature: r,
        smartWalletType: n,
        smartWalletVersion: i
    }) {
        try {
            let s = await this.api.post(oie, {
                message: e,
                signature: r,
                smart_wallet_type: n,
                smart_wallet_version: i
            });
            return Vn(s)
        } catch (s) {
            throw xr(s)
        }
    }
    async linkWithSiwe({
        message: e,
        signature: r,
        chainId: n,
        walletClientType: i,
        connectorType: s
    }) {
        try {
            let a = await this.linkWithSiweInternal({
                message: e,
                signature: r,
                chainId: n,
                walletClientType: i,
                connectorType: s
            });
            return Vn(a)
        } catch (a) {
            throw xr(a)
        }
    }
    async generateSiwsNonce({
        address: e,
        captchaToken: r
    }) {
        try {
            return (await this.api.post(die, {
                address: e,
                token: r
            })).nonce
        } catch (n) {
            throw xr(n)
        }
    }
    async authenticateWithSiwsInternal({
        message: e,
        signature: r,
        walletClientType: n,
        connectorType: i,
        mode: s,
        messageType: a = "plain"
    }) {
        return await this.api.post(uie, {
            message: e,
            signature: r,
            walletClientType: n,
            connectorType: i,
            mode: s,
            message_type: a
        })
    }
    async sendAccountTransferRequest({
        nonce: e,
        account: r,
        accountType: n,
        externalWalletMetadata: i,
        telegramAuthResult: s,
        telegramWebAppData: a,
        farcasterEmbeddedAddress: o,
        oAuthUserInfo: c
    }) {
        try {
            let l, u;
            switch (n) {
                case "email":
                    l = kie, u = {
                        nonce: e,
                        email: r
                    };
                    break;
                case "sms":
                    l = Nie, u = {
                        nonce: e,
                        phoneNumber: r
                    };
                    break;
                case "siwe":
                    if (l = lie, !i) throw Error("Wallet parameters must be defined");
                    u = {
                        nonce: e,
                        address: r,
                        ...i
                    };
                    break;
                case "farcaster":
                    l = vie, u = {
                        nonce: e,
                        farcaster_id: r,
                        farcaster_embedded_address: o
                    };
                    break;
                case "telegram":
                    l = Gie, u = {
                        nonce: e,
                        telegram_auth_result: s,
                        telegram_web_app_data: a
                    };
                    break;
                case "siws":
                    l = pie, u = {
                        nonce: e,
                        address: r,
                        ...i
                    };
                    break;
                case "custom":
                case "guest":
                case "passkey":
                    throw Error("Invalid transfer account type");
                default:
                    l = jie, u = {
                        nonce: e,
                        userInfo: c
                    }
            }
            let h = await this.api.post(l, u);
            return await this.getAuthenticatedUser() ? ? Vn(h)
        } catch (l) {
            throw xr(l)
        }
    }
    async linkWithSiwsInternal({
        message: e,
        signature: r,
        walletClientType: n,
        connectorType: i,
        messageType: s = "plain"
    }) {
        return await this.api.post(hie, {
            message: e,
            signature: r,
            walletClientType: n,
            connectorType: i,
            message_type: s
        })
    }
    async linkWithSiws({
        message: e,
        signature: r,
        walletClientType: n,
        connectorType: i,
        messageType: s = "plain"
    }) {
        try {
            let a = await this.linkWithSiwsInternal({
                message: e,
                signature: r,
                walletClientType: n,
                connectorType: i,
                messageType: s
            });
            return Vn(a)
        } catch (a) {
            throw xr(a)
        }
    }
    async updateUserAndIdToken() {
        try {
            let e = await this.api.get(ise);
            return this.session.updateIdentityToken(e.identity_token), Vn(e.user)
        } catch (e) {
            throw xr(e)
        }
    }
    async scanTransaction(e) {
        try {
            return await this.api.post(sse, e)
        } catch (r) {
            throw xr(r)
        }
    }
    constructor({
        apiUrl: e = u4,
        appId: r,
        appClientId: n,
        timeout: i = 2e4
    }) {
        Object.defineProperty(this, Ev, {
            value: G9e
        }), this._cachedProviderAppDetails = {}, this.apiUrl = e, this.fallbackApiUrl = this.apiUrl, this.useServerCookies = e !== u4 && e.startsWith("https://privy."), this.timeout = i, this.appId = r, this.appClientId = n, this.clientAnalyticsId = function(s, a) {
            if (!Object.prototype.hasOwnProperty.call(s, a)) throw TypeError("attempted to use private field on non-instance");
            return s
        }(this, Ev)[Ev](), xv || (xv = new q9e), this.session = xv, this.api = this.generateApi(), this.session.client = this
    }
}

function G9e() {
    if (typeof window > "u") return null;
    try {
        let e = rt.get(h4);
        if (typeof e == "string" && e.length > 0) return e
    } catch {}
    let t = Sm();
    try {
        return rt.put(h4, t), t
    } catch {
        return t
    }
}
const K9e = ({
        delayedExecution: t,
        ...e
    }) => {
        let {
            enabled: r,
            siteKey: n,
            appId: i,
            setError: s,
            setToken: a,
            setExecuting: o,
            ref: c
        } = qi(), [, l] = v.useMemo(() => (n == null ? void 0 : n.split("t:")) || [], [n]);
        if (v.useEffect(() => {
                var u;
                return (u = c.current) == null ? void 0 : u.remove
            }, []), !r) return null;
        if (!l) throw Error("Unsupported captcha site key");
        return d.jsx("div", {
            className: "hidden h-0 w-0",
            children: d.jsx(QO, { ...e,
                ref: c,
                siteKey: l,
                options: {
                    action: i,
                    size: "invisible",
                    ...t ? {
                        appearance: "execute",
                        execution: "execute"
                    } : {
                        appearance: "always",
                        execution: "render"
                    }
                },
                onUnsupported: () => {
                    var u;
                    (u = e.onUnsupported) == null || u.call(e), console.warn("Browser does not support Turnstile.")
                },
                onError: () => {
                    var u;
                    (u = e.onError) == null || u.call(e), s("Captcha failed"), o(!1)
                },
                onSuccess: u => {
                    var h;
                    (h = e.onSuccess) == null || h.call(e, u), a(u), o(!1)
                },
                onExpire: () => {
                    var u, h;
                    (u = e.onExpire) == null || u.call(e);
                    try {
                        (h = c.current) == null || h.reset(), s(void 0), a(void 0)
                    } catch {
                        s("expired_and_failed_reset")
                    }
                }
            })
        })
    },
    Y9e = t => {
        let [e, r] = v.useState("auto");
        return v.useEffect(() => {
            let n = new ResizeObserver(i => {
                var s;
                r(((s = i[0]) == null ? void 0 : s.contentRect.height) ? ? "auto")
            });
            return t.current && n.observe(t.current), () => {
                t.current && n.unobserve(t.current)
            }
        }, [t.current]), e
    },
    Z9e = {
        login: {
            onComplete: [],
            onError: []
        },
        logout: {
            onSuccess: []
        },
        connectWallet: {
            onSuccess: [],
            onError: []
        },
        connectOrCreateWallet: {
            onSuccess: [],
            onError: []
        },
        createWallet: {
            onSuccess: [],
            onError: []
        },
        linkAccount: {
            onSuccess: [],
            onError: []
        },
        update: {
            onSuccess: [],
            onError: []
        },
        configureMfa: {
            onMfaRequired: []
        },
        setWalletPassword: {
            onSuccess: [],
            onError: []
        },
        setWalletRecovery: {
            onSuccess: [],
            onError: []
        },
        signMessage: {
            onSuccess: [],
            onError: []
        },
        signTypedData: {
            onSuccess: [],
            onError: []
        },
        sendTransaction: {
            onSuccess: [],
            onError: []
        },
        signTransaction: {
            onSuccess: [],
            onError: []
        },
        signSolanaTransaction: {
            onSuccess: [],
            onError: []
        },
        signSolanaMessage: {
            onSuccess: [],
            onError: []
        },
        sendSolanaTransaction: {
            onSuccess: [],
            onError: []
        },
        accessToken: {
            onAccessTokenGranted: [],
            onAccessTokenRemoved: []
        },
        oAuthAuthorization: {
            onOAuthTokenGrant: []
        },
        fundWallet: {
            onUserExited: []
        },
        fundSolanaWallet: {
            onUserExited: []
        },
        customAuth: {
            onAuthenticated: [],
            onUnauthenticated: []
        }
    },
    NU = v.createContext(void 0);
let OU = () => v.useContext(NU);

function Wd(t, e) {
    if (!e) return;
    let r = OU().current[t];
    return v.useEffect(() => {
        var n;
        for (let [i, s] of Object.entries(e)) Object.prototype.hasOwnProperty.call(r, i) || console.warn(`Invalid event type "${i}" for action "${t}"`), (n = r[i]) == null || n.push(s);
        return () => {
            var i;
            for (let [s, a] of Object.entries(e)) Object.prototype.hasOwnProperty.call(r, s) || console.warn(`Invalid event type "${s}" for action "${t}"`), r[s] = (i = r[s]) == null ? void 0 : i.filter(o => o !== a)
        }
    }, [e])
}

function _e(t, e, r, ...n) {
    for (let i of t.current[e][r]) i(...n)
}

function yc() {
    let t = OU();
    return (e, r, ...n) => _e(t, e, r, ...n)
}

function J9e(t) {
    Wd("configureMfa", t)
}
const lc = z.div.withConfig({
        displayName: "Grow",
        componentId: "sc-ddbf22b4-0"
    })(["text-align:left;flex-grow:1;"]),
    jU = z.div.withConfig({
        displayName: "AlignBottom",
        componentId: "sc-ddbf22b4-1"
    })(["display:flex;flex-direction:column;justify-content:flex-end;flex-grow:1;"]),
    zp = z.div.withConfig({
        displayName: "LoginMethodContainer",
        componentId: "sc-ddbf22b4-2"
    })(["display:flex;flex-direction:column;gap:12px;-ms-overflow-style:none;scrollbar-width:none;&::-webkit-scrollbar{display:none;}"]),
    RU = z(zp).withConfig({
        displayName: "LoginMethodContainerWithScrollShadows",
        componentId: "sc-ddbf22b4-3"
    })(["", " background-repeat:no-repeat;background-size:100% 32px,100% 16px;background-attachment:local,scroll;max-height:400px;overflow-y:auto;scrollbar-width:none;padding:2px;"], t => t.$colorScheme === "light" ? "background: linear-gradient(var(--privy-color-background), var(--privy-color-background) 70%) bottom, linear-gradient(rgba(0, 0, 0, 0) 20%, rgba(0, 0, 0, 0.06)) bottom;" : t.$colorScheme === "dark" ? "background: linear-gradient(var(--privy-color-background), var(--privy-color-background) 70%) bottom, linear-gradient(rgba(255, 255, 255, 0) 20%, rgba(255, 255, 255, 0.06)) bottom;" : void 0);
let MU = pi(["&&{width:100%;font-size:16px;line-height:24px;@media (min-width:440px){font-size:14px;}display:flex;gap:12px;align-items:center;padding:12px 16px;border:1px solid var(--privy-color-foreground-4) !important;border-radius:var(--privy-border-radius-mdlg);transition:background-color 200ms ease;cursor:pointer;&:hover{background-color:var(--privy-color-background-2);}&:disabled{cursor:pointer;background-color:var(--privy-color-background-2);}svg{height:24px;max-height:24px;max-width:24px;}}"]);
const DU = z.div.withConfig({
        displayName: "Subtitle",
        componentId: "sc-ddbf22b4-4"
    })(["text-align:center;font-size:14px;margin-bottom:24px;"]),
    Pr = z.button.attrs({
        className: "login-method-button"
    }).withConfig({
        displayName: "LoginMethodButton",
        componentId: "sc-ddbf22b4-5"
    })(["", ""], MU),
    y$ = z.a.withConfig({
        displayName: "LoginMethodButtonLink",
        componentId: "sc-ddbf22b4-6"
    })(["", ""], MU),
    ch = z.div.withConfig({
        displayName: "Hide",
        componentId: "sc-ddbf22b4-7"
    })(["width:100%;height:100%;min-height:inherit;display:flex;flex-direction:column;", ""], t => t.$if ? "display: none;" : ""),
    Q9e = z.div.withConfig({
        displayName: "EmptyWalletState",
        componentId: "sc-ddbf22b4-8"
    })(["width:100%;height:100%;padding:", ";"], t => t.$withPadding ? "64px 0px" : "0px"),
    X9e = z.div.withConfig({
        displayName: "Header",
        componentId: "sc-ddbf22b4-9"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;margin-bottom:32px;gap:12px;& h3{font-size:18px;font-style:normal;font-weight:600;line-height:24px;}& p{max-width:300px;font-size:14px;font-style:normal;font-weight:400;line-height:20px;}"]);

function eCe(t) {
    return d.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 460 40",
        ...t,
        children: d.jsx("g", {
            fill: t.color || "var(--privy-color-foreground)",
            children: d.jsx("path", {
                d: "M0 15.4v15.38h4.64V19.96h3.58c2.47 0 3.63-.01 3.77-.02 1-.08 1.49-.15 2.18-.3a9.45 9.45 0 0 0 4.6-2.37c1.66-1.57 2.64-3.87 2.81-6.56.02-.3.02-1.19 0-1.49-.1-1.77-.56-3.35-1.36-4.72A8.84 8.84 0 0 0 15.14.57c-.93-.3-1.75-.43-3.09-.54C11.9.02 10.2 0 5.93 0H0ZM10.85 4c1.85.05 3.1.45 4.16 1.3.22.17.54.49.69.68a5.97 5.97 0 0 1 1.19 3.13c.04.35.04 1.36 0 1.71-.08.68-.23 1.3-.44 1.85a4.8 4.8 0 0 1-1.09 1.68A5.63 5.63 0 0 1 12 15.92c-.6.08-.4.08-4.01.09H4.64V3.98h2.9c1.6 0 3.08 0 3.31.02ZM187.65 5.71v5.72h-.27l-.09-.14a15.9 15.9 0 0 0-1.21-1.73c-.43-.5-1-.95-1.7-1.36-.54-.3-1.05-.5-1.73-.63a8.98 8.98 0 0 0-1.7-.17 8.84 8.84 0 0 0-7.8 4.03 12.95 12.95 0 0 0-2.03 6.39c-.07.98-.06 2.15.02 3.13.2 2.47.87 4.53 2.02 6.25a8.98 8.98 0 0 0 10.22 3.65 6.5 6.5 0 0 0 2.8-1.93c.41-.51.84-1.1 1.1-1.55l.1-.17h.37v3.58h4.38V0h-4.48Zm-5.24 5.54c1.3.14 2.3.6 3.17 1.48.9.9 1.5 2.09 1.85 3.64.36 1.6.39 3.72.06 5.43a8.13 8.13 0 0 1-1.54 3.62 5.1 5.1 0 0 1-3.93 1.96 6.13 6.13 0 0 1-2.32-.31 5.87 5.87 0 0 1-3.33-3.5c-.39-1-.62-2.05-.72-3.32-.03-.32-.04-1.35-.02-1.73.08-1.56.4-2.91.96-4.05a6.2 6.2 0 0 1 1.06-1.58 5.08 5.08 0 0 1 3.6-1.66c.25-.02.9 0 1.16.02ZM210.07 15.39l.01 15.38h4.38l.01-3.57h.37l.09.15c.24.44.84 1.26 1.21 1.7a6.79 6.79 0 0 0 2.57 1.75 9.3 9.3 0 0 0 6.86-.49 9.28 9.28 0 0 0 4.05-4.07A13.05 13.05 0 0 0 231 21.6c.21-1.73.18-3.7-.09-5.32a13.03 13.03 0 0 0-1.5-4.3 9.1 9.1 0 0 0-3.75-3.63 9.15 9.15 0 0 0-4.43-.96 7.46 7.46 0 0 0-2.8.5A7.07 7.07 0 0 0 216 9.7c-.4.52-.82 1.12-1.1 1.59l-.07.14h-.27V0h-4.5Zm11.13-4.14c1.07.1 1.94.44 2.7 1.04a6.1 6.1 0 0 1 1.64 1.98c.43.84.78 2 .94 3.11.15 1.16.16 2.4.02 3.54a9.34 9.34 0 0 1-1.39 4.03 5.33 5.33 0 0 1-2.69 2.15c-.9.3-2.04.38-3.06.2a5.14 5.14 0 0 1-3.45-2.37 6.03 6.03 0 0 1-.45-.8c-.5-1.03-.8-2.2-.92-3.58-.04-.49-.06-.89-.05-1.53.01-.76.05-1.23.13-1.85.38-2.53 1.47-4.38 3.15-5.31a5.46 5.46 0 0 1 2.3-.63 10 10 0 0 1 1.13.02ZM69.05 2.17l-.01 2.77V7.7h-3.36v3.6h3.36v6.8l.01 7.15c.06 1.4.4 2.44 1.1 3.37a5.8 5.8 0 0 0 2.97 2.07c.91.3 1.83.42 2.9.38a8.71 8.71 0 0 0 2.66-.48l-.8-3.7-.38.06a4.96 4.96 0 0 1-2.43-.06c-.33-.1-.56-.25-.8-.49-.4-.41-.6-.88-.7-1.67-.02-.2-.02-.62-.03-6.82v-6.6h4.73V7.7h-4.73V2.16h-4.49ZM133.34 2.17V7.7h-3.39v3.6h3.38v6.9l.01 7.17a5.66 5.66 0 0 0 2.36 4.49c.85.6 2.03 1.03 3.26 1.17.85.1 2.03.05 2.81-.1.3-.06.75-.18 1-.26l.2-.06v-.05l-.81-3.67-.37.06a4.99 4.99 0 0 1-1.8.09c-.85-.13-1.32-.4-1.7-.97a2.63 2.63 0 0 1-.39-1.04c-.06-.4-.06 0-.06-7.1V11.3h4.7V7.7h-4.7l-.01-2.77V2.16h-4.49ZM293.41 2.36a14.56 14.56 0 0 0-13.7 16.07 14.59 14.59 0 0 0 21.86 11.08 14.5 14.5 0 0 0 7.11-14.07 14.61 14.61 0 0 0-6.53-10.73 14.49 14.49 0 0 0-8.74-2.35ZM350.8 2.36a10.17 10.17 0 0 0-7.56 4.2c-.16.2-.45.63-.58.83l-.05.1h-.47l-.01-4.36h-7.36v36.4h7.82V27.27h.49l.05.07a11.3 11.3 0 0 0 7.49 4.15 10.52 10.52 0 0 0 9.38-4.1c1.66-2.1 2.73-4.9 3.07-8.06.1-.87.13-1.4.13-2.37 0-.8 0-1.1-.07-1.76a15.95 15.95 0 0 0-3.23-8.72 12.8 12.8 0 0 0-1.85-1.84 10.49 10.49 0 0 0-7.26-2.28Zm-.94 6.05c1.27.15 2.33.65 3.2 1.5.98.96 1.67 2.31 2.03 4 .34 1.57.38 3.68.12 5.39a9.78 9.78 0 0 1-1.04 3.25c-.14.25-.44.69-.6.89a5.35 5.35 0 0 1-4.31 2.07 5.25 5.25 0 0 1-4.41-1.9 7.35 7.35 0 0 1-1.26-2.32 14.09 14.09 0 0 1-.62-4.83c.05-1.98.38-3.53 1.02-4.85a5.63 5.63 0 0 1 2.5-2.65c.66-.34 1.3-.5 2.14-.58.18-.02 1.04 0 1.23.03ZM363.63 3.1l-.01 3.2v3.16h1.43c1.26.01 1.44.02 1.54.04.42.09.66.28.79.62.08.23.08.08.08 2.96a911.57 911.57 0 0 1 .03 10.18v7.54h7.82v-7.4l.01-7.83c.03-.94.11-1.63.27-2.28.46-1.9 1.54-2.93 3.35-3.23.52-.08.2-.08 5-.08h4.4V3.08h-3.1c-3.48 0-3.91.01-4.67.1-1.83.2-3.04.79-3.96 1.88-.5.6-.9 1.32-1.26 2.26l-.06.17h-.46V3.09h-5.6c-4.46 0-5.6 0-5.6.02ZM390.8 16.95V30.8h3.87l3.86-.01V3.09h-7.73ZM400.6 3.1l-.01.4v.38l4.66 13.4 4.69 13.47.02.05h10.3l.03-.05 4.67-13.45 4.67-13.4V3.1h-7.43l-6.7 19.26h-.5l-3.28-9.5-3.31-9.64-.05-.12h-3.88l-3.88.01ZM430.98 3.1c-.01 0-.02.19-.02.4v.39l5.08 14.59c2.8 8.02 5.08 14.6 5.08 14.61.01.02-.22.02-4.8.02h-4.82v6.42h4.95c5.09 0 5.23 0 5.87-.06 3.15-.28 5.29-1.63 6.63-4.15.28-.55.44-.95.87-2.16L459 6.78l1-2.89v-.8h-7.43l-6.69 19.26h-.5l-3.27-9.46-3.31-9.64-.06-.16h-3.88l-3.88.01ZM36.57 7.36c-1.36.1-2.6.6-3.62 1.45a5.65 5.65 0 0 0-1.67 2.42l-.05.13H31V7.7h-4.35v23.08h4.5v-7.3c0-8 0-7.34.08-7.82a4.89 4.89 0 0 1 2.06-3.18c.83-.58 1.74-.89 2.87-.98a11.87 11.87 0 0 1 2.8.25H39v-4.3l-.21-.02c-.61-.07-1.74-.1-2.22-.07ZM51.08 7.41c-2.33.12-4.3.84-5.95 2.16a9.89 9.89 0 0 0-2.03 2.2 12.5 12.5 0 0 0-2 5.78 18.04 18.04 0 0 0 0 3.65 12.13 12.13 0 0 0 2.26 6.05 9.74 9.74 0 0 0 5 3.52c2.11.64 4.7.64 6.8 0a9.78 9.78 0 0 0 4.88-3.37c1.38-1.78 2.19-4 2.4-6.58.13-1.46.06-3.06-.18-4.42a11.24 11.24 0 0 0-3.58-6.6 10 10 0 0 0-5.75-2.35c-.56-.06-1.31-.07-1.85-.04Zm1.42 3.78c.88.1 1.62.34 2.28.75a6.13 6.13 0 0 1 1.99 2.15 10.31 10.31 0 0 1 1.2 5c.02 1.23-.12 2.44-.42 3.51a7.14 7.14 0 0 1-1.81 3.32c-.61.6-1.2.98-1.95 1.24a6 6 0 0 1-2 .3 5.7 5.7 0 0 1-2.72-.6 5 5 0 0 1-1.28-.94A7.1 7.1 0 0 1 46 22.73c-.57-1.99-.6-4.46-.08-6.5a7.24 7.24 0 0 1 2.03-3.67 5.13 5.13 0 0 1 3.35-1.4 11 11 0 0 1 1.2.03ZM92.05 7.4c-.96.06-1.56.15-2.3.33a9.62 9.62 0 0 0-6.09 4.66 13.5 13.5 0 0 0-1.71 7c0 .83 0 1.04.06 1.6.16 1.77.58 3.32 1.29 4.7A9.72 9.72 0 0 0 90.28 31c1.84.37 4.08.32 5.85-.13a9.07 9.07 0 0 0 5.02-3.1A7.64 7.64 0 0 0 102.5 25l-2.11-.39-2.11-.38-.08.13a4.72 4.72 0 0 1-2.35 2.55 6.3 6.3 0 0 1-2.23.58c-.29.03-1.13.03-1.44 0a6.35 6.35 0 0 1-3.02-1.04 5.93 5.93 0 0 1-2.02-2.43 8.44 8.44 0 0 1-.72-3.18v-.26h16.38v-.81c0-1.83-.06-2.76-.25-3.87-.2-1.22-.53-2.24-1.05-3.28a8.9 8.9 0 0 0-2.66-3.26 10.1 10.1 0 0 0-5.34-1.94 18.3 18.3 0 0 0-1.46-.03Zm1.3 3.75c1.2.13 2.19.55 3.05 1.3a5.8 5.8 0 0 1 1.78 2.96c.13.51.21 1.17.21 1.66v.15H86.43v-.12c.08-.97.3-1.78.72-2.61.5-1 1.2-1.8 2.14-2.42a5.32 5.32 0 0 1 2.9-.95c.2-.01.97 0 1.17.03ZM116.79 7.41c-2 .1-3.73.65-5.22 1.65a10.7 10.7 0 0 0-4.25 6.06 16.1 16.1 0 0 0-.5 5.8c.2 2.17.84 4.13 1.88 5.76.58.9 1.32 1.73 2.15 2.4a9.37 9.37 0 0 0 3.6 1.8 12.06 12.06 0 0 0 3.92.34 10.2 10.2 0 0 0 3.84-.95 8.31 8.31 0 0 0 4.76-6.75l.01-.04h-4.37l-.05.16a4.87 4.87 0 0 1-4.24 3.75c-.59.07-1.32.06-1.93-.05a5.47 5.47 0 0 1-3.5-2.27c-.56-.75-1-1.73-1.26-2.79a13.8 13.8 0 0 1-.16-5.24 7.77 7.77 0 0 1 2.1-4.3 5.48 5.48 0 0 1 2.15-1.3 6.4 6.4 0 0 1 3.89.1c.59.21 1.03.5 1.5.96a5.32 5.32 0 0 1 1.46 2.5l.04.15h4.37v-.06a8.22 8.22 0 0 0-5.31-6.94 10.98 10.98 0 0 0-4.88-.74ZM156.2 7.41a9.87 9.87 0 0 0-6 2.29 11.02 11.02 0 0 0-3.41 5.43c-.52 1.78-.68 3.9-.48 5.97.17 1.8.63 3.38 1.37 4.8a9.68 9.68 0 0 0 5.91 4.86c1.65.48 3.63.61 5.53.36 3.72-.49 6.55-2.62 7.56-5.69.12-.39.13-.42.1-.43-.02 0-4.13-.75-4.19-.75-.03 0-.04 0-.1.16-.18.42-.45.9-.72 1.22-.16.2-.49.53-.7.7-.67.54-1.5.9-2.43 1.08-.48.08-.83.11-1.41.11-.64 0-1.07-.04-1.6-.15a5.76 5.76 0 0 1-3.93-2.83 8 8 0 0 1-.99-3.79v-.16h16.38v-1.11l-.02-1.43c-.1-2.25-.53-4-1.35-5.59a9.24 9.24 0 0 0-6.18-4.75c-1.04-.26-2.2-.36-3.33-.3Zm1.45 3.74a5.35 5.35 0 0 1 3.66 1.94 6.1 6.1 0 0 1 1.38 4.01v.12h-11.97v-.06c0-.02 0-.14.02-.25a6.6 6.6 0 0 1 2.15-4.32 5.73 5.73 0 0 1 3.5-1.46c.25-.02 1 0 1.26.02ZM233.58 7.82l8.37 23.22a49.22 49.22 0 0 1-.67 1.9 5.36 5.36 0 0 1-1.14 1.8c-.41.4-.82.58-1.48.69-.27.04-1.03.03-1.35 0a8.05 8.05 0 0 1-1.1-.23l-1.08 3.67c0 .02.32.14.66.22.83.21 1.57.29 2.56.28.56-.01.8-.03 1.24-.1 2.71-.4 4.66-2.09 5.86-5.08l9.64-26.44c0-.02-4.82-.06-4.83-.05l-2.93 8.96-2.91 8.94h-.24l-.22-.65-2.91-8.95-2.7-8.3H233.53ZM293.05 35.8c-1.18.04-1.93.09-2.8.16-2.52.24-4.53.69-5.43 1.23-.7.41-.76.86-.2 1.28.88.66 3.29 1.19 6.36 1.4a48.55 48.55 0 0 0 5.75.05c3.47-.19 6.24-.78 7.11-1.5.22-.19.3-.34.3-.53 0-.1 0-.12-.04-.22-.35-.69-2.32-1.3-5.25-1.63a41.09 41.09 0 0 0-5.8-.24Zm0 0"
            })
        })
    })
}
let w$ = z.div.withConfig({
    displayName: "TermsAndConditionsContainer",
    componentId: "sc-bdb69ecc-0"
})(["margin-top:16px;font-size:13px;text-align:center;color:var(--privy-color-foreground-3);&& > a{color:var(--privy-color-accent);}"]);

function Yy({
    app: {
        legal: {
            privacyPolicyUrl: t,
            termsAndConditionsUrl: e,
            requireUsersAcceptTerms: r
        }
    },
    alwaysShowImplicitConsent: n
}) {
    let i = !(!t || !e);
    return r && !n || !e && !t ? d.jsx(w$, {}) : d.jsxs(w$, {
        children: ["By logging in I agree to the", " ", e && d.jsx("a", {
            href: e,
            target: "_blank",
            children: i ? "Terms" : "Terms of Service"
        }), i && " & ", t && d.jsx("a", {
            href: t,
            target: "_blank",
            children: "Privacy Policy"
        })]
    })
}
const ot = () => {
        let {
            appearance: t
        } = Gt();
        return d.jsx(Wt, {
            children: t.footerLogo ? ? d.jsx("a", {
                href: "https://www.privy.io/",
                target: "_blank",
                id: "protected-by-privy",
                children: d.jsx(eCe, {
                    height: 13,
                    width: 150
                })
            })
        })
    },
    Wt = z.div.withConfig({
        displayName: "ModalFooter",
        componentId: "sc-bdb69ecc-1"
    })(["display:flex;align-items:center;justify-content:center;padding-top:8px;padding-bottom:12px;gap:8px;font-size:13px;&& a{padding:0.5rem 0;&:hover{text-decoration:none;}}@media all and (display-mode:standalone){padding-bottom:30px;}"]),
    tCe = ({
        backFn: t
    }) => d.jsx("div", {
        children: d.jsx(y8, {
            onClick: t,
            children: d.jsx(tj, {
                height: "16px",
                width: "16px",
                strokeWidth: 2
            })
        })
    }),
    rCe = ({
        infoFn: t
    }) => d.jsx("div", {
        children: d.jsx(iCe, {
            "aria-label": "info",
            onClick: t,
            children: d.jsx(Ql, {
                height: "22px",
                width: "22px",
                strokeWidth: 2
            })
        })
    }),
    nCe = t => d.jsx("div", {
        children: d.jsx(y8, {
            "aria-label": "close modal",
            onClick: t.onClose,
            children: d.jsx(_oe, {
                height: "16px",
                width: "16px",
                strokeWidth: 2
            })
        })
    }),
    Pe = ({
        backFn: t,
        infoFn: e,
        onClose: r,
        title: n,
        closeable: i = !0
    }) => {
        let {
            closePrivyModal: s
        } = $e(), a = Gt();
        return d.jsxs(sCe, {
            children: [d.jsxs(aCe, {
                children: [t && d.jsx(tCe, {
                    backFn: t
                }), e && d.jsx(rCe, {
                    infoFn: e
                })]
            }), n && d.jsx(cCe, {
                id: "privy-dialog-title",
                children: n
            }), d.jsx(oCe, {
                children: !a.render.standalone && i && d.jsx(nCe, {
                    onClose: r || (() => s())
                })
            })]
        })
    };
let y8 = z.button.withConfig({
        displayName: "StyledButton",
        componentId: "sc-f295093d-0"
    })(["&&{cursor:pointer;display:flex;opacity:0.6;background-color:var(--privy-color-background-2);border-radius:var(--privy-border-radius-full);padding:4px;> svg{margin:auto;color:var(--privy-color-foreground);}:hover{opacity:1;}}"]),
    iCe = z(y8).withConfig({
        displayName: "TransparentStyledButton",
        componentId: "sc-f295093d-1"
    })(["&&{background-color:transparent;}"]),
    sCe = z.div.withConfig({
        displayName: "StyledHeader",
        componentId: "sc-f295093d-2"
    })(["padding:16px 0;display:flex;align-items:center;justify-content:space-between;h2{font-size:16px;line-height:24px;font-weight:600;color:var(--privy-color-foreground);}"]),
    aCe = z.div.withConfig({
        displayName: "LeftActionContainer",
        componentId: "sc-f295093d-3"
    })(["flex:1;align-items:center;display:flex;gap:8px;"]),
    oCe = z.div.withConfig({
        displayName: "RightActionContainer",
        componentId: "sc-f295093d-4"
    })(["flex:1;display:flex;justify-content:flex-end;"]),
    cCe = z.div.withConfig({
        displayName: "TitleContainer",
        componentId: "sc-f295093d-5"
    })(["overflow:hidden;white-space:nowrap;max-width:100%;text-overflow:ellipsis;text-align:center;color:var(--privy-color-foreground-2);"]);
const O0 = z.div.withConfig({
        displayName: "AppLogoContainer",
        componentId: "sc-ba98f772-0"
    })(["display:flex;flex-direction:column;align-items:center;padding:0px 0px 30px;@media (max-width:440px){padding:10px 10px 20px;}"]),
    Cr = z.div.withConfig({
        displayName: "Title",
        componentId: "sc-ba98f772-1"
    })(["font-size:18px;line-height:30px;text-align:center;font-weight:600;margin-bottom:10px;"]),
    Ar = z.div.withConfig({
        displayName: "SubTitle",
        componentId: "sc-ba98f772-2"
    })(["font-size:0.875rem;text-align:center;"]),
    xd = z.div.withConfig({
        displayName: "Container",
        componentId: "sc-ba98f772-3"
    })(["display:flex;flex-direction:column;align-items:center;gap:10px;flex-grow:1;padding:20px 0;@media (max-width:440px){padding:10px 10px 20px;}"]),
    Zy = z.div.withConfig({
        displayName: "List",
        componentId: "sc-ba98f772-4"
    })(["display:flex;flex-direction:column;align-items:stretch;gap:0.75rem;padding:1rem 0rem 0rem;flex-grow:1;width:100%;"]),
    oo = z.div.withConfig({
        displayName: "ListItemIcon",
        componentId: "sc-ba98f772-5"
    })(["width:25px;display:flex;align-items:center;justify-content:flex-start;> svg{z-index:2;height:25px !important;width:25px !important;color:var(--privy-color-accent);}"]),
    co = z.div.withConfig({
        displayName: "ListItem",
        componentId: "sc-ba98f772-6"
    })(["display:flex;align-items:center;gap:10px;font-size:0.875rem;line-height:1rem;text-align:left;"]),
    Bo = z.div.withConfig({
        displayName: "BottomSection",
        componentId: "sc-ba98f772-7"
    })(["display:flex;flex-direction:column;gap:10px;padding-top:20px;"]),
    LU = z.div.withConfig({
        displayName: "MethodList",
        componentId: "sc-ba98f772-8"
    })(["display:flex;flex-direction:column;align-items:stretch;gap:1rem;padding:1rem 0rem 0rem;flex-grow:1;width:100%;"]),
    _v = z.div.withConfig({
        displayName: "MethodListItem",
        componentId: "sc-ba98f772-9"
    })(["display:flex;gap:5px;width:100%;position:relative;"]),
    Cv = z.button.withConfig({
        displayName: "RemoveMethodButton",
        componentId: "sc-ba98f772-10"
    })(["&&{background-color:transparent;color:var(--privy-color-foreground-3);padding:0 0.75rem;display:flex;align-items:center;height:100%;> svg{z-index:2;height:20px !important;width:20px !important;}}&&:hover{color:var(--privy-color-error);}"]),
    Av = z.div.withConfig({
        displayName: "MethodText",
        componentId: "sc-ba98f772-11"
    })(["display:flex;align-items:center;gap:0.5rem;> svg{z-index:2;height:20px !important;width:20px !important;}"]),
    b$ = z.div.withConfig({
        displayName: "ExtraText",
        componentId: "sc-ba98f772-12"
    })(["display:flex;align-items:center;gap:6px;font-weight:400 !important;color:", ";> svg{z-index:2;height:18px !important;width:18px !important;display:flex !important;align-items:flex-end;}"], t => t.$isAccent ? "var(--privy-color-accent)" : "var(--privy-color-foreground-3)"),
    kv = z.div.withConfig({
        displayName: "SmsInsecureText",
        componentId: "sc-ba98f772-13"
    })(["width:100%;display:flex;justify-content:space-between;"]),
    UU = z.p.withConfig({
        displayName: "TermsText",
        componentId: "sc-ba98f772-14"
    })(["text-align:left;width:100%;color:var(--privy-color-foreground-3) !important;"]),
    u1 = z.button.withConfig({
        displayName: "PrimaryTextButton",
        componentId: "sc-ba98f772-15"
    })(["display:flex;flex-direction:row;align-items:center;justify-content:center;user-select:none;&{width:100%;cursor:pointer;border-radius:var(--privy-border-radius-md);font-size:0.875rem;line-height:1rem;font-style:normal;font-weight:500;line-height:22px;letter-spacing:-0.016px;}&&{color:", ";background-color:transparent;padding:0.5rem 0px;}&:hover{text-decoration:underline;}"], t => t.theme === "dark" ? "var(--privy-color-foreground-2)" : "var(--privy-color-accent)"),
    Oi = z.div.withConfig({
        displayName: "IconWrapper",
        componentId: "sc-ba98f772-16"
    })(["display:flex;align-items:center;justify-content:center;color:var(--privy-color-accent);width:100%;> svg{z-index:2;width:3rem;height:3rem;}"]),
    FU = z.div.withConfig({
        displayName: "ErrorMessage",
        componentId: "sc-ba98f772-17"
    })(["color:var(--privy-color-error);"]),
    BU = ({
        handleClose: t,
        user: e,
        onSelect: r
    }) => d.jsxs(d.Fragment, {
        children: [d.jsx(Pe, {
            onClose: t
        }, "header"), d.jsx(Oi, {
            style: {
                marginBottom: "1.5rem"
            },
            children: d.jsx(hd, {})
        }), d.jsx(Cr, {
            children: "Verify your identity"
        }), d.jsx(Ar, {
            children: "Choose a verification method"
        }), d.jsxs(LU, {
            children: [e.mfaMethods.includes("totp") && d.jsxs(Pr, {
                onClick: () => r("totp"),
                children: [d.jsx(oy, {}), "Authenticator app"]
            }, "totp"), e.mfaMethods.includes("sms") && d.jsxs(Pr, {
                onClick: () => r("sms"),
                children: [d.jsx(Ca, {}), "SMS"]
            }, "sms"), e.mfaMethods.includes("passkey") && d.jsxs(Pr, {
                onClick: () => r("passkey"),
                children: [d.jsx(sx, {}), "Passkey"]
            }, "passkey")]
        }), d.jsx(Wt, {})]
    }),
    Ia = ({
        success: t,
        fail: e
    }) => d.jsxs(d.Fragment, {
        children: [d.jsx(Ls, {
            className: t ? "success" : e ? "fail" : ""
        }), d.jsx(w8, {
            className: t ? "success" : e ? "fail" : ""
        })]
    }),
    Ls = z.span.withConfig({
        displayName: "Loader",
        componentId: "sc-ce7792e2-0"
    })(["&&{width:82px;height:82px;border-width:4px;border-style:solid;border-color:", ";border-bottom-color:transparent;border-radius:50%;display:inline-block;box-sizing:border-box;animation:rotation 1.2s linear infinite;transition:border-color 800ms;}@keyframes rotation{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}&&&.success{border-color:var(--privy-color-success);border-bottom-color:var(--privy-color-success);}&&&.fail{border-color:var(--privy-color-error);border-bottom-color:var(--privy-color-error);}"], t => t.color ? ? "var(--privy-color-accent)"),
    w8 = z(Ls).withConfig({
        displayName: "LoaderFaint",
        componentId: "sc-ce7792e2-1"
    })(["&&{border-bottom-color:", ";animation:none;opacity:0.5;}"], t => t.color ? ? "var(--privy-color-accent)"),
    pl = t => d.jsx(lCe, {
        color: t.color || "var(--privy-color-foreground-3)"
    });
let lCe = z(Ls).withConfig({
    displayName: "StyledButtonLoader",
    componentId: "sc-ce7792e2-2"
})(["&&{height:1rem;width:1rem;margin:2px 0;border-width:1.5px;transition:border-color 200ms ease;}"]);
const Jy = z.button.withConfig({
        displayName: "Button",
        componentId: "sc-172643dd-0"
    })(["display:flex;flex-direction:row;align-items:center;justify-content:center;user-select:none;&{width:100%;cursor:pointer;border-radius:var(--privy-border-radius-md);font-size:1rem;font-style:normal;font-weight:500;line-height:22px;letter-spacing:-0.016px;}&&{padding:12px 16px;}"]),
    Qe = ({
        children: t,
        loading: e,
        disabled: r,
        success: n,
        loadingText: i = "Loading...",
        ...s
    }) => d.jsx(WU, {
        disabled: e || r,
        $success: n,
        ...s,
        children: e ? d.jsxs("span", {
            children: [d.jsx(pl, {}), i ? d.jsx("span", {
                children: i
            }) : null]
        }) : t
    }),
    qp = ({
        children: t,
        loading: e,
        disabled: r,
        ...n
    }) => d.jsx(dCe, {
        disabled: r,
        ...n,
        children: e ? d.jsx(pl, {
            color: "var(--privy-color-foreground-accent)"
        }) : t
    });
let dCe = z(Jy).withConfig({
    displayName: "StyledPrimaryButtonWithoutGray",
    componentId: "sc-172643dd-1"
})(["position:relative;&&{background-color:var(--privy-color-accent);color:var(--privy-color-foreground-accent);transition:background-color 200ms ease;}&:hover{background-color:var(--privy-color-accent-dark);}&:active{background-color:var(--privy-color-accent-dark);}&:disabled,&:hover:disabled,&:active:disabled{cursor:not-allowed;pointer-events:none;color:var(--privy-color-foreground-accent);background-color:var(--privy-color-accent-dark);}"]);
const uCe = ({
    children: t,
    loading: e,
    disabled: r,
    loadingText: n = "Loading...",
    ...i
}) => d.jsx(WU, {
    as: "a",
    disabled: e || r,
    ...i,
    children: e ? d.jsxs("span", {
        children: [d.jsx(pl, {}), n ? d.jsx("span", {
            children: n
        }) : null]
    }) : t
});
let WU = z(Jy).withConfig({
    displayName: "StyledPrimaryButton",
    componentId: "sc-172643dd-2"
})(["position:relative;&&{background-color:", ";color:var(--privy-color-foreground-accent);transition:background-color 200ms ease;}&:hover{background-color:", ";}&:active{background-color:", ";}&:hover:disabled,&:active:disabled{background-color:var(--privy-color-background-2);color:var(--privy-color-foreground-3);cursor:not-allowed;}", " > span{display:flex;align-items:center;gap:8px;opacity:1;animation:fadein 200ms ease;}"], t => t.$warn ? "var(--privy-color-error)" : t.$success ? "var(--privy-color-success)" : "var(--privy-color-accent)", t => t.$warn ? "var(--privy-color-error)" : t.$success ? "var(--privy-color-success)" : "var(--privy-color-accent-dark)", t => t.$warn ? "var(--privy-color-error)" : t.$success ? "var(--privy-color-success)" : "var(--privy-color-accent-dark)", t => t.disabled ? pi(["&&&,&&&:hover,&&&:active{background-color:var(--privy-color-background-2);color:var(--privy-color-foreground-3);cursor:not-allowed;pointer-events:none;}"]) : "");
const po = ({
    children: t,
    loading: e,
    disabled: r,
    loadingText: n = "Loading...",
    ...i
}) => d.jsx(hCe, {
    disabled: e || r,
    ...i,
    children: e ? d.jsxs("span", {
        children: [d.jsx(pl, {}), n ? d.jsx("span", {
            children: n
        }) : null]
    }) : t
});
let hCe = z(Jy).withConfig({
    displayName: "StyledSecondaryButton",
    componentId: "sc-172643dd-3"
})(["&&{border-width:1px;border-color:", ";color:var(--privy-color-foreground);transition:border-color 200ms ease;}&:hover,&:active{border-color:", ";}&:hover:disabled,&:active:disabled{border-color:var(--privy-color-foreground-accent);color:var(--privy-color-foreground-3);cursor:not-allowed;}> span{display:flex;align-items:center;gap:8px;opacity:1;animation:fadein 200ms ease;}"], t => t.$warn ? "var(--privy-color-error)" : "var(--privy-color-foreground-4)", t => t.$warn ? "var(--privy-color-error)" : "var(--privy-color-foreground-3)");
const b8 = z.button.withConfig({
        displayName: "SoftCtaButton",
        componentId: "sc-172643dd-4"
    })(["&&{padding:12px 16px;font-weight:500;text-align:center;color:var(--privy-color-foreground-accent);background-color:var(--privy-color-accent);border-radius:var(--privy-border-radius-sm);min-width:144px;opacity:", ";transition:opacity 200ms ease,background-color 200ms ease,color 200ms ease;user-select:none;", " &:hover{background-color:var(--privy-color-accent-dark);}&:active{background-color:var(--privy-color-accent-dark);}&:hover:disabled,&:active:disabled{background-color:var(--privy-color-background-2);color:var(--privy-color-foreground-3);cursor:not-allowed;}}"], t => t.invisible ? "0" : "1", t => t.invisible && pi(["pointer-events:none;"])),
    j0 = ({
        children: t,
        onClick: e,
        disabled: r,
        isSubmitting: n,
        ...i
    }) => d.jsxs(fCe, {
        $isSubmitting: n,
        onClick: e,
        disabled: r,
        ...i,
        children: [d.jsx("span", {
            children: t
        }), d.jsx("span", {
            children: d.jsx(pl, {})
        })]
    });
let fCe = z.button.withConfig({
    displayName: "StyledEmbeddedButton",
    componentId: "sc-172643dd-6"
})(["&&{color:var(--privy-color-accent);font-size:16px;font-style:normal;font-weight:500;line-height:24px;cursor:pointer;border-radius:0px var(--privy-border-radius-mdlg) var(--privy-border-radius-mdlg) 0px;border:none;transition:color 200ms ease;@media (min-width:441px){font-size:14px;}:hover{color:var(--privy-color-accent-dark);}&& > :first-child{opacity:", ";}&& > :last-child{position:absolute;display:flex;top:50%;left:50%;transform:translate3d(-50%,-50%,0);opacity:", ";}:disabled,:hover:disabled{color:var(--privy-color-foreground-3);cursor:not-allowed;}}"], t => t.$isSubmitting ? 0 : 1, t => t.$isSubmitting ? 1 : 0);
const Iv = ({
    label: t,
    children: e,
    valueStyles: r
}) => d.jsxs(pCe, {
    children: [d.jsx("div", {
        children: t
    }), d.jsx(gCe, {
        style: { ...r
        },
        children: e
    })]
});
let pCe = z.div.withConfig({
        displayName: "StyledDetailsRow",
        componentId: "sc-4ebfdd45-0"
    })(["display:flex;align-items:center;justify-content:space-between;width:100%;> :first-child{color:var(--privy-color-foreground-3);text-align:left;}> :last-child{color:var(--privy-color-foreground-2);text-align:right;}"]),
    gCe = z.div.withConfig({
        displayName: "ValueWrapper",
        componentId: "sc-4ebfdd45-1"
    })(["font-size:14px;line-height:100%;display:flex;align-items:center;justify-content:center;border-radius:var(--privy-border-radius-full);background-color:var(--privy-color-background-2);padding:4px 8px;"]),
    mCe = new Intl.NumberFormat(void 0, {
        style: "currency",
        currency: "USD",
        maximumFractionDigits: 2
    }),
    zU = t => mCe.format(t);
const qU = (t, e) => {
        let r = zU(e * parseFloat(t));
        return r !== "$0.00" ? r : "<$0.01"
    },
    td = (t, e) => {
        let r = zU(e * parseFloat(Cd(t)));
        return r === "$0.00" ? "<$0.01" : r
    },
    ba = (t, e, r = 6, n = !1) => `${HU(t,r,n)} ${e}`,
    HU = (t, e = 6, r = !1) => {
        let n = parseFloat(Cd(t)).toFixed(e).replace(/0+$/, "").replace(/\.$/, "");
        return r ? n : `${n==="0"?"<0.001":n}`
    },
    v8 = t => t.reduce((e, r) => e + r, 0 n),
    yCe = (t, e) => {
        let {
            chains: r
        } = $e(), n = `https://etherscan.io/address/${e}`, i = `${((s,a)=>{var l;let o=Number(s),c=a.find(u=>u.id===o);if(!c)throw new br(`Unsupported chainId ${s}`,4901);return(l=c.blockExplorers)==null?void 0:l.default.url})(t,r)}/address/${e}`;
        if (!i) return n;
        try {
            new URL(i)
        } catch {
            return n
        }
        return i
    };
async function Eu(t, e) {
    try {
        return await t
    } catch {
        return e
    }
}
const Pf = "11111111111111111111111111111111",
    wCe = ["CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C", "CPMDWBwJDtYax9qW7AyRuVC19Cc4L4Vcy4n2BHAbHkCW"],
    bCe = ["JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4"];
let vCe = new Intl.NumberFormat(void 0, {
    style: "currency",
    currency: "USD",
    maximumFractionDigits: 2
});

function tl(t, e = 6, r = !1, n = !1) {
    let i = (parseFloat(t.toString()) / 1e9).toFixed(e).replace(/0+$/, "").replace(/\.$/, ""),
        s = n ? "" : " SOL";
    return r ? `${i}${s}` : `${i==="0"?"<0.001":i}${s}`
}

function Qf(t, e) {
    let r = parseFloat(t.toString()) / 1e9,
        n = vCe.format(e * r);
    return n === "$0.00" ? "<$0.01" : n
}

function VU({
    amount: t,
    fee: e,
    tokenPrice: r,
    isUsdc: n
}) {
    let i = BigInt(Math.floor(parseFloat(t) * 10 ** (n ? 6 : 9))),
        s = n ? i : i + e;
    return {
        fundingAmountInBaseUnit: i,
        fundingAmountInUsd: r ? Qf(i, r) : void 0,
        totalPriceInUsd: r ? Qf(s, r) : void 0,
        totalPriceInNativeCurrency: tl(s),
        feePriceInNativeCurrency: tl(e),
        feePriceInUsd: r ? Qf(e, r) : void 0
    }
}
let xCe = {
    "mainnet-beta": {
        EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v: {
            symbol: "USDC",
            decimals: 6,
            address: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
        },
        Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB: {
            symbol: "USDT",
            decimals: 6,
            address: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"
        },
        So11111111111111111111111111111111111111112: {
            symbol: "SOL",
            decimals: 9,
            address: "So11111111111111111111111111111111111111112"
        }
    },
    devnet: {
        "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU": {
            symbol: "USDC",
            decimals: 6,
            address: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU"
        },
        EJwZgeZrdC8TXTQbQBoL6bfuAnFUUy1PVCMB4DYPzVaS: {
            symbol: "USDT",
            decimals: 6,
            address: "EJwZgeZrdC8TXTQbQBoL6bfuAnFUUy1PVCMB4DYPzVaS"
        },
        So11111111111111111111111111111111111111112: {
            symbol: "SOL",
            decimals: 9,
            address: "So11111111111111111111111111111111111111112"
        }
    },
    testnet: {}
};
async function ca(t, e, r) {
    let n = xCe[t];
    if (!n[r]) {
        let i = await e.getSplTokenMetadata({
            mintAddress: r,
            cluster: t
        });
        i && (n[r] = {
            address: r,
            symbol: i.symbol,
            decimals: i.decimals
        })
    }
    return n[r]
}

function al(t) {
    return "version" in t
}

function h1(t, e) {
    let r = (al(t) ? t.message : t.compileMessage()).staticAccountKeys.find(n => n.toBase58() === e);
    if (!r) throw Error(`Transaction does not contain public key ${e}`);
    return r
}

function v$(t, e, r) {
    var n;
    return {
        signature: t,
        parsedTransaction: r ? ? null,
        signedTransaction: e,
        fees: BigInt(((n = r == null ? void 0 : r.meta) == null ? void 0 : n.fee) || 0)
    }
}
async function GU(t, e) {
    var n;
    let {
        value: r
    } = await e.simulateTransaction(t);
    if (r.err === "BlockhashNotFound") throw Error("Simulation failed: Blockhash not found");
    return r.err == null && ((n = r.logs) == null ? void 0 : n.every(i => !/insufficient funds/gi.test(i)))
}
async function ECe({
    tx: t,
    connection: e,
    client: r,
    checkFunds: n
}) {
    var h, f, p, g;
    let i = al(t) ? t.message : t.compileMessage(),
        s = ((h = i.staticAccountKeys[0]) == null ? void 0 : h.toBase58()) ? ? "",
        a = await async function(m, y) {
            return BigInt((al(m) ? (await y.getFeeForMessage(m.message)).value : await m.getEstimatedFee(y)) ? ? 0)
        }(t, e),
        o = !n || await Eu(GU(t, e), !0),
        c = {},
        l = [],
        u = await async function(m, y) {
            return [...m.staticAccountKeys.map(w => w), ...(await Promise.all(m.addressTableLookups.map(async w => y.getAddressLookupTable(w.accountKey).then(({
                value: x
            }) => x)))).map((w, x) => {
                var E, _;
                return [...((E = m.addressTableLookups[x]) == null ? void 0 : E.writableIndexes.map(b => {
                    let A = w == null ? void 0 : w.state.addresses[b];
                    if (A) return {
                        key: A,
                        isWritable: !0,
                        altIdx: x
                    }
                })) ? ? [], ...((_ = m.addressTableLookups[x]) == null ? void 0 : _.readonlyIndexes.map(b => {
                    let A = w == null ? void 0 : w.state.addresses[b];
                    if (A) return {
                        key: A,
                        isWritable: !1,
                        altIdx: x
                    }
                })) ? ? []]
            }).flat().filter(w => !!w).sort((w, x) => w.isWritable !== x.isWritable ? w.isWritable ? -1 : 1 : w.altIdx - x.altIdx).map(({
                key: w
            }) => w)]
        }(i, e);
    for (let m of i.compiledInstructions) {
        let y = ((f = i.staticAccountKeys[m.programIdIndex]) == null ? void 0 : f.toBase58()) || "";
        if (y !== "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" && y !== "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb")
            if (y !== Pf) {
                if (y === "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL") {
                    let w = await Eu(function(x, E, _) {
                        let [b, A, I, T] = x.accountKeyIndexes.map(C => E[C]);
                        return {
                            type: "ata-creation",
                            program: _,
                            payer: b == null ? void 0 : b.toBase58(),
                            ata: A == null ? void 0 : A.toBase58(),
                            owner: I == null ? void 0 : I.toBase58(),
                            mint: T == null ? void 0 : T.toBase58()
                        }
                    }(m, u, y));
                    if (!w) {
                        l.push({
                            type: "unknown",
                            program: y,
                            discriminator: m.data[0]
                        });
                        continue
                    }
                    if (l.push(w), w.ata && w.owner && w.mint) {
                        c[w.ata] = {
                            owner: w.owner,
                            mint: w.mint
                        };
                        continue
                    }
                }
                if (wCe.includes(y)) {
                    let w = await Eu(ACe(m, u, e, r, y));
                    if (!w) {
                        l.push({
                            type: "unknown",
                            program: y,
                            discriminator: m.data[0]
                        });
                        continue
                    }
                    l.push(w)
                } else if (bCe.includes(y)) {
                    let w = await Eu(kCe(m, u, e, r, y));
                    if (!w) {
                        l.push({
                            type: "unknown",
                            program: y,
                            discriminator: m.data[0]
                        });
                        continue
                    }
                    l.push(w)
                } else l.push({
                    type: "unknown",
                    program: y,
                    discriminator: m.data[0]
                })
            } else {
                let w = await Eu(CCe(m, u));
                if (!w) {
                    l.push({
                        type: "unknown",
                        program: y,
                        discriminator: m.data[0]
                    });
                    continue
                }
                l.push(w)
            }
        else {
            let w = await Eu(_Ce(m, u, e, r, c, y));
            if (!w) {
                l.push({
                    type: "unknown",
                    program: y,
                    discriminator: m.data[0]
                });
                continue
            }
            l.push(w), w.type === "spl-transfer" && (w.fromAta && w.fromAccount && w.token.address && (c[p = w.fromAta] ? ? (c[p] = {
                owner: w.fromAccount,
                mint: w.token.address
            })), w.toAta && w.toAccount && w.token.address && (c[g = w.toAta] ? ? (c[g] = {
                owner: w.toAccount,
                mint: w.token.address
            })))
        }
    }
    return {
        spender: s,
        fee: a,
        instructions: l,
        hasFunds: !!o
    }
}

function ai(t, e = 0) {
    try {
        return function(n, i = 0) {
            let s = 0 n;
            for (let a = 0; a < 8; a++) s |= BigInt(n[i + a]) << BigInt(8 * a);
            return s
        }(t, e)
    } catch {}
    try {
        return t.readBigInt64LE(e)
    } catch {}
    let r = On(t);
    try {
        return ((n, i = 0) => {
            let s = n[i],
                a = n[i + 7];
            if (!s || !a) throw Error(`Buffer offset out of range: first: ${s}, last: ${a}.`);
            return (BigInt(n[i + 4] + 256 * n[i + 5] + 65536 * n[i + 6] + (a << 24)) << 32 n) + BigInt(s + 256 * n[++i] + 65536 * n[++i] + 16777216 * n[++i])
        })(r)
    } catch {}
    try {
        return r.subarray(e).readBigInt64LE()
    } catch {}
    try {
        return r.readBigInt64LE(e)
    } catch {}
    return 0 n
}
async function _Ce(t, e, r, n, i, s) {
    var c, l, u, h, f, p, g, m, y, w, x;
    let a = t.data[0],
        o = t.accountKeyIndexes.map(E => e[E]);
    if (a === 1) {
        let [E, _, b] = o;
        return {
            type: "spl-init-account",
            program: s,
            account: E == null ? void 0 : E.toBase58(),
            mint: _ == null ? void 0 : _.toBase58(),
            owner: b == null ? void 0 : b.toBase58()
        }
    }
    if (a === 3) {
        let E, _, [b, A, I] = o,
            T = "",
            C = A ? i[A.toBase58()] : void 0;
        if (C) E = C.owner, T = C.mint;
        else if (A) {
            let R = await r.getParsedAccountInfo(A, "confirmed"),
                D = (c = R.value) == null ? void 0 : c.data;
            E = (u = (l = D == null ? void 0 : D.parsed) == null ? void 0 : l.info) == null ? void 0 : u.owner, T = ((f = (h = D == null ? void 0 : D.parsed) == null ? void 0 : h.info) == null ? void 0 : f.mint) ? ? "", _ = (m = (g = (p = D == null ? void 0 : D.parsed) == null ? void 0 : p.info) == null ? void 0 : g.tokenAmount) == null ? void 0 : m.decimals
        }
        if (!T && b) {
            let R = await r.getParsedAccountInfo(b, "confirmed"),
                D = (y = R.value) == null ? void 0 : y.data;
            T = ((x = (w = D == null ? void 0 : D.parsed) == null ? void 0 : w.info) == null ? void 0 : x.mint) ? ? ""
        }
        let $ = Nh(r.rpcEndpoint),
            P = await ca($, n, T),
            N = (P == null ? void 0 : P.symbol) ? ? "";
        return _ ? ? (_ = (P == null ? void 0 : P.decimals) ? ? 9), {
            type: "spl-transfer",
            program: s,
            fromAta: b == null ? void 0 : b.toBase58(),
            fromAccount: I == null ? void 0 : I.toBase58(),
            toAta: A == null ? void 0 : A.toBase58(),
            toAccount: E,
            value: ai(t.data, 1),
            token: {
                symbol: N,
                decimals: _,
                address: T
            }
        }
    }
    if (a === 9) {
        let [E, _, b] = o;
        return {
            type: "spl-close-account",
            program: s,
            source: E == null ? void 0 : E.toBase58(),
            destination: _ == null ? void 0 : _.toBase58(),
            owner: b == null ? void 0 : b.toBase58()
        }
    }
    if (a === 17) return {
        type: "spl-sync-native",
        program: s
    };
    throw Error(`Token program instruction type ${a} not supported`)
}
async function CCe(t, e) {
    let r = t.data[0],
        n = t.accountKeyIndexes.map(i => e[i]);
    if (r === 0) {
        let [, i] = n;
        return {
            type: "create-account",
            program: Pf,
            account: i == null ? void 0 : i.toBase58(),
            value: ai(t.data, 4),
            withSeed: !1
        }
    }
    if (r === 2) {
        let [i, s] = n;
        return {
            type: "sol-transfer",
            program: Pf,
            fromAccount: i == null ? void 0 : i.toBase58(),
            toAccount: s == null ? void 0 : s.toBase58(),
            token: {
                symbol: "SOL",
                decimals: 9
            },
            value: ai(t.data, 4),
            withSeed: !1
        }
    }
    if (r === 3) {
        let [, i] = n, s = ai(t.data.slice(t.data.length - 32 - 8 - 8));
        return {
            type: "create-account",
            program: Pf,
            account: i == null ? void 0 : i.toBase58(),
            withSeed: !0,
            value: s
        }
    }
    if (r === 11) {
        let [i, s] = n;
        return {
            type: "sol-transfer",
            program: Pf,
            fromAccount: i == null ? void 0 : i.toBase58(),
            toAccount: s == null ? void 0 : s.toBase58(),
            value: ai(t.data, 4),
            token: {
                symbol: "SOL",
                decimals: 9
            },
            withSeed: !0
        }
    }
    throw Error(`System program instruction type ${r} not supported`)
}
async function ACe(t, e, r, n, i) {
    let s = t.accountKeyIndexes.map(c => {
            var l;
            return (l = e[c]) == null ? void 0 : l.toBase58()
        }),
        a = t.data[0],
        o = Nh(r.rpcEndpoint);
    if (a === 143) {
        let c = s[10],
            l = s[11];
        return {
            type: "raydium-swap-base-input",
            program: i,
            mintIn: c,
            mintOut: l,
            tokenIn: c ? await ca(o, n, c) : void 0,
            tokenOut: l ? await ca(o, n, l) : void 0,
            amountIn: ai(t.data, 8),
            minimumAmountOut: ai(t.data, 16)
        }
    }
    if (a === 55) {
        let c = s[10],
            l = s[11];
        return {
            type: "raydium-swap-base-output",
            program: i,
            mintIn: c,
            mintOut: l,
            tokenIn: c ? await ca(o, n, c) : void 0,
            tokenOut: l ? await ca(o, n, l) : void 0,
            maxAmountIn: ai(t.data, 8),
            amountOut: ai(t.data, 16)
        }
    }
    throw Error(`Raydium swap program instruction type ${a} not supported`)
}
async function kCe(t, e, r, n, i) {
    var c, l, u, h, f, p;
    let s = t.data[0],
        a = t.accountKeyIndexes.map(g => e[g]),
        o = Nh(r.rpcEndpoint);
    if ([208, 51, 239, 151, 123, 43, 237, 92].includes(s)) {
        let g = (c = a[5]) == null ? void 0 : c.toBase58(),
            m = (l = a[6]) == null ? void 0 : l.toBase58();
        return {
            type: "jupiter-swap-exact-out-route",
            program: i,
            mintIn: g,
            mintOut: m,
            tokenIn: g ? await ca(o, n, g) : void 0,
            tokenOut: m ? await ca(o, n, m) : void 0,
            outAmount: ai(t.data, t.data.length - 1 - 2 - 8 - 8),
            quotedInAmount: ai(t.data, t.data.length - 1 - 2 - 8)
        }
    }
    if ([176, 209, 105, 168, 154, 125, 69, 62].includes(s)) {
        let g = (u = a[7]) == null ? void 0 : u.toBase58(),
            m = (h = a[8]) == null ? void 0 : h.toBase58();
        return {
            type: "jupiter-swap-exact-out-route",
            program: i,
            mintIn: g,
            mintOut: m,
            tokenIn: g ? await ca(o, n, g) : void 0,
            tokenOut: m ? await ca(o, n, m) : void 0,
            outAmount: ai(t.data, t.data.length - 1 - 2 - 8 - 8),
            quotedInAmount: ai(t.data, t.data.length - 1 - 2 - 8)
        }
    }
    if ([193, 32, 155, 51, 65, 214, 156, 129].includes(s)) {
        let g = (f = a[7]) == null ? void 0 : f.toBase58(),
            m = (p = a[8]) == null ? void 0 : p.toBase58();
        return {
            type: "jupiter-swap-shared-accounts-route",
            program: i,
            mintIn: g,
            mintOut: m,
            tokenIn: g ? await ca(o, n, g) : void 0,
            tokenOut: m ? await ca(o, n, m) : void 0,
            inAmount: ai(t.data, t.data.length - 1 - 2 - 8 - 8),
            quotedOutAmount: ai(t.data, t.data.length - 1 - 2 - 8)
        }
    }
    throw [62, 198, 214, 193, 213, 159, 108, 210].includes(s) && console.warn("Jupiter swap program instruction 'claim' not implemented"), [116, 206, 27, 191, 166, 19, 0, 73].includes(s) && console.warn("Jupiter swap program instruction 'claim_token' not implemented"), [26, 74, 236, 151, 104, 64, 183, 249].includes(s) && console.warn("Jupiter swap program instruction 'close_token' not implemented"), [229, 194, 212, 172, 8, 10, 134, 147].includes(s) && console.warn("Jupiter swap program instruction 'create_open_orders' not implemented"), [28, 226, 32, 148, 188, 136, 113, 171].includes(s) && console.warn("Jupiter swap program instruction 'create_program_open_orders' not implemented"), [232, 242, 197, 253, 240, 143, 129, 52].includes(s) && console.warn("Jupiter swap program instruction 'create_token_ledger' not implemented"), [147, 241, 123, 100, 244, 132, 174, 118].includes(s) && console.warn("Jupiter swap program instruction 'create_token_account' not implemented"), [229, 23, 203, 151, 122, 227, 173, 42].includes(s) && console.warn("Jupiter swap program instruction 'route' not implemented"), [150, 86, 71, 116, 167, 93, 14, 104].includes(s) && console.warn("Jupiter swap program instruction 'route_with_token_ledger' not implemented"), [228, 85, 185, 112, 78, 79, 77, 2].includes(s) && console.warn("Jupiter swap program instruction 'set_token_ledger' not implemented"), [230, 121, 143, 80, 119, 159, 106, 170].includes(s) && console.warn("Jupiter swap program instruction 'shared_accounts_route_with_token_ledger' not implemented"), Error(`Jupiter swap program instruction type ${s} not supported`)
}
const ICe = ({
        weiQuantities: t,
        tokenPrice: e,
        tokenSymbol: r
    }) => {
        let n = v8(t),
            i = e ? td(n, e) : void 0,
            s = ba(n, r);
        return d.jsx(x8, {
            children: i || s
        })
    },
    KU = ({
        weiQuantities: t,
        tokenPrice: e,
        tokenSymbol: r
    }) => {
        let n = v8(t),
            i = e ? td(n, e) : void 0,
            s = ba(n, r);
        return d.jsx(x8, {
            children: i ? d.jsxs(d.Fragment, {
                children: [d.jsx($Ce, {
                    children: "USD"
                }), i === "<$0.01" ? d.jsxs(ZU, {
                    children: [d.jsx(YU, {
                        children: "<"
                    }), "$0.01"]
                }) : i]
            }) : s
        })
    },
    x$ = ({
        quantities: t,
        tokenPrice: e,
        tokenSymbol: r = "SOL",
        tokenDecimals: n = 9
    }) => {
        let i = t.reduce((o, c) => o + c, 0 n),
            s = e && r === "SOL" && n === 9 ? Qf(i, e) : void 0,
            a = r === "SOL" && n === 9 ? tl(i) : `${Nn(i,n)} ${r}`;
        return d.jsx(x8, {
            children: s ? d.jsx(d.Fragment, {
                children: s === "<$0.01" ? d.jsxs(ZU, {
                    children: [d.jsx(YU, {
                        children: "<"
                    }), "$0.01"]
                }) : s
            }) : a
        })
    };
let x8 = z.span.withConfig({
        displayName: "StyledPriceDisplay",
        componentId: "sc-596cd423-0"
    })(["font-size:14px;line-height:140%;display:flex;gap:4px;align-items:center;"]),
    $Ce = z.span.withConfig({
        displayName: "StyledPriceUnit",
        componentId: "sc-596cd423-1"
    })(["font-size:12px;line-height:12px;color:var(--privy-color-foreground-3);"]),
    YU = z.span.withConfig({
        displayName: "TinyLessThan",
        componentId: "sc-596cd423-2"
    })(["font-size:10px;"]),
    ZU = z.span.withConfig({
        displayName: "FlexCenter",
        componentId: "sc-596cd423-3"
    })(["display:flex;align-items:center;"]);
const zd = z.div.withConfig({
        displayName: "BottomPusherContainer",
        componentId: "sc-cb963810-0"
    })(["display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-end;margin-top:auto;gap:16px;flex-grow:100;"]),
    ol = z.div.withConfig({
        displayName: "CenteredItem",
        componentId: "sc-cb963810-1"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;flex-grow:1;width:100%;"]),
    E8 = z.div.withConfig({
        displayName: "HorizontallyCenteredItem",
        componentId: "sc-cb963810-2"
    })(["display:flex;flex-direction:column;align-items:center;width:100%;"]),
    _8 = z(ol).withConfig({
        displayName: "CenteredItemWithPadding",
        componentId: "sc-cb963810-3"
    })(["padding:20px 0;"]),
    wc = z(ol).withConfig({
        displayName: "CenteredItemWithGap",
        componentId: "sc-cb963810-4"
    })(["gap:16px;"]),
    Qy = z.div.withConfig({
        displayName: "FlexContainer",
        componentId: "sc-cb963810-5"
    })(["display:flex;flex-direction:column;width:100%;"]),
    ls = z.div.withConfig({
        displayName: "FixedGappedContainer",
        componentId: "sc-cb963810-6"
    })(["display:flex;flex-direction:column;gap:8px;"]),
    SCe = z.div.withConfig({
        displayName: "StyledCalloutSection",
        componentId: "sc-cb963810-8"
    })(["display:flex;flex-direction:column;justify-content:flex-start;align-items:flex-start;text-align:left;gap:8px;padding:16px;margin-top:16px;margin-bottom:16px;width:100%;background:var(--privy-color-background-2);border-radius:var(--privy-border-radius-md);&& h4{color:var(--privy-color-foreground-3);font-size:14px;text-decoration:underline;font-weight:medium;}&& p{color:var(--privy-color-foreground-3);font-size:14px;}"]),
    er = z.div.withConfig({
        displayName: "RefactorSpacerTop",
        componentId: "sc-cb963810-9"
    })(["height:16px;"]),
    nr = z.div.withConfig({
        displayName: "RefactorSpacerBottom",
        componentId: "sc-cb963810-10"
    })(["height:12px;"]),
    TCe = z.div.withConfig({
        displayName: "RelativeContainer",
        componentId: "sc-cb963810-11"
    })(["position:relative;"]),
    C8 = z.div.withConfig({
        displayName: "ConfigurableSpacer",
        componentId: "sc-cb963810-12"
    })(["height:", "px;"], t => t.height ? ? "12"),
    PCe = z.div.withConfig({
        displayName: "Circle",
        componentId: "sc-cb963810-13"
    })(["background-color:var(--privy-color-accent);display:flex;justify-content:center;align-items:center;border-radius:50%;border-color:white;border-width:2px !important;"]),
    NCe = ({
        gas: t,
        tokenPrice: e,
        tokenSymbol: r
    }) => d.jsxs(Qy, {
        style: {
            paddingBottom: "12px"
        },
        children: [d.jsxs(JU, {
            children: [d.jsx(XU, {
                children: "Est. Fees"
            }), d.jsx("div", {
                children: d.jsx(KU, {
                    weiQuantities: [BigInt(t)],
                    tokenPrice: e,
                    tokenSymbol: r
                })
            })]
        }), e && d.jsx(QU, {
            children: `${ba(BigInt(t),r)}`
        })]
    }),
    OCe = ({
        value: t,
        gas: e,
        tokenPrice: r,
        tokenSymbol: n
    }) => {
        let i = BigInt(t ? ? 0) + BigInt(e);
        return d.jsxs(Qy, {
            children: [d.jsxs(JU, {
                children: [d.jsx(XU, {
                    children: "Total (including fees)"
                }), d.jsx("div", {
                    children: d.jsx(KU, {
                        weiQuantities: [BigInt(t || 0), BigInt(e)],
                        tokenPrice: r,
                        tokenSymbol: n
                    })
                })]
            }), r && d.jsx(QU, {
                children: ba(i, n)
            })]
        })
    };
let JU = z.div.withConfig({
        displayName: "TransactionTotalRow",
        componentId: "sc-f8ef9b74-0"
    })(["display:flex;flex-direction:row;justify-content:space-between;align-items:center;padding-top:4px;"]),
    QU = z.div.withConfig({
        displayName: "ValueConversionRow",
        componentId: "sc-f8ef9b74-1"
    })(["display:flex;flex-direction:row;height:12px;font-size:12px;line-height:12px;color:var(--privy-color-foreground-3);font-weight:400;"]),
    XU = z.div.withConfig({
        displayName: "TotalText",
        componentId: "sc-f8ef9b74-2"
    })(["font-size:14px;line-height:22.4px;font-weight:400;"]);
const R0 = v.createContext(void 0),
    Xy = v.createContext(void 0),
    jCe = ({
        defaultValue: t,
        children: e
    }) => {
        let [r, n] = v.useState(t || null);
        return d.jsx(R0.Provider, {
            value: {
                activePanel: r,
                togglePanel: i => {
                    n(r === i ? null : i)
                }
            },
            children: d.jsx(UCe, {
                children: e
            })
        })
    },
    RCe = ({
        value: t,
        children: e
    }) => {
        let {
            activePanel: r,
            togglePanel: n
        } = v.useContext(R0), i = r === t;
        return d.jsx(Xy.Provider, {
            value: {
                onToggle: () => n(t),
                value: t
            },
            children: d.jsx(zCe, {
                isActive: i ? "true" : "false",
                "data-open": String(i),
                children: e
            })
        })
    },
    MCe = ({
        children: t
    }) => {
        let {
            activePanel: e
        } = v.useContext(R0), {
            onToggle: r,
            value: n
        } = v.useContext(Xy), i = e === n;
        return d.jsxs(d.Fragment, {
            children: [d.jsxs(FCe, {
                onClick: r,
                "data-open": String(i),
                children: [d.jsx(WCe, {
                    children: t
                }), d.jsx(HCe, {
                    isactive: i ? "true" : "false",
                    children: d.jsx(cy, {
                        height: "16px",
                        width: "16px",
                        strokeWidth: "2"
                    })
                })]
            }), d.jsx(BCe, {})]
        })
    },
    DCe = ({
        children: t
    }) => {
        let {
            activePanel: e
        } = v.useContext(R0), {
            value: r
        } = v.useContext(Xy);
        return d.jsx(qCe, {
            "data-open": String(e === r),
            children: d.jsx(eF, {
                children: t
            })
        })
    },
    LCe = ({
        children: t
    }) => {
        let {
            activePanel: e
        } = v.useContext(R0), {
            value: r
        } = v.useContext(Xy);
        return d.jsx(eF, {
            children: typeof t == "function" ? t({
                isActive: e === r
            }) : t
        })
    };
let UCe = z.div.withConfig({
        displayName: "AccordionRoot",
        componentId: "sc-d25f9267-0"
    })(["display:flex;flex-direction:column;width:100%;gap:8px;"]),
    FCe = z.div.withConfig({
        displayName: "AccordionTriggerContainer",
        componentId: "sc-d25f9267-1"
    })(["display:flex;justify-content:space-between;align-items:center;width:100%;cursor:pointer;padding-bottom:8px;"]),
    BCe = z.div.withConfig({
        displayName: "AccordionDivider",
        componentId: "sc-d25f9267-2"
    })(["width:100%;&&{border-top:1px solid;border-color:var(--privy-color-foreground-4);}padding-bottom:12px;"]),
    WCe = z.div.withConfig({
        displayName: "AccordionTriggerContent",
        componentId: "sc-d25f9267-3"
    })(["font-size:14px;font-weight:500;line-height:19.6px;width:100%;padding-right:8px;"]),
    zCe = z.div.withConfig({
        displayName: "AccordionPanelContainer",
        componentId: "sc-d25f9267-4"
    })(["display:flex;flex-direction:column;width:100%;overflow:hidden;padding:12px;&&{border:1px solid;border-color:var(--privy-color-foreground-4);border-radius:var(--privy-border-radius-md);}"]),
    qCe = z.div.withConfig({
        displayName: "AccordionContentContainer",
        componentId: "sc-d25f9267-5"
    })(["position:relative;overflow:hidden;transition:max-height 25ms ease-out;&[data-open='true']{max-height:700px;}&[data-open='false']{max-height:0;}"]),
    eF = z.div.withConfig({
        displayName: "ContentWrapper",
        componentId: "sc-d25f9267-6"
    })(["display:flex;flex-direction:column;gap:12px;flex:1 1 auto;min-height:1px;"]),
    HCe = z.div.withConfig({
        displayName: "IconWrapper",
        componentId: "sc-d25f9267-7"
    })(["transform:", ";"], t => t.isactive === "true" ? "rotate(180deg)" : "rotate(0deg)");
const x4 = ({
    walletAddress: t,
    chainId: e = 1,
    network: r,
    rpcEndpoint: n
}) => d.jsx(VCe, {
    href: r === "ethereum" ? yCe(e, t) : P9e(t, Nh(n || "")),
    target: "_blank",
    children: Yn(t)
});
let VCe = z.a.withConfig({
    displayName: "StyledLink",
    componentId: "sc-adda23e5-0"
})(["&:hover{text-decoration:underline;}"]);
const tF = ({
    from: t,
    to: e,
    txn: r,
    transactionInfo: n,
    tokenPrice: i,
    gas: s,
    tokenSymbol: a
}) => {
    let o = BigInt((r == null ? void 0 : r.value) || 0);
    return d.jsx(jCe, { ...Gt().render.standalone ? {
            defaultValue: "details"
        } : {},
        children: d.jsxs(RCe, {
            value: "details",
            children: [d.jsx(MCe, {
                children: d.jsxs(GCe, {
                    children: [d.jsx("div", {
                        children: (n == null ? void 0 : n.title) || "Details"
                    }), d.jsx(KCe, {
                        children: d.jsx(ICe, {
                            weiQuantities: [o],
                            tokenPrice: i,
                            tokenSymbol: a
                        })
                    })]
                })
            }), d.jsxs(DCe, {
                children: [d.jsx(Iv, {
                    label: "From",
                    children: d.jsx(x4, {
                        walletAddress: t,
                        chainId: r.chainId || 1,
                        network: "ethereum"
                    })
                }), d.jsx(Iv, {
                    label: "To",
                    children: d.jsx(x4, {
                        walletAddress: e,
                        chainId: r.chainId || 1,
                        network: "ethereum"
                    })
                }), n && n.action && d.jsx(Iv, {
                    label: "Action",
                    children: n.action
                }), s && d.jsx(NCe, {
                    value: r.value,
                    gas: s,
                    tokenPrice: i,
                    tokenSymbol: a
                })]
            }), d.jsx(LCe, {
                children: ({
                    isActive: c
                }) => d.jsx(OCe, {
                    value: r.value,
                    displayFee: c,
                    gas: s || "0x0",
                    tokenPrice: i,
                    tokenSymbol: a
                })
            })]
        })
    })
};
let GCe = z.div.withConfig({
        displayName: "AccordionTriggerContent",
        componentId: "sc-e1259f7b-0"
    })(["display:flex;flex-direction:row;justify-content:space-between;"]),
    KCe = z.div.withConfig({
        displayName: "TotalText",
        componentId: "sc-e1259f7b-1"
    })(["flex-shrink:0;padding-left:8px;"]);
const rF = ({
    enabled: t = !0
} = {}) => {
    let {
        showFiatPrices: e,
        getUsdPriceForSol: r
    } = $e(), [n, i] = v.useState(!0), [s, a] = v.useState(void 0), [o, c] = v.useState(void 0);
    return v.useEffect(() => {
        (async () => {
            if (e && t) try {
                i(!0);
                let l = await r();
                l ? c(l) : a(Error("Unable to fetch SOL price"))
            } catch (l) {
                a(l)
            } finally {
                i(!1)
            } else i(!1)
        })()
    }, []), {
        solPrice: o,
        isSolPriceLoading: n,
        solPriceError: s
    }
};

function Oh(t) {
    let {
        tokenPrice: e,
        isTokenPriceLoading: r,
        tokenPriceError: n
    } = (o => {
        let {
            showFiatPrices: c,
            getUsdTokenPrice: l,
            chains: u
        } = $e(), [h, f] = v.useState(!0), [p, g] = v.useState(void 0), [m, y] = v.useState(void 0);
        return v.useEffect(() => {
            o || (o = 1);
            let w = S6(u).find(x => x.id === Number(o));
            (async () => {
                if (c) {
                    if (!w) return f(!1), void g(Error(`Unable to fetch token price on chain id ${o}`));
                    try {
                        f(!0);
                        let x = await l(w);
                        x ? y(x) : g(Error(`Unable to fetch token price on chain id ${w.id}`))
                    } catch (x) {
                        g(x)
                    } finally {
                        f(!1)
                    }
                } else f(!1)
            })()
        }, [o]), {
            tokenPrice: m,
            isTokenPriceLoading: h,
            tokenPriceError: p
        }
    })(t === "solana" ? -1 : t), {
        solPrice: i,
        isSolPriceLoading: s,
        solPriceError: a
    } = rF({
        enabled: t === "solana"
    });
    return t === "solana" ? {
        tokenPrice: i,
        isTokenPriceLoading: s,
        tokenPriceError: a
    } : {
        tokenPrice: e,
        isTokenPriceLoading: r,
        tokenPriceError: n
    }
}
const nF = v.createContext(null);

function gl() {
    let t = v.useContext(nF);
    return t === null ? (console.warn("`useWallets` was called outside the PrivyProvider component"), {
        wallets: [],
        ready: !1
    }) : t
}
async function f1(t, e, r, n) {
    let i = ZO(t),
        s = await (async () => n ? await n() : await e.prepareTransactionRequest({ ...i,
            account: {
                address: r,
                type: "json-rpc"
            }
        }))();
    return { ...s,
        type: Mae[s.type]
    }
}
const E4 = ({
    pendingTransaction: t
}) => {
    let {
        getAccessToken: e
    } = $t(), {
        wallets: r
    } = gl(), {
        walletProxy: n,
        rpcConfig: i,
        chains: s,
        appId: a,
        nativeTokenSymbolForChainId: o
    } = $e(), [c, l] = v.useState(null), [u, h] = v.useState(t), {
        tokenPrice: f
    } = Oh(u.chainId), p = o(t.chainId) || "ETH", g = v.useMemo(() => r.find(m => m.walletClientType === "privy"), [r]);
    return v.useEffect(() => {
        (async function() {
            if (!await e() || !n || !g) return u;
            let m = oh(u.chainId, s, i, {
                    appId: a
                }),
                y = await f1(u, m, g.address);
            return l(cn(BigInt(y.gas ? ? 0))), y
        })().then(h).catch(console.error)
    }, [n]), g ? d.jsx(YCe, {
        children: d.jsx(tF, {
            from: g.address,
            to: u.to,
            txn: u,
            gas: c ? ? void 0,
            tokenPrice: f,
            tokenSymbol: p
        })
    }) : null
};
let YCe = z.div.withConfig({
        displayName: "TransactionInfoWrapper",
        componentId: "sc-ec4f9711-0"
    })(["width:100%;padding:1rem 0;"]),
    Fi = z.div.withConfig({
        displayName: "StackedContainer",
        componentId: "sc-f7e7d474-0"
    })(["display:flex;flex-direction:column;justify-content:center;align-items:center;width:100%;height:82px;> div{position:relative;}> div > span{position:absolute;left:-41px;top:-41px;}> div > :last-child{position:absolute;left:-19px;top:-19px;}"]);
const M0 = ({
        style: t,
        ...e
    }) => d.jsx("svg", {
        x: 0,
        y: 0,
        width: "65",
        height: "64",
        viewBox: "0 0 65 64",
        style: {
            height: "64px",
            width: "65px",
            ...t
        },
        fill: "currentColor",
        xmlns: "http://www.w3.org/2000/svg",
        ...e,
        children: d.jsx("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M3.71369 17.5625V10.375C3.71369 6.44625 6.85845 3.25 10.7238 3.25H17.7953C18.6783 3.25 19.3941 2.52244 19.3941 1.625C19.3941 0.727562 18.6783 0 17.7953 0H10.7238C5.09529 0 0.516113 4.65419 0.516113 10.375V17.5625C0.516113 18.4599 1.23194 19.1875 2.1149 19.1875C2.99787 19.1875 3.71369 18.4599 3.71369 17.5625ZM17.7953 60.7501C18.6783 60.7501 19.3941 61.4777 19.3941 62.3751C19.3941 63.2726 18.6783 64.0001 17.7953 64.0001H10.7238C5.09529 64.0001 0.516113 59.3459 0.516113 53.6251V46.4376C0.516113 45.5402 1.23194 44.8126 2.1149 44.8126C2.99787 44.8126 3.71369 45.5402 3.71369 46.4376V53.6251C3.71369 57.5538 6.85845 60.7501 10.7238 60.7501H17.7953ZM63.4839 46.4376V53.6251C63.4839 59.3459 58.9048 64.0001 53.2763 64.0001H46.2047C45.3217 64.0001 44.6059 63.2726 44.6059 62.3751C44.6059 61.4777 45.3217 60.7501 46.2047 60.7501H53.2763C57.1416 60.7501 60.2864 57.5538 60.2864 53.6251V46.4376C60.2864 45.5402 61.0022 44.8126 61.8851 44.8126C62.7681 44.8126 63.4839 45.5402 63.4839 46.4376ZM63.4839 10.375V17.5625C63.4839 18.4599 62.7681 19.1875 61.8851 19.1875C61.0022 19.1875 60.2864 18.4599 60.2864 17.5625V10.375C60.2864 6.44625 57.1416 3.25 53.2763 3.25H46.2047C45.3217 3.25 44.6059 2.52244 44.6059 1.625C44.6059 0.727562 45.3217 0 46.2047 0H53.2763C58.9048 0 63.4839 4.65419 63.4839 10.375ZM43.0331 47.3022C43.7067 46.6698 43.7483 45.6022 43.1262 44.9176C42.5039 44.233 41.4536 44.1906 40.78 44.823C38.3832 47.0732 35.265 48.3125 31.9997 48.3125C28.7344 48.3125 25.6162 47.0732 23.2194 44.823C22.5457 44.1906 21.4955 44.233 20.8732 44.9176C20.251 45.6022 20.2927 46.6698 20.9663 47.3022C23.9784 50.1301 27.8968 51.6875 31.9997 51.6875C36.1026 51.6875 40.021 50.1301 43.0331 47.3022ZM35.3207 24.1249V36.1249C35.3207 38.5029 33.4173 40.4374 31.0777 40.4374H29.7249C28.8079 40.4374 28.0646 39.6819 28.0646 38.7499C28.0646 37.8179 28.8079 37.0624 29.7249 37.0624H31.0777C31.5863 37.0624 32.0001 36.6419 32.0001 36.1249V24.1249C32.0001 23.1929 32.7434 22.4374 33.6604 22.4374C34.5774 22.4374 35.3207 23.1929 35.3207 24.1249ZM46.7581 28.8437V24.0312C46.7581 23.151 46.056 22.4374 45.19 22.4374C44.324 22.4374 43.622 23.151 43.622 24.0312V28.8437C43.622 29.7239 44.324 30.4374 45.19 30.4374C46.056 30.4374 46.7581 29.7239 46.7581 28.8437ZM17.6109 28.8437C17.6109 29.7239 18.313 30.4374 19.1789 30.4374C20.0449 30.4374 20.747 29.7239 20.747 28.8437V24.0312C20.747 23.151 20.0449 22.4374 19.1789 22.4374C18.313 22.4374 17.6109 23.151 17.6109 24.0312V28.8437Z"
        })
    }),
    iF = ({
        hasBlockingError: t,
        error: e,
        onClose: r,
        onBack: n,
        handleSubmit: i,
        account: s,
        submitSuccess: a
    }) => {
        var c;
        let {
            pendingTransaction: o
        } = $e();
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                onClose: r
            }, "header"), d.jsx(Fi, {
                children: d.jsxs("div", {
                    children: [d.jsx(Ia, {
                        success: a,
                        fail: !!e
                    }), d.jsx(e ? yo : M0, {
                        style: {
                            width: "38px",
                            height: "38px"
                        }
                    })]
                })
            }), d.jsx(Cr, {
                style: {
                    marginTop: "1rem"
                },
                children: "Verifying with passkey"
            }), d.jsxs(Zy, {
                children: [d.jsxs(co, {
                    children: [d.jsx(oo, {
                        children: d.jsx(hd, {})
                    }), "Approve this action using your touch, face, PIN, or hardware key."]
                }), d.jsxs(co, {
                    children: [d.jsx(oo, {
                        children: d.jsx(Aoe, {})
                    }), "You last added a passkey on", " ", (c = s == null ? void 0 : s.firstVerifiedAt) == null ? void 0 : c.toLocaleDateString(void 0, {
                        month: "short",
                        day: "numeric",
                        year: "numeric"
                    }), "."]
                })]
            }), o && d.jsx(xd, {
                children: d.jsx(E4, {
                    pendingTransaction: o
                })
            }), e && d.jsxs(d.Fragment, {
                children: [d.jsx(FU, {
                    style: {
                        marginTop: "1.25rem"
                    },
                    children: e.message
                }), d.jsx(Qe, {
                    disabled: t,
                    onClick: i,
                    style: {
                        marginTop: "1.25rem"
                    },
                    children: "Try again"
                })]
            }), n && d.jsx(u1, {
                style: {
                    marginTop: "1rem"
                },
                onClick: n,
                children: "Choose another method"
            }), d.jsx(Wt, {})]
        })
    };
let ZCe = Array(6).fill("");
var gf, JCe = ((gf = JCe || {})[gf.RESET_AFTER_DELAY = 0] = "RESET_AFTER_DELAY", gf[gf.CLEAR_ON_NEXT_VALID_INPUT = 1] = "CLEAR_ON_NEXT_VALID_INPUT", gf);

function _4(t) {
    return /^[0-9]{1}$/.test(t)
}

function E$(t) {
    return t.length === 6 && t.every(_4)
}
const p1 = ({
    onChange: t,
    disabled: e,
    errorReasonOverride: r,
    success: n
}) => {
    let [i, s] = v.useState(ZCe), [a, o] = v.useState(null), [c, l] = v.useState(null), u = async f => {
        var I;
        f.preventDefault();
        let p = f.currentTarget.value.replace(/\s+/g, "");
        if (p === "") return;
        let g = i.reduce((T, C) => T + Number(_4(C)), 0),
            m = p.split(""),
            y = !m.every(_4),
            w = m.length + g > 6;
        if (y) return o("Passcode can only be numbers"), void l(1);
        if (w) return o("Passcode must be exactly 6 numbers"), void l(1);
        o(null), l(null);
        let x = Number((I = f.currentTarget.name) == null ? void 0 : I.charAt(4)),
            E = [...p || [""]].slice(0, 6 - x),
            _ = [...i.slice(0, x), ...E, ...i.slice(x + E.length)];
        s(_);
        let b = Math.min(Math.max(x + E.length, 0), 5),
            A = document.querySelector(`input[name=pin-${b}]`);
        if (A == null || A.focus(), E$(_)) try {
            await t(_.join(""));
            let T = document.querySelector(`input[name=pin-${b}]`);
            T == null || T.blur()
        } catch (T) {
            l(1), o(T.message)
        } else try {
            await t(null)
        } catch (T) {
            l(1), o(T.message)
        }
    }, h = n ? "success" : !r && !a ? "" : "fail";
    return d.jsx(d.Fragment, {
        children: d.jsxs(QCe, {
            children: [d.jsx("div", {
                children: i.map((f, p) => d.jsx("input", {
                    name: `pin-${p}`,
                    type: "text",
                    value: i[p],
                    onChange: u,
                    onKeyUp: g => {
                        g.key === "Backspace" && (m => {
                            c === 1 && (o(null), l(null));
                            let y = [...i.slice(0, m), "", ...i.slice(m + 1)];
                            if (s(y), m > 0) {
                                let w = document.querySelector(`input[name=pin-${m-1}]`);
                                w == null || w.focus()
                            }
                            E$(y) ? t(y.join("")) : t(null)
                        })(p)
                    },
                    inputMode: "numeric",
                    autoFocus: p === 0,
                    pattern: "[0-9]",
                    className: h,
                    autoComplete: gr.isMobile ? "one-time-code" : "off",
                    disabled: e
                }, p))
            }), d.jsx("div", {
                children: d.jsx(XCe, {
                    $fail: !!r || !!a,
                    children: r || a
                })
            })]
        })
    })
};
let QCe = z.div.withConfig({
        displayName: "PinInputContainer",
        componentId: "sc-7a171f6-0"
    })(["display:flex;flex-direction:column;width:100%;gap:8px;@media (max-width:440px){margin-top:8px;margin-bottom:8px;}> div:nth-child(1){display:flex;justify-content:center;gap:0.5rem;width:100%;border-radius:var(--privy-border-radius-md);> input{border:1px solid var(--privy-color-foreground-4);background:var(--privy-color-background);border-radius:var(--privy-border-radius-md);padding:8px 10px;height:58px;width:46px;text-align:center;font-size:18px;}> input:disabled{background:var(--privy-color-background-2);}> input:focus{border:1px solid var(--privy-color-accent);}> input:invalid{border:1px solid var(--privy-color-error);}> input.success{border:1px solid var(--privy-color-success);}> input.fail{border:1px solid var(--privy-color-error);animation:shake 180ms;animation-iteration-count:2;}}@keyframes shake{0%{transform:translate(1px,0px);}33%{transform:translate(-1px,0px);}67%{transform:translate(-1px,0px);}100%{transform:translate(1px,0px);}}"]),
    XCe = z.div.withConfig({
        displayName: "InputHelp",
        componentId: "sc-7a171f6-1"
    })(["line-height:20px;font-size:13px;display:flex;justify-content:flex-start;width:100%;color:", ";"], t => t.$fail ? "var(--privy-color-error)" : "var(--privy-color-foreground-3)");
const sF = ({
        selectedMethod: t,
        submitSuccess: e,
        hasBlockingError: r,
        onClose: n,
        onBack: i,
        handleSubmitCode: s
    }) => {
        let {
            app: a
        } = Ne(), {
            pendingTransaction: o
        } = $e();
        switch (t) {
            case "sms":
                return d.jsxs(d.Fragment, {
                    children: [d.jsx(Pe, {
                        onClose: n
                    }, "header"), d.jsx(Oi, {
                        style: {
                            marginBottom: "1.5rem"
                        },
                        children: d.jsx(Ca, {})
                    }), d.jsx(Cr, {
                        children: "Enter verification code"
                    }), d.jsxs(xd, {
                        children: [d.jsx(p1, {
                            success: e,
                            disabled: r,
                            onChange: s
                        }), d.jsxs(Ar, {
                            children: ["To continue, please enter the 6-digit code sent to your ", d.jsx("strong", {
                                children: "mobile device"
                            })]
                        }), o && d.jsx(E4, {
                            pendingTransaction: o
                        })]
                    }), i && d.jsx(u1, {
                        theme: a == null ? void 0 : a.appearance.palette.colorScheme,
                        onClick: i,
                        children: "Choose another method"
                    }), d.jsx(po, {
                        onClick: n,
                        children: "Cancel"
                    }), d.jsx(Wt, {})]
                });
            case "totp":
                return d.jsxs(d.Fragment, {
                    children: [d.jsx(Pe, {
                        onClose: n
                    }, "header"), d.jsx(Oi, {
                        style: {
                            marginBottom: "1.5rem"
                        },
                        children: d.jsx(oy, {})
                    }), d.jsx(Cr, {
                        children: "Enter verification code"
                    }), d.jsxs(xd, {
                        children: [d.jsx(p1, {
                            success: e,
                            disabled: r,
                            onChange: s
                        }), d.jsxs(Ar, {
                            children: ["To continue, please enter the 6-digit code generated from your", " ", d.jsx("strong", {
                                children: "authenticator app"
                            })]
                        }), o && d.jsx(E4, {
                            pendingTransaction: o
                        })]
                    }), i && d.jsx(u1, {
                        theme: a == null ? void 0 : a.appearance.palette.colorScheme,
                        onClick: i,
                        children: "Choose another method"
                    }), d.jsx(po, {
                        onClick: n,
                        children: "Cancel"
                    }), d.jsx(Wt, {})]
                });
            default:
                return null
        }
    },
    eAe = ["error", "invalid_request_arguments", "wallet_not_on_device", "invalid_recovery_pin", "insufficient_funds", "missing_or_invalid_mfa", "mfa_verification_max_attempts_reached", "mfa_timeout", "twilio_verification_failed"];
class Nr extends Error {
    constructor(e, r) {
        super(r), this.type = e
    }
}

function jh(t) {
    let e = t.type;
    return typeof e == "string" && eAe.includes(e)
}

function Hp(t) {
    return jh(t) && t.type === "wallet_not_on_device"
}

function A8(t) {
    return !!jh(t) && t.type === "mfa_timeout"
}

function k8(t) {
    return !!jh(t) && t.type === "missing_or_invalid_mfa"
}

function tAe(t) {
    return !!jh(t) && t.type === "mfa_verification_max_attempts_reached"
}

function aF(t) {
    return !(!jh(t) || !t.message.includes("code 429"))
}

function oF(t) {
    return !! function(e) {
        let r = e.type;
        return typeof r == "string" && r === "client_error"
    }(t) && t.message === "MFA canceled"
}
const g1 = t => tAe(t) ? {
        isBlocking: !0,
        error: Error("You have exceeded the maximum number of attempts. Please close this window and try again in 10 seconds.")
    } : k8(t) ? {
        isBlocking: !1,
        error: Error("The code you entered is not valid")
    } : A8(t) ? {
        isBlocking: !0,
        error: Error("You have exceeded the time limit for code entry. Please try again in 30 seconds.")
    } : (console.error(t), {
        isBlocking: !1,
        error: Error("Something went wrong.")
    }),
    rAe = {
        component: () => {
            let {
                user: t
            } = $t(), {
                data: e
            } = Ne(), [r, n] = v.useState(t == null ? void 0 : t.mfaMethods[0]), [i, s] = v.useState(!1), [a, o] = v.useState(), [c, l] = v.useState();
            if (v.useEffect(() => {
                    n(t == null ? void 0 : t.mfaMethods[0])
                }, [t == null ? void 0 : t.mfaMethods]), !(e != null && e.mfaVerify)) throw Error("Missing modal data for MFA verification screen.");
            let {
                onFailure: u,
                onSuccess: h,
                generateOptions: f,
                verifyTotpCode: p,
                verifyPasskey: g,
                verifySmsCode: m,
                sendSmsCode: y
            } = e.mfaVerify, w = async b => {
                if (b !== "passkey") try {
                    n(b), b === "sms" && (n(b), await y()), b === "totp" && n(b)
                } catch (A) {
                    console.error(A)
                } else try {
                    n(b);
                    let A = await f();
                    if (!A) throw Error("something went wrong");
                    o(A), await g(A), s(!0), l(void 0), h()
                } catch (A) {
                    l(g1(A))
                }
            }, x = async b => {
                l(void 0);
                try {
                    if (!b || !r) return;
                    if (r === "passkey") {
                        if (!a) throw Error("Missing passkey challenge");
                        await g(a)
                    } else r === "sms" ? await m(b) : r === "totp" && await p(b);
                    l(void 0), s(!0), h()
                } catch (A) {
                    throw g1(A).error
                }
            }, E = () => {
                c || !i ? u((c == null ? void 0 : c.error) ? ? Error("Canceled MFA verification.")) : h()
            }, _ = v.useRef(!1);
            return v.useEffect(() => {
                !_.current && r && (_.current = !0, w(r).finally(() => {
                    _.current = !1
                }))
            }, [open]), t ? r === "passkey" ? d.jsx(iF, {
                account: t.linkedAccounts.filter(b => b.type === "passkey" && b.enrolledInMfa).sort((b, A) => A.firstVerifiedAt.valueOf() - b.firstVerifiedAt.valueOf())[0],
                submitSuccess: i,
                hasBlockingError: (c == null ? void 0 : c.isBlocking) ? ? !1,
                error: c == null ? void 0 : c.error,
                onClose: E,
                onBack: () => {
                    n(void 0), l(void 0)
                },
                handleSubmit: () => x(a).catch(l)
            }) : r === "sms" || r === "totp" ? d.jsx(sF, {
                selectedMethod: r,
                submitSuccess: i,
                hasBlockingError: (c == null ? void 0 : c.isBlocking) ? ? !1,
                handleSubmitCode: x,
                onClose: E,
                onBack: t.mfaMethods.length > 1 ? () => n(void 0) : void 0
            }) : d.jsx(BU, {
                user: t,
                onSelect: w,
                handleClose: E
            }) : null
        }
    };

function cF() {
    let {
        promptMfa: t,
        init: e,
        submit: r,
        cancel: n,
        mfaMethods: i
    } = v.useContext(Td);
    return {
        promptMfa: t,
        init: e,
        submit: r,
        cancel: n,
        mfaMethods: i
    }
}
const _$ = ({
        onClose: t
    }) => {
        let {
            user: e
        } = $t(), [r, n] = v.useState((e == null ? void 0 : e.mfaMethods[0]) ? ? null), {
            init: i,
            cancel: s,
            submit: a
        } = cF(), [o, c] = v.useState(!1), [l, u] = v.useState(null), [h, f] = v.useState();
        v.useEffect(() => {
            n((e == null ? void 0 : e.mfaMethods[0]) ? ? null)
        }, [e == null ? void 0 : e.mfaMethods]);
        let p = v.useRef(!1);
        async function g(w) {
            f(void 0);
            try {
                if (!w || !r) return;
                await a(r, w), c(!0), f(void 0), t()
            } catch (x) {
                throw g1(x).error
            }
        }
        async function m(w) {
            if (w !== "passkey") try {
                n(w), await i(w)
            } catch (x) {
                console.error(x)
            } else try {
                n(w);
                let x = await i(w);
                if (!x) throw Error("something went wrong");
                u(x), await a(w, x), c(!0), f(void 0), t()
            } catch (x) {
                f(g1(x))
            }
        }
        v.useEffect(() => {
            !p.current && r && (p.current = !0, m(r).finally(() => {
                p.current = !1
            }))
        }, []);
        let y = () => {
            n(null), f(void 0), s(), t()
        };
        return e ? r === "passkey" ? d.jsx(iF, {
            account: e.linkedAccounts.filter(w => w.type === "passkey" && w.enrolledInMfa).sort((w, x) => x.firstVerifiedAt.valueOf() - w.firstVerifiedAt.valueOf())[0],
            submitSuccess: o,
            hasBlockingError: (h == null ? void 0 : h.isBlocking) ? ? !1,
            error: h == null ? void 0 : h.error,
            onClose: y,
            onBack: () => {
                n(null), f(void 0)
            },
            handleSubmit: () => g(l).catch(f)
        }) : r ? d.jsx(sF, {
            submitSuccess: o,
            hasBlockingError: (h == null ? void 0 : h.isBlocking) ? ? !1,
            handleSubmitCode: g,
            selectedMethod: r,
            onClose: y,
            onBack: e.mfaMethods.length > 1 ? () => n(null) : void 0
        }) : d.jsx(BU, {
            user: e,
            onSelect: m,
            handleClose: y
        }) : null
    },
    m1 = vh(() => ({
        inProgressMfaFlow: void 0
    })),
    nAe = BW([":root{--privy-border-radius-sm:6px;--privy-border-radius-md:12px;--privy-border-radius-mdlg:16px;--privy-border-radius-lg:24px;--privy-border-radius-full:9999px;--privy-color-background:", ";--privy-color-background-2:", ";--privy-color-background-3:", ";--privy-color-foreground:", ";--privy-color-foreground-2:", ";--privy-color-foreground-3:", ";--privy-color-foreground-4:", ";--privy-color-foreground-accent:", ";--privy-color-accent:", ";--privy-color-accent-light:", ";--privy-color-accent-lightest:", ";--privy-color-accent-dark:", ";--privy-color-accent-darkest:", ";--privy-color-success:", ";--privy-color-success-dark:", ";--privy-color-success-light:", ";--privy-color-error:", ";--privy-color-error-light:", ";--privy-color-warn:", ";--privy-color-warn-light:", ";--privy-height-modal-full:620px;--privy-height-modal-compact:480px;};"], t => t.theme.background, t => t.theme.background2, t => t.theme.background3, t => t.theme.foreground, t => t.theme.foreground2, t => t.theme.foreground3, t => t.theme.foreground4, t => t.theme.foregroundAccent, t => t.theme.accent, t => t.theme.accentLight, t => t.theme.accentLightest, t => t.theme.accentDark, t => t.theme.accentDarkest, t => t.theme.success, t => t.theme.successDark, t => t.theme.successLight, t => t.theme.error, t => t.theme.errorLight, t => t.theme.warn, t => t.theme.warnLight),
    C$ = z.div.withConfig({
        displayName: "StylesWrapper",
        componentId: "sc-bc1e45b4-0"
    })(["", " color:var(--privy-color-foreground-2);h3{font-size:16px;line-height:24px;font-weight:500;color:var(--privy-color-foreground-2);}h4{font-size:14px;line-height:20px;font-weight:500;color:var(--privy-color-foreground);}p{font-size:13px;line-height:20px;color:var(--privy-color-foreground-2);}button:focus,input:focus,optgroup:focus,select:focus,textarea:focus{outline:none;border-color:var(--privy-color-accent-light);box-shadow:0 0 0 1px var(--privy-color-accent-light);}.mobile-only{@media (min-width:441px){display:none;}}@keyframes fadein{0%{opacity:0;}100%{opacity:1;}}"], `
  *,
  ::before,
  ::after {
    box-sizing: border-box;
    border-width: 0;
    border-style: solid;
  }

  line-height: 1.15;
  -webkit-text-size-adjust: 100%;
  -moz-tab-size: 4;
  tab-size: 4;
  font-feature-settings: normal;

  margin: 0;
  font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,
    'Apple Color Emoji', 'Segoe UI Emoji';

  hr {
    height: 0;
    color: inherit;
    border-top-width: 1px;
  }

  abbr:where([title]) {
    text-decoration: underline dotted;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-size: inherit;
    font-weight: inherit;
    font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,
    'Apple Color Emoji', 'Segoe UI Emoji';
    display: inline;
  }

  a {
    color: inherit;
    text-decoration: inherit;
  }

  b,
  strong {
    font-weight: bolder;
  }

  code,
  kbd,
  samp,
  pre {
    font-family: ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 1em;
  }

  small {
    font-size: 80%;
  }

  sub,
  sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
  }

  sub {
    bottom: -0.25em;
  }

  sup {
    top: -0.5em;
  }

  table {
    text-indent: 0;
    border-color: inherit;
    border-collapse: collapse;
  }

  button,
  input,
  optgroup,
  select,
  textarea {
    font-family: inherit;
    font-size: 100%;
    font-weight: inherit;
    line-height: inherit;
    color: inherit;
    margin: 0;
    padding: 0;
  }

  button,
  select {
    text-transform: none;
  }

  button,
  [type='button'],
  [type='reset'],
  [type='submit'] {
    -webkit-appearance: button;
    background-color: transparent;
    background-image: none;
  }

  ::-moz-focus-inner {
    border-style: none;
    padding: 0;
  }

  :-moz-focusring {
    outline: 1px dotted ButtonText;
  }

  :-moz-ui-invalid {
    box-shadow: none;
  }

  legend {
    padding: 0;
  }

  progress {
    vertical-align: baseline;
  }

  ::-webkit-inner-spin-button,
  ::-webkit-outer-spin-button {
    height: auto;
  }

  [type='search'] {
    -webkit-appearance: textfield;
    outline-offset: -2px;
  }

  ::-webkit-search-decoration {
    -webkit-appearance: none;
  }

  ::-webkit-file-upload-button {
    -webkit-appearance: button;
    font: inherit;
  }

  summary {
    display: list-item;
  }

  blockquote,
  dl,
  dd,
  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  hr,
  figure,
  p,
  pre {
    margin: 0;
  }

  fieldset {
    margin: 0;
    padding: 0;
  }

  legend {
    padding: 0;
  }

  ol,
  ul,
  menu {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  textarea {
    resize: vertical;
  }

  input::placeholder,
  textarea::placeholder {
    opacity: 1;
    color: #9ca3af;
  }

  button,
  [role='button'] {
    cursor: pointer;
  }

  :disabled {
    cursor: default;
  }

  img,
  svg,
  video,
  canvas,
  audio,
  iframe,
  embed,
  object {
    display: block;
  }

  img,
  video {
    max-width: 100%;
    height: auto;
  }

  [hidden] {
    display: none;
  }
`),
    iAe = ({
        children: t,
        open: e,
        onClick: r,
        ...n
    }) => d.jsx(bR, {
        show: e,
        as: at.Fragment,
        children: d.jsxs(Oue, {
            onClose: r,
            ...n,
            as: aAe,
            children: [d.jsx(Np, {
                as: at.Fragment,
                enterFrom: "entering",
                leaveTo: "leaving",
                children: d.jsx(sAe, {
                    id: "privy-dialog-backdrop",
                    "aria-hidden": "true"
                })
            }), d.jsx(oAe, {
                children: d.jsx(Np, {
                    as: at.Fragment,
                    enterFrom: "entering",
                    leaveTo: "leaving",
                    children: d.jsx(vR, {
                        as: cAe,
                        children: t
                    })
                })
            })]
        })
    });
let sAe = z.div.withConfig({
        displayName: "Backdrop",
        componentId: "sc-3cfde0b5-0"
    })(["position:fixed;inset:0;transition:backdrop-filter 100ms ease;backdrop-filter:blur(3px);-webkit-backdrop-filter:blur(3px);&.entering,&.leaving{backdrop-filter:unset;-webkit-backdrop-filter:unset;}"]),
    aAe = z.div.withConfig({
        displayName: "DialogWrapper",
        componentId: "sc-3cfde0b5-1"
    })(["position:relative;z-index:999999;"]),
    oAe = z.div.withConfig({
        displayName: "DialogContainer",
        componentId: "sc-3cfde0b5-2"
    })(["position:fixed;inset:0;display:flex;align-items:center;justify-content:center;width:100vw;min-height:100vh;"]);
const cAe = z.div.withConfig({
        displayName: "Panel",
        componentId: "sc-3cfde0b5-3"
    })(["padding:0;background:transparent;border:none;width:100%;pointer-events:auto;outline:none;display:block;@media (max-width:440px){opacity:1;transform:translate3d(0,0,0);transition:transform 200ms ease-in;position:fixed;bottom:0;&.entering,&.leaving{opacity:0;transform:translate3d(0,100%,0);transition:transform 150ms ease-in 0ms,opacity 0ms ease 150ms;}}@media (min-width:441px){opacity:1;transition:opacity 100ms ease-in;&.entering,&.leaving{opacity:0;transition-delay:5ms;}margin:auto;width:360px;box-shadow:0px 8px 36px rgba(55,65,81,0.15);border-radius:var(--privy-border-radius-lg);}"]),
    lAe = z.div.withConfig({
        displayName: "CenterItem",
        componentId: "sc-3cfde0b5-4"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;"]);
let lF = () => {
        let {
            ready: t,
            isModalOpen: e
        } = $t(), {
            headless: r
        } = Gt(), {
            currentScreen: n
        } = Ne(), {
            status: i,
            execute: s,
            reset: a,
            enabled: o
        } = qi(), c = m1(h => h.inProgressMfaFlow), l = () => m1.setState({
            inProgressMfaFlow: void 0
        }), u = e && n && n.isCaptchaRequired && !r && i === "ready";
        return v.useEffect(() => {
            u && s()
        }, [u]), v.useEffect(() => {
            !e && o && a()
        }, [e, o]), n && !t && n.isShownBeforeReady ? d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {}), d.jsx(er, {}), d.jsx(lAe, {
                children: d.jsx(Ls, {})
            }), d.jsx(nr, {}), d.jsx(Wt, {})]
        }) : n || c !== "txn" ? n ? d.jsxs(d.Fragment, {
            children: [d.jsx(ch, {
                $if: !!c,
                children: d.jsx(n.component, {})
            }), c === "txn" && d.jsx(_$, {
                onClose: l
            }), c === "auth" && d.jsx(rAe.component, {})]
        }) : null : d.jsx(_$, {
            onClose: l
        })
    },
    dAe = () => {
        let t = v.useRef(null);
        return d.jsx(hAe, {
            style: {
                height: Y9e(t)
            },
            id: "privy-modal-content",
            children: d.jsx("div", {
                ref: t,
                children: d.jsx(lF, {})
            })
        })
    };
const uAe = ({
    open: t
}) => {
    let e = Gt(),
        {
            gracefulClosePrivyModal: r
        } = (() => {
            let {
                closePrivyModal: i
            } = $e(), {
                onUserCloseViaDialogOrKeybindRef: s
            } = Ne();
            return {
                gracefulClosePrivyModal: v.useCallback(() => {
                    if (!(s != null && s.current)) return i({
                        shouldCallAuthOnSuccess: !1
                    });
                    s.current()
                }, [i])
            }
        })(),
        n = m1(i => i.inProgressMfaFlow);
    return J9e({
        onMfaRequired: () => {
            e.mfa.noPromptOnMfaRequired || m1.setState({
                inProgressMfaFlow: "txn"
            })
        }
    }), e.render.standalone ? d.jsx(C$, {
        children: d.jsx(dF, {
            id: "privy-modal-content",
            children: d.jsx(lF, {})
        })
    }) : d.jsx(iAe, {
        open: !(!t && !n),
        id: "privy-dialog",
        "aria-label": "log in or sign up",
        "aria-labelledby": "privy-dialog-title",
        onClick: () => r(),
        children: d.jsx(C$, {
            children: d.jsx(dAe, {})
        })
    })
};
let dF = z.div.withConfig({
        displayName: "ContentWrapper",
        componentId: "sc-b220e1ee-0"
    })(["display:flex;flex-direction:column;text-align:center;font-size:14px;line-height:20px;width:100%;background:var(--privy-color-background);padding:0 16px;"]),
    hAe = z(dF).withConfig({
        displayName: "BaseModal",
        componentId: "sc-b220e1ee-1"
    })(["transition:height 150ms ease-out;overflow-x:hidden;overflow-y:auto;scrollbar-width:none;max-height:calc(100svh - 32px);border-radius:var(--privy-border-radius-lg) var(--privy-border-radius-lg) 0 0;box-shadow:0px 0px 36px rgba(55,65,81,0.15);@media (min-width:441px){box-shadow:0px 8px 36px rgba(55,65,81,0.15);border-radius:var(--privy-border-radius-lg);}"]);

function fAe(t) {
    let e = v.useRef(null),
        r = v.useRef();
    return v.useEffect(() => {
        var n, i;
        (n = r.current) == null || n.remove(), r.current = function({
            botUsername: s,
            scriptHost: a
        }) {
            let o = document.createElement("script"),
                {
                    origin: c
                } = new URL(a);
            return o.async = !0, o.src = `${c}/js/telegram-login.js`, o.setAttribute("data-telegram-login", s), o.setAttribute("data-request-access", "write"), o.setAttribute("data-lang", "en"), o
        }(t), (i = e.current) == null || i.after(r.current)
    }, [t]), d.jsx("div", {
        ref: e,
        hidden: !0
    })
}
const Rt = ({
    address: t,
    showCopyIcon: e,
    url: r,
    className: n
}) => {
    let [i, s] = v.useState(!1);

    function a(o) {
        o.stopPropagation(), navigator.clipboard.writeText(t).then(() => s(!0)).catch(console.error)
    }
    return v.useEffect(() => {
        if (i) {
            let o = setTimeout(() => s(!1), 2e3);
            return () => clearTimeout(o)
        }
    }, [i]), r ? d.jsxs(pAe, {
        children: [d.jsx("a", {
            title: t,
            className: n,
            href: `${r}/address/${t}`,
            target: "_blank",
            children: Yn(t)
        }), !!e && (i ? d.jsx(k$, {}) : d.jsx(A$, {
            onClick: a
        }))]
    }) : d.jsxs("button", {
        title: t,
        className: n,
        onClick: a,
        children: [Yn(t), !!e && d.jsx(i ? k$ : A$, {})]
    })
};
let A$ = z(IR).withConfig({
        displayName: "StyledSquare2StackIcon",
        componentId: "sc-ffd38c92-0"
    })(["&&{display:inline;}stroke-width:2;height:0.875rem;width:0.875rem;margin-left:0.125rem;color:var(--privy-color-foreground-3);cursor:pointer;"]),
    k$ = z(che).withConfig({
        displayName: "StyledCheckIcon",
        componentId: "sc-ffd38c92-1"
    })(["&&{display:inline;}stroke-width:2;height:0.875rem;width:0.875rem;margin-left:0.125rem;color:var(--privy-color-success);"]),
    pAe = z.span.withConfig({
        displayName: "Link",
        componentId: "sc-ffd38c92-2"
    })(["display:inline-flex;align-items:center;gap:0.25rem;"]);
const gAe = () => {
    let {
        solanaWallets: t
    } = $e(), {
        ready: e,
        wallets: r
    } = gl();
    return v.useEffect(() => {
        if (e) {
            let n = [...r, ...t].map(i => ({
                address: i.address,
                connectorType: i.connectorType,
                walletClientType: i.walletClientType,
                connectedAt: i.connectedAt,
                id: i.meta.id
            }));
            rt.put(QL, n)
        }
    }, [e, r, t]), null
};
async function Es(t, e, r, n, i, s = !1) {
    var l, u, h;
    let a = s,
        o = async f => {
            var p;
            if (a && e && e.length > 0) {
                f === (s ? 0 : 1) ? i("configureMfa", "onMfaRequired", {
                    mfaMethods: e
                }) : (p = n.current) == null || p.reject(new Nr("missing_or_invalid_mfa", "MFA verification failed, retry."));
                let g = await new Promise((m, y) => {
                    r.current = {
                        resolve: m,
                        reject: y
                    }, setTimeout(() => {
                        var x;
                        let w = new Nr("mfa_timeout", "Timed out waiting for MFA code");
                        (x = n.current) == null || x.reject(w), y(w)
                    }, 3e5)
                });
                return await t(g)
            }
            return await t()
        },
        c = null;
    for (let f = 0; f < 4; f++) try {
        c = await o(f), (l = n.current) == null || l.resolve(void 0);
        break
    } catch (p) {
        if (p.type !== "missing_or_invalid_mfa") throw (u = n.current) == null || u.resolve(void 0), p;
        a = !0
    }
    if (c === null) {
        let f = new Nr("mfa_verification_max_attempts_reached", "Max MFA verification attempts reached");
        throw (h = n.current) == null || h.reject(f), f
    }
    return c
}
var I$;
let mAe = (I$ = 0, () => "id-" + I$++);

function nn(t) {
    return t.error !== void 0
}
let Yr = new class {
        enqueue(t, e) {
            this.callbacks[t] = e
        }
        dequeue(t, e) {
            let r = this.callbacks[e];
            if (!r) throw Error(`cannot dequeue ${t} event: no event found for id ${e}`);
            switch (delete this.callbacks[e], t) {
                case "privy:iframe:ready":
                case "privy:user-signer:sign":
                case "privy:wallets:add":
                case "privy:wallets:import":
                case "privy:wallets:set-recovery":
                case "privy:wallets:connect":
                case "privy:wallets:recover":
                case "privy:wallets:rpc":
                case "privy:wallet:create":
                case "privy:mfa:verify":
                case "privy:mfa:init-enrollment":
                case "privy:mfa:submit-enrollment":
                case "privy:mfa:unenroll":
                case "privy:mfa:clear":
                case "privy:auth:unlink-passkey":
                case "privy:farcaster:init-signer":
                case "privy:farcaster:sign":
                case "privy:solana-wallet:create":
                case "privy:delegated-actions:consent":
                    return r;
                default:
                    throw Error(`invalid wallet event type ${t}`)
            }
        }
        constructor() {
            this.callbacks = {}
        }
    },
    $v = new Map,
    yAe = (t, e) => typeof e == "bigint" ? e.toString() : e;

function sn(t, e, r, n) {
    let i = r.contentWindow;
    if (!i) throw Error("iframe not initialized");
    let s = ((o, c) => `${o}${JSON.stringify(c,yAe)}`)(t, e);
    if (t === "privy:wallet:create") {
        let o = $v.get(s);
        if (o) return o
    }
    let a = new Promise((o, c) => {
        let l = mAe();
        Yr.enqueue(l, {
            resolve: o,
            reject: c
        }), i.postMessage({
            id: l,
            event: t,
            data: e
        }, n)
    }).finally(() => {
        $v.delete(s)
    });
    return $v.set(s, a), a
}

function wAe(t) {
    let e = SU(),
        r = v.useRef(null),
        n = v.useRef(t.mfaMethods),
        i = yc(),
        [s, a] = v.useState(!1);
    return v.useEffect(() => {
        n.current = t.mfaMethods
    }, [t.mfaMethods]), v.useEffect(() => {
        if (!s) return;
        let o = r.current;
        if (!o) return;

        function c(h) {
            var f;
            h && h.origin === t.origin && typeof(f = h.data).event == "string" && /^privy:.+/.test(f.event) && function(p) {
                switch (p.event) {
                    case "privy:iframe:ready":
                        let g = Yr.dequeue(p.event, p.id);
                        return nn(p) ? g.reject(new Nr(p.error.type, p.error.message)) : g.resolve(p.data);
                    case "privy:user-signer:sign":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    case "privy:wallets:add":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    case "privy:wallets:set-recovery":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    case "privy:wallets:connect":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    case "privy:wallets:recover":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    case "privy:wallets:rpc":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    case "privy:wallet:create":
                        let m = Yr.dequeue(p.event, p.id);
                        return nn(p) ? m.reject(new Nr(p.error.type, p.error.message)) : m.resolve(p.data);
                    case "privy:wallets:import":
                        let y = Yr.dequeue(p.event, p.id);
                        return nn(p) ? y.reject(new Nr(p.error.type, p.error.message)) : y.resolve(p.data);
                    case "privy:mfa:verify":
                        let w = Yr.dequeue(p.event, p.id);
                        return nn(p) ? w.reject(new Nr(p.error.type, p.error.message)) : w.resolve(p.data);
                    case "privy:mfa:init-enrollment":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    case "privy:mfa:submit-enrollment":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    case "privy:mfa:unenroll":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    case "privy:mfa:clear":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    case "privy:auth:unlink-passkey":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    case "privy:solana-wallet:create":
                        let x = Yr.dequeue(p.event, p.id);
                        return nn(p) ? x.reject(new Nr(p.error.type, p.error.message)) : x.resolve(p.data);
                    case "privy:farcaster:init-signer":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    case "privy:farcaster:sign":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    case "privy:delegated-actions:consent":
                        {
                            let E = Yr.dequeue(p.event, p.id);
                            return nn(p) ? E.reject(new Nr(p.error.type, p.error.message)) : E.resolve(p.data)
                        }
                    default:
                        console.warn("Unsupported wallet proxy method:", p)
                }
            }(h.data)
        }
        let l = {
            signWithUserSigner: h => Es(f => sn("privy:user-signer:sign", { ...h,
                ...f
            }, o, t.origin), n.current, t.mfaPromise, t.mfaSubmitPromise, i),
            addWallet: h => Es(f => sn("privy:wallets:add", { ...h,
                ...f
            }, o, t.origin), n.current, t.mfaPromise, t.mfaSubmitPromise, i),
            setRecovery: h => Es(f => sn("privy:wallets:set-recovery", { ...h,
                ...f
            }, o, t.origin), n.current, t.mfaPromise, t.mfaSubmitPromise, i),
            connect: h => Es(f => sn("privy:wallets:connect", { ...h,
                ...f
            }, o, t.origin), n.current, t.mfaPromise, t.mfaSubmitPromise, i),
            recover: h => Es(f => sn("privy:wallets:recover", { ...h,
                ...f
            }, o, t.origin), n.current, t.mfaPromise, t.mfaSubmitPromise, i, !h.recoveryAccessToken && !h.recoveryPassword && !h.recoverySecretOverride),
            rpc: h => Es(f => sn("privy:wallets:rpc", { ...h,
                ...f
            }, o, t.origin), n.current, t.mfaPromise, t.mfaSubmitPromise, i),
            create: h => sn("privy:wallet:create", h, o, t.origin),
            importWallet: h => sn("privy:wallets:import", h, o, t.origin),
            createSolana: h => Es(f => sn("privy:solana-wallet:create", { ...h,
                ...f
            }, o, t.origin), n.current, t.mfaPromise, t.mfaSubmitPromise, i),
            createDelegatedAction: h => sn("privy:delegated-actions:consent", h, o, t.origin),
            verifyMfa: h => Es(f => sn("privy:mfa:verify", { ...h,
                ...f
            }, o, t.origin), n.current, t.mfaPromise, t.mfaSubmitPromise, i, !0),
            initEnrollMfa: h => Es(f => sn("privy:mfa:init-enrollment", { ...h,
                ...f
            }, o, t.origin), n.current, t.mfaPromise, t.mfaSubmitPromise, i),
            submitEnrollMfa: h => Es(f => sn("privy:mfa:submit-enrollment", { ...h,
                ...f
            }, o, t.origin), n.current, t.mfaPromise, t.mfaSubmitPromise, i),
            unenrollMfa: h => Es(f => sn("privy:mfa:unenroll", { ...h,
                ...f
            }, o, t.origin), n.current, t.mfaPromise, t.mfaSubmitPromise, i),
            clearMfa: h => sn("privy:mfa:clear", h, o, t.origin),
            unlinkPasskeyAccount: h => Es(f => sn("privy:auth:unlink-passkey", { ...h,
                ...f
            }, o, t.origin), n.current, t.mfaPromise, t.mfaSubmitPromise, i),
            initFarcasterSigner: h => sn("privy:farcaster:init-signer", h, o, t.origin),
            signFarcasterMessage: h => sn("privy:farcaster:sign", h, o, t.origin)
        };
        window.addEventListener("message", c);
        let u = new AbortController;
        return m4(() => sn("privy:iframe:ready", {}, o, t.origin), {
            abortSignal: u.signal
        }).then(() => t.onLoad(l), (...h) => {
            console.warn("Privy iframe failed to load: ", ...h), t.onLoadFailed()
        }), () => {
            window.removeEventListener("message", c), u.abort()
        }
    }, [s]), e ? d.jsx("iframe", {
        ref: r,
        width: "0",
        height: "0",
        style: {
            display: "none",
            height: "0px",
            width: "0px"
        },
        onLoad: () => a(!0),
        src: gU(t.origin, `/apps/${t.appId}/embedded-wallets`, {
            caid: t.clientAnalyticsId,
            client_id: t.appClientId
        })
    }) : null
}

function lh(t) {
    return ["ethereum", "solana"].includes(t.chainType)
}
const bAe = ({
        address: t,
        user: e
    }) => {
        let r = e.linkedAccounts.find(n => n.type === "wallet" && n.walletClientType === "privy" && n.address === t);
        if (!r) throw new J("Address to delegate is not associated with current user.");
        if (!lh(r)) throw new J(`useDelegatedActions is not supported for ${r.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);
        return {
            address: r.address,
            chainType: r.chainType,
            walletIndex: r.walletIndex ? ? 0
        }
    },
    vAe = ({
        address: t,
        user: e
    }) => {
        let r = e.linkedAccounts.find(i => i.type === "wallet" && i.walletClientType === "privy" && i.address === t);
        if (!r) throw new J("Address to delegate is not associated with current user.");
        let n = r.imported ? r : Rs(e);
        if (!n) throw new J("Unable to determine root address for delegated address.");
        if (!lh(n)) throw new J(`useDelegatedActions is not supported for ${n.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);
        return {
            address: n.address,
            chainType: n.chainType,
            imported: n.imported
        }
    },
    $$ = t => t.linkedAccounts.filter(e => e.type === "wallet" && e.walletClientType === "privy" && e.delegated),
    xAe = () => {
        let t = Gt();
        v.useEffect(() => {
            (async e => {
                let r = new URL("v3/wallets", "https://explorer-api.walletconnect.com");
                r.searchParams.append("projectId", e);
                let n = await fetch(r);
                return n.ok ? Object.values((await n.json()).listings).sort(({
                    slug: i
                }, {
                    slug: s
                }) => i === "rainbow" && s === "metamask" ? 1 : i === "metamask" || i === "rainbow" ? -1 : 1) : (console.debug(`Failed to fetch WalletConnect listings: ${await n.text().catch(()=>"No response.")}`), [])
            })(t.walletConnectCloudProjectId).then(e => $9e({
                listings: e
            })).catch(console.error)
        }, [t.walletConnectCloudProjectId])
    };

function uF(t) {
    let e = t.replace("eip155:", "");
    if (e) return parseInt(e);
    throw Error("Chain ID not compatible with CAIP-2 format.")
}
const S$ = "popup-privy-oauth",
    T$ = "PRIVY_OAUTH_USE_BROADCAST_CHANNEL";
class EAe {
    async authenticate() {
        if (!this.api) throw new J("Auth flow has no API instance");
        try {
            return await this.api.post(oO, {
                authorization_code: this.meta.authorizationCode,
                state_code: this.meta.stateCode,
                code_verifier: this.meta.codeVerifier,
                provider: this.meta.provider
            })
        } catch (e) {
            throw qt(e)
        }
    }
    async link() {
        if (!this.api) throw new J("Auth flow has no API instance");
        try {
            return await this.api.post(cO, {
                authorization_code: this.meta.authorizationCode,
                state_code: this.meta.stateCode,
                code_verifier: this.meta.codeVerifier,
                provider: this.meta.provider
            })
        } catch (e) {
            throw qt(e)
        }
    }
    constructor({
        authorizationCode: e,
        stateCode: r,
        codeVerifier: n,
        provider: i
    }) {
        this.meta = {
            authorizationCode: e,
            stateCode: r,
            codeVerifier: n,
            provider: i
        }
    }
}
async function hF({
    api: t,
    requesterAppId: e,
    providerAppId: r
}) {
    let n = (await t.get(`/api/v1/apps/${e}/cross-app/connections`)).connections.find(i => i.provider_app_id === r);
    if (!n) throw new J("Invalid connected app");
    return {
        name: n.provider_app_name,
        logoUrl: n.provider_app_icon_url || void 0,
        apiUrl: n.provider_app_custom_api_url,
        readOnly: n.read_only
    }
}
const ew = () => window.open(void 0, void 0, _Ae({
    w: 440,
    h: 680
}));
let _Ae = ({
    w: t,
    h: e
}) => {
    let r = window.screenLeft !== void 0 ? window.screenLeft : window.screenX,
        n = window.screenTop !== void 0 ? window.screenTop : window.screenY,
        i = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width,
        s = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;
    return `toolbar=0,location=0,menubar=0,height=${e},width=${t},popup=1,left=${(i-t)/2/(i/window.screen.availWidth)+r},top=${(s-e)/2/(s/window.screen.availHeight)+n}`
};
const Sv = async ({
    user: t,
    address: e,
    client: r,
    request: n,
    requesterAppId: i,
    reconnect: s
}) => {
    r.createAnalyticsEvent({
        eventName: "cross_app_request_started",
        payload: {
            address: e,
            method: n.method
        }
    });
    let a = t == null ? void 0 : t.linkedAccounts.find(h => h.type === "cross_app" && (h.embeddedWallets.some(f => f.address === e) || h.smartWallets.some(f => f.address === e)));
    if (!t || !a) throw r.createAnalyticsEvent({
        eventName: "cross_app_request_error",
        payload: {
            error: "Cannot request a signature with this wallet address",
            address: e
        }
    }), new J("Cannot request a signature with this wallet address");
    let o = r.getProviderAccessToken(a.providerApp.id),
        c = await hF({
            api: r.api,
            requesterAppId: i,
            providerAppId: a.providerApp.id
        });
    if (!o) {
        if (c.readOnly) throw console.error("cannot transact against a read-only provider app"), new J("Cannot transact against a read-only provider app");
        await s({
            appId: a.providerApp.id,
            action: "link"
        }) && (o = r.getProviderAccessToken(a.providerApp.id))
    }
    if (!o) throw r.createAnalyticsEvent({
        eventName: "cross_app_request_error",
        payload: {
            error: "Transactions require a valid token",
            address: e
        }
    }), new J("Transactions require a valid token");
    let l = ew();
    if (!l) throw r.createAnalyticsEvent({
        eventName: "cross_app_request_error",
        payload: {
            error: "Missing token",
            address: e
        }
    }), new J("Failed to initialize signature request");
    let u = new URL(`${c.apiUrl}/oauth/transact`);
    return u.searchParams.set("token", o || ""), u.searchParams.set("request", CAe(n)), l.location = u.href, new Promise((h, f) => {
        let p = setTimeout(() => {
                y(), f(new J("Request timeout")), r.createAnalyticsEvent({
                    eventName: "cross_app_request_error",
                    payload: {
                        error: "Request timeout",
                        address: e
                    }
                })
            }, 12e4),
            g = setInterval(() => {
                l.closed && (y(), f(new J("User rejected request")), r.createAnalyticsEvent({
                    eventName: "cross_app_request_error",
                    payload: {
                        error: "User rejected request",
                        address: e
                    }
                }))
            }, 300),
            m = w => {
                var x, E, _;
                w.data && (((x = w.data.token) == null ? void 0 : x.action) === "set" && ((E = w.data.token) == null ? void 0 : E.value) !== void 0 ? r.storeProviderAccessToken(a.providerApp.id, w.data.token.value) : ((_ = w.data.token) == null ? void 0 : _.action) === "clear" && r.storeProviderAccessToken(a.providerApp.id, null), w.data.type === "PRIVY_CROSS_APP_ACTION_RESPONSE" && w.data.result && (y(), h(w.data.result), r.createAnalyticsEvent({
                    eventName: "cross_app_request_success",
                    payload: {
                        address: e,
                        method: n.method
                    }
                })), w.data.type === "PRIVY_CROSS_APP_ACTION_ERROR" && w.data.error && (y(), f(w.data.error), r.createAnalyticsEvent({
                    eventName: "cross_app_request_error",
                    payload: {
                        error: w.data.error,
                        address: e
                    }
                })))
            };
        window.addEventListener("message", m);
        let y = () => {
            l.close(), clearInterval(g), clearTimeout(p), window.removeEventListener("message", m)
        }
    })
};
let CAe = t => JSON.stringify({
    content: {
        request: {
            request: C4(t, cn)
        }
    },
    timestamp: Date.now(),
    callbackUrl: window.origin
});
const C4 = (t, e) => typeof t == "bigint" ? e(t) : Array.isArray(t) ? t.map(r => C4(r, e)) : t && typeof t == "object" ? Object.fromEntries(Object.entries(t).map(([r, n]) => [r, C4(n, e)])) : t,
    I8 = ({
        title: t,
        description: e,
        children: r,
        ...n
    }) => d.jsx(fF, { ...n,
        children: d.jsxs(d.Fragment, {
            children: [d.jsx("h3", {
                children: t
            }), typeof e == "string" ? d.jsx("p", {
                children: e
            }) : e, r]
        })
    }),
    tw = z(I8).withConfig({
        displayName: "PaddedScreenHeader",
        componentId: "sc-523a75d6-0"
    })(["margin-bottom:24px;"]),
    $r = ({
        title: t,
        description: e,
        icon: r,
        children: n,
        ...i
    }) => d.jsxs(AAe, { ...i,
        children: [r || null, d.jsx("h3", {
            children: t
        }), e && typeof e == "string" ? d.jsx("p", {
            children: e
        }) : e, n]
    });
let fF = z.div.withConfig({
        displayName: "StyledSection",
        componentId: "sc-523a75d6-1"
    })(["display:flex;flex-direction:column;justify-content:flex-start;align-items:flex-start;text-align:left;gap:8px;width:100%;margin-bottom:24px;&& h3{font-size:17px;color:var(--privy-color-foreground);}&& p{color:var(--privy-color-foreground-2);font-size:14px;}"]),
    AAe = z(fF).withConfig({
        displayName: "CenteredStyledSection",
        componentId: "sc-523a75d6-2"
    })(["align-items:center;text-align:center;gap:16px;h3{margin-bottom:24px;}"]);
const pF = t => d.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 21 20",
        ...t,
        children: [d.jsx("path", {
            fill: "url(#icloud-gradient)",
            d: "M12.34 7.315a4.26 4.26 0 0 0-3.707 2.18 2.336 2.336 0 0 0-1.02-.236 2.336 2.336 0 0 0-2.3 1.963 3.217 3.217 0 0 0 1.244 6.181c.135-.001.27-.01.404-.029h8.943c.047.004.094.006.141.007.045-.001.09-.004.135-.007h.214v-.016a2.99 2.99 0 0 0 1.887-.988c.487-.55.757-1.261.757-1.998v-.006a3.017 3.017 0 0 0-.69-1.915 2.992 2.992 0 0 0-1.748-1.034 4.26 4.26 0 0 0-4.26-4.102Z"
        }), d.jsx("defs", {
            children: d.jsxs("linearGradient", {
                id: "icloud-gradient",
                x1: 19.086,
                x2: 3.333,
                y1: 14.38,
                y2: 14.163,
                gradientUnits: "userSpaceOnUse",
                children: [d.jsx("stop", {
                    stopColor: "#3E82F4"
                }), d.jsx("stop", {
                    offset: 1,
                    stopColor: "#93DCF7"
                })]
            })
        })]
    }),
    gF = ({
        style: t,
        ...e
    }) => d.jsxs("svg", {
        width: "16",
        height: "14",
        style: t,
        viewBox: "0 0 16 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...e,
        children: [d.jsxs("g", {
            clipPath: "url(#clip0_2115_829)",
            children: [d.jsx("path", {
                d: "M2.34709 12.9404L2.3471 12.9404L2.34565 12.938L1.64031 11.7448L1.64004 11.7444L0.651257 10.0677C0.640723 10.0496 0.630746 10.0314 0.621325 10.0129H4.16461L2.39424 13.0139C2.3775 12.9901 2.36178 12.9656 2.34709 12.9404Z",
                fill: "#0066DA",
                stroke: "#6366F1"
            }), d.jsx("path", {
                d: "M8 4.48713L5.47995 0.215332C5.23253 0.358922 5.02176 0.556358 4.87514 0.80764L0.219931 8.70508C0.076007 8.95094 0.000191627 9.22937 0 9.51277H5.04009L8 4.48713Z",
                fill: "#00AC47"
            }), d.jsx("path", {
                d: "M13.48 13.7847C13.7274 13.6411 13.9382 13.4437 14.0848 13.1924L14.3781 12.6988L15.7801 10.3206C15.9267 10.0693 16.0001 9.79114 16.0001 9.51294H10.9596L12.0321 11.577L13.48 13.7847Z",
                fill: "#EA4335"
            }), d.jsx("path", {
                d: "M8.00003 4.48718L10.5201 0.215385C10.2726 0.0717949 9.98857 0 9.69533 0H6.30472C6.01148 0 5.7274 0.0807692 5.47998 0.215385L8.00003 4.48718Z",
                fill: "#00832D"
            }), d.jsx("path", {
                d: "M10.9599 9.51294H5.04007L2.52002 13.7847C2.76744 13.9283 3.05152 14.0001 3.34476 14.0001H12.6552C12.9484 14.0001 13.2325 13.9194 13.4799 13.7847L10.9599 9.51294Z",
                fill: "#2684FC"
            }), d.jsx("path", {
                d: "M13.4525 4.75636L11.1249 0.80764C10.9782 0.556358 10.7675 0.358922 10.52 0.215332L8 4.48713L10.9599 9.51277H15.9908C15.9908 9.23456 15.9175 8.95636 15.7709 8.70508L13.4525 4.75636Z",
                fill: "#FFBA00"
            })]
        }), d.jsx("defs", {
            children: d.jsx("clipPath", {
                id: "clip0_2115_829",
                children: d.jsx("rect", {
                    width: "16",
                    height: "14",
                    fill: "white"
                })
            })
        })]
    });
async function P$({
    url: t,
    popup: e,
    provider: r
}) {
    return e.location = t, new Promise((n, i) => {
        function s() {
            e == null || e.close(), window.removeEventListener("message", a)
        }

        function a(o) {
            o.data && (o.data.type === "PRIVY_OAUTH_RESPONSE" && o.data.stateCode && o.data.authorizationCode && (n(o.data), s()), o.origin === "https://cdn.apple-cloudkit.com" && o.data.ckSession && (n({
                type: "PRIVY_OAUTH_RESPONSE",
                ckWebAuthToken: o.data.ckSession
            }), s()), o.data.type === "PRIVY_OAUTH_ERROR" && (i(o.data.error), s()))
        }
        window.addEventListener("message", a)
    })
}
async function kAe({
    api: t,
    provider: e,
    stateCode: r,
    codeVerifier: n,
    authorizationCode: i
}) {
    if (!i || !r) throw new J("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");
    if (i === "undefined") throw new J("User denied confirmation during OAuth flow");
    try {
        return (await t.post(Die, {
            authorization_code: i,
            state_code: r,
            code_verifier: n,
            provider: e
        })).access_token
    } catch (s) {
        let a = qt(s);
        throw a.privyErrorCode ? new J(a.message || "Invalid code during OAuth flow.", void 0, a.privyErrorCode) : a.message === "User denied confirmation during OAuth flow" ? new J("Invalid code during oauth flow.", void 0, ee.OAUTH_USER_DENIED) : new J("Invalid code during OAuth flow.", void 0, ee.UNKNOWN_AUTH_ERROR)
    }
}
async function N$({
    api: t,
    provider: e
}) {
    let r = Gy(),
        n = c8(),
        i = await l8(r);
    try {
        return e === "icloud" ? {
            url: (await t.post(Mie, {
                client_type: "web"
            })).url
        } : {
            url: (await t.post(Rie, {
                redirect_to: window.location.href,
                code_challenge: i,
                state_code: n
            })).url,
            codeVerifier: r,
            stateCode: n,
            provider: e
        }
    } catch (s) {
        throw qt(s)
    }
}
const $8 = (t, {
        chainType: e,
        walletIndex: r
    } = {}) => (t == null ? void 0 : t.linkedAccounts.filter(n => !(n.type !== "wallet" || n.walletClientType !== "privy" || r !== void 0 && n.walletIndex !== r || e !== void 0 && n.chainType !== e))) ? ? [],
    mF = async ({
        user: t,
        accessToken: e,
        proxy: r,
        refreshSessionAndUser: n,
        privy: i,
        appConfig: s,
        recoverEmbeddedWallet: a,
        setUser: o,
        walletIndex: c,
        chainType: l,
        recoveryMethod: u,
        recoveryPassword: h,
        recoveryAccessToken: f
    }) => {
        if (c === 0)
            if (s.embeddedWallets.mode === "user-controlled-server-wallets-only") await A3(i, {
                request: {
                    chain_type: l
                }
            });
            else if (l === "ethereum") {
            let m = Sd(t);
            m && await a({
                address: m.address
            }), await r.create({
                accessToken: e,
                solanaAddress: m == null ? void 0 : m.address,
                recoveryMethod: u,
                recoveryPassword: h,
                recoveryAccessToken: f
            })
        } else {
            if (l !== "solana") throw Error("Invalid input to create wallet"); {
                let m = Xa(t);
                m && await a({
                    address: m.address
                }), await r.createSolana({
                    accessToken: e,
                    ethereumAddress: m == null ? void 0 : m.address,
                    recoveryMethod: u,
                    recoveryPassword: h,
                    recoveryAccessToken: f
                })
            }
        } else if (s.embeddedWallets.mode === "user-controlled-server-wallets-only") await A3(i, {
            request: {
                chain_type: l
            }
        });
        else {
            let {
                entropyId: m,
                entropyIdVerifier: y
            } = Sn(t);
            await a(), await r.addWallet({
                accessToken: e,
                entropyId: m,
                entropyIdVerifier: y,
                chainType: l,
                hdWalletIndex: c
            })
        }
        let p = await n(),
            g = $8(p, {
                chainType: l,
                walletIndex: c
            })[0];
        return o(p), {
            user: p,
            account: g
        }
    },
    S8 = () => {
        let {
            getAccessToken: t
        } = $t(), {
            walletProxy: e,
            recoverEmbeddedWallet: r,
            setUser: n,
            refreshSessionAndUser: i,
            privy: s
        } = $e(), a = Gt();
        return {
            create: async ({
                walletIndex: o,
                chainType: c,
                latestUser: l,
                recoveryMethod: u,
                recoveryPassword: h,
                recoveryAccessToken: f
            }) => {
                let p = l;
                p || (p = await i());
                let g = await t();
                if (!p || !g || !e) throw Error("User must be authenticated before creating a Privy wallet");
                return await mF({
                    appConfig: a,
                    user: p,
                    refreshSessionAndUser: i,
                    privy: s,
                    accessToken: g,
                    proxy: e,
                    recoverEmbeddedWallet: r,
                    setUser: n,
                    walletIndex: o,
                    chainType: c,
                    recoveryMethod: u,
                    recoveryPassword: h,
                    recoveryAccessToken: f
                })
            }
        }
    },
    T8 = {
        component: () => {
            let {
                user: t
            } = $t(), {
                closePrivyModal: e,
                isNewUserThisSession: r,
                updateWallets: n
            } = $e(), {
                app: i,
                data: s,
                onUserCloseViaDialogOrKeybindRef: a
            } = Ne(), {
                onSuccess: o,
                onFailure: c,
                callAuthOnSuccessOnClose: l
            } = s.createWallet, u = () => {
                let h = Xa(t) ? ? Sd(t);
                t && h ? (n(), o({
                    user: t,
                    account: h
                })) : c(Error("Failed to create wallet")), e({
                    shouldCallAuthOnSuccess: l
                })
            };
            return v.useEffect(() => {
                let h = setTimeout(u, o8);
                return () => clearTimeout(h)
            }, []), a.current = u, d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    onClose: u
                }), d.jsx(er, {}), d.jsxs(wc, {
                    children: [d.jsx(vd, {
                        fill: "var(--privy-color-accent)",
                        width: "64px",
                        height: "64px"
                    }), d.jsx($r, {
                        title: r ? "Welcome" + (i != null && i.name ? ` to ${i==null?void 0:i.name}` : "") : "All set!",
                        description: r ? "You’ve successfully created an account." : "Your account is secured."
                    })]
                }), d.jsx(nr, {}), d.jsx(ot, {})]
            })
        }
    },
    A4 = z.div.withConfig({
        displayName: "RecoveryContainer",
        componentId: "sc-12b46968-0"
    })(["display:flex;flex-direction:column;gap:12px;padding-top:24px;padding-bottom:24px;"]),
    IAe = z.div.withConfig({
        displayName: "RecoveryExplainerContainer",
        componentId: "sc-12b46968-1"
    })(["padding-bottom:24px;"]);
let O$ = {
    "google-drive": {
        name: "Google Drive",
        component: gF
    },
    icloud: {
        name: "iCloud",
        component: pF
    }
};
const yF = {
    component: () => {
        var $;
        let {
            logout: t
        } = $t(), {
            navigate: e,
            setModalData: r,
            data: n
        } = Ne(), {
            closePrivyModal: i,
            createAnalyticsEvent: s
        } = $e(), {
            execute: a
        } = (() => {
            let {
                client: P,
                walletProxy: N,
                refreshSessionAndUser: R
            } = $e(), {
                data: D
            } = Ne(), {
                getAccessToken: S,
                user: O
            } = $t(), M = yc(), {
                create: U
            } = S8();
            return {
                execute: async ({
                    provider: k,
                    action: F,
                    popup: q,
                    shouldCreateEth: W,
                    shouldCreateSol: K
                }) => {
                    var Y, X;
                    let H, j;
                    if (!P) throw new J("Missing client");

                    function V(ne) {
                        if (!ne && P) throw P.createAnalyticsEvent({
                            eventName: "recovery_oauth_error",
                            payload: {
                                error: "Unable to open recovery OAuth popup",
                                provider: k
                            }
                        }), new J("Recovery OAuth failed")
                    }
                    switch (k) {
                        case "google-drive":
                            {
                                let ne, ae, {
                                    url: ue,
                                    codeVerifier: he,
                                    stateCode: fe
                                } = await N$({
                                    api: P.api,
                                    provider: k
                                });V(ue);
                                try {
                                    let de = await P$({
                                        url: ue,
                                        popup: q,
                                        provider: k
                                    });
                                    if (ne = de.stateCode, ae = de.authorizationCode, ne !== fe) throw P.createAnalyticsEvent({
                                        eventName: "possible_phishing_attempt",
                                        payload: {
                                            provider: k,
                                            storedStateCode: fe ? ? "",
                                            returnedStateCode: ne ? ? ""
                                        }
                                    }), new J("Unexpected auth flow. This may be a phishing attempt.", void 0, ee.OAUTH_UNEXPECTED)
                                } catch (de) {
                                    throw P.createAnalyticsEvent({
                                        eventName: "recovery_oauth_error",
                                        payload: {
                                            error: de.toString(),
                                            provider: k
                                        }
                                    }), new J("Recovery OAuth failed")
                                }[H, j] = await Promise.all([S(), kAe({
                                    api: P.api,
                                    provider: k,
                                    codeVerifier: he,
                                    stateCode: ne,
                                    authorizationCode: ae
                                })]);
                                break
                            }
                        case "icloud":
                            {
                                let {
                                    url: ne
                                } = await N$({
                                    api: P.api,
                                    provider: k
                                });V(ne);
                                let {
                                    ckWebAuthToken: ae
                                } = await P$({
                                    url: ne,
                                    popup: q,
                                    provider: k
                                });j = ae,
                                H = await S()
                            }
                    }
                    if (!N) throw new J("Cannot connect to wallet proxy");
                    if (!H) throw new J("Unable to authorize user");
                    switch (F) {
                        case "recover":
                            {
                                let ne = (Y = D == null ? void 0 : D.recoverWallet) == null ? void 0 : Y.entropyId,
                                    ae = (X = D == null ? void 0 : D.recoverWallet) == null ? void 0 : X.entropyIdVerifier;
                                if (!ne || !ae) throw new J("Recovery OAuth failed");P.createAnalyticsEvent({
                                    eventName: "embedded_wallet_recovery_started",
                                    payload: {
                                        walletAddress: ne,
                                        recoveryMethod: k
                                    }
                                }),
                                await N.recover({
                                    accessToken: H,
                                    entropyId: ne,
                                    entropyIdVerifier: ae,
                                    recoveryAccessToken: j
                                }),
                                P.createAnalyticsEvent({
                                    eventName: "embedded_wallet_recovery_completed",
                                    payload: {
                                        walletAddress: ne,
                                        recoveryMethod: k
                                    }
                                });
                                break
                            }
                        case "create-wallet":
                            {
                                let ne;
                                if (P.createAnalyticsEvent({
                                        eventName: "embedded_wallet_creation_started"
                                    }), W && K) ne = await U({
                                    recoveryMethod: k,
                                    recoveryAccessToken: j,
                                    chainType: "ethereum",
                                    walletIndex: 0,
                                    latestUser: O
                                }),
                                ne = await U({
                                    chainType: "solana",
                                    walletIndex: 0,
                                    latestUser: ne.user
                                });
                                else if (K) ne = await U({
                                    recoveryMethod: k,
                                    recoveryAccessToken: j,
                                    chainType: "solana",
                                    walletIndex: 0,
                                    latestUser: O
                                });
                                else {
                                    if (!W) throw Error("Invalid args to create wallet");
                                    ne = await U({
                                        recoveryMethod: k,
                                        recoveryAccessToken: j,
                                        chainType: "ethereum",
                                        walletIndex: 0,
                                        latestUser: O
                                    })
                                }
                                if (!ne) throw M("createWallet", "onError", ee.UNKNOWN_EMBEDDED_WALLET_ERROR), Error("Failed to create wallet");P.createAnalyticsEvent({
                                    eventName: "embedded_wallet_creation_completed",
                                    payload: {
                                        walletAddress: ne.account.address
                                    }
                                }),
                                M("createWallet", "onSuccess", {
                                    wallet: ne.account
                                });
                                break
                            }
                        case "set-recovery":
                            {
                                let ne = Rs(O);
                                if (!ne) throw M("setWalletRecovery", "onError", ee.EMBEDDED_WALLET_NOT_FOUND), Error("Embedded wallet not found");P.createAnalyticsEvent({
                                    eventName: "embedded_wallet_set_recovery_started",
                                    payload: {
                                        walletAddress: ne.address,
                                        existingRecoveryMethod: ne.recoveryMethod,
                                        targetRecoveryMethod: k
                                    }
                                });
                                let {
                                    entropyId: ae,
                                    entropyIdVerifier: ue
                                } = Sn(O);await N.setRecovery({
                                    accessToken: H,
                                    entropyId: ae,
                                    entropyIdVerifier: ue,
                                    recoveryMethod: k,
                                    recoveryAccessToken: j
                                });
                                let he = Rs(await R());
                                if (!he) throw M("createWallet", "onError", ee.UNKNOWN_EMBEDDED_WALLET_ERROR), Error("Failed to set recovery on wallet");P.createAnalyticsEvent({
                                    eventName: "embedded_wallet_set_recovery_completed",
                                    payload: {
                                        walletAddress: ne.address,
                                        existingRecoveryMethod: ne.recoveryMethod,
                                        targetRecoveryMethod: k
                                    }
                                }),
                                M("setWalletRecovery", "onSuccess", {
                                    method: k,
                                    wallet: he
                                });
                                break
                            }
                        default:
                            throw new J("Unsupported recovery action")
                    }
                }
            }
        })(), [o, c] = v.useState(!1), {
            provider: l,
            action: u,
            isInAccountCreateFlow: h,
            shouldCreateEth: f,
            shouldCreateSol: p
        } = n == null ? void 0 : n.recoveryOAuthStatus, [g, m] = v.useState(void 0), [y, w] = v.useState(u === "create-wallet");
        if (l === "user-passcode") throw Error("RecoveryOAuthScreen should never be called with a wallet that specifies recoveryMethod: `user-passcode`");
        let x = O$[l].name,
            E = O$[l].component,
            _ = ($ = n == null ? void 0 : n.recoverWallet) == null ? void 0 : $.onCompleteNavigateTo,
            b = new di(async (P = "create-wallet") => (w(!0), new Promise((N, R) => {
                setTimeout(async () => {
                    try {
                        let D = window.open();
                        await a({
                            provider: l,
                            action: P,
                            popup: D,
                            shouldCreateEth: f,
                            shouldCreateSol: p
                        }), c(!0), N()
                    } catch {
                        m({
                            message: `${P==="recover"?"Recovery":"Back up"} with ${x} unsuccessful`,
                            detail: u === "recover" ? `Please verify that you are selecting the ${x} account associated with your backup.` : "",
                            retryable: !0
                        }), R()
                    }
                }, 0)
            })));
        v.useEffect(() => {
            u !== "recover" && b.execute(h ? "create-wallet" : "set-recovery")
        }, []), v.useEffect(() => {
            if (!o) return;
            let P = setTimeout(() => {
                h ? (r({
                    createWallet: {
                        onSuccess: () => {},
                        onFailure: N => {
                            s({
                                eventName: "embedded_wallet_creation_failure_logout",
                                payload: {
                                    error: N,
                                    screen: "RecoveryOAuthScreen"
                                }
                            }), t()
                        },
                        callAuthOnSuccessOnClose: !0,
                        shouldCreateEth: !1,
                        shouldCreateSol: !1
                    }
                }), e(T8)) : i({
                    shouldCallAuthOnSuccess: !1
                })
            }, Ir);
            return () => clearTimeout(P)
        }, [o]);
        let A = v.useCallback(async () => {
                await b.execute("recover"), _ ? e(_) : c(!0)
            }, []),
            I = l === "google-drive" ? "Google Drive" : "Apple iCloud",
            T = o && `Successfully ${u==="recover"?"recovered":"backed up"} with ${I}.` || g && g.message || `${u==="recover"?"Recovering":"Backing up"} with ${I}...`,
            C = g ? g.detail : "";
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {}), y ? d.jsx(d.Fragment, {
                children: d.jsxs(A4, {
                    children: [d.jsx($r, {
                        title: T,
                        icon: d.jsx(E, {
                            style: {
                                width: "38px",
                                height: "38px"
                            }
                        }),
                        description: C
                    }), g && (g != null && g.retryable) ? d.jsx(Qe, {
                        onClick: () => {
                            p4(), m(void 0), u === "create-wallet" ? b.execute("create-wallet") : A()
                        },
                        disabled: !o && !(g != null && g.retryable),
                        children: "Try again"
                    }) : null]
                })
            }) : d.jsxs(A4, {
                children: [d.jsx($r, {
                    title: "Confirm it's really you",
                    icon: d.jsx(E, {
                        style: {
                            height: 42,
                            width: 48
                        }
                    }),
                    description: `To confirm your identity, please log in to ${I} where your account is backed up.`
                }), d.jsxs(Qe, {
                    onClick: A,
                    children: ["Confirm with ", I]
                })]
            }), d.jsx(ot, {})]
        })
    }
};
let Tv = z.div.withConfig({
        displayName: "IconContainer",
        componentId: "sc-ccfae04f-0"
    })(["width:24px;height:24px;display:flex;justify-content:center;align-items:center;"]),
    $Ae = {
        "google-drive": "Google Drive",
        icloud: "iCloud",
        "user-passcode": "password",
        privy: "Privy",
        "privy-v2": "Privy"
    },
    SAe = ({
        onClose: t
    }) => d.jsxs(IAe, {
        children: [d.jsx($r, {
            title: "Why do I need to secure my account?",
            icon: d.jsx(Ql, {
                width: 48
            }),
            description: d.jsxs(d.Fragment, {
                children: [d.jsx("p", {
                    children: "Your app uses cryptography to secure your account. App secrets are split and encrypted so only you can access them."
                }), d.jsx("p", {
                    children: "To use this app on new devices, secure account secrets using a password, your Google or your Apple account. It’s important you don’t lose access to the method you choose."
                })]
            })
        }), d.jsx(Qe, {
            onClick: t,
            children: "Select backup method"
        })]
    });
const k4 = {
    component: () => {
        let [t, e] = v.useState(!1), {
            navigate: r,
            lastScreen: n,
            navigateBack: i,
            setModalData: s,
            data: a,
            onUserCloseViaDialogOrKeybindRef: o
        } = Ne(), {
            user: c
        } = $t(), {
            embeddedWallets: l
        } = Gt(), {
            closePrivyModal: u
        } = $e(), h = Rs(c), f = h === null, {
            isInAccountCreateFlow: p,
            isResettingPassword: g,
            shouldCreateEth: m,
            shouldCreateSol: y
        } = a.recoverySelection, w = h && h.recoveryMethod !== "privy", x = w ? d.jsxs("span", {
            children: ["Your account is currently secured using", " ", d.jsx("strong", {
                children: $Ae[(h == null ? void 0 : h.recoveryMethod) || "user-passcode"]
            }), "."]
        }) : "Select a method for logging in on new devices and recovering your account.";

        function E(b) {
            s({
                recoveryOAuthStatus: {
                    provider: b,
                    action: f ? "create-wallet" : "set-recovery",
                    isInAccountCreateFlow: p,
                    shouldCreateEth: m,
                    shouldCreateSol: y
                }
            }), r(yF)
        }

        function _() {
            var b, A;
            (b = a == null ? void 0 : a.setWalletPassword) == null || b.onFailure(Error("User exited set recovery flow")), u({
                shouldCallAuthOnSuccess: ((A = a == null ? void 0 : a.setWalletPassword) == null ? void 0 : A.callAuthOnSuccessOnClose) ? ? !1
            })
        }
        return o.current = _, d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                onClose: _,
                backFn: t ? () => e(!1) : n ? i : void 0,
                infoFn: n || t ? void 0 : () => e(!0)
            }, "header"), t ? d.jsx(SAe, {
                onClose: () => e(!1)
            }) : d.jsxs(d.Fragment, {
                children: [d.jsx($r, {
                    title: w ? "Update backup method" : "Secure your account",
                    icon: d.jsx(FL, {
                        width: 48
                    }),
                    description: x
                }), d.jsx(A4, {
                    children: l.userOwnedRecoveryOptions.filter(b => !["icloud", "google-drive"].includes((h == null ? void 0 : h.recoveryMethod) || "") || b !== (h == null ? void 0 : h.recoveryMethod)).sort().map(b => {
                        switch (b) {
                            case "google-drive":
                                return d.jsxs(Pr, {
                                    onClick: () => E("google-drive"),
                                    children: [d.jsx(Tv, {
                                        children: d.jsx(gF, {
                                            style: {
                                                width: 18
                                            }
                                        })
                                    }), "Back up to Google Drive"]
                                }, b);
                            case "icloud":
                                return d.jsxs(Pr, {
                                    onClick: () => E("icloud"),
                                    children: [d.jsx(Tv, {
                                        children: d.jsx(pF, {
                                            style: {
                                                width: 24
                                            }
                                        })
                                    }), "Back up to Apple iCloud"]
                                }, b);
                            case "user-passcode":
                                return d.jsxs(Pr, {
                                    onClick: () => {
                                        r(dB({
                                            isCreatingWallet: f,
                                            skipSplashScreen: !0
                                        }))
                                    },
                                    children: [d.jsx(Tv, {
                                        children: d.jsx(v_e, {
                                            style: {
                                                width: 18
                                            }
                                        })
                                    }), g ? "Reset your" : "Set a", " password"]
                                }, b);
                            default:
                                return null
                        }
                    })
                })]
            }), d.jsx(ot, {})]
        })
    }
};
let TAe = pi(["font-size:14px;font-style:normal;font-weight:400;line-height:20px;letter-spacing:-0.008px;text-align:left;transition:color 0.1s ease-in;"]);
const wF = z.span.withConfig({
        displayName: "StatusText",
        componentId: "sc-acac4b9-0"
    })(["", " transition:color 0.1s ease-in;color:", ";text-transform:", ";&[aria-hidden='true']{visibility:hidden;}"], TAe, ({
        error: t
    }) => t ? "var(--privy-color-error)" : "var(--privy-color-foreground-3)", ({
        error: t
    }) => t ? "" : "capitalize"),
    rw = z.div.withConfig({
        displayName: "EmbeddedWalletScreenContainer",
        componentId: "sc-acac4b9-1"
    })(["display:flex;flex-direction:column;justify-content:center;flex-grow:1;"]),
    nw = z(Qe).withConfig({
        displayName: "NoAnimationPrimaryButton",
        componentId: "sc-acac4b9-2"
    })(["", ""], ({
        $hideAnimations: t
    }) => t && pi(["&&{transition:none;}"]));
let bF = pi(["&&{width:100%;border-width:1px;border-radius:var(--privy-border-radius-md);border-color:var(--privy-color-foreground-3);background:var(--privy-color-background);color:var(--privy-color-foreground);padding:12px;font-size:16px;font-style:normal;font-weight:300;line-height:22px;}"]);
const P8 = z.input.withConfig({
        displayName: "PasswordInput",
        componentId: "sc-acac4b9-3"
    })(["", " &::placeholder{color:var(--privy-color-foreground-3);font-style:italic;font-size:14px;}overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"], bF),
    PAe = z.div.withConfig({
        displayName: "PasswordDisplay",
        componentId: "sc-acac4b9-4"
    })(["", ""], bF),
    iw = z.div.withConfig({
        displayName: "PasswordContainer",
        componentId: "sc-acac4b9-5"
    })(["position:relative;width:100%;display:flex;align-items:center;justify-content:", ";"], ({
        centered: t
    }) => t ? "center" : "space-between"),
    sw = z.div.withConfig({
        displayName: "Header",
        componentId: "sc-acac4b9-6"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;margin:32px 0;gap:4px;& h3{font-size:18px;font-style:normal;font-weight:600;line-height:24px;}& p{max-width:300px;font-size:14px;font-style:normal;font-weight:400;line-height:20px;}"]),
    N8 = z.div.withConfig({
        displayName: "Details",
        componentId: "sc-acac4b9-7"
    })(["display:flex;flex-direction:column;gap:10px;padding-bottom:1rem;"]),
    I4 = z.div.withConfig({
        displayName: "DetailItem",
        componentId: "sc-acac4b9-8"
    })(["display:flex;text-align:left;align-items:center;gap:8px;max-width:300px;font-size:14px;font-style:normal;font-weight:400;line-height:20px;letter-spacing:-0.008px;margin:0 8px;color:var(--privy-color-foreground-2);> :first-child{min-width:24px;}"]),
    j$ = z(Jy).withConfig({
        displayName: "ExportButton",
        componentId: "sc-acac4b9-10"
    })(["display:flex;flex:1;gap:4px;justify-content:center;&&{background:var(--privy-color-background);border-radius:var(--privy-border-radius-md);border-color:var(--privy-color-foreground-3);border-width:1px;}"]),
    aw = z.div.withConfig({
        displayName: "InputRightIcons",
        componentId: "sc-acac4b9-11"
    })(["position:absolute;right:0.5rem;display:flex;flex-direction:row;justify-content:space-around;align-items:center;"]),
    NAe = z(z7e).withConfig({
        displayName: "RegenerateIcon",
        componentId: "sc-acac4b9-12"
    })(["height:1.25rem;width:1.25rem;stroke:var(--privy-color-accent);cursor:pointer;:active{stroke:var(--privy-color-accent-light);}"]),
    ow = z(s_e).withConfig({
        displayName: "HiddenIcon",
        componentId: "sc-acac4b9-13"
    })(["height:1.25rem;width:1.25rem;stroke:var(--privy-color-accent);cursor:pointer;:active{stroke:var(--privy-color-accent-light);}"]),
    cw = z(o_e).withConfig({
        displayName: "ShownIcon",
        componentId: "sc-acac4b9-14"
    })(["height:1.25rem;width:1.25rem;stroke:var(--privy-color-accent);cursor:pointer;:active{stroke:var(--privy-color-accent-light);}"]),
    OAe = z.progress.withConfig({
        displayName: "StrengthMeter",
        componentId: "sc-acac4b9-15"
    })(["height:4px;width:100%;margin:8px 0;::-webkit-progress-bar{border-radius:8px;background:var(--privy-color-foreground-4);}::-webkit-progress-value{border-radius:8px;transition:all 0.1s ease-out;background:", ";}"], ({
        label: t
    }) => (t === "Strong" ? "#78dca6" : t === "Medium" && "var(--privy-color-warn)") || "var(--privy-color-error)"),
    jAe = ({
        buttonHideAnimations: t,
        buttonLoading: e,
        password: r,
        onSubmit: n,
        onBack: i
    }) => {
        let [s, a] = v.useState(!0), [o, c] = v.useState(!1), [l, u] = v.useState(""), h = r === l;
        return v.useEffect(() => {
            l && !o && c(!0)
        }, [l]), d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                closeable: !1,
                backFn: i
            }), d.jsx(er, {}), d.jsxs(rw, {
                children: [d.jsxs(sw, {
                    children: [d.jsx(yo, {
                        height: 48,
                        width: 48,
                        stroke: "var(--privy-color-background)",
                        fill: "var(--privy-color-accent)"
                    }), d.jsx("h3", {
                        style: {
                            color: "var(--privy-color-foreground)"
                        },
                        children: "Confirm your password"
                    }), d.jsx("p", {
                        style: {
                            color: "var(--privy-color-foreground-2)"
                        },
                        children: "Please re-enter your password below to continue."
                    })]
                }), d.jsxs(iw, {
                    children: [d.jsx(P8, {
                        value: l,
                        onChange: f => u(f.target.value),
                        onKeyUp: f => {
                            f.key === "Enter" && n()
                        },
                        onBlur: () => c(!0),
                        placeholder: "confirm your password",
                        type: s ? "password" : "text",
                        style: {
                            paddingRight: "2.3rem"
                        }
                    }), d.jsx(aw, {
                        style: {
                            right: "0.75rem"
                        },
                        children: s ? d.jsx(ow, {
                            onClick: () => a(!1)
                        }) : d.jsx(cw, {
                            onClick: () => a(!0)
                        })
                    })]
                }), d.jsx(wF, {
                    "aria-hidden": !o || h,
                    error: !0,
                    children: "Passwords do not match"
                })]
            }), d.jsx(nw, {
                onClick: n,
                loading: e,
                disabled: !h,
                $hideAnimations: t,
                children: "Continue"
            }), d.jsx(nr, {}), d.jsx(ot, {})]
        })
    },
    vF = ({
        className: t,
        checked: e,
        color: r = "var(--privy-color-accent)",
        ...n
    }) => d.jsx("label", {
        children: d.jsxs(RAe, {
            className: t,
            children: [d.jsx(EF, {
                checked: e,
                ...n
            }), d.jsx(MAe, {
                color: r,
                checked: e,
                children: d.jsx(xF, {
                    viewBox: "0 0 24 24",
                    children: d.jsx("polyline", {
                        points: "20 6 9 17 4 12"
                    })
                })
            })]
        })
    });
let RAe = z.div.withConfig({
        displayName: "CheckboxContainer",
        componentId: "sc-db51b935-1"
    })(["display:inline-block;vertical-align:middle;"]),
    xF = z.svg.withConfig({
        displayName: "Icon",
        componentId: "sc-db51b935-2"
    })(["fill:none;stroke:white;stroke-width:3px;"]),
    EF = z.input.attrs({
        type: "checkbox"
    }).withConfig({
        displayName: "HiddenCheckbox",
        componentId: "sc-db51b935-3"
    })(["border:0;clip:rect(0 0 0 0);clippath:inset(50%);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px;"]),
    MAe = z.div.withConfig({
        displayName: "StyledCheckbox",
        componentId: "sc-db51b935-4"
    })(["display:inline-block;width:18px;height:18px;transition:all 150ms;cursor:pointer;border-color:", ";border-radius:3px;background:", ";&&{border-width:1px;}", ":focus + &{box-shadow:0 0 0 1px ", ";}", "{visibility:", ";}"], t => t.color, t => t.checked ? t.color : "var(--privy-color-background)", EF, t => t.color, xF, t => t.checked ? "visible" : "hidden");
const DAe = ({
    buttonHideAnimations: t,
    buttonLoading: e,
    onSubmit: r,
    onBack: n,
    config: i
}) => {
    let [s, a] = v.useState(!1);
    return d.jsxs(d.Fragment, {
        children: [d.jsx(Pe, {
            closeable: !1,
            backFn: n
        }), d.jsx(er, {}), d.jsxs(rw, {
            children: [d.jsxs(sw, {
                children: [d.jsx(yo, {
                    height: 48,
                    width: 48,
                    stroke: "var(--privy-color-background)",
                    fill: "var(--privy-color-error)"
                }), d.jsx("h3", {
                    style: {
                        color: "var(--privy-color-foreground)"
                    },
                    children: "Confirm you have saved"
                }), d.jsx("p", {
                    style: {
                        color: "var(--privy-color-foreground-2)"
                    },
                    children: "Losing access to your password means you will lose access to your account."
                })]
            }), d.jsx(N8, {
                children: d.jsxs(I4, {
                    style: {
                        color: "var(--privy-color-error)",
                        cursor: "pointer"
                    },
                    onClick: o => {
                        o.preventDefault(), a(c => !c)
                    },
                    children: [d.jsx(vF, {
                        color: "var(--privy-color-error)",
                        readOnly: !0,
                        checked: s
                    }), d.jsx(d.Fragment, {
                        children: "I understand that if I lose my password and device, I will lose access to my account and my assets."
                    })]
                })
            })]
        }), d.jsxs(LAe, {
            children: [i.initiatedBy === "user" && d.jsx(po, {
                onClick: i.onCancel,
                disabled: e,
                children: "Cancel"
            }), d.jsx(nw, {
                onClick: r,
                loading: e,
                $hideAnimations: t,
                disabled: !s,
                children: "Set Password"
            })]
        }), d.jsx(nr, {}), d.jsx(ot, {})]
    })
};
let LAe = z.div.withConfig({
        displayName: "ButtonsContainer",
        componentId: "sc-d1659c5f-0"
    })(["display:flex;gap:10px;"]),
    UAe = /[a-z]/,
    FAe = /[A-Z]/,
    BAe = /[0-9]/,
    _F = "!@#$%^&*()\\-_+.",
    CF = `a-zA-Z0-9${_F}`,
    WAe = RegExp(`[${_F}]`),
    zAe = RegExp(`[${CF}]`);
const qAe = RegExp(`^[${CF}]{6,}$`),
    AF = () => k7e(4, $7e);

function HAe(t) {
    return t > .9 ? "Strong" : t > .5 ? "Medium" : "Weak"
}

function VAe(t = "") {
    return (.3 * function(e) {
        if (e.length < 8) return 0;
        let r = 0;
        return UAe.test(e) && (r += 1), FAe.test(e) && (r += 1), BAe.test(e) && (r += 1), WAe.test(e) && (r += 1), Math.max(0, Math.min(1, r / 3))
    }(t) + v7e(t) / 95) / 2
}
const GAe = ({
    buttonHideAnimations: t,
    buttonLoading: e,
    password: r = "",
    config: n,
    isResettingPassword: i,
    onSubmit: s,
    onClose: a,
    onBack: o,
    onPasswordChange: c,
    onPasswordGenerate: l
}) => {
    let [u, h] = v.useState(!1), [f, p] = v.useState(!1);
    v.useEffect(() => {
        r && !f && p(!0)
    }, [r]);
    let g = v.useMemo(() => f ? 6 > ((r == null ? void 0 : r.length) || 0) ? "Password must be at least 6 characters" : qAe.test(r || "") ? null : `Invalid characters used ( ${((w="")=>[...new Set(w.split("").filter(x=>!zAe.test(x)).map(x=>x.replace(" ","SPACE")))])(r).join(" ")} )` : null, [r, f]),
        m = v.useMemo(() => g ? {
            value: 0,
            label: "Weak"
        } : function(w = "") {
            let x = VAe(w);
            return {
                value: x,
                label: HAe(x)
            }
        }(r), [r, g]),
        y = v.useMemo(() => !(r != null && r.length) || !!g, [g, r]);
    return d.jsxs(d.Fragment, {
        children: [d.jsx(Pe, {
            onClose: a,
            closeable: n.initiatedBy === "user",
            backFn: o
        }), d.jsx(er, {}), d.jsxs(rw, {
            children: [d.jsxs(sw, {
                children: [d.jsx(h_e, {
                    height: 48,
                    width: 48,
                    stroke: "var(--privy-color-accent)"
                }), d.jsxs("h3", {
                    style: {
                        color: "var(--privy-color-foreground)"
                    },
                    children: [i ? "Reset" : "Set", " your password"]
                }), d.jsx("p", {
                    style: {
                        color: "var(--privy-color-foreground-2)"
                    },
                    children: "Select a strong, memorable password to secure your account."
                })]
            }), d.jsxs(iw, {
                children: [d.jsx(P8, {
                    value: r,
                    onChange: w => c(w.target.value),
                    onKeyUp: w => {
                        w.key === "Enter" && s()
                    },
                    placeholder: "enter or generate a strong password",
                    type: u ? "password" : "text",
                    style: {
                        paddingRight: "3.8rem"
                    }
                }), d.jsxs(aw, {
                    style: {
                        width: "3.5rem"
                    },
                    children: [u ? d.jsx(ow, {
                        onClick: () => h(!1)
                    }) : d.jsx(cw, {
                        onClick: () => h(!0)
                    }), d.jsx(NAe, {
                        onClick: l
                    })]
                })]
            }), d.jsx(OAe, {
                value: m.value === 0 ? .01 : m.value,
                label: m.label
            }), d.jsx(wF, {
                error: !!g,
                children: g || `Password Strength: ${f?m.label:"--"}`
            }), d.jsxs(YAe, {
                children: [d.jsx(KAe, {
                    children: d.jsxs(N8, {
                        children: [d.jsxs(I4, {
                            children: [d.jsx(vd, {
                                width: 24,
                                height: 24,
                                fill: "var(--privy-color-accent)"
                            }), "This password is used to secure your account."]
                        }), d.jsxs(I4, {
                            children: [d.jsx(vd, {
                                width: 24,
                                height: 24,
                                fill: "var(--privy-color-accent)"
                            }), "Use it to log in on a new environment, like another browser or device."]
                        })]
                    })
                }), d.jsx(nw, {
                    onClick: s,
                    loading: e,
                    disabled: y,
                    $hideAnimations: t,
                    children: "Continue"
                })]
            })]
        }), d.jsx(nr, {}), d.jsx(ot, {})]
    })
};
let KAe = z(N8).withConfig({
        displayName: "DetailsContainer",
        componentId: "sc-2da5fe90-0"
    })(["flex:1;padding-top:1rem;"]),
    YAe = z.div.withConfig({
        displayName: "LowerContainer",
        componentId: "sc-2da5fe90-1"
    })(["display:flex;flex-direction:column;height:100%;"]);
const ZAe = ({
    buttonHideAnimations: t,
    buttonLoading: e,
    appName: r,
    password: n,
    onSubmit: i,
    onBack: s
}) => {
    let [a, o] = v.useState(!1), [c, l] = v.useState(!0), u = v.useCallback(() => {
        o(!0), n && navigator.clipboard.writeText(n)
    }, [n]), h = v.useCallback(() => {
        let f = document.createElement("a"),
            p = r.toLowerCase().replace(/[^a-z\s]/g, "").replace(/\s/g, "-"),
            g = new Blob([JAe(r, n)], {
                type: "text/plain"
            }),
            m = URL.createObjectURL(g);
        f.href = m, f.target = "_blank", f.download = `${p}-privy-wallet-recovery.txt`, document.body.appendChild(f), f.click(), setTimeout(() => {
            f.remove(), URL.revokeObjectURL(m)
        }, 5e3)
    }, [n]);
    return d.jsxs(d.Fragment, {
        children: [d.jsx(Pe, {
            backFn: s,
            closeable: !1
        }), d.jsx(er, {}), d.jsxs(rw, {
            children: [d.jsxs(sw, {
                children: [d.jsx(yo, {
                    height: 48,
                    width: 48,
                    stroke: "var(--privy-color-background)",
                    fill: "var(--privy-color-accent)"
                }), d.jsx("h3", {
                    style: {
                        color: "var(--privy-color-foreground)"
                    },
                    children: "Save your password"
                }), d.jsx("p", {
                    style: {
                        color: "var(--privy-color-foreground-2)"
                    },
                    children: "For your security, this password cannot be reset, so keep it somewhere safe."
                })]
            }), d.jsxs(iw, {
                centered: !0,
                children: [d.jsx(PAe, {
                    children: c ? "•".repeat(n.length) : n
                }), d.jsx(aw, {
                    style: {
                        right: "0.75rem"
                    },
                    children: c ? d.jsx(ow, {
                        onClick: () => l(!1)
                    }) : d.jsx(cw, {
                        onClick: () => l(!0)
                    })
                })]
            }), d.jsxs("div", {
                style: {
                    display: "flex",
                    margin: "12px 0",
                    gap: "12px"
                },
                children: [d.jsx(j$, {
                    onClick: u,
                    children: d.jsxs(d.Fragment, a ? {
                        children: [d.jsx(DL, {
                            style: {
                                width: 24,
                                height: 24
                            },
                            stroke: "var(--privy-color-accent)"
                        }), "Copied"]
                    } : {
                        children: [d.jsx(n_e, {
                            style: {
                                width: 24,
                                height: 24
                            },
                            stroke: "var(--privy-color-accent)"
                        }), "Copy"]
                    })
                }), d.jsxs(j$, {
                    onClick: h,
                    children: [d.jsx(B7e, {
                        style: {
                            width: 24,
                            height: 24
                        },
                        stroke: "var(--privy-color-accent)"
                    }), "Download"]
                })]
            })]
        }), d.jsx(nw, {
            onClick: i,
            loading: e,
            $hideAnimations: t,
            children: "Continue"
        }), d.jsx(nr, {}), d.jsx(ot, {})]
    })
};
let JAe = (t, e) => `Your wallet recovery password for ${t} is

${e}

You will need this password to access your ${t} wallet on a new device. Please keep it somewhere safe.`;
const QAe = ({
    error: t,
    onClose: e
}) => d.jsxs(d.Fragment, {
    children: [d.jsx(Pe, {
        closeable: !1
    }), d.jsx(er, {}), d.jsxs(wc, t ? {
        children: [d.jsx(zy, {
            fill: "var(--privy-color-error)",
            width: "64px",
            height: "64px"
        }), d.jsx($r, {
            title: "Something went wrong",
            description: t
        })]
    } : {
        children: [d.jsx(vd, {
            fill: "var(--privy-color-success)",
            width: "64px",
            height: "64px"
        }), d.jsx($r, {
            title: "Success"
        })]
    }), d.jsx(Qe, {
        onClick: e,
        children: "Close"
    }), d.jsx(nr, {}), d.jsx(ot, {})]
});
let XAe = (t, e) => {
    switch (t) {
        case "creating":
            return e === "back" ? t : "saving";
        case "saving":
            return e === "back" ? "creating" : "confirming";
        case "confirming":
            return e === "back" ? "saving" : "finalizing";
        case "finalizing":
            return e === "back" ? "confirming" : "done";
        default:
            return t
    }
};
const kF = ({
    onSubmit: t,
    ...e
}) => {
    let {
        lastScreen: r,
        navigate: n
    } = Ne(), {
        send: i,
        state: s
    } = (() => {
        let [l, u] = v.useReducer(XAe, "creating");
        return {
            send: u,
            state: l
        }
    })(), a = v.useCallback(async () => {
        s === "finalizing" && await t(), i("next")
    }, [s, i, t]);
    v.useEffect(() => {
        let l;
        return s === "done" && e.config.initiatedBy === "automatic" && (l = setTimeout(() => {
            var u;
            return (u = e.onClose) == null ? void 0 : u.call(e)
        }, Ir)), () => {
            l && clearTimeout(l)
        }
    }, [s, e.config.initiatedBy, e.onClose]);
    let o = v.useCallback(() => {
            i("back")
        }, [i]),
        c = v.useCallback(() => {
            n(k4)
        }, [r, n]);
    return s === "creating" ? d.jsx(GAe, { ...e,
        onSubmit: a,
        onBack: r === k4 ? c : void 0
    }) : s === "saving" ? d.jsx(ZAe, { ...e,
        onSubmit: a,
        onBack: o
    }) : s === "confirming" ? d.jsx(jAe, { ...e,
        onSubmit: a,
        onBack: o
    }) : s === "finalizing" ? d.jsx(DAe, { ...e,
        onSubmit: a,
        onBack: o
    }) : s === "done" ? d.jsx(QAe, { ...e,
        onSubmit: a
    }) : null
};
let eke = {
    apple_oauth: "apple",
    custom_auth: "custom",
    discord_oauth: "discord",
    email: "email",
    farcaster: "farcaster",
    github_oauth: "github",
    google_oauth: "google",
    instagram_oauth: "instagram",
    linkedin_oauth: "linkedin",
    passkey: "passkey",
    phone: "sms",
    spotify_oauth: "spotify",
    telegram: "telegram",
    tiktok_oauth: "tiktok",
    line_oauth: "line",
    twitter_oauth: "twitter",
    wallet: "siwe",
    smart_wallet: "siwe",
    cross_app: "privy:"
};
const lw = t => {
    let e = eke[t];
    return t === "wallet" || t === "phone" ? {
        displayName: t,
        loginMethod: e
    } : {
        displayName: e,
        loginMethod: e
    }
};
let IF = v.createContext({});
const tke = ({
    children: t
}) => {
    let e = Gt(),
        [r, n] = v.useState({});
    return Wd("login", {
        onComplete: ({
            loginAccount: i
        }) => {
            i && i.type !== "passkey" && i.type !== "cross_app" && (i.type !== "wallet" || i.walletClientType !== "privy") && (rt.put(R$(e.id), i.type), i.type === "wallet" ? (rt.put(Pv(e.id), i.walletClientType), rt.put(Nv(e.id), i.chainType), n({
                accountType: i.type,
                walletClientType: i.walletClientType,
                chainType: i.chainType
            })) : (rt.del(Pv(e.id)), rt.del(Nv(e.id)), n({
                accountType: i.type
            })))
        }
    }), v.useEffect(() => {
        if (!e.id) return;
        let i = rt.get(R$(e.id)),
            s = rt.get(Pv(e.id)),
            a = rt.get(Nv(e.id));
        i && n(i === "wallet" ? {
            accountType: i,
            walletClientType: s,
            chainType: a
        } : {
            accountType: i
        })
    }, [e.id]), d.jsx(IF.Provider, {
        value: r,
        children: t
    })
};
let R$ = t => `privy:${t}:recent-login-method`,
    Pv = t => `privy:${t}:recent-login-wallet-client`,
    Nv = t => `privy:${t}:recent-login-chain-type`;
const ml = () => v.useContext(IF),
    rke = () => {
        var i;
        let {
            app: t
        } = Ne(), e = (i = t == null ? void 0 : t.appearance) == null ? void 0 : i.logo, r = `${t==null?void 0:t.name} logo`, n = {
            maxHeight: "90px",
            maxWidth: "180px"
        };
        return e ? typeof e == "string" ? d.jsx("img", {
            src: e,
            alt: r,
            style: n
        }) : e.type === "svg" || e.type === "img" ? at.cloneElement(e, {
            alt: r,
            style: n
        }) : (console.warn("`config.appearance.logo` must be a string, or an SVG / IMG element. Nothing will be rendered."), null) : null
    },
    $F = t => {
        let {
            app: e
        } = Ne();
        return e != null && e.appearance.logo ? d.jsx(nke, { ...t,
            children: d.jsx(rke, {})
        }) : null
    },
    nke = z.div.withConfig({
        displayName: "AppLogoContainer",
        componentId: "sc-a206bd44-0"
    })(["display:flex;flex-direction:column;align-items:center;padding:24px 0;flex-grow:1;justify-content:center;"]),
    SF = ({
        name: t,
        logoUrl: e,
        size: r = "38px"
    }) => typeof e == "string" ? d.jsx("img", {
        src: e,
        alt: `${t??"Provider app"} logo`,
        style: {
            width: r,
            height: r,
            maxHeight: "90px",
            maxWidth: "180px",
            borderRadius: "8px"
        }
    }) : d.jsx("span", {}),
    ike = ({
        appId: t
    }) => {
        let [e, r] = v.useState(void 0), {
            startCrossAppAuthFlow: n,
            authenticated: i
        } = $t(), {
            client: s
        } = $e();
        return v.useEffect(() => {
            (async () => s && r(await s.getCrossAppProviderDetails(t)))()
        }, [s]), d.jsx(Pr, {
            onClick: () => n({
                appId: t,
                action: i ? "link" : "login"
            }),
            disabled: !e,
            children: e ? d.jsxs(d.Fragment, {
                children: [d.jsx(SF, {
                    name: e.name,
                    logoUrl: e.icon_url || void 0,
                    size: "24px"
                }), " ", e.name]
            }) : d.jsx(pl, {})
        })
    },
    O8 = (t, e) => !Xa(t) && (e === "all-users" || e === "users-without-wallets" && !ske(t).length);
let ske = t => t.linkedAccounts.filter(e => e.type === "wallet" && e.chainType === "ethereum");
const j8 = (t, e) => !Sd(t) && (e === "all-users" || e === "users-without-wallets" && !ake(t).length);
let ake = t => t.linkedAccounts.filter(e => e.type === "wallet" && e.chainType === "solana");
const yl = (t, e) => O8(t, e.ethereum.createOnLogin) || j8(t, e.solana.createOnLogin),
    TF = z.span.withConfig({
        displayName: "CircleBackground",
        componentId: "sc-c9f33cd-0"
    })(["&&{width:82px;height:82px;border-width:4px;border-style:solid;border-color:", ";background-color:", ";border-radius:50%;display:inline-block;box-sizing:border-box;}"], t => t.color ? ? "var(--privy-color-accent)", t => t.color ? ? "var(--privy-color-accent)"),
    D0 = {
        component: () => {
            let {
                navigate: t,
                app: e,
                setModalData: r,
                data: n
            } = Ne(), {
                getAuthMeta: i,
                client: s
            } = $e();
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {}), d.jsxs(oke, {
                    children: [d.jsx(Fi, {
                        children: d.jsxs("div", {
                            children: [d.jsx(TF, {
                                color: "var(--privy-color-warn-light)"
                            }), d.jsx(Ql, {
                                height: 38,
                                width: 38,
                                strokeWidth: 2,
                                stroke: "var(--privy-color-warn)"
                            })]
                        })
                    }), d.jsxs(cke, {
                        children: [d.jsx("h3", {
                            children: "Account not found"
                        }), d.jsxs("p", {
                            children: ["Please try logging in again or go to ", e.name, " to create an account."]
                        })]
                    }), d.jsx(lc, {}), d.jsx(Qe, {
                        onClick: () => {
                            let a = i();
                            r({ ...n,
                                login: { ...n == null ? void 0 : n.login,
                                    ...a != null && a.disableSignup ? {
                                        disableSignup: !0
                                    } : {}
                                }
                            }), s != null && s.authFlow && (s.authFlow = void 0), t(Xn)
                        },
                        children: "Try logging in again"
                    })]
                })]
            })
        }
    };
let oke = z.div.withConfig({
        displayName: "ConnectContainer",
        componentId: "sc-feca2100-0"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;width:100%;padding-bottom:16px;margin-top:24px;"]),
    cke = z.div.withConfig({
        displayName: "GappedContainer",
        componentId: "sc-feca2100-1"
    })(["display:flex;flex-direction:column;gap:8px;"]);
const R8 = z.span.withConfig({
    displayName: "CircleBorder",
    componentId: "sc-9056b8b8-0"
})(["&&{width:82px;height:82px;border-width:4px;border-style:solid;border-color:", ";border-bottom-color:transparent;border-radius:50%;display:inline-block;box-sizing:border-box;animation:rotation 1.2s linear infinite;transition:border-color 800ms;border-bottom-color:", ";}"], t => t.color ? ? "var(--privy-color-accent)", t => t.color ? ? "var(--privy-color-accent)");

function lke(t) {
    return d.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        ...t,
        children: [d.jsx("circle", {
            cx: "12",
            cy: "12",
            r: "10"
        }), d.jsx("line", {
            x1: "12",
            x2: "12",
            y1: "8",
            y2: "12"
        }), d.jsx("line", {
            x1: "12",
            x2: "12.01",
            y1: "16",
            y2: "16"
        })]
    })
}
let M$ = "0x0000000000000000000000000000000000000000";
const Gu = ({
    originCurrency: t,
    destinationCurrency: e,
    ...r
}) => ({
    tradeType: "EXPECTED_OUTPUT",
    originCurrency: t ? ? M$,
    destinationCurrency: e ? ? M$,
    ...r
});
let PF = "https://api.relay.link",
    NF = "https://api.testnets.relay.link";
const Vp = async ({
        input: t,
        isTestnet: e
    }) => {
        let r = await fetch((e ? NF : PF) + "/quote", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(t)
            }),
            n = await r.json();
        if (!(r.ok || typeof n.message == "string" && n.message.startsWith("Invalid address"))) throw console.error("Relay error:", n), Error(n.message ? ? "Error fetching quote from relay");
        return n
    },
    y1 = t => {
        var r, n;
        let e = (n = (r = t.steps[0]) == null ? void 0 : r.items) == null ? void 0 : n[0];
        if (e) return {
            from: e.data.from,
            to: e.data.to,
            value: Number(e.data.value),
            chainId: Number(e.data.chainId),
            data: e.data.data
        }
    };

function M8({
    transactionHash: t,
    wallet: e,
    isTestnet: r,
    bridgingStatus: n,
    setBridgingStatus: i,
    onSuccess: s,
    onFailure: a
}) {
    v.useEffect(() => {
        if (t && e && n) {
            if (["delayed", "waiting", "pending"].includes(n)) {
                let o = setInterval(async () => {
                    try {
                        let c = await async function({
                            transactionHash: l,
                            isTestnet: u
                        }) {
                            var p;
                            let h = await fetch((u ? NF : PF) + "/requests/v2?hash=" + l),
                                f = await h.json();
                            if (!h.ok) throw "message" in f && typeof f.message == "string" ? Error(f.message) : Error("Error fetching request from relay");
                            return ((p = f.requests.at(0)) == null ? void 0 : p.status) ? ? "pending"
                        }({
                            transactionHash: t,
                            isTestnet: r
                        });
                        i(c)
                    } catch (c) {
                        console.error(c)
                    }
                }, 1e3);
                return () => clearInterval(o)
            }
            n === "success" ? s({
                transactionHash: t,
                wallet: e
            }) : ["refund", "failure"].includes(n) && a({
                error: new OF(t, r)
            })
        }
    }, [n, t, r, e])
}
class OF extends J {
    constructor(e, r) {
        super("We were unable to complete the bridging transaction. Funds will be refunded on your wallet.", void 0, ee.TRANSACTION_FAILURE), this.relayLink = r ? `https://testnets.relay.link/transaction/${e}` : `https://relay.link/transaction/${e}`
    }
}
const jF = ({
        style: t,
        ...e
    }) => d.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: "1.5",
        stroke: "currentColor",
        style: {
            height: "1.5rem",
            width: "1.5rem",
            ...t
        },
        ...e,
        children: d.jsx("path", {
            fillRule: "evenodd",
            d: "M12 1.5a5.25 5.25 0 00-5.25 5.25v3a3 3 0 00-3 3v6.75a3 3 0 003 3h10.5a3 3 0 003-3v-6.75a3 3 0 00-3-3v-3c0-2.9-2.35-5.25-5.25-5.25zm3.75 8.25v-3a3.75 3.75 0 10-7.5 0v3h7.5z",
            clipRule: "evenodd"
        })
    }),
    Sr = {
        component: () => {
            var a, o;
            let {
                navigate: t,
                navigateBack: e,
                data: r,
                lastScreen: n,
                currentScreen: i
            } = Ne(), s = ((a = r == null ? void 0 : r.errorModalData) == null ? void 0 : a.previousScreen) || (n === i ? void 0 : n);
            return d.jsx(L0, {
                error: ((o = r == null ? void 0 : r.errorModalData) == null ? void 0 : o.error) || Error(),
                backFn: () => s ? t(s, !1) : e(),
                onClick: () => t(s || Xn, !1)
            })
        }
    },
    L0 = ({
        error: t,
        backFn: e,
        onClick: r
    }) => {
        let {
            reset: n
        } = qi(), {
            app: i
        } = Ne(), s = ((a, o) => {
            let c = d.jsx(yo, {
                height: 38,
                width: 38,
                stroke: "var(--privy-color-error)"
            });
            if (a instanceof OF) return {
                title: "Transaction failed",
                detail: d.jsxs(d.Fragment, {
                    children: [d.jsx("p", {
                        children: a.message
                    }), d.jsxs("p", {
                        children: ["Check the", " ", d.jsx(hke, {
                            href: a.relayLink,
                            target: "_blank",
                            children: "refund status"
                        }), "."]
                    })]
                }),
                ctaText: "Try again",
                icon: c
            };
            if (a instanceof J) switch (a.privyErrorCode) {
                case ee.CLIENT_REQUEST_TIMEOUT:
                    return {
                        title: "Timed out",
                        detail: a.message,
                        ctaText: "Try again",
                        icon: c
                    };
                case ee.INSUFFICIENT_BALANCE:
                    return {
                        title: "Insufficient balance",
                        detail: a.message,
                        ctaText: "Try again",
                        icon: c
                    };
                case ee.TRANSACTION_FAILURE:
                    return {
                        title: "Transaction failure",
                        detail: a.message,
                        ctaText: "Try again",
                        icon: c
                    };
                default:
                    return {
                        title: "Something went wrong",
                        detail: "Try again later",
                        ctaText: "Try again",
                        icon: c
                    }
            } else {
                if (a instanceof Nr && a.type === "twilio_verification_failed") return {
                    title: "Something went wrong",
                    detail: a.message,
                    ctaText: "Try again",
                    icon: d.jsx(Ca, {
                        height: 38,
                        width: 38,
                        stroke: "var(--privy-color-error)"
                    })
                };
                if (!(a instanceof Qn)) return a instanceof es && a.status && [400, 422].includes(a.status) ? {
                    title: "Something went wrong",
                    detail: a.message,
                    ctaText: "Try again",
                    icon: c
                } : {
                    title: "Something went wrong",
                    detail: "Try again later",
                    ctaText: "Try again",
                    icon: c
                };
                switch (a.privyErrorCode) {
                    case ee.INVALID_CAPTCHA:
                        return {
                            title: "Something went wrong",
                            detail: "Please try again.",
                            ctaText: "Try again",
                            icon: c
                        };
                    case ee.DISALLOWED_LOGIN_METHOD:
                        return {
                            title: "Not allowed",
                            detail: a.message,
                            ctaText: "Try another method",
                            icon: c
                        };
                    case ee.ALLOWLIST_REJECTED:
                        return {
                            title: o.errorTitle || "You don't have access to this app",
                            detail: o.errorDetail || "Have you been invited?",
                            ctaText: o.errorCtaText || "Try another account",
                            icon: d.jsx(jF, {
                                style: {
                                    width: "38px",
                                    height: "38px",
                                    strokeWidth: "1",
                                    stroke: "var(--privy-color-accent)",
                                    fill: "var(--privy-color-accent)"
                                }
                            })
                        };
                    case ee.CAPTCHA_FAILURE:
                        return {
                            title: "Something went wrong",
                            detail: "You did not pass CAPTCHA. Please try again.",
                            ctaText: "Try again",
                            icon: d.jsx("span", {})
                        };
                    case ee.CAPTCHA_TIMEOUT:
                        return {
                            title: "Something went wrong",
                            detail: "Something went wrong! Please try again later.",
                            ctaText: "Try again",
                            icon: d.jsx("span", {})
                        };
                    case ee.LINKED_TO_ANOTHER_USER:
                        return {
                            title: "Authentication failed",
                            detail: "This account has already been linked to another user.",
                            ctaText: "Try again",
                            icon: c
                        };
                    case ee.NOT_SUPPORTED:
                        return {
                            title: "This region is not supported",
                            detail: "SMS authentication from this region is not available",
                            ctaText: "Try another method",
                            icon: c
                        };
                    case ee.TOO_MANY_REQUESTS:
                        return {
                            title: "Request failed",
                            detail: "Too many attempts.",
                            ctaText: "Try again later",
                            icon: c
                        };
                    default:
                        return {
                            title: "Something went wrong",
                            detail: "Try again later",
                            ctaText: "Try again",
                            icon: c
                        }
                }
            }
        })(t, i.allowlistConfig);
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                backFn: e
            }), d.jsxs(dke, {
                children: [d.jsx(Fi, {
                    children: d.jsxs("div", {
                        children: [d.jsx(R8, {
                            color: "var(--privy-color-error)"
                        }), s.icon]
                    })
                }), d.jsxs(uke, {
                    children: [d.jsx("h3", {
                        children: s.title
                    }), typeof s.detail == "string" ? d.jsx("p", {
                        children: s.detail
                    }) : s.detail]
                }), d.jsx(Qe, {
                    color: "var(--privy-color-error)",
                    onClick: () => {
                        t instanceof Qn && (t.privyErrorCode === ee.INVALID_CAPTCHA && n(), t.privyErrorCode === ee.ALLOWLIST_REJECTED && i.allowlistConfig.errorCtaLink) ? window.location.href = i.allowlistConfig.errorCtaLink : r == null || r()
                    },
                    children: s.ctaText
                })]
            })]
        })
    };
let dke = z.div.withConfig({
        displayName: "ConnectContainer",
        componentId: "sc-b0d5228e-0"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;width:100%;padding-bottom:16px;"]),
    uke = z.div.withConfig({
        displayName: "GappedContainer",
        componentId: "sc-b0d5228e-1"
    })(["display:flex;flex-direction:column;gap:8px;"]),
    hke = z.a.withConfig({
        displayName: "Link",
        componentId: "sc-b0d5228e-2"
    })(["color:var(--privy-color-accent) !important;font-weight:600;"]);
const RF = ({
        onTransfer: t,
        isTransferring: e,
        transferSuccess: r
    }) => d.jsx(Qe, { ...r ? {
            success: !0,
            children: "Success!"
        } : {
            warn: !0,
            loading: e,
            onClick: t,
            children: "Transfer and delete account"
        }
    }),
    MF = z.div.withConfig({
        displayName: "ConnectContainer",
        componentId: "sc-3505eb4c-0"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;gap:8px;width:100%;padding-bottom:16px;"]),
    $4 = z.div.withConfig({
        displayName: "GappedContainer",
        componentId: "sc-3505eb4c-1"
    })(["display:flex;flex-direction:column;&& p{font-size:14px;}width:100%;gap:16px;"]),
    DF = z.div.withConfig({
        displayName: "DisclosedAccountContainer",
        componentId: "sc-3505eb4c-2"
    })(["display:flex;cursor:pointer;align-items:center;width:100%;border:1px solid var(--privy-color-foreground-4) !important;border-radius:var(--privy-border-radius-md);padding:8px 10px;font-size:14px;font-weight:500;gap:8px;"]),
    fke = z(Wy).withConfig({
        displayName: "StyledExclamationCircleIcon",
        componentId: "sc-3505eb4c-3"
    })(["position:relative;width:", ";height:", ";color:var(--privy-color-foreground-3);margin-left:auto;"], ({
        $iconSize: t
    }) => `${t}px`, ({
        $iconSize: t
    }) => `${t}px`),
    pke = z(IR).withConfig({
        displayName: "StyledCopyIcon",
        componentId: "sc-3505eb4c-4"
    })(["position:relative;width:15px;height:15px;color:var(--privy-color-foreground-3);margin-left:auto;"]),
    gke = z.ol.withConfig({
        displayName: "ListContainer",
        componentId: "sc-3505eb4c-5"
    })(["display:flex;flex-direction:column;font-size:14px;width:100%;text-align:left;"]),
    D$ = z.li.withConfig({
        displayName: "ListItem",
        componentId: "sc-3505eb4c-6"
    })(["font-size:14px;list-style-type:auto;list-style-position:outside;margin-left:1rem;margin-bottom:0.5rem;&:last-child{margin-bottom:0;}"]),
    mke = z.div.withConfig({
        displayName: "CircleContainer",
        componentId: "sc-3505eb4c-7"
    })(["position:relative;width:60px;height:60px;margin:10px;display:flex;justify-content:center;align-items:center;"]);
let yke = () => d.jsx(mke, {
    children: d.jsx(fke, {
        $iconSize: 60
    })
});
const wke = ({
        address: t,
        onClose: e,
        onRetry: r,
        onTransfer: n,
        isTransferring: i,
        transferSuccess: s
    }) => {
        var c;
        let {
            defaultChain: a
        } = Gt(), o = ((c = a.blockExplorers) == null ? void 0 : c.default.url) ? ? "https://etherscan.io";
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                onClose: e,
                backFn: r
            }), d.jsxs(MF, {
                children: [d.jsx(yke, {}), d.jsxs($4, {
                    children: [d.jsx("h3", {
                        children: "Check account assets before transferring"
                    }), d.jsx("p", {
                        children: "Before transferring, ensure there are no assets in the other account. Assets in that account will not transfer automatically and may be lost."
                    }), d.jsxs(gke, {
                        children: [d.jsx("p", {
                            children: " To check your balance, you can:"
                        }), d.jsx(D$, {
                            children: "Log out and log back into the other account, or "
                        }), d.jsxs(D$, {
                            children: ["Copy your wallet address and use a", " ", d.jsx("u", {
                                children: d.jsx("a", {
                                    target: "_blank",
                                    href: o,
                                    children: "block explorer"
                                })
                            }), " ", "to see if the account holds any assets."]
                        })]
                    }), d.jsxs(DF, {
                        onClick: () => navigator.clipboard.writeText(t).catch(console.error),
                        children: [d.jsx(P0, {
                            color: "var(--privy-color-foreground-1)",
                            strokeWidth: 2,
                            height: "28px",
                            width: "28px"
                        }), d.jsx(Rt, {
                            address: t,
                            showCopyIcon: !1
                        }), d.jsx(pke, {})]
                    }), d.jsx(RF, {
                        onTransfer: n,
                        isTransferring: i,
                        transferSuccess: s
                    })]
                })]
            }), d.jsx(ot, {})]
        })
    },
    qd = {
        component: () => {
            let {
                initiateAccountTransfer: t,
                closePrivyModal: e
            } = $e(), {
                data: r,
                navigate: n,
                lastScreen: i,
                setModalData: s
            } = Ne(), [a, o] = v.useState(void 0), [c, l] = v.useState(!1), [u, h] = v.useState(!1), f = async () => {
                var p, g, m, y, w, x, E, _, b, A;
                try {
                    if (!((p = r == null ? void 0 : r.accountTransfer) != null && p.nonce) || !((g = r == null ? void 0 : r.accountTransfer) != null && g.account)) throw Error("missing account transfer inputs");
                    h(!0), await t({
                        nonce: (m = r == null ? void 0 : r.accountTransfer) == null ? void 0 : m.nonce,
                        account: (y = r == null ? void 0 : r.accountTransfer) == null ? void 0 : y.account,
                        accountType: (w = r == null ? void 0 : r.accountTransfer) == null ? void 0 : w.linkMethod,
                        externalWalletMetadata: (x = r == null ? void 0 : r.accountTransfer) == null ? void 0 : x.externalWalletMetadata,
                        telegramWebAppData: (E = r == null ? void 0 : r.accountTransfer) == null ? void 0 : E.telegramWebAppData,
                        telegramAuthResult: (_ = r == null ? void 0 : r.accountTransfer) == null ? void 0 : _.telegramAuthResult,
                        farcasterEmbeddedAddress: (b = r == null ? void 0 : r.accountTransfer) == null ? void 0 : b.farcasterEmbeddedAddress,
                        oAuthUserInfo: (A = r == null ? void 0 : r.accountTransfer) == null ? void 0 : A.oAuthUserInfo
                    }), l(!0), h(!1), setTimeout(e, 1e3)
                } catch (I) {
                    s({
                        errorModalData: {
                            error: I,
                            previousScreen: i || qd
                        }
                    }), n(Sr, !0)
                }
            };
            return a ? d.jsx(wke, {
                address: a,
                onClose: e,
                onRetry: () => o(void 0),
                onTransfer: f,
                isTransferring: u,
                transferSuccess: c
            }) : d.jsx(bke, {
                onClose: e,
                onInfo: () => {
                    var p;
                    return o((p = r == null ? void 0 : r.accountTransfer) == null ? void 0 : p.embeddedWalletAddress)
                },
                onContinue: () => {
                    var p;
                    return o((p = r == null ? void 0 : r.accountTransfer) == null ? void 0 : p.embeddedWalletAddress)
                },
                onTransfer: f,
                isTransferring: u,
                transferSuccess: c,
                data: r
            })
        }
    },
    bke = ({
        onClose: t,
        onContinue: e,
        onInfo: r,
        onTransfer: n,
        transferSuccess: i,
        isTransferring: s,
        data: a
    }) => {
        var c, l, u, h, f, p, g;
        if (!((c = a == null ? void 0 : a.accountTransfer) != null && c.linkMethod) || !((l = a == null ? void 0 : a.accountTransfer) != null && l.displayName)) return;
        let o = {
            method: (u = a == null ? void 0 : a.accountTransfer) == null ? void 0 : u.linkMethod,
            handle: (h = a == null ? void 0 : a.accountTransfer) == null ? void 0 : h.displayName,
            disclosedAccount: (f = a == null ? void 0 : a.accountTransfer) != null && f.embeddedWalletAddress ? {
                type: "wallet",
                handle: (p = a == null ? void 0 : a.accountTransfer) == null ? void 0 : p.embeddedWalletAddress
            } : void 0
        };
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                closeable: !0
            }), d.jsxs(MF, {
                children: [d.jsx(Fi, {
                    children: d.jsxs("div", {
                        children: [d.jsx(R8, {
                            color: "var(--privy-color-error)"
                        }), d.jsx(yo, {
                            height: 38,
                            width: 38,
                            stroke: "var(--privy-color-error)"
                        })]
                    })
                }), d.jsxs($4, {
                    children: [d.jsxs("h3", {
                        children: [function(m) {
                            switch (m) {
                                case "sms":
                                    return "Phone number";
                                case "email":
                                    return "Email address";
                                case "siwe":
                                    return "Wallet address";
                                case "siws":
                                    return "Solana wallet address";
                                case "linkedin":
                                    return "LinkedIn profile";
                                case "google":
                                case "apple":
                                case "discord":
                                case "github":
                                case "instagram":
                                case "spotify":
                                case "tiktok":
                                case "line":
                                case "twitter":
                                case "telegram":
                                case "farcaster":
                                    return `${eU(m.replace("_oauth",""))} profile`;
                                default:
                                    return m.startsWith("privy:") ? "Cross-app account" : m
                            }
                        }(o.method), " is associated with another account"]
                    }), d.jsxs("p", {
                        children: ["Do you want to transfer", d.jsx("b", {
                            children: o.handle ? ` ${o.handle}` : ""
                        }), " to this account instead? This will delete your other account."]
                    }), d.jsx(vke, {
                        onClick: r,
                        disclosedAccount: o.disclosedAccount
                    })]
                }), d.jsxs($4, {
                    style: {
                        gap: 12,
                        marginTop: 12
                    },
                    children: [(g = a == null ? void 0 : a.accountTransfer) != null && g.embeddedWalletAddress ? d.jsx(Qe, {
                        onClick: e,
                        children: "Continue"
                    }) : d.jsx(RF, {
                        onTransfer: n,
                        transferSuccess: i,
                        isTransferring: s
                    }), d.jsx(po, {
                        onClick: t,
                        children: "No thanks"
                    })]
                })]
            }), d.jsx(ot, {})]
        })
    };

function vke({
    disclosedAccount: t,
    onClick: e
}) {
    return t ? d.jsxs(DF, {
        onClick: e,
        children: [d.jsx(P0, {
            color: "var(--privy-color-foreground-1)",
            strokeWidth: 2,
            height: "28px",
            width: "28px"
        }), d.jsx(Rt, {
            address: t.handle,
            showCopyIcon: !1
        }), d.jsx(lke, {
            width: 15,
            height: 15,
            color: "var(--privy-color-foreground-3)",
            style: {
                marginLeft: "auto"
            }
        })]
    }) : null
}
const LF = () => d.jsx(xke, {
    children: d.jsxs(Eke, {
        children: [d.jsx(_ke, {}), d.jsx(Cke, {})]
    })
});
let xke = z.div.withConfig({
        displayName: "LoadingContainer",
        componentId: "sc-85b54ede-0"
    })(["display:flex;justify-content:center;align-items:center;flex-grow:1;margin:12px;padding:16px;@media all and (display-mode:standalone){margin-bottom:30px;}"]),
    Eke = z.div.withConfig({
        displayName: "SpinnerContainer",
        componentId: "sc-85b54ede-1"
    })(["position:relative;height:140px;width:140px;opacity:1;animation:fadein 200ms ease;"]),
    _ke = z.div.withConfig({
        displayName: "CircleFixed",
        componentId: "sc-85b54ede-2"
    })(["position:absolute;top:0;right:0;bottom:0;left:0;width:140px;height:140px;&&{border:4px solid var(--privy-color-accent-light);border-radius:50%;}"]),
    Cke = z.div.withConfig({
        displayName: "CircleRotate",
        componentId: "sc-85b54ede-3"
    })(["position:absolute;top:0;right:0;bottom:0;left:0;width:140px;height:140px;animation:spin 1200ms linear infinite;&&{border:4px solid;border-color:var(--privy-color-accent) transparent transparent transparent;border-radius:50%;}@keyframes spin{from{transform:rotate(0deg);}to{transform:rotate(360deg);}}"]);
const bc = {
    component: () => {
        let {
            app: t,
            setModalData: e,
            navigate: r,
            data: n,
            onUserCloseViaDialogOrKeybindRef: i
        } = Ne(), [s, a] = v.useState(""), {
            embeddedWallets: o
        } = Gt(), {
            authenticated: c,
            user: l,
            getAccessToken: u
        } = $t(), {
            closePrivyModal: h,
            walletProxy: f
        } = $e(), {
            onSuccess: p,
            onFailure: g,
            callAuthOnSuccessOnClose: m,
            shouldCreateEth: y,
            shouldCreateSol: w
        } = n.createWallet, x = (t == null ? void 0 : t.embeddedWallets.requireUserOwnedRecoveryOnCreate) === !0, [E, _] = v.useState(null), {
            create: b
        } = S8(), A = y ? ? (!!l && O8(l, t.embeddedWallets.ethereum.createOnLogin)), I = w ? ? (!!l && j8(l, t.embeddedWallets.solana.createOnLogin)), T = new di(async () => {
            let C = await u();
            if (l && C && f) try {
                let $;
                if (A && I) $ = await b({
                    chainType: "ethereum",
                    walletIndex: 0,
                    latestUser: l
                }), $ = await b({
                    chainType: "solana",
                    walletIndex: 0,
                    latestUser: $.user
                });
                else if (I) $ = await b({
                    chainType: "solana",
                    walletIndex: 0,
                    latestUser: l
                });
                else {
                    if (!A) return void h({
                        shouldCallAuthOnSuccess: m
                    });
                    $ = await b({
                        chainType: "ethereum",
                        walletIndex: 0,
                        latestUser: l
                    })
                }
                _($), r(T8)
            } catch ($) {
                a($.message)
            }
        });
        return v.useEffect(() => c && l ? x ? (e({ ...n,
            createWallet: { ...n.createWallet,
                shouldCreateEth: A,
                shouldCreateSol: I
            },
            recoverySelection: { ...n == null ? void 0 : n.recoverySelection,
                isInAccountCreateFlow: !0,
                shouldCreateEth: A,
                shouldCreateSol: I
            }
        }), r(uB({
            walletAction: "create",
            showAutomaticRecovery: !1,
            availableRecoveryMethods: o.userOwnedRecoveryOptions,
            legacySetWalletPasswordFlow: !1,
            isResettingPassword: !1
        }))) : void T.execute() : (r(Xn), void g(Error("User must be authenticated before creating a Privy wallet"))), [x, c]), i.current = () => null, s ? d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                closeable: !1
            }), d.jsxs(wc, {
                children: [d.jsx(zy, {
                    fill: "var(--privy-color-error)",
                    width: "64px",
                    height: "64px"
                }), d.jsx($r, {
                    title: "Something went wrong",
                    description: s
                })]
            }), d.jsx(Qe, {
                onClick: () => {
                    E ? (p(E), h({
                        shouldCallAuthOnSuccess: m
                    })) : (g(new Xc("User wallet creation failed")), h({
                        shouldCallAuthOnSuccess: !1
                    }))
                },
                children: "Close"
            }), d.jsx(Ake, {})]
        }) : d.jsx(LF, {})
    }
};
let Ake = z.div.withConfig({
    displayName: "BottomSpacing",
    componentId: "sc-1a8a319a-0"
})(["height:44px;"]);
const Hd = {
        component: () => {
            let {
                user: t,
                logout: e
            } = $t(), {
                app: r,
                onUserCloseViaDialogOrKeybindRef: n,
                setModalData: i,
                navigate: s
            } = Ne(), {
                acceptTerms: a,
                closePrivyModal: o,
                createAnalyticsEvent: c
            } = $e(), l = u => {
                u == null || u.preventDefault(), o({
                    shouldCallAuthOnSuccess: !1
                }), e()
            };
            return n.current = l, d.jsx(kke, {
                termsAndConditionsUrl: r == null ? void 0 : r.legal.termsAndConditionsUrl,
                privacyPolicyUrl: r == null ? void 0 : r.legal.privacyPolicyUrl,
                onAccept: async u => {
                    u.preventDefault(), await a(), t && yl(t, r.embeddedWallets) ? (i({
                        createWallet: {
                            onSuccess: () => {},
                            onFailure: h => {
                                console.error(h), c({
                                    eventName: "embedded_wallet_creation_failure_logout",
                                    payload: {
                                        error: h,
                                        screen: "AffirmativeConsentScreen"
                                    }
                                }), e()
                            },
                            callAuthOnSuccessOnClose: !0
                        }
                    }), s(bc)) : o()
                },
                onDecline: l
            })
        }
    },
    kke = ({
        termsAndConditionsUrl: t,
        privacyPolicyUrl: e,
        onAccept: r,
        onDecline: n
    }) => d.jsxs(d.Fragment, {
        children: [d.jsx(Pe, {
            closeable: !1
        }), d.jsx(D7e, {
            width: 56,
            height: 56,
            fill: "var(--privy-color-accent)",
            style: {
                margin: "auto"
            }
        }), d.jsx(Cr, {
            style: {
                marginTop: 24
            },
            children: "One last step"
        }), d.jsx(Ar, {
            children: "By signing up, you agree to our terms and privacy policy."
        }), d.jsxs(zp, {
            style: {
                marginTop: 24
            },
            children: [t && d.jsxs(y$, {
                target: "_blank",
                href: t,
                children: ["View Terms ", d.jsx(c4, {
                    style: {
                        marginLeft: "auto"
                    }
                })]
            }), e && d.jsxs(y$, {
                target: "_blank",
                href: e,
                children: ["View Privacy Policy ", d.jsx(c4, {
                    style: {
                        marginLeft: "auto"
                    }
                })]
            })]
        }), d.jsxs(Ike, {
            style: {
                marginTop: 24
            },
            children: [d.jsx(po, {
                onClick: n,
                children: "No thanks"
            }), d.jsx(Qe, {
                onClick: r,
                children: "Accept"
            })]
        }), d.jsx(ot, {})]
    });
let Ike = z.div.withConfig({
    displayName: "ButtonsContainer",
    componentId: "sc-9abb9a03-0"
})(["display:flex;gap:10px;"]);
const $ke = () => d.jsx("svg", {
    width: "200",
    height: "200",
    viewBox: "-77 -77 200 200",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    style: {
        height: "28px",
        width: "28px"
    },
    children: d.jsx("rect", {
        width: "50",
        height: "50",
        fill: "black",
        rx: 10,
        ry: 10
    })
});
let Ov = (t, e, r, n, i) => {
        for (let s = e; s < e + n; s++)
            for (let a = r; a < r + i; a++) {
                let o = t == null ? void 0 : t[a];
                o && o[s] && (o[s] = 0)
            }
        return t
    },
    Ske = ({
        x: t,
        y: e,
        cellSize: r,
        bgColor: n,
        fgColor: i
    }) => d.jsx(d.Fragment, {
        children: [0, 1, 2].map(s => d.jsx("circle", {
            r: r * (7 - 2 * s) / 2,
            cx: t + 7 * r / 2,
            cy: e + 7 * r / 2,
            fill: s % 2 != 0 ? n : i
        }, `finder-${t}-${e}-${s}`))
    }),
    Tke = ({
        cellSize: t,
        matrixSize: e,
        bgColor: r,
        fgColor: n
    }) => d.jsx(d.Fragment, {
        children: [
            [0, 0],
            [(e - 7) * t, 0],
            [0, (e - 7) * t]
        ].map(([i, s]) => d.jsx(Ske, {
            x: i,
            y: s,
            cellSize: t,
            bgColor: r,
            fgColor: n
        }, `finder-${i}-${s}`))
    }),
    Pke = ({
        matrix: t,
        cellSize: e,
        color: r
    }) => d.jsx(d.Fragment, {
        children: t.map((n, i) => n.map((s, a) => s ? d.jsx("rect", {
            height: e - .4,
            width: e - .4,
            x: i * e + .1 * e,
            y: a * e + .1 * e,
            rx: .5 * e,
            ry: .5 * e,
            fill: r
        }, `cell-${i}-${a}`) : d.jsx(at.Fragment, {}, `circle-${i}-${a}`)))
    }),
    Nke = ({
        cellSize: t,
        matrixSize: e,
        element: r,
        sizePercentage: n,
        bgColor: i
    }) => {
        if (!r) return d.jsx(d.Fragment, {});
        let s = e * (n || .14),
            a = Math.floor(e / 2 - s / 2),
            o = Math.floor(e / 2 + s / 2);
        (o - a) % 2 != e % 2 && (o += 1);
        let c = (o - a) * t,
            l = c - .2 * c,
            u = a * t;
        return d.jsxs(d.Fragment, {
            children: [d.jsx("rect", {
                x: a * t,
                y: a * t,
                width: c,
                height: c,
                fill: i
            }), d.jsx(r, {
                x: u + .1 * c,
                y: u + .1 * c,
                height: l,
                width: l
            })]
        })
    },
    Oke = t => {
        var s;
        let e = t.outputSize,
            r = ((a, o) => {
                let c = G_e.create(a, {
                        errorCorrectionLevel: o
                    }).modules,
                    l = ((u, h) => {
                        let f = u.slice(0),
                            p = [];
                        for (; f.length;) p.push(f.splice(0, h));
                        return p
                    })(Array.from(c.data), c.size);
                return l = Ov(l, 0, 0, 7, 7), l = Ov(l, l.length - 7, 0, 7, 7), Ov(l, 0, l.length - 7, 7, 7)
            })(t.url, t.errorCorrectionLevel),
            n = e / r.length,
            i = function(a, {
                min: o,
                max: c
            }) {
                return Math.min(Math.max(a, o), c)
            }(2 * n, {
                min: .025 * e,
                max: .036 * e
            });
        return d.jsxs("svg", {
            height: t.outputSize,
            width: t.outputSize,
            viewBox: `0 0 ${t.outputSize} ${t.outputSize}`,
            style: {
                height: "100%",
                width: "100%",
                padding: `${i}px`
            },
            children: [d.jsx(Pke, {
                matrix: r,
                cellSize: n,
                color: t.fgColor
            }), d.jsx(Tke, {
                cellSize: n,
                matrixSize: r.length,
                fgColor: t.fgColor,
                bgColor: t.bgColor
            }), d.jsx(Nke, {
                cellSize: n,
                element: (s = t.logo) == null ? void 0 : s.element,
                bgColor: t.bgColor,
                matrixSize: r.length
            })]
        })
    },
    jke = z.div.attrs({
        className: "ph-no-capture"
    }).withConfig({
        displayName: "QrContainer",
        componentId: "sc-597e27f3-0"
    })(["display:flex;justify-content:center;align-items:center;height:", ";width:", ";margin:auto;background-color:", ";&&{border-width:2px;border-color:", ";border-radius:var(--privy-border-radius-md);}"], t => `${t.$size}px`, t => `${t.$size}px`, t => t.$bgColor, t => t.$borderColor);
const U0 = t => {
        let {
            appearance: e
        } = Gt(), r = t.bgColor || "#FFFFFF", n = t.fgColor || "#000000", i = t.size || 160, s = e.palette.colorScheme === "dark" ? r : n;
        return d.jsx(jke, {
            $size: i,
            $bgColor: r,
            $fgColor: n,
            $borderColor: s,
            children: d.jsx(Oke, {
                url: t.url,
                logo: {
                    element: t.squareLogoElement ? ? $ke
                },
                outputSize: i,
                bgColor: r,
                fgColor: n,
                errorCorrectionLevel: t.errorCorrectionLevel || "Q"
            })
        })
    },
    dc = z.span.withConfig({
        displayName: "ErrorMessage",
        componentId: "sc-fcb8cd50-0"
    })(["text-align:left;font-size:0.75rem;font-weight:500;line-height:1.125rem;color:var(--privy-color-error);"]);
let UF = z.label.withConfig({
    displayName: "BaseEmailForm",
    componentId: "sc-6423bc41-0"
})(["display:block;position:relative;width:100%;> svg{position:absolute;margin:13px 17px;height:24px;width:24px;color:var(--privy-color-foreground-3);}&& > input{background-color:#f00;font-size:16px;line-height:24px;padding:12px 88px 12px 52px;flex-grow:1;background:var(--privy-color-background);border:1px solid ", ";border-radius:var(--privy-border-radius-mdlg);width:100%;@media (min-width:441px){font-size:14px;padding-right:78px;}:focus{outline:none;border-color:", ";box-shadow:", ";}:autofill,:-webkit-autofill{background:var(--privy-color-background);}&& > input::placeholder{color:var(--privy-color-foreground-3);}&:disabled{opacity:0.4;cursor:not-allowed;}&:disabled,&:disabled:hover,&:disabled > span{color:var(--privy-color-foreground-3);}}&& > button:last-child{right:0px;line-height:24px;padding:13px 17px;:focus{outline:none;}&:disabled{opacity:0.4;cursor:not-allowed;}&:disabled,&:disabled:hover,&:disabled > span{color:var(--privy-color-foreground-3);}}"], ({
    $error: t
}) => t ? "var(--privy-color-error) !important" : "var(--privy-color-foreground-4)", ({
    $error: t
}) => t ? "var(--privy-color-error) !important" : "var(--privy-color-accent-light)", ({
    $error: t
}) => t ? "none" : "0 0 0 1px var(--privy-color-accent-light)");
const FF = z(UF).withConfig({
        displayName: "EmailUpdateForm",
        componentId: "sc-6423bc41-1"
    })(["background-color:var(--privy-color-background);transition:background-color 200ms ease;&& > button{right:0;line-height:24px;position:absolute;padding:13px 17px;background-color:#090;:focus{outline:none;border-color:var(--privy-color-accent);}}"]),
    Rke = z(UF).withConfig({
        displayName: "EmailInputForm",
        componentId: "sc-6423bc41-2"
    })(["&& > input{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;padding-right:", ";border:1px solid ", ";&& > input::placeholder{color:var(--privy-color-foreground-3);}}&& > :last-child{right:16px;position:absolute;top:50%;transform:translate(0,-50%);}&& > button:last-child{right:0px;line-height:24px;padding:13px 17px;:focus{outline:none;}}"], t => t.$stacked ? "16px" : "88px", ({
        $error: t
    }) => t ? "var(--privy-color-error) !important" : "var(--privy-color-foreground-4)"),
    BF = z.div.withConfig({
        displayName: "InputContainerForm",
        componentId: "sc-6423bc41-3"
    })(["width:100%;&& > ", "{display:block;text-align:left;padding-left:var(--privy-border-radius-mdlg);padding-bottom:5px;}"], dc),
    $a = z.span.withConfig({
        displayName: "Subtitle",
        componentId: "sc-7a11f796-0"
    })(["margin-top:4px;color:var(--privy-color-foreground);text-align:center;font-size:0.875rem;font-weight:400;line-height:1.375rem;&& a{color:var(--privy-color-accent);}"]),
    L$ = t => {
        var r;
        let e = (r = localStorage.getItem("-walletlink:https://www.walletlink.org:Addresses")) == null ? void 0 : r.split(" ").filter(n => Jn(n, {
            strict: !0
        })).map(n => Zr(n));
        return !!(e != null && e.length) && !!(t != null && t.linkedAccounts.filter(n => n.type == "wallet" && e.includes(n.address)).length)
    };
let WF = v.createContext({
    plugins: {
        current: {}
    }
});
const Mke = ({
        children: t
    }) => {
        let e = v.useRef({});
        return d.jsx(WF.Provider, {
            value: {
                plugins: e
            },
            children: t
        })
    },
    Rh = () => {
        let {
            plugins: t
        } = v.useContext(WF);
        return v.useCallback(e => t.current[e], [t])
    },
    zF = Symbol("solana-ledger-plugin"),
    dw = {
        component: () => {
            let {
                navigate: t,
                app: e
            } = Ne(), r = (e == null ? void 0 : e.allowlistConfig.errorTitle) || "You don't have access to this app", n = (e == null ? void 0 : e.allowlistConfig.errorDetail) || "Have you been invited?", i = (e == null ? void 0 : e.allowlistConfig.errorCtaText) || "Try another account";
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {}), d.jsxs(Dke, {
                    children: [d.jsx(Fi, {
                        children: d.jsxs("div", {
                            children: [d.jsx(R8, {}), d.jsx(jF, {
                                style: {
                                    width: "38px",
                                    height: "38px",
                                    strokeWidth: "1",
                                    stroke: "var(--privy-color-accent)",
                                    fill: "var(--privy-color-accent)"
                                }
                            })]
                        })
                    }), d.jsxs(Lke, {
                        children: [d.jsx(typeof r == "string" ? "h3" : d.Fragment, {
                            children: r
                        }), d.jsx(typeof n == "string" ? "p" : d.Fragment, {
                            children: n
                        })]
                    }), e != null && e.allowlistConfig.errorCtaLink ? d.jsx(Qe, {
                        as: "a",
                        href: e.allowlistConfig.errorCtaLink,
                        children: i
                    }) : d.jsx(Qe, {
                        onClick: () => {
                            t(Xn)
                        },
                        children: i
                    })]
                })]
            })
        }
    };
let Dke = z.div.withConfig({
        displayName: "ConnectContainer",
        componentId: "sc-274cb2fe-0"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;width:100%;padding-bottom:16px;"]),
    Lke = z.div.withConfig({
        displayName: "GappedContainer",
        componentId: "sc-274cb2fe-1"
    })(["display:flex;flex-direction:column;gap:8px;"]);
const Uke = ({
    icon: t
}) => d.jsx(d.Fragment, {
    children: d.jsx(Fke, {
        children: d.jsxs("div", {
            children: [d.jsx(Ia, {}), typeof t == "string" ? d.jsx("span", {
                style: {
                    background: `url('${t}')`,
                    height: "38px",
                    width: "38px",
                    borderRadius: "6px",
                    margin: "auto",
                    backgroundSize: "cover"
                }
            }) : t ? d.jsx(t, {
                style: {
                    width: "38px",
                    height: "38px"
                }
            }) : d.jsx("span", {})]
        })
    })
});
let Fke = z.div.withConfig({
    displayName: "StackedContainer",
    componentId: "sc-26c1d9b9-0"
})(["display:flex;flex-direction:column;justify-content:center;align-items:center;width:100%;height:82px;> div{position:relative;}> div > span{position:absolute;left:-41px;top:-41px;}> div > :last-child{position:absolute;left:-19px;top:-19px;}"]);
const Sa = {
    component: () => {
        let {
            lastScreen: t,
            currentScreen: e,
            data: r,
            navigateBack: n,
            navigate: i,
            setModalData: s
        } = Ne(), {
            status: a,
            token: o,
            waitForResult: c,
            reset: l,
            execute: u
        } = qi(), h = v.useRef([]), f = N => {
            h.current = [N, ...h.current]
        }, [p, g] = v.useState(!0);
        v.useEffect(() => (f(setTimeout(g, 1e3, !1)), () => {
            h.current.forEach(N => clearTimeout(N)), h.current = []
        }), []);
        let [m, y] = v.useState(""), [w, x] = v.useState("Checking that you are a human..."), [E, _] = v.useState(d.jsx(Qe, {
            onClick: () => {},
            disabled: !0,
            children: "Continue"
        })), [b, A] = v.useState(!1), [I, T] = v.useState(3), C = r == null ? void 0 : r.captchaModalData, $ = async N => {
            try {
                await (C == null ? void 0 : C.callback(N)), C != null && C.onSuccessNavigateTo && i(C == null ? void 0 : C.onSuccessNavigateTo, !1)
            } catch (R) {
                if (R instanceof Ky) return;
                s({
                    errorModalData: {
                        error: R,
                        previousScreen: t || Xn
                    }
                }), i((C == null ? void 0 : C.onErrorNavigateTo) || Sr, !1)
            }
        };
        v.useEffect(() => {
            a === "success" ? f(setTimeout(async () => {
                let N = await c();
                !N || C != null && C.userIntentRequired || $(N)
            }, 1e3)) : a === "ready" && f(setTimeout(() => {
                a === "ready" && u()
            }, 500))
        }, [a]), v.useEffect(() => {
            if (!p) switch (a) {
                case "success":
                    y("Success!"), x("CAPTCHA passed successfully."), _(d.jsx(Qe, {
                        onClick: () => {
                            A(!0), $(o)
                        },
                        disabled: !(C != null && C.userIntentRequired),
                        loading: b,
                        children: C != null && C.userIntentRequired ? "Continue" : "Continuing..."
                    })), setTimeout(() => {
                        A(!0), $(o)
                    }, 2e3);
                    break;
                case "loading":
                    y(""), x("Checking that you are a human..."), _(d.jsx(Qe, {
                        onClick: () => {},
                        disabled: !0,
                        children: "Continue"
                    }));
                    break;
                case "error":
                    y("Something went wrong"), I <= 0 ? (x("If you use an adblocker or VPN, try disabling and re-attempting."), _(null)) : (x("You did not pass CAPTCHA. Please try again."), _(d.jsx(Qe, {
                        onClick: P,
                        children: "Retry"
                    })))
            }
        }, [a, p, b]);
        let P = async () => {
            if (I <= 0) return;
            T(R => R - 1), l(), u();
            let N = await c();
            !N || C != null && C.userIntentRequired || $(N)
        };
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                backFn: t && e !== t ? n : void 0
            }), d.jsxs(Bke, {
                children: [a === "success" ? d.jsx(vd, {
                    fill: "var(--privy-color-success)",
                    width: "64px",
                    height: "64px"
                }) : a === "error" ? d.jsx(zy, {
                    fill: "var(--privy-color-error)",
                    width: "64px",
                    height: "64px"
                }) : d.jsx(Uke, {}), d.jsxs(ls, {
                    children: [m ? d.jsx("h3", {
                        children: m
                    }) : null, d.jsx("p", {
                        children: w
                    })]
                }), E]
            }), d.jsx(Wt, {})]
        })
    }
};
let Bke = z.div.withConfig({
    displayName: "CaptchaContainer",
    componentId: "sc-1be5b3b9-0"
})(["display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;width:100%;"]);
const Wke = t => d.jsx("svg", {
        id: "Layer_1",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "-0.625 12.48 397.647 399.546",
        width: "2500",
        height: "674",
        preserveAspectRatio: "none",
        ...t,
        children: d.jsx("g", {
            children: d.jsx("path", {
                fill: "#333745",
                d: "M 333.9 12.8 L 150.9 12.8 L 150.9 258.4 L 396.5 258.4 L 396.5 76.7 C 396.6 42.2 368.4 12.8 333.9 12.8 Z M 94.7 12.8 L 64 12.8 C 29.5 12.8 0 40.9 0 76.8 L 0 107.5 L 94.7 107.5 L 94.7 12.8 Z M 0 165 L 94.7 165 L 94.7 259.7 L 0 259.7 L 0 165 Z M 301.9 410.6 L 332.6 410.6 C 367.1 410.6 396.6 382.5 396.6 346.6 L 396.6 316 L 301.9 316 L 301.9 410.6 Z M 150.9 316 L 245.6 316 L 245.6 410.7 L 150.9 410.7 L 150.9 316 Z M 0 316 L 0 346.7 C 0 381.2 28.1 410.7 64 410.7 L 94.7 410.7 L 94.7 316 L 0 316 Z"
            })
        })
    }),
    zke = {
        component: function() {
            let {
                data: t,
                setModalData: e,
                navigateBack: r,
                lastScreen: n,
                navigate: i
            } = Ne();

            function s(a) {
                e(a === "wallet" ? { ...t,
                    login: { ...t == null ? void 0 : t.login,
                        isSigningInWithLedgerSolana: !1
                    }
                } : { ...t,
                    login: { ...t == null ? void 0 : t.login,
                        isSigningInWithLedgerSolana: !0
                    }
                }), i(Yo)
            }
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    backFn: n && n !== Yo ? r : void 0
                }), d.jsxs(qke, {
                    children: [d.jsxs(Hke, {
                        children: [d.jsx(_U, {
                            style: {
                                width: "48px",
                                height: "48px"
                            }
                        }), d.jsx(qy, {
                            width: 24,
                            height: 24
                        }), d.jsx(Wke, {
                            style: {
                                width: "48px",
                                height: "48px"
                            }
                        })]
                    }), d.jsxs(Vke, {
                        children: [d.jsx(Gke, {
                            children: "Phantom supports Ledger"
                        }), d.jsxs(Kke, {
                            children: ["Are you using a Ledger hardware wallet?", d.jsx("br", {}), "Continue to sign with Ledger"]
                        })]
                    }), d.jsxs(Yke, {
                        children: [d.jsx(po, {
                            onClick: () => s("wallet"),
                            children: "Continue without Ledger"
                        }), d.jsx(Qe, {
                            onClick: () => s("ledger"),
                            children: "Continue with Ledger"
                        })]
                    })]
                }), d.jsx(ot, {})]
            })
        }
    };
let qke = z.div.withConfig({
        displayName: "ConnectContainer",
        componentId: "sc-8c598100-0"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;width:100%;"]),
    Hke = z.div.withConfig({
        displayName: "IconContainer",
        componentId: "sc-8c598100-1"
    })(["display:flex;align-items:center;justify-content:center;gap:8px;"]),
    Vke = z.div.withConfig({
        displayName: "TextContainer",
        componentId: "sc-8c598100-2"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;gap:8px;"]),
    Gke = z.p.withConfig({
        displayName: "Title",
        componentId: "sc-8c598100-3"
    })(["&&{font-size:18px;font-weight:600;}"]),
    Kke = z.p.withConfig({
        displayName: "Subtitle",
        componentId: "sc-8c598100-4"
    })(["&&{font-size:14px;}"]),
    Yke = z.div.withConfig({
        displayName: "ButtonsContainer",
        componentId: "sc-8c598100-5"
    })(["width:100%;display:flex;flex-direction:column;gap:10px;margin-top:24px;"]);
const Zke = ({
        style: t,
        ...e
    }) => d.jsx("svg", {
        width: "40",
        height: "40",
        viewBox: "0 0 40 40",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: {
            height: "38px",
            width: "38px",
            ...t
        },
        ...e,
        children: d.jsx("path", {
            d: "M20 13.6V20M20 26.4H20.016M36 20C36 28.8365 28.8366 36 20 36C11.1635 36 4.00001 28.8365 4.00001 20C4.00001 11.1634 11.1635 3.99999 20 3.99999C28.8366 3.99999 36 11.1634 36 20Z",
            stroke: "currentColor",
            strokeWidth: "3.2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        })
    }),
    F0 = {
        component: () => {
            let {
                navigate: t
            } = Ne();
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {}), d.jsxs(Jke, {
                    children: [d.jsx(Qke, {
                        children: d.jsx(Zke, {})
                    }), d.jsxs(Xke, {
                        children: [d.jsx("h3", {
                            children: "Unable to sign in"
                        }), d.jsx("p", {
                            children: "This application has reached its user limit and cannot sign in new users."
                        })]
                    }), d.jsx(Qe, {
                        onClick: () => {
                            t(Xn)
                        },
                        children: "Go back"
                    })]
                }), d.jsx(ot, {})]
            })
        }
    };
let Jke = z.div.withConfig({
        displayName: "ConnectContainer",
        componentId: "sc-b3ae112e-0"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;width:100%;padding-top:8px;padding-bottom:32px;"]),
    Qke = z.div.withConfig({
        displayName: "IconContainer",
        componentId: "sc-b3ae112e-1"
    })(["display:flex;align-items:center;justify-content:center;height:72px;aspect-ratio:1;color:var(--privy-color-error);background-color:var(--privy-color-error-light);border-radius:50%;"]),
    Xke = z.div.withConfig({
        displayName: "GappedContainer",
        componentId: "sc-b3ae112e-2"
    })(["display:flex;flex-direction:column;gap:8px;"]);
const qF = t => (t == null ? void 0 : t.privyErrorCode) === ee.LINKED_TO_ANOTHER_USER ? Hc.ERROR_USER_EXISTS : t instanceof ni && !t.details.default ? t.details : t instanceof bU ? Hc.ERROR_TIMED_OUT : t instanceof vU ? Hc.ERROR_USER_REJECTED_CONNECTION : (t == null ? void 0 : t.privyErrorCode) === ee.CANNOT_LINK_MORE_OF_TYPE ? Hc.ERROR_USER_LIMIT_REACHED : Hc.ERROR_WALLET_CONNECTION,
    Yo = {
        component: () => {
            var Be, ce, Ie, xe, ie, Ee, ft, Ae, Le, Te, Ue, De, We, dt;
            let t, [e, r] = v.useState(!1),
                [n, i] = v.useState(!1),
                [s, a] = v.useState(void 0),
                {
                    authenticated: o,
                    logout: c
                } = $t(),
                {
                    app: l,
                    navigate: u,
                    navigateBack: h,
                    lastScreen: f,
                    currentScreen: p,
                    setModalData: g,
                    data: m
                } = Ne(),
                {
                    getAuthFlow: y,
                    walletConnectionStatus: w,
                    closePrivyModal: x,
                    initLoginWithWallet: E,
                    loginWithWallet: _,
                    updateWallets: b,
                    createAnalyticsEvent: A
                } = $e(),
                {
                    walletConnectors: I
                } = $t(),
                [T, C] = v.useState(0),
                {
                    user: $
                } = $t(),
                P = Rh(),
                [N] = v.useState(($ == null ? void 0 : $.linkedAccounts.length) || 0),
                [R, D] = v.useState(""),
                [S, O] = v.useState(""),
                [M, U] = v.useState(!1),
                {
                    hasTabbedAway: k
                } = function() {
                    let [He, ut] = v.useState(!1), Ye = v.useCallback(() => {
                        document.hidden && ut(!0)
                    }, []);
                    return v.useEffect(() => (document.addEventListener("visibilitychange", Ye), () => document.removeEventListener("visibilitychange", Ye)), [Ye]), {
                        hasTabbedAway: He,
                        reset: () => ut(!1)
                    }
                }(),
                {
                    enabled: F,
                    token: q
                } = qi(),
                W = mc(((Be = w == null ? void 0 : w.connector) == null ? void 0 : Be.walletClientType) || "unknown"),
                K = gr.isMobile && ((ce = w == null ? void 0 : w.connector) == null ? void 0 : ce.connectorType) === "wallet_connect_v2" || gr.isMobile && ((Ie = w == null ? void 0 : w.connector) == null ? void 0 : Ie.connectorType) === "coinbase_wallet" || gr.isMobile && ((xe = w == null ? void 0 : w.connector) == null ? void 0 : xe.connectorType) === "base_account" || gr.isMobile && ((ie = w == null ? void 0 : w.connector) == null ? void 0 : ie.connectorType) === "injected" && ((Ee = w == null ? void 0 : w.connector) == null ? void 0 : Ee.walletClientType) === "phantom",
                H = (w == null ? void 0 : w.status) === "connected",
                j = (w == null ? void 0 : w.status) === "switching_to_supported_chain";
            v.useEffect(() => {
                var Ye, we, vt, Lt, _t, tr;
                let He = y(),
                    ut = He instanceof qu || He instanceof c1 ? He : void 0;
                H && ((Ye = w.connector) == null ? void 0 : Ye.chainType) === "solana" && ((we = w.connector) == null ? void 0 : we.walletClientType) === "phantom" && P(zF) && ((vt = m == null ? void 0 : m.login) == null ? void 0 : vt.isSigningInWithLedgerSolana) === void 0 ? u(zke, !1) : (H && !ut && (!F || q || o ? E(w.connectedWallet, q, (Lt = m == null ? void 0 : m.login) == null ? void 0 : Lt.disableSignup, (_t = m == null ? void 0 : m.login) != null && _t.isSigningInWithLedgerSolana ? "transaction" : "plain").then(() => {
                    U(!0)
                }) : (g({
                    captchaModalData: {
                        callback: dr => {
                            var Yt, Ot;
                            return E(w.connectedWallet, dr, (Yt = m == null ? void 0 : m.login) == null ? void 0 : Yt.disableSignup, (Ot = m == null ? void 0 : m.login) != null && Ot.isSigningInWithLedgerSolana ? "transaction" : "plain").then(() => {
                                U(!0)
                            })
                        },
                        userIntentRequired: !1,
                        onSuccessNavigateTo: Yo,
                        onErrorNavigateTo: Sr
                    }
                }), u(Sa, !1))), ut instanceof c1 && ((tr = m == null ? void 0 : m.login) != null && tr.isSigningInWithLedgerSolana) && (ut.messageType = "transaction"), ut && K && H && !ut.preparedMessage ? ut.buildMessage() : ut && !K && H && (n || (async () => {
                    var dr, Yt;
                    i(!0), a(void 0);
                    try {
                        ((dr = w == null ? void 0 : w.connector) == null ? void 0 : dr.connectorType) === "wallet_connect_v2" && ((Yt = w == null ? void 0 : w.connector) == null ? void 0 : Yt.walletClientType) === "metamask" && await l1(2500), await Y()
                    } catch (Ot) {
                        console.warn("Auto-prompted signature failed", Ot)
                    } finally {
                        i(!1)
                    }
                })()))
            }, [T, H, M]), v.useEffect(() => {
                if ($ && e) {
                    let He = 900;
                    if (l != null && l.legal.requireUsersAcceptTerms && !$.hasAcceptedTerms) {
                        let Ye = setTimeout(() => {
                            u(Hd)
                        }, He);
                        return () => clearTimeout(Ye)
                    }
                    if (yl($, l.embeddedWallets)) {
                        let Ye = setTimeout(() => {
                            g({
                                createWallet: {
                                    onSuccess: () => {},
                                    onFailure: we => {
                                        console.error(we), A({
                                            eventName: "embedded_wallet_creation_failure_logout",
                                            payload: {
                                                error: we,
                                                screen: "ConnectionStatusScreen"
                                            }
                                        }), c()
                                    },
                                    callAuthOnSuccessOnClose: !0
                                }
                            }), u(bc)
                        }, He);
                        return () => clearTimeout(Ye)
                    }
                    b();
                    let ut = setTimeout(() => x({
                        shouldCallAuthOnSuccess: !0,
                        isSuccess: !0
                    }), Ir);
                    return () => clearTimeout(ut)
                }
            }, [$, e]);
            let V = He => {
                var ut, Ye, we, vt, Lt, _t, tr, dr, Yt, Ot, mt, ur, Vr, pt;
                if ((He == null ? void 0 : He.privyErrorCode) !== ee.ALLOWLIST_REJECTED) {
                    if ((He == null ? void 0 : He.privyErrorCode) === ee.USER_LIMIT_REACHED) return console.error(new l0(He).toString()), void u(F0);
                    if ((He == null ? void 0 : He.privyErrorCode) !== ee.USER_DOES_NOT_EXIST) return (He == null ? void 0 : He.privyErrorCode) === ee.ACCOUNT_TRANSFER_REQUIRED && ((Ye = (ut = He.data) == null ? void 0 : ut.data) != null && Ye.nonce) ? (g({
                        accountTransfer: {
                            nonce: (vt = (we = He.data) == null ? void 0 : we.data) == null ? void 0 : vt.nonce,
                            account: (Lt = y()) == null ? void 0 : Lt.meta.address,
                            displayName: (dr = (tr = (_t = He.data) == null ? void 0 : _t.data) == null ? void 0 : tr.account) == null ? void 0 : dr.displayName,
                            externalWalletMetadata: {
                                walletClientType: (Yt = y()) == null ? void 0 : Yt.meta.walletClientType,
                                chainId: (Ot = y()) == null ? void 0 : Ot.meta.chainId,
                                connectorType: (mt = y()) == null ? void 0 : mt.meta.connectorType
                            },
                            linkMethod: y() instanceof qu ? "siwe" : "siws",
                            embeddedWalletAddress: (pt = (Vr = (ur = He.data) == null ? void 0 : ur.data) == null ? void 0 : Vr.otherUser) == null ? void 0 : pt.embeddedWalletAddress
                        }
                    }), void u(qd)) : void a(qF(He));
                    u(D0)
                } else u(dw)
            };
            async function Y() {
                try {
                    await _(), r(!0)
                } catch (He) {
                    V(He)
                } finally {
                    i(!1)
                }
            }
            v.useEffect(() => {
                w != null && w.connectError && V(w == null ? void 0 : w.connectError)
            }, [w]), ((He, ut) => {
                let Ye = v.useRef(() => {});
                v.useEffect(() => {
                    Ye.current = He
                }), v.useEffect(() => {
                    if (ut !== null) {
                        let we = setInterval(() => Ye.current(), ut || 0);
                        return () => clearInterval(we)
                    }
                }, [ut])
            })(() => {
                let He = X === "wallet_connect_v2" && (w == null ? void 0 : w.connector) instanceof Vu ? w.connector.redirectUri : void 0;
                He && D(He);
                let ut = X === "wallet_connect_v2" && (w == null ? void 0 : w.connector) instanceof Vu ? w.connector.fallbackUniversalRedirectUri : void 0;
                ut && O(ut)
            }, (w == null ? void 0 : w.connector) instanceof Vu && !R ? 500 : null);
            let X = ((ft = w == null ? void 0 : w.connector) == null ? void 0 : ft.connectorType) || "injected",
                ne = ((Ae = w == null ? void 0 : w.connector) == null ? void 0 : Ae.walletClientType) || "unknown",
                ae = ((Le = W == null ? void 0 : W.metadata) == null ? void 0 : Le.shortName) || (W == null ? void 0 : W.name) || ((Te = w == null ? void 0 : w.connector) == null ? void 0 : Te.walletBranding.name) || "Browser Extension",
                ue = ((Ue = W == null ? void 0 : W.image_url) == null ? void 0 : Ue.md) || ((De = w == null ? void 0 : w.connector) == null ? void 0 : De.walletBranding.icon) || (He => d.jsx(f8, { ...He
                })),
                he = ae === "Browser Extension" ? ae.toLowerCase() : ae;
            t = e ? `Successfully connected with ${he}` : s ? s.message : j ? "Switching networks" : H ? n && K ? "Signing" : "Sign to verify" : `Waiting for ${he}`;
            let fe = "Don’t see your wallet? Check your other browser windows.";
            e ? fe = N === (($ == null ? void 0 : $.linkedAccounts.length) || 0) ? "Wallet was already linked." : "You’re good to go!" : T >= 2 && s ? fe = "Unable to connect wallet" : s ? fe = s.detail : j ? fe = "Switch your wallet to the requested network." : H && K ? fe = "Sign the message in your wallet to verify it belongs to you." : ne === "metamask" && gr.isMobile ? fe = "Click continue to open and connect MetaMask." : ne === "metamask" ? fe = "For the best experience, connect only one wallet at a time." : X === "wallet_connect" ? fe = "Open your mobile wallet app to continue" : X === "coinbase_wallet" ? fU() || (fe = L$($) ? "Continue with the Coinbase app. Not the right wallet? Reset your connection below." : "Open the Coinbase app on your phone to continue.") : (We = m == null ? void 0 : m.login) != null && We.isSigningInWithLedgerSolana && (fe = "Ledger requires a transaction to verify your identity. You’ll sign a transaction that performs no onchain action.");
            let de = (dt = I == null ? void 0 : I.walletConnectors) == null ? void 0 : dt.find(He => He.walletClientType === "coinbase_wallet"),
                ye = ne === "coinbase_wallet" && (L$($) || s === Hc.ERROR_USER_EXISTS);
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    backFn: f && p !== f ? h : void 0
                }), d.jsxs(eIe, {
                    children: [d.jsx(w1, {
                        walletLogo: ue,
                        success: e,
                        fail: !!s
                    }), d.jsxs(ls, {
                        children: [d.jsx("h3", {
                            children: t
                        }), d.jsx("p", {
                            children: fe
                        }), H || !R || k ? null : d.jsxs("p", {
                            children: ["Still here?", " ", d.jsx("a", {
                                href: R,
                                target: "_blank",
                                style: {
                                    textDecoration: "underline"
                                },
                                children: "Try connecting again"
                            }), S && d.jsxs(d.Fragment, {
                                children: [" ", "or", " ", d.jsx("a", {
                                    href: S,
                                    target: "_blank",
                                    style: {
                                        textDecoration: "underline"
                                    },
                                    children: "use this different link"
                                })]
                            })]
                        })]
                    }), ye ? d.jsx(Qe, {
                        onClick: () => de && (de == null ? void 0 : de.disconnect()),
                        disabled: e,
                        children: "Use a different wallet"
                    }) : s == Hc.ERROR_USER_EXISTS && p !== f ? d.jsx(Qe, {
                        onClick: h,
                        children: "Use a different wallet"
                    }) : H && !e && K ? d.jsx(Qe, {
                        onClick: () => {
                            i(!0), Y()
                        },
                        disabled: n,
                        children: n ? "Signing" : "Sign with your wallet"
                    }) : !e && (s != null && s.retryable) && T < 2 ? d.jsx(Qe, {
                        onClick: () => {
                            C(T + 1), a(void 0), H ? (i(!0), Y()) : w == null || w.connectRetry()
                        },
                        disabled: !e && (!(s != null && s.retryable) || T >= 2),
                        children: "Retry"
                    }) : e || s ? null : d.jsx(Qe, {
                        onClick: () => {},
                        disabled: !0,
                        children: "Connecting"
                    })]
                }), d.jsx(Wt, {})]
            })
        }
    };
let eIe = z.div.withConfig({
        displayName: "ConnectContainer",
        componentId: "sc-f8d47c4f-0"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;width:100%;"]),
    tIe = z.div.withConfig({
        displayName: "StackedContainer",
        componentId: "sc-f8d47c4f-1"
    })(["display:flex;flex-direction:column;justify-content:center;align-items:center;width:100%;height:82px;> div{position:relative;}> div > span{position:absolute;left:-41px;top:-41px;}> div > :last-child{position:absolute;left:-19px;top:-19px;}"]);
const w1 = t => {
    let e = t.walletLogo;
    return d.jsx(d.Fragment, {
        children: d.jsx(tIe, {
            children: d.jsxs("div", {
                children: [d.jsx(Ia, {
                    success: t.success,
                    fail: t.fail
                }), typeof e == "string" ? d.jsx("span", {
                    style: {
                        background: `url('${e}') 0 0 / contain`,
                        height: "38px",
                        width: "38px",
                        borderRadius: "6px",
                        margin: "auto",
                        backgroundSize: "contain"
                    }
                }) : d.jsx(e, {
                    style: {
                        width: "38px",
                        height: "38px"
                    }
                })]
            })
        })
    })
};
class ts {
    static normalize(e) {
        return e.replace(/[-_]wallet$/, "").replace(/[-_]extension$/, "").toLowerCase()
    }
    isEth(e) {
        return e.chains.some(r => r.startsWith("eip155:"))
    }
    isSol(e) {
        return e.chains.some(r => r.startsWith("solana:"))
    }
    inAllowList(e, r) {
        if (!this.normalizedAllowList || this.normalizedAllowList.length === 0 || r === "listing" && this.includeWalletConnect) return !0;
        let n = ts.normalize(e);
        return this.normalizedAllowList.some(i => n === ts.normalize(i))
    }
    chainMatches(e) {
        return this.chainFilter === "ethereum-only" ? e === "ethereum" : this.chainFilter !== "solana-only" || e === "solana"
    }
    connectorOk(e) {
        return !!(e.connectorType !== "null" && this.chainMatches(e.chainType) && (this.inAllowList(e.walletClientType, "connector") || (e.connectorType === "injected" || e.connectorType === "solana_adapter") && (this.detectedGeneric || e.chainType === "ethereum" && this.detectedEth || e.chainType === "solana" && this.detectedSol)))
    }
    listingOk(e) {
        if (e.slug.includes("coinbase")) return !1;
        if (this.chainFilter === "ethereum-only") {
            if (!this.isEth(e)) return !1
        } else if (this.chainFilter === "solana-only" && !this.isSol(e)) return !1;
        return !!this.inAllowList(e.slug, "listing")
    }
    getWallets(e, r) {
        var o;
        let n = new Map,
            i = c => {
                let l = n.get(c.id);
                if (l) {
                    l.chainType !== c.chainType && (l.chainType = "multi");
                    let u = new Set(l.chains);
                    c.chains.forEach(h => u.add(h)), l.chains = Array.from(u), !l.icon && c.icon && (l.icon = c.icon), !l.url && c.url && (l.url = c.url), !l.listing && c.listing && (l.listing = c.listing)
                } else n.set(c.id, c)
            };
        e.filter(c => this.connectorOk(c)).forEach(c => {
            var u, h;
            let l = ts.normalize(c.walletClientType);
            i({
                id: l,
                label: ((u = c.walletBranding) == null ? void 0 : u.name) ? ? l,
                source: "connector",
                connector: c,
                chainType: c.chainType,
                icon: typeof((h = c.walletBranding) == null ? void 0 : h.icon) == "string" ? c.walletBranding.icon : void 0,
                url: void 0,
                chains: [c.chainType === "ethereum" ? "eip155" : "solana"]
            })
        }), r.filter(c => this.listingOk(c)).forEach(c => {
            var f;
            let l = this.isEth(c),
                u = this.isSol(c),
                h = ts.normalize(c.slug);
            i({
                id: h,
                label: c.name || h,
                source: "listing",
                listing: c,
                chainType: l && u ? "multi" : l ? "ethereum" : "solana",
                icon: (f = c.image_url) == null ? void 0 : f.sm,
                url: c.homepage,
                chains: c.chains
            })
        });
        let s = Array.from(n.values()),
            a = new Map;
        return (o = this.normalizedAllowList) == null || o.forEach((c, l) => {
            a.set(ts.normalize(c), l)
        }), {
            wallets: s.slice().sort((c, l) => {
                let u = ts.normalize(c.id),
                    h = ts.normalize(l.id);
                u === "binanceus" || u === "binance-defi" ? u = "binance" : u === "universalprofiles" ? u = "universal_profile" : u === "cryptocom-defi" && (u = "cryptocom"), h === "binanceus" || h === "binance-defi" ? h = "binance" : h === "universalprofiles" ? h = "universal_profile" : h === "cryptocom-defi" && (h = "cryptocom");
                let f = a.has(u),
                    p = a.has(h);
                return f && p ? a.get(u) - a.get(h) : f ? -1 : p ? 1 : c.source === "connector" && l.source === "listing" ? -1 : c.source === "listing" && l.source === "connector" ? 1 : c.label.toLowerCase().localeCompare(l.label.toLowerCase())
            }),
            walletCount: s.length
        }
    }
    constructor(e, r) {
        var n, i, s, a;
        this.chainFilter = e, r && r.length > 0 && (this.normalizedAllowList = r.map(String)), this.detectedGeneric = ((n = this.normalizedAllowList) == null ? void 0 : n.includes("detected_wallets")) ? ? !1, this.detectedEth = ((i = this.normalizedAllowList) == null ? void 0 : i.includes("detected_ethereum_wallets")) ? ? !1, this.detectedSol = ((s = this.normalizedAllowList) == null ? void 0 : s.includes("detected_solana_wallets")) ? ? !1, this.includeWalletConnect = ((a = this.normalizedAllowList) == null ? void 0 : a.includes("wallet_connect")) ? ? !1
    }
}
const rIe = ({ ...t
    }) => d.jsx("svg", {
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...t,
        children: d.jsx("path", {
            d: "M4 12L12 4M4 4L12 12",
            stroke: "black",
            strokeOpacity: "0.8",
            strokeWidth: "1.5",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        })
    }),
    Og = {
        phantom: {
            mobile: {
                native: "phantom://",
                universal: "https://phantom.app/ul/"
            }
        },
        solflare: {
            mobile: {
                native: void 0,
                universal: "https://solflare.com/ul/v1/"
            }
        }
    };
var S4 = t => d.jsxs("svg", {
        viewBox: "0 0 32 32",
        xmlns: "http://www.w3.org/2000/svg",
        ...t,
        children: [d.jsx("path", {
            d: "m0 0h32v32h-32z",
            fill: "#5469d4"
        }), d.jsx("path", {
            d: "m15.997 5.333-.143.486v14.106l.143.143 6.548-3.87z",
            fill: "#c2ccf4"
        }), d.jsx("path", {
            d: "m15.996 5.333-6.548 10.865 6.548 3.87z",
            fill: "#fff"
        }), d.jsx("path", {
            d: "m15.997 21.306-.08.098v5.025l.08.236 6.552-9.227z",
            fill: "#c2ccf4"
        }), d.jsx("path", {
            d: "m15.996 26.665v-5.36l-6.548-3.867z",
            fill: "#fff"
        }), d.jsx("path", {
            d: "m15.995 20.07 6.548-3.87-6.548-2.976v6.847z",
            fill: "#8698e8"
        }), d.jsx("path", {
            d: "m9.448 16.2 6.548 3.87v-6.846z",
            fill: "#c2ccf4"
        })]
    }),
    T4 = t => d.jsxs("svg", {
        viewBox: "0 0 32 32",
        xmlns: "http://www.w3.org/2000/svg",
        ...t,
        children: [d.jsxs("linearGradient", {
            id: "a",
            gradientUnits: "userSpaceOnUse",
            x1: "7.233",
            x2: "24.766",
            y1: "24.766",
            y2: "7.234",
            children: [d.jsx("stop", {
                offset: "0",
                stopColor: "#9945ff"
            }), d.jsx("stop", {
                offset: ".2",
                stopColor: "#7962e7"
            }), d.jsx("stop", {
                offset: "1",
                stopColor: "#00d18c"
            })]
        }), d.jsx("path", {
            d: "m0 0h32v32h-32z",
            fill: "#10111a"
        }), d.jsx("path", {
            clipRule: "evenodd",
            d: "m9.873 20.41a.645.645 0 0 1 .476-.21l14.662.012a.323.323 0 0 1 .238.54l-3.123 3.438a.643.643 0 0 1 -.475.21l-14.662-.012a.323.323 0 0 1 -.238-.54zm15.376-2.862a.322.322 0 0 1 -.238.54l-14.662.012a.642.642 0 0 1 -.476-.21l-3.122-3.44a.323.323 0 0 1 .238-.54l14.662-.012a.644.644 0 0 1 .475.21zm-15.376-9.738a.644.644 0 0 1 .476-.21l14.662.012a.322.322 0 0 1 .238.54l-3.123 3.438a.643.643 0 0 1 -.475.21l-14.662-.012a.323.323 0 0 1 -.238-.54z",
            fill: "url(#a)",
            fillRule: "evenodd"
        })]
    });
const nIe = z.div.withConfig({
        displayName: "Header",
        componentId: "sc-5622aaf1-0"
    })(["display:flex;justify-content:space-between;align-items:center;"]),
    U$ = z.button.withConfig({
        displayName: "CloseButton",
        componentId: "sc-5622aaf1-1"
    })(["padding:0.25rem;height:30px;width:30px;display:flex;align-items:center;justify-content:center;border-radius:var(--privy-border-radius-full);background:var(--privy-color-background-2);"]),
    iIe = z.div.withConfig({
        displayName: "WalletIconWithActiveIndicator",
        componentId: "sc-5622aaf1-2"
    })(["position:relative;&::after{content:' ';border-radius:var(--privy-border-radius-full);height:6px;width:6px;background-color:var(--privy-color-success);position:absolute;right:-3px;bottom:-3px;}"]),
    Xf = z.img.withConfig({
        displayName: "WalletIcon",
        componentId: "sc-5622aaf1-3"
    })(["width:1.5rem;height:1.5rem;border-radius:0.25rem;object-fit:contain;"]),
    sIe = z.span.withConfig({
        displayName: "Chip",
        componentId: "sc-5622aaf1-4"
    })(["display:flex;gap:0.25rem;align-items:center;padding:0.25rem 0.5rem;font-size:0.75rem;font-weight:500;line-height:1.125rem;border-radius:var(--privy-border-radius-sm);background-color:var(--privy-color-background-3);svg{width:100%;max-width:1rem;max-height:1rem;stroke-width:2;}"]),
    aIe = z.div.withConfig({
        displayName: "ScrollContainer",
        componentId: "sc-5622aaf1-5"
    })(["display:flex;flex-direction:column;gap:0.5rem;max-height:24rem;overflow-y:scroll;&::-webkit-scrollbar{display:none;}scrollbar-gutter:stable both-edges;scrollbar-width:none;-ms-overflow-style:none;", " background-repeat:no-repeat;background-size:100% 32px,100% 16px;background-attachment:local,scroll;"], t => t.$colorScheme === "light" ? "background: linear-gradient(var(--privy-color-background), var(--privy-color-background) 70%) bottom, linear-gradient(rgba(0, 0, 0, 0) 20%, rgba(0, 0, 0, 0.06)) bottom;" : t.$colorScheme === "dark" ? "background: linear-gradient(var(--privy-color-background), var(--privy-color-background) 70%) bottom, linear-gradient(rgba(255, 255, 255, 0) 20%, rgba(255, 255, 255, 0.06)) bottom;" : void 0),
    oIe = vh(() => ({
        isModalOpen: !1,
        resolvers: null
    }));
vh(() => ({}));
const cIe = ({
        address: t,
        client: e,
        appId: r
    }) => {
        let n = `${e}:${t}`;
        r && rt.put(lIe(r), n), oIe.setState({
            wallet: n
        })
    },
    lIe = t => `privy:${t}:active-wallet-connection`;

function HF({
    walletList: t,
    walletChainType: e
}) {
    var m;
    let r = Gt(),
        {
            connectors: n
        } = $e(),
        i = N0(y => y.listings),
        s = e ? ? r.appearance.walletChainType,
        a = t ? ? ((m = r.appearance) == null ? void 0 : m.walletList),
        o = v.useMemo(() => new ts(s, a), [s, a]),
        {
            wallets: c,
            walletCount: l
        } = v.useMemo(() => o.getWallets(n, i), [o, n, i]),
        [u, h] = v.useState(""),
        f = v.useMemo(() => u ? c.filter(y => y.label.toLowerCase().includes(u.toLowerCase())) : c, [u, c]),
        [p, g] = v.useState();
    return {
        selected: p,
        setSelected: g,
        search: u,
        setSearch: h,
        wallets: f,
        walletCount: l
    }
}
let VF = t => !t || typeof t != "string" && (t instanceof h8 || t instanceof g8);
const P4 = ({
    index: t,
    style: e,
    data: r,
    recent: n
}) => {
    var c, l;
    let i = r.wallets[t],
        {
            walletChainType: s,
            handleWalletClick: a
        } = r,
        o = { ...e,
            boxSizing: "border-box"
        };
    return i ? d.jsxs(lm, {
        style: o,
        onClick: () => a(i),
        children: [i.icon && (i.connector && !VF(i.connector) ? d.jsx(iIe, {
            children: d.jsx(Xf, {
                src: i.icon
            })
        }) : d.jsx(Xf, {
            src: i.icon
        })), d.jsx(dm, {
            children: i.label
        }), n ? d.jsxs(d.Fragment, {
            children: [d.jsx(b1, {
                children: d.jsxs(d.Fragment, {
                    children: [s === "ethereum-only" && d.jsx(S4, {}), s === "solana-only" && d.jsx(T4, {})]
                })
            }), d.jsx(sIe, {
                children: "Recent"
            })]
        }) : d.jsx(b1, {
            children: !(s === "ethereum-only" || s === "solana-only") && d.jsxs(d.Fragment, {
                children: [((c = i.chains) == null ? void 0 : c.some(u => u.startsWith("eip155"))) && d.jsx(S4, {}), ((l = i.chains) == null ? void 0 : l.some(u => u.startsWith("solana"))) && d.jsx(T4, {})]
            })
        })]
    }) : null
};
var GF = ({
    showHeader: t = !0,
    className: e,
    suggestedAddress: r,
    customDescription: n,
    connectOnly: i,
    preSelectedWalletId: s,
    ...a
}) => {
    var U;
    let o = Gt(),
        {
            connectors: c
        } = $e(),
        l = a.walletChainType || o.appearance.walletChainType,
        u = a.walletList || ((U = o.appearance) == null ? void 0 : U.walletList),
        {
            onBack: h,
            onClose: f,
            app: p
        } = a,
        {
            selected: g,
            setSelected: m,
            qrUrl: y,
            setQrUrl: w,
            connecting: x,
            uiState: E,
            wallets: _,
            handleConnect: b,
            handleBack: A,
            showSearchBar: I,
            isInitialConnectView: T,
            title: C,
            search: $,
            setSearch: P
        } = function({
            onConnect: k,
            onBack: F,
            onClose: q,
            onConnectError: W,
            walletList: K,
            walletChainType: H,
            app: j
        }) {
            let V = Gt(),
                {
                    connectors: Y
                } = $e(),
                {
                    wallets: X,
                    walletCount: ne,
                    search: ae,
                    setSearch: ue,
                    selected: he,
                    setSelected: fe
                } = HF({
                    walletList: K,
                    walletChainType: H
                }),
                [de, ye] = v.useState(),
                [Be, ce] = v.useState(),
                [Ie, xe] = v.useState(),
                ie = !he && !Be && !Ie,
                Ee = ie && (ne > 6 || ae.length > 0),
                ft = Y.find(Ue => Ue.connectorType === "wallet_connect_v2"),
                Ae = v.useCallback(async (Ue, De) => {
                    if (Ue) {
                        if (ye("loading"), typeof Ue == "string") return xe({
                            connector: Ue,
                            name: (De == null ? void 0 : De.name) ? ? "Wallet",
                            icon: De == null ? void 0 : De.icon
                        }), void window.open(Ue, "_blank");
                        xe({
                            connector: Ue,
                            name: (De == null ? void 0 : De.name) ? ? Ue.walletBranding.name ? ? "Wallet",
                            icon: (De == null ? void 0 : De.icon) ? ? Ue.walletBranding.icon
                        });
                        try {
                            let We = await Ue.connect({
                                showPrompt: !0
                            });
                            if (!We) return ye("error"), void(W == null ? void 0 : W(new br("Unable to connect wallet")));
                            ye("success"), cIe({
                                address: We.address,
                                client: We.walletClientType,
                                appId: V.id
                            }), setTimeout(() => {
                                k({
                                    connector: Ue,
                                    wallet: We
                                })
                            }, Ir)
                        } catch {
                            ye("error"), W == null || W(new br("Unable to connect wallet"))
                        }
                    }
                }, [V.id, k]),
                Le = v.useCallback(() => Be ? (ye(void 0), xe(void 0), void ce(void 0)) : Ie ? (ye(void 0), void xe(void 0)) : he ? (ye(void 0), xe(void 0), void fe(void 0)) : de === "error" || de === "loading" ? (ye(void 0), void xe(void 0)) : void(F == null ? void 0 : F()), [Be, Ie, he, de, F]),
                Te = v.useMemo(() => (Ie == null ? void 0 : Ie.connector) === ft && Be && gr.isMobile ? `Go to ${Ie.name} to continue` : (Ie == null ? void 0 : Ie.connector) === ft && Be ? `Scan code to connect to ${Ie.name}` : typeof(Ie == null ? void 0 : Ie.connector) == "string" ? `Open or install ${Ie.name}` : he && !Ie ? "Select network" : Ie ? null : "Connect wallet", [Ie, Be, he, ft]);
            return {
                selected: he,
                setSelected: fe,
                qrUrl: Be,
                setQrUrl: ce,
                connecting: Ie,
                uiState: de,
                search: ae,
                setSearch: ue,
                wallets: X,
                walletCount: ne,
                wc: ft,
                isInitialConnectView: ie,
                showSearchBar: Ee,
                title: Te,
                handleConnect: Ae,
                handleBack: Le,
                onClose: q,
                onConnect: k,
                app: j
            }
        }({ ...a,
            walletList: u,
            walletChainType: l
        }),
        N = c.find(k => k.connectorType === "wallet_connect_v2"),
        R = _.length > 0,
        D = v.useRef(null),
        S = zce({
            count: _.length,
            getScrollElement: () => D.current,
            estimateSize: () => 54,
            overscan: 6,
            gap: 5
        }),
        O = v.useCallback(async k => {
            var H, j, V, Y, X, ne;
            let F, q = l !== "solana-only" && ((H = k.chains) == null ? void 0 : H.some(ae => ae.startsWith("eip155"))),
                W = l !== "ethereum-only" && ((j = k.chains) == null ? void 0 : j.some(ae => ae.startsWith("solana"))),
                K = p8[k.id];
            if (W && K) F = K.getMobileRedirect({
                isSolana: !0,
                connectOnly: !!i,
                useUniversalLink: !1
            });
            else {
                let ae = (Y = (V = k.listing) == null ? void 0 : V.mobile) == null ? void 0 : Y.native;
                F = ((ne = (X = k.listing) == null ? void 0 : X.mobile) == null ? void 0 : ne.universal) || ae || k.url
            }
            if (q && W) {
                let ae = ts.normalize(k.id),
                    ue = c.filter(de => ts.normalize(de.walletClientType) === ae && !(de.chainType === "ethereum" && de instanceof h8 || de.chainType === "solana" && de instanceof g8)),
                    he = ue.find(de => de.chainType === "ethereum"),
                    fe = ue.find(de => de.chainType === "solana");
                if (!he && k.listing) {
                    let de = Og[k.listing.slug] ? { ...k.listing,
                        ...Og[k.listing.slug]
                    } : k.listing;
                    N.setWalletEntry(de, w), await N.resetConnection(k.id), he = N
                }
                if (!fe && F && (fe = F), he || fe) return void m({
                    eth: he,
                    sol: fe,
                    name: k.label,
                    icon: k.icon
                })
            }
            if (VF(k.connector)) {
                if (q || W || k.url || k.listing) {
                    if (q && k.listing) {
                        let ae = Og[k.listing.slug] ? { ...k.listing,
                            ...Og[k.listing.slug]
                        } : k.listing;
                        N.setWalletEntry(ae, w), await N.resetConnection(k.id)
                    }
                    if (q && W) return void m({
                        eth: N,
                        sol: F,
                        name: k.label,
                        icon: k.icon
                    });
                    if (W) return void await b(F, {
                        name: k.label,
                        icon: k.icon
                    });
                    if (q) return void(k.listing ? await b(N, {
                        name: k.label,
                        icon: k.icon
                    }) : k.url ? await b(k.url, {
                        name: k.label,
                        icon: k.icon
                    }) : console.warn("Cannot connect to EVM wallet without connector or listing details:", k.label));
                    if (k.url) return void await b(k.url, {
                        name: k.label,
                        icon: k.icon
                    })
                }
            } else await b(k.connector, {
                name: k.label,
                icon: k.icon
            })
        }, [N, b, m, w, A, f, p, T, C, n, r, o, c]),
        M = s ? h : A;
    return v.useEffect(() => {
        if (!s) return;
        let k = _.find(({
            id: F
        }) => F === s);
        k && O(k).catch(console.error)
    }, [s]), d.jsxs("div", {
        className: e,
        children: [t && d.jsx(d.Fragment, {
            children: d.jsxs(nIe, {
                children: [h || !T ? d.jsx(U$, {
                    onClick: M,
                    children: d.jsx(tj, {
                        height: "1rem",
                        width: "1rem",
                        strokeWidth: 1.5
                    })
                }) : d.jsx("div", {}), d.jsx(U$, {
                    onClick: f,
                    children: d.jsx(rIe, {})
                })]
            })
        }), d.jsx(hIe, {
            title: t && C || "",
            description: x && !y && typeof x.connector == "string" ? `To connect to ${x.name}, install and open the app. Then confirm the connection when prompted.` : T ? n ? ? (r ? d.jsxs("span", {
                children: ["Connect the wallet with address ", d.jsx(Rt, {
                    address: r
                }), " ", p != null && p.name ? `to ${p.name}.` : "."]
            }) : p ? `Connect a wallet to your ${p.name} account` : null) : null
        }), I && d.jsxs(d.Fragment, {
            children: [d.jsxs(FF, {
                style: {
                    marginTop: "0.5rem",
                    background: "transparent"
                },
                children: [d.jsx(g_e, {}), d.jsx("input", {
                    className: "login-method-button",
                    type: "text",
                    placeholder: "Search wallets",
                    onChange: k => P(k.target.value),
                    value: $
                })]
            }), d.jsx(dIe, {})]
        }), d.jsxs(aIe, {
            ref: D,
            $colorScheme: o.appearance.palette.colorScheme,
            style: {
                marginBottom: y ? "0.5rem" : void 0
            },
            children: [y && d.jsxs(d.Fragment, {
                children: [gr.isMobile ? d.jsxs(F$, {
                    children: [x != null && x.icon ? d.jsx(w1, {
                        walletLogo: x.icon,
                        success: E === "success",
                        fail: E === "error"
                    }) : null, d.jsxs("h3", {
                        children: ["Waiting for ", (x == null ? void 0 : x.name) ? ? "connection"]
                    })]
                }) : d.jsx(U0, {
                    size: 280,
                    url: y.universal ? ? y.native,
                    squareLogoElement: x != null && x.icon ? typeof x.icon == "string" ? k => d.jsx("svg", { ...k,
                        children: d.jsx("image", {
                            href: x.icon,
                            height: k.height,
                            width: k.width
                        })
                    }) : x.icon : R9e
                }), gr.isMobile && E === "loading" && d.jsx(Qe, {
                    style: {
                        marginTop: "0.5rem"
                    },
                    onClick: () => window.open(y.universal ? ? y.native, "_blank"),
                    children: "Open in app"
                })]
            }), x && !y && typeof x.connector != "string" && d.jsxs(F$, {
                children: [x.icon ? d.jsx(w1, {
                    walletLogo: x.icon,
                    success: E === "success",
                    fail: E === "error"
                }) : null, d.jsxs("h3", {
                    children: ["Waiting for ", x.name]
                }), d.jsx($a, {
                    children: E === "error" ? "Please try connecting again." : "For the best experience, connect only one wallet at a time."
                }), E === "error" && d.jsx(Qe, {
                    style: {
                        marginTop: "1.5rem"
                    },
                    onClick: () => b(x.connector, {
                        name: x.name,
                        icon: x.icon
                    }),
                    children: "Retry"
                })]
            }), x && !y && typeof x.connector == "string" && d.jsx(d.Fragment, {
                children: d.jsxs(lm, {
                    onClick: () => window.open(x.connector, "_blank"),
                    children: [x.icon && (typeof x.icon == "string" ? d.jsx(Xf, {
                        src: x.icon
                    }) : d.jsx(x.icon, {})), d.jsx(dm, {
                        children: x.name
                    })]
                })
            }), (g == null ? void 0 : g.eth) && !x && d.jsxs(lm, {
                onClick: () => b(g.eth, {
                    name: g.name,
                    icon: g.icon
                }),
                children: [g.icon && (typeof g.icon == "string" ? d.jsx(Xf, {
                    src: g.icon
                }) : d.jsx(g.icon, {})), d.jsx(dm, {
                    children: g.name
                }), d.jsx(b1, {
                    children: d.jsx(S4, {})
                })]
            }), (g == null ? void 0 : g.sol) && !x && d.jsxs(lm, {
                onClick: () => b(g.sol, {
                    name: g.name,
                    icon: g.icon
                }),
                children: [g.icon && (typeof g.icon == "string" ? d.jsx(Xf, {
                    src: g.icon
                }) : d.jsx(g.icon, {})), d.jsx(dm, {
                    children: g.name
                }), d.jsx(b1, {
                    children: d.jsx(T4, {})
                })]
            }), T && d.jsxs(d.Fragment, {
                children: [!R && d.jsx(uIe, {
                    children: "No wallets found. Try another search."
                }), _.length > 0 && d.jsx("div", {
                    style: {
                        height: 54 * Math.min(_.length + 1, 5),
                        width: "100%"
                    },
                    children: d.jsx("div", {
                        style: {
                            height: `${S.getTotalSize()}px`,
                            width: "100%",
                            position: "relative"
                        },
                        children: S.getVirtualItems().map(k => d.jsx(P4, {
                            index: k.index,
                            style: {
                                position: "absolute",
                                top: 0,
                                left: 0,
                                height: `${k.size}px`,
                                transform: `translateY(${k.start}px)`
                            },
                            data: {
                                wallets: _,
                                walletChainType: l,
                                handleWalletClick: O
                            }
                        }, k.key))
                    })
                })]
            })]
        })]
    })
};
let lm = z.button.withConfig({
        displayName: "Button",
        componentId: "sc-a459b5ac-0"
    })(["button&{gap:0.5rem;align-items:center;display:flex;position:relative;text-align:left;font-weight:500;transition:background 200ms ease-in;width:calc(100% - 4px);border-radius:var(--privy-border-radius-mdlg);margin:0 2px;padding:1em;border:1px solid var(--privy-color-foreground-4);}svg{stroke-width:2.5;width:100%;max-height:1rem;max-width:1rem;flex-shrink:0;}&:hover{background:var(--privy-color-background-2);}"]),
    b1 = z.span.withConfig({
        displayName: "ButtonBadge",
        componentId: "sc-a459b5ac-1"
    })(["display:flex;align-items:center;justify-content:end;margin-left:auto;position:relative;& > svg{border-radius:var(--privy-border-radius-full);}& > svg:not(:last-child){border-radius:var(--privy-border-radius-full);margin-right:-0.375rem;}"]),
    F$ = z.div.withConfig({
        displayName: "ConnectContainer",
        componentId: "sc-a459b5ac-2"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;h3{margin-top:1.5rem;font-size:1rem;font-weight:500;line-height:1.5rem;}"]),
    dIe = z.div.withConfig({
        displayName: "SearchDivider",
        componentId: "sc-a459b5ac-3"
    })(["width:100%;height:0.5rem;"]),
    uIe = z.div.withConfig({
        displayName: "EmptyContainer",
        componentId: "sc-a459b5ac-4"
    })(["height:60px;display:flex;align-items:center;justify-content:center;text-align:center;"]),
    dm = z.span.withConfig({
        displayName: "WalletName",
        componentId: "sc-a459b5ac-5"
    })(["text-overflow:ellipsis;white-space:nowrap;"]),
    hIe = z($r).withConfig({
        displayName: "StyledCenteredScreenHeader",
        componentId: "sc-a459b5ac-6"
    })(["gap:8px;margin-bottom:8px;h3{margin-bottom:0;}"]);
const fIe = ({ ...t
    }) => d.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "25",
        height: "25",
        viewBox: "0 0 25 25",
        fill: "none",
        ...t,
        children: [d.jsxs("g", {
            clipPath: "url(#clip0_2856_1743)",
            children: [d.jsx("path", {
                d: "M22.1673 8.24075V16.3642C22.1673 17.3256 21.3421 18.105 20.3241 18.105H17.0028M22.1673 8.24075C22.1673 7.27936 21.3421 6.5 20.3241 6.5H11.5302M22.1673 8.24075V8.42852C22.1673 9.03302 21.8352 9.59423 21.2901 9.91105L15.1463 13.4818C14.5539 13.8261 13.8067 13.8261 13.2143 13.4818L10.1621 11.5401",
                stroke: "currentColor",
                strokeWidth: "1.5",
                strokeLinecap: "round",
                strokeLinejoin: "round"
            }), d.jsx("path", {
                d: "M3.12913 6.64816C0.508085 12.9507 3.49251 20.1847 9.79504 22.8057L11.5068 23.5176C12.4522 23.9108 13.7783 23.2222 14.1714 22.2768L14.6054 21.2333C14.7687 20.8406 14.6438 20.3871 14.3024 20.1334L11.2872 17.8927C10.9878 17.6702 10.5843 17.6488 10.2632 17.8384L9.11575 18.5156C8.78274 18.7121 8.3597 18.6844 8.07552 18.4221C5.94293 16.4542 4.77629 13.6264 4.90096 10.7273C4.91757 10.3409 5.19796 10.023 5.57269 9.92753L6.86381 9.59869C7.22522 9.50664 7.49627 9.20696 7.55169 8.83815L8.10986 5.12321C8.17306 4.70259 7.94188 4.29293 7.54915 4.1296L6.50564 3.69564C5.56026 3.30248 4.23416 3.99103 3.84101 4.9364L3.12913 6.64816Z",
                stroke: "currentColor",
                strokeWidth: "1.5",
                strokeLinecap: "round",
                strokeLinejoin: "round"
            })]
        }), d.jsx("defs", {
            children: d.jsx("clipPath", {
                id: "clip0_2856_1743",
                children: d.jsx("rect", {
                    x: "0.5",
                    y: "0.5",
                    width: "24",
                    height: "24",
                    rx: "6",
                    fill: "white"
                })
            })
        })]
    }),
    um = {
        component: () => {
            var u, h, f, p, g, m;
            let {
                setWalletConnectionStatus: t,
                closePrivyModal: e
            } = $e(), {
                app: r,
                data: n,
                navigate: i
            } = Ne(), s = yc(), a = (u = n == null ? void 0 : n.externalConnectWallet) == null ? void 0 : u.description, o = v.useRef((h = n == null ? void 0 : n.externalConnectWallet) == null ? void 0 : h.suggestedAddress).current, c = v.useRef(((f = n == null ? void 0 : n.externalConnectWallet) == null ? void 0 : f.walletList) ? ? r.appearance.walletList), l = v.useRef(((p = n == null ? void 0 : n.externalConnectWallet) == null ? void 0 : p.walletChainType) ? ? r.appearance.walletChainType);
            return d.jsxs(d.Fragment, {
                children: [d.jsx(pIe, {
                    walletList: c.current,
                    walletChainType: l.current,
                    onClose: e,
                    onConnect: v.useCallback(({
                        connector: y,
                        wallet: w
                    }) => {
                        var x;
                        s("connectWallet", "onSuccess", {
                            wallet: w
                        }), t({
                            status: "connected",
                            connectedWallet: w,
                            connector: y,
                            connectError: null,
                            connectRetry: () => null
                        }), i(Yo, !((x = n == null ? void 0 : n.externalConnectWallet) != null && x.preSelectedWalletId))
                    }, [t, i, (g = n == null ? void 0 : n.externalConnectWallet) == null ? void 0 : g.preSelectedWalletId]),
                    onConnectError: y => {
                        y instanceof Qn ? (console.warn(y.cause ? y.cause : y.message), s("connectWallet", "onError", y.privyErrorCode || ee.GENERIC_CONNECT_WALLET_ERROR)) : (console.warn(y), s("connectWallet", "onError", ee.UNKNOWN_CONNECT_WALLET_ERROR))
                    },
                    onBack: () => i(Xn),
                    suggestedAddress: o,
                    customDescription: a || "",
                    preSelectedWalletId: (m = n == null ? void 0 : n.externalConnectWallet) == null ? void 0 : m.preSelectedWalletId,
                    app: r
                }), r && d.jsx(Yy, {
                    app: r
                }), d.jsx(ot, {})]
            })
        },
        isUnauthenticatedScreem: !0
    };
let pIe = z(GF).withConfig({
    displayName: "StyledConnectWalletView",
    componentId: "sc-5838b4b8-0"
})(["padding:0;padding-top:1em;"]);
const N4 = {
    component: () => {
        var c, l, u, h;
        let {
            closePrivyModal: t
        } = $e(), {
            app: e,
            data: r
        } = Ne(), n = yc(), i = (c = r == null ? void 0 : r.externalConnectWallet) == null ? void 0 : c.description, s = v.useRef((l = r == null ? void 0 : r.externalConnectWallet) == null ? void 0 : l.suggestedAddress).current, a = v.useRef(((u = r == null ? void 0 : r.externalConnectWallet) == null ? void 0 : u.walletList) ? ? e.appearance.walletList), o = v.useRef(((h = r == null ? void 0 : r.externalConnectWallet) == null ? void 0 : h.walletChainType) ? ? e.appearance.walletChainType);
        return d.jsxs(d.Fragment, {
            children: [d.jsx(gIe, {
                connectOnly: !0,
                walletList: a.current,
                walletChainType: o.current,
                onClose: () => {
                    n("connectWallet", "onError", ee.GENERIC_CONNECT_WALLET_ERROR), t().catch(console.error)
                },
                onConnect: ({
                    wallet: f
                }) => {
                    n("connectWallet", "onSuccess", {
                        wallet: f
                    }), t().catch(console.error)
                },
                onConnectError: f => {
                    f instanceof Qn ? (console.warn(f.cause ? f.cause : f.message), n("connectWallet", "onError", f.privyErrorCode || ee.GENERIC_CONNECT_WALLET_ERROR)) : (console.warn(f), n("connectWallet", "onError", ee.UNKNOWN_CONNECT_WALLET_ERROR))
                },
                suggestedAddress: s,
                customDescription: i,
                app: e
            }), e && d.jsx(Yy, {
                app: e,
                alwaysShowImplicitConsent: !0
            }), d.jsx(ot, {})]
        })
    },
    isUnauthenticatedScreem: !0
};
let gIe = z(GF).withConfig({
    displayName: "StyledConnectWalletView",
    componentId: "sc-6059beb7-0"
})(["padding:0;padding-top:1em;"]);
const O4 = ({
    chainType: t,
    withPadding: e
}) => {
    let r = "";
    return r = t === "ethereum-only" || t === "ethereum-and-solana" ? "Rainbow, Phantom, or Coinbase Wallet" : "Phantom or Solflare", d.jsx(Q9e, {
        $withPadding: e,
        children: d.jsxs(X9e, {
            children: [d.jsx(Ql, {
                style: {
                    color: "var(--privy-color-warn)",
                    height: 48,
                    width: 48
                }
            }), d.jsx("h3", {
                children: "No wallets available"
            }), d.jsxs("p", {
                children: ["Please download an external wallet provider, like ", r, "."]
            })]
        })
    }, "empty-wallet-state")
};
let mIe = ES(["from,to{background:var(--privy-color-foreground-4);color:var(--privy-color-foreground-4);}50%{background:var(--privy-color-foreground-accent);color:var(--privy-color-foreground-accent);}"]);
const uw = pi(["", ""], t => t.$isLoading ? pi(["width:35%;animation:", " 2s linear infinite;border-radius:var(--privy-border-radius-sm);"], mIe) : ""),
    Ta = ({
        children: t,
        color: e,
        isLoading: r,
        isPulsing: n,
        ...i
    }) => d.jsx(yIe, {
        $color: e,
        $isLoading: r,
        $isPulsing: n,
        ...i,
        children: t
    });
let yIe = z.span.withConfig({
    displayName: "StyledSpan",
    componentId: "sc-eba15c9-0"
})(["padding:0.125rem 0.5rem;font-size:0.75rem;font-weight:500;line-height:1.125rem;border-radius:var(--privy-border-radius-sm);display:flex;align-items:center;", " ", ""], t => {
    let e, r;
    t.$color === "green" && (e = "var(--privy-color-success-dark)", r = "var(--privy-color-success-light)"), t.$color === "red" && (e = "var(--privy-color-error)", r = "var(--privy-color-error-light)"), t.$color === "gray" && (e = "var(--privy-color-foreground-2)", r = "var(--privy-color-background-2)");
    let n = ES(["from,to{background-color:", ";}50%{background-color:rgba(", ",0.8);}"], r, r);
    return pi(["color:", ";background-color:", ";", ";"], e, r, t.$isPulsing && pi(["animation:", " 3s linear infinite;"], n))
}, uw);
const rd = ({
        style: t,
        ...e
    }) => d.jsxs("svg", {
        width: "1000",
        height: "1000",
        viewBox: "0 0 1000 1000",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: {
            height: "24px",
            ...t
        },
        ...e,
        children: [d.jsx("rect", {
            width: "1000",
            height: "1000",
            rx: "200",
            fill: "#855DCD"
        }), d.jsx("path", {
            d: "M257.778 155.556H742.222V844.444H671.111V528.889H670.414C662.554 441.677 589.258 373.333 500 373.333C410.742 373.333 337.446 441.677 329.586 528.889H328.889V844.444H257.778V155.556Z",
            fill: "white"
        }), d.jsx("path", {
            d: "M128.889 253.333L157.778 351.111H182.222V746.667C169.949 746.667 160 756.616 160 768.889V795.556H155.556C143.283 795.556 133.333 805.505 133.333 817.778V844.444H382.222V817.778C382.222 805.505 372.273 795.556 360 795.556H355.556V768.889C355.556 756.616 345.606 746.667 333.333 746.667H306.667V253.333H128.889Z",
            fill: "white"
        }), d.jsx("path", {
            d: "M675.556 746.667C663.283 746.667 653.333 756.616 653.333 768.889V795.556H648.889C636.616 795.556 626.667 805.505 626.667 817.778V844.444H875.556V817.778C875.556 805.505 865.606 795.556 853.333 795.556H848.889V768.889C848.889 756.616 838.94 746.667 826.667 746.667V351.111H851.111L880 253.333H702.222V746.667H675.556Z",
            fill: "white"
        })]
    }),
    KF = ({
        style: t,
        color: e,
        ...r
    }) => d.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: "1.5",
        stroke: e || "currentColor",
        style: {
            height: "1.5rem",
            width: "1.5rem",
            ...t
        },
        ...r,
        children: d.jsx("path", {
            strokeLinecap: "round",
            strokeLinejoin: "round",
            d: "M4.5 12.75l6 6 9-13.5"
        })
    }),
    wIe = ({
        color: t,
        ...e
    }) => d.jsx("svg", {
        version: "1.1",
        id: "Layer_1",
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        x: "0px",
        y: "0px",
        viewBox: "0 0 115.77 122.88",
        xmlSpace: "preserve",
        ...e,
        children: d.jsx("g", {
            children: d.jsx("path", {
                fill: t || "currentColor",
                className: "st0",
                d: "M89.62,13.96v7.73h12.19h0.01v0.02c3.85,0.01,7.34,1.57,9.86,4.1c2.5,2.51,4.06,5.98,4.07,9.82h0.02v0.02 v73.27v0.01h-0.02c-0.01,3.84-1.57,7.33-4.1,9.86c-2.51,2.5-5.98,4.06-9.82,4.07v0.02h-0.02h-61.7H40.1v-0.02 c-3.84-0.01-7.34-1.57-9.86-4.1c-2.5-2.51-4.06-5.98-4.07-9.82h-0.02v-0.02V92.51H13.96h-0.01v-0.02c-3.84-0.01-7.34-1.57-9.86-4.1 c-2.5-2.51-4.06-5.98-4.07-9.82H0v-0.02V13.96v-0.01h0.02c0.01-3.85,1.58-7.34,4.1-9.86c2.51-2.5,5.98-4.06,9.82-4.07V0h0.02h61.7 h0.01v0.02c3.85,0.01,7.34,1.57,9.86,4.1c2.5,2.51,4.06,5.98,4.07,9.82h0.02V13.96L89.62,13.96z M79.04,21.69v-7.73v-0.02h0.02 c0-0.91-0.39-1.75-1.01-2.37c-0.61-0.61-1.46-1-2.37-1v0.02h-0.01h-61.7h-0.02v-0.02c-0.91,0-1.75,0.39-2.37,1.01 c-0.61,0.61-1,1.46-1,2.37h0.02v0.01v64.59v0.02h-0.02c0,0.91,0.39,1.75,1.01,2.37c0.61,0.61,1.46,1,2.37,1v-0.02h0.01h12.19V35.65 v-0.01h0.02c0.01-3.85,1.58-7.34,4.1-9.86c2.51-2.5,5.98-4.06,9.82-4.07v-0.02h0.02H79.04L79.04,21.69z M105.18,108.92V35.65v-0.02 h0.02c0-0.91-0.39-1.75-1.01-2.37c-0.61-0.61-1.46-1-2.37-1v0.02h-0.01h-61.7h-0.02v-0.02c-0.91,0-1.75,0.39-2.37,1.01 c-0.61,0.61-1,1.46-1,2.37h0.02v0.01v73.27v0.02h-0.02c0,0.91,0.39,1.75,1.01,2.37c0.61,0.61,1.46,1,2.37,1v-0.02h0.01h61.7h0.02 v0.02c0.91,0,1.75-0.39,2.37-1.01c0.61-0.61,1-1.46,1-2.37h-0.02V108.92L105.18,108.92z"
            })
        })
    }),
    hw = t => {
        let [e, r] = v.useState(!1);
        return d.jsxs(bIe, {
            color: t.color,
            onClick: () => {
                r(!0), navigator.clipboard.writeText(t.text), setTimeout(() => r(!1), 1500)
            },
            $justCopied: e,
            children: [e ? d.jsx(KF, {
                style: {
                    height: "14px",
                    width: "14px"
                },
                strokeWidth: "2"
            }) : d.jsx(wIe, {
                style: {
                    height: "14px",
                    width: "14px"
                }
            }), e ? "Copied" : "Copy", " ", t.itemName ? t.itemName : "to Clipboard"]
        })
    };
let bIe = z.button.withConfig({
    displayName: "StyledCopytoClipboardButton",
    componentId: "sc-46f4187f-0"
})(["display:flex;align-items:center;gap:6px;&&{margin:8px 2px;font-size:14px;color:", ";font-weight:", ";transition:color 350ms ease;:focus,:active{background-color:transparent;border:none;outline:none;box-shadow:none;}:hover{color:", ";}:active{color:'var(--privy-color-foreground)';font-weight:medium;}@media (max-width:440px){margin:12px 2px;}}svg{width:14px;height:14px;}"], t => t.$justCopied ? "var(--privy-color-foreground)" : t.color || "var(--privy-color-foreground-3)", t => t.$justCopied ? "medium" : "normal", t => t.$justCopied ? "var(--privy-color-foreground)" : "var(--privy-color-foreground-2)");
const YF = t => {
    let [e, r] = v.useState(!1);
    return d.jsx(vIe, {
        color: t.color,
        href: t.url,
        target: "_blank",
        rel: "noreferrer noopener",
        onClick: () => {
            r(!0), setTimeout(() => r(!1), 1500)
        },
        justOpened: e,
        children: t.text
    })
};
let vIe = z.a.withConfig({
        displayName: "StyledOpenLinkButton",
        componentId: "sc-4e695c83-0"
    })(["display:flex;align-items:center;gap:6px;&&{margin:8px 2px;font-size:14px;color:", ";font-weight:", ";transition:color 350ms ease;:focus,:active{background-color:transparent;border:none;outline:none;box-shadow:none;}:hover{color:", ";}:active{color:'var(--privy-color-foreground)';font-weight:medium;}@media (max-width:440px){margin:12px 2px;}}svg{width:14px;height:14px;}"], t => t.justOpened ? "var(--privy-color-foreground)" : t.color || "var(--privy-color-foreground-3)", t => t.justOpened ? "medium" : "normal", t => t.justOpened ? "var(--privy-color-foreground)" : "var(--privy-color-foreground-2)"),
    B$ = "#8a63d2";
const j4 = {
    component: () => {
        let {
            authenticated: t,
            logout: e,
            ready: r,
            user: n
        } = $t(), {
            lastScreen: i,
            navigate: s,
            navigateBack: a,
            setModalData: o,
            app: c
        } = Ne(), {
            getAuthFlow: l,
            loginWithFarcaster: u,
            closePrivyModal: h,
            createAnalyticsEvent: f
        } = $e(), [p, g] = v.useState(void 0), [m, y] = v.useState(!1), [w, x] = v.useState(!1), E = v.useRef([]), _ = l(), b = _ == null ? void 0 : _.meta.connectUri;
        return v.useEffect(() => {
            let A = Date.now(),
                I = setInterval(async () => {
                    var $, P, N, R, D, S, O, M, U, k, F, q, W, K, H;
                    let T = await _.pollForReady.execute(),
                        C = Date.now() - A;
                    if (T) {
                        clearInterval(I), y(!0);
                        try {
                            await u(), x(!0)
                        } catch (j) {
                            let V = {
                                retryable: !1,
                                message: "Authentication failed"
                            };
                            if ((j == null ? void 0 : j.privyErrorCode) === ee.ALLOWLIST_REJECTED) return void s(dw);
                            if ((j == null ? void 0 : j.privyErrorCode) === ee.USER_LIMIT_REACHED) return console.error(new l0(j).toString()), void s(F0);
                            if ((j == null ? void 0 : j.privyErrorCode) === ee.USER_DOES_NOT_EXIST) return void s(D0);
                            if ((j == null ? void 0 : j.privyErrorCode) === ee.LINKED_TO_ANOTHER_USER) V.detail = j.message ? ? "This account has already been linked to another user.";
                            else {
                                if ((j == null ? void 0 : j.privyErrorCode) === ee.ACCOUNT_TRANSFER_REQUIRED && ((P = ($ = j.data) == null ? void 0 : $.data) != null && P.nonce)) return o({
                                    accountTransfer: {
                                        nonce: (R = (N = j.data) == null ? void 0 : N.data) == null ? void 0 : R.nonce,
                                        account: (S = (D = j.data) == null ? void 0 : D.data) == null ? void 0 : S.subject,
                                        displayName: (U = (M = (O = j.data) == null ? void 0 : O.data) == null ? void 0 : M.account) == null ? void 0 : U.displayName,
                                        linkMethod: "farcaster",
                                        embeddedWalletAddress: (q = (F = (k = j.data) == null ? void 0 : k.data) == null ? void 0 : F.otherUser) == null ? void 0 : q.embeddedWalletAddress,
                                        farcasterEmbeddedAddress: (H = (K = (W = j.data) == null ? void 0 : W.data) == null ? void 0 : K.otherUser) == null ? void 0 : H.farcasterEmbeddedAddress
                                    }
                                }), void s(qd);
                                (j == null ? void 0 : j.privyErrorCode) === ee.INVALID_CREDENTIALS ? (V.retryable = !0, V.detail = "Something went wrong. Try again.") : (j == null ? void 0 : j.privyErrorCode) === ee.TOO_MANY_REQUESTS && (V.detail = "Too many requests. Please wait before trying again.")
                            }
                            g(V)
                        }
                    } else C > 12e4 && (clearInterval(I), g({
                        retryable: !0,
                        message: "Authentication failed",
                        detail: "The request timed out. Try again."
                    }))
                }, 2e3);
            return () => {
                clearInterval(I), E.current.forEach(T => clearTimeout(T))
            }
        }, []), v.useEffect(() => {
            if (r && t && w && n) {
                if (c != null && c.legal.requireUsersAcceptTerms && !n.hasAcceptedTerms) {
                    let A = setTimeout(() => {
                        s(Hd)
                    }, Ir);
                    return () => clearTimeout(A)
                }
                w && (yl(n, c.embeddedWallets) ? E.current.push(setTimeout(() => {
                    o({
                        createWallet: {
                            onSuccess: () => {},
                            onFailure: A => {
                                console.error(A), f({
                                    eventName: "embedded_wallet_creation_failure_logout",
                                    payload: {
                                        error: A,
                                        screen: "FarcasterConnectStatusScreen"
                                    }
                                }), e()
                            },
                            callAuthOnSuccessOnClose: !0
                        }
                    }), s(bc)
                }, Ir)) : E.current.push(setTimeout(() => h({
                    shouldCallAuthOnSuccess: !0,
                    isSuccess: !0
                }), Ir)))
            }
        }, [w, r, t, n]), d.jsxs(d.Fragment, gr.isMobile || m ? {
            children: [d.jsx(Pe, {
                backFn: i ? a : void 0,
                onClose: h
            }, "header"), d.jsx(er, {}), d.jsx(d.Fragment, gr.isIOS ? {
                children: d.jsxs(xIe, {
                    children: [d.jsx(Fi, {
                        children: d.jsxs("div", {
                            children: [d.jsx(Ia, {
                                success: w,
                                fail: !!p
                            }), d.jsx(rd, {
                                style: {
                                    width: "38px",
                                    height: "38px"
                                }
                            })]
                        })
                    }), d.jsxs(ls, {
                        children: [d.jsx(Cr, {
                            children: p ? p.message : "Sign in with Farcaster"
                        }), d.jsx(Ar, {
                            children: p ? p.detail : "To sign in with Farcaster, please open the Farcaster app."
                        })]
                    }), b && d.jsx(Qe, {
                        onClick: A => {
                            A.preventDefault(), window.location.href = b
                        },
                        children: "Open Farcaster app"
                    })]
                })
            } : {
                children: d.jsxs(W$, {
                    children: [d.jsx(Fi, {
                        children: d.jsxs("div", {
                            children: [d.jsx(Ia, {
                                success: w,
                                fail: !!p
                            }), d.jsx(rd, {
                                style: {
                                    width: "38px",
                                    height: "38px"
                                }
                            })]
                        })
                    }), d.jsxs(ls, {
                        children: [d.jsx(Cr, {
                            children: p ? p.message : "Signing in with Farcaster"
                        }), d.jsx(Ar, {
                            children: p ? p.detail : "This should only take a moment"
                        }), d.jsx(ol, {
                            children: b && gr.isMobile && d.jsx(YF, {
                                text: "Take me to Farcaster",
                                url: b,
                                color: B$
                            })
                        })]
                    })]
                })
            }), d.jsx(Wt, {})]
        } : {
            children: [d.jsx(Pe, {
                backFn: i ? a : void 0,
                onClose: h
            }, "header"), d.jsx(er, {}), d.jsx(W$, {
                children: d.jsxs("div", {
                    children: [d.jsx(Cr, {
                        children: "Sign in with Farcaster"
                    }), d.jsx(Ar, {
                        children: "Scan with your phone's camera to continue."
                    }), d.jsx(_8, {
                        children: b ? d.jsx(U0, {
                            url: b,
                            size: 275,
                            squareLogoElement: rd
                        }) : d.jsx(Ls, {})
                    }), d.jsxs(ol, {
                        children: [d.jsx(Ar, {
                            children: "Or copy this link and paste it into a phone browser to open the Farcaster app."
                        }), b && d.jsx(hw, {
                            text: b,
                            itemName: "link",
                            color: B$
                        })]
                    })]
                })
            }), d.jsx(Wt, {})]
        })
    }
};
let W$ = z.div.withConfig({
        displayName: "ConnectContainer",
        componentId: "sc-fb1f34c9-0"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;margin-left:27px;margin-right:27px;gap:24px;"]),
    xIe = z.div.withConfig({
        displayName: "ConnectContainerButton",
        componentId: "sc-fb1f34c9-1"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;width:100%;"]);
const ZF = () => {
    let [t, e] = v.useState(!1), {
        currentScreen: r,
        navigate: n,
        setModalData: i,
        data: s
    } = Ne(), {
        enabled: a,
        token: o
    } = qi(), {
        initLoginWithFarcaster: c
    } = $e(), {
        accountType: l
    } = ml();
    return d.jsxs(Pr, {
        onClick: async () => {
            var u;
            e(!0);
            try {
                a && !o ? (i({
                    captchaModalData: {
                        callback: h => {
                            var f;
                            return c(h, (f = s == null ? void 0 : s.login) == null ? void 0 : f.disableSignup)
                        },
                        userIntentRequired: !0,
                        onSuccessNavigateTo: j4,
                        onErrorNavigateTo: Sr
                    }
                }), n(Sa)) : (await c(o, (u = s == null ? void 0 : s.login) == null ? void 0 : u.disableSignup), n(j4))
            } catch (h) {
                i({
                    errorModalData: {
                        error: h,
                        previousScreen: r || Xn
                    }
                }), n(Sr)
            } finally {
                e(!1)
            }
        },
        disabled: !1,
        children: [d.jsx(rd, {}), " Farcaster", t && d.jsx(pl, {}), l === "farcaster" && d.jsx(EIe, {
            color: "gray",
            children: "Recent"
        })]
    })
};
let EIe = z(Ta).withConfig({
    displayName: "StyledChip",
    componentId: "sc-30c9632d-0"
})(["margin-left:auto;"]);
const B0 = ({
        style: t,
        ...e
    }) => d.jsxs("svg", {
        x: 0,
        y: 0,
        width: "65",
        height: "64",
        viewBox: "0 0 65 64",
        style: {
            height: "64px",
            width: "65px",
            ...t
        },
        xmlns: "http://www.w3.org/2000/svg",
        ...e,
        children: [d.jsxs("g", {
            clipPath: "url(#clip0_113_33841)",
            children: [d.jsx("path", {
                d: "M39.1193 0.943398C34.636 -0.174912 29.9185 -0.334713 25.328 0.656273C24.9732 0.732859 24.7477 1.08253 24.8243 1.43729C24.9009 1.79205 25.2506 2.01756 25.6053 1.94097C30.0015 0.991934 34.53 1.14842 38.8375 2.22802C49.1385 4.80983 57.7129 12.5548 60.9786 22.6718C62.2416 26.5843 62.7781 30.7505 62.8855 35.1167C62.8945 35.4795 63.1958 35.7664 63.5586 35.7575C63.9215 35.7485 64.2083 35.4472 64.1994 35.0843C64.0905 30.6582 63.5477 26.3849 62.2536 22.3432C58.8621 11.7515 49.9005 3.63265 39.1193 0.943398Z"
            }), d.jsx("path", {
                d: "M21.9931 2.93163C22.343 2.83511 22.5484 2.47325 22.4518 2.12339C22.3553 1.77352 21.9935 1.56815 21.6436 1.66466C16.8429 2.98903 10.0898 7.56519 5.91628 13.6786C5.91465 13.681 5.91304 13.6834 5.91145 13.6858C2.24684 19.2083 -0.0503572 26.1484 0.591012 32.8828C0.591623 32.8892 0.592328 32.8956 0.593127 32.902C0.746837 34.1317 1.00488 35.3591 1.26323 36.5879C1.80735 39.1761 2.35282 41.7706 1.92765 44.4064C1.86986 44.7647 2.11347 45.102 2.47177 45.1598C2.83007 45.2176 3.16738 44.974 3.22518 44.6157C3.66961 41.8605 3.11776 39.173 2.56581 36.4851C2.31054 35.2419 2.05525 33.9987 1.89847 32.7486C1.29525 26.3851 3.46802 19.7466 7.00418 14.416C11.0189 8.5373 17.5201 4.16562 21.9931 2.93163Z"
            }), d.jsx("path", {
                d: "M30.6166 4.39985C38.8671 3.89603 47.1159 7.26314 52.6556 13.7139C52.8921 13.9893 52.8605 14.4042 52.5852 14.6406C52.3099 14.8771 51.895 14.8455 51.6585 14.5702C46.3904 8.43576 38.541 5.23144 30.6927 5.71195C30.6899 5.71212 30.6871 5.71227 30.6843 5.71241C20.7592 6.19265 11.4643 12.9257 8.04547 22.3603C7.92183 22.7016 7.54498 22.8779 7.20375 22.7543C6.86253 22.6306 6.68616 22.2538 6.80981 21.9126C10.4114 11.9735 20.1717 4.90702 30.6166 4.39985Z"
            }), d.jsx("path", {
                d: "M54.6576 16.5848C54.4553 16.2836 54.047 16.2033 53.7457 16.4057C53.4444 16.608 53.3642 17.0163 53.5665 17.3176C56.6376 21.8904 57.9074 26.8665 58.4094 32.7717C58.4401 33.1333 58.7582 33.4016 59.1199 33.3708C59.4815 33.3401 59.7497 33.022 59.719 32.6604C59.206 26.6261 57.8965 21.4076 54.6576 16.5848Z"
            }), d.jsx("path", {
                d: "M59.2796 35.4504C59.6419 35.4277 59.9539 35.703 59.9765 36.0653C60.2242 40.0279 60.2265 44.5112 59.7881 47.8243C59.7405 48.1841 59.4102 48.4372 59.0504 48.3896C58.6906 48.342 58.4376 48.0117 58.4852 47.6519C58.9077 44.4586 58.91 40.0704 58.6648 36.1473C58.6421 35.785 58.9174 35.473 59.2796 35.4504Z"
            }), d.jsx("path", {
                d: "M7.05311 25.5432C7.13829 25.1904 6.92135 24.8354 6.56855 24.7502C6.21576 24.665 5.86071 24.882 5.77553 25.2348C5.2932 27.2325 5.0428 29.2847 5.03288 31.3388C5.02266 33.4559 5.41742 35.5225 5.81234 37.5899C6.1354 39.2811 6.45855 40.9728 6.5602 42.6932C6.69373 44.9531 6.21839 47.2163 5.39698 49.3703C5.26766 49.7094 5.43774 50.0891 5.77685 50.2184C6.11596 50.3477 6.4957 50.1777 6.62502 49.8386C7.49325 47.5617 8.01954 45.1092 7.87221 42.6157C7.77126 40.9071 7.44813 39.2252 7.12512 37.5439C6.73099 35.4925 6.33704 33.442 6.34716 31.3451C6.35659 29.3933 6.59455 27.4425 7.05311 25.5432Z"
            }), d.jsx("path", {
                d: "M24.2964 10.94C24.4317 11.2768 24.2683 11.6595 23.9315 11.7947C17.1187 14.5307 12.0027 20.7047 10.959 27.9852C10.523 31.0269 10.9941 34.0398 11.465 37.052C11.7303 38.7483 11.9954 40.4443 12.0985 42.1451C12.3221 45.833 11.902 49.8839 9.50192 53.5696C9.30387 53.8737 8.89677 53.9597 8.59264 53.7617C8.28851 53.5636 8.20251 53.1565 8.40056 52.8524C10.5873 49.4944 11.0012 45.7644 10.7867 42.2246C10.6821 40.499 10.4185 38.7833 10.1552 37.0686C9.68265 33.9923 9.21067 30.9195 9.65804 27.7987C10.7724 20.025 16.221 13.4748 23.4417 10.5751C23.7785 10.4399 24.1612 10.6032 24.2964 10.94Z"
            }), d.jsx("path", {
                d: "M47.3662 14.6814C41.9915 9.64741 34.2017 7.89046 27.122 9.4433C26.7675 9.52105 26.5432 9.87147 26.6209 10.226C26.6987 10.5805 27.0491 10.8048 27.4036 10.7271C34.1075 9.25665 41.4426 10.934 46.4677 15.6406C50.7033 19.6077 53.1628 25.38 53.8066 31.6779C53.8435 32.0389 54.1661 32.3017 54.5272 32.2648C54.8883 32.2279 55.151 31.9053 55.1141 31.5442C54.4456 25.0047 51.8822 18.9111 47.3662 14.6814Z"
            }), d.jsx("path", {
                d: "M54.9766 34.6738C55.3376 34.6368 55.6604 34.8994 55.6975 35.2604C56.3216 41.337 56.0526 47.9003 55.1104 54.2496C55.0571 54.6086 54.7229 54.8565 54.3639 54.8032C54.0049 54.7499 53.7571 54.4157 53.8103 54.0567C54.7394 47.7957 55.001 41.3439 54.39 35.3947C54.353 35.0336 54.6156 34.7109 54.9766 34.6738Z"
            }), d.jsx("path", {
                d: "M32.0659 13.3553C21.9959 13.3553 13.814 21.3892 13.814 31.3219C13.814 32.3829 13.9081 33.4225 14.0876 34.4334C14.1511 34.7907 14.4922 35.029 14.8495 34.9655C15.2069 34.9021 15.4451 34.561 15.3817 34.2036C15.2155 33.2677 15.1283 32.305 15.1283 31.3219C15.1283 22.1352 22.7014 14.6696 32.0659 14.6696C36.2978 14.6696 40.1642 16.1949 43.1319 18.7152C43.4086 18.9501 43.8233 18.9163 44.0582 18.6396C44.2931 18.363 44.2593 17.9483 43.9827 17.7134C40.7847 14.9975 36.6188 13.3553 32.0659 13.3553Z"
            }), d.jsx("path", {
                d: "M45.455 20.1635C45.717 19.9123 46.133 19.921 46.3842 20.183C49.2843 23.2072 50.2126 27.9605 50.8269 31.9494C51.5188 36.4426 51.6244 40.826 51.6244 42.8585C51.6244 43.2214 51.3302 43.5156 50.9673 43.5156C50.6044 43.5156 50.3101 43.2214 50.3101 42.8585C50.3101 40.8589 50.2055 36.5497 49.5279 32.1494C48.9577 28.4462 48.1356 23.9082 45.4356 21.0927C45.1844 20.8307 45.1931 20.4147 45.455 20.1635Z"
            }), d.jsx("path", {
                d: "M51.4576 46.6219C51.4864 46.2601 51.2165 45.9435 50.8547 45.9146C50.493 45.8858 50.1763 46.1557 50.1474 46.5175C49.8247 50.5654 49.403 54.6088 48.5474 58.3439C48.4663 58.6977 48.6874 59.0502 49.0412 59.1312C49.3949 59.2123 49.7474 58.9912 49.8285 58.6374C50.7067 54.8039 51.134 50.6806 51.4576 46.6219Z"
            }), d.jsx("path", {
                d: "M15.1454 36.852C15.5015 36.7819 15.847 37.0137 15.9171 37.3698C17.3066 44.4257 16.3467 50.8355 12.6672 56.4502C12.4682 56.7537 12.0609 56.8385 11.7573 56.6396C11.4538 56.4407 11.369 56.0333 11.5679 55.7298C15.0299 50.4469 15.9617 44.3985 14.6276 37.6238C14.5575 37.2677 14.7893 36.9221 15.1454 36.852Z"
            }), d.jsx("path", {
                d: "M32.0659 17.631C25.5291 17.631 19.1165 22.691 18.462 29.0504C18.1754 31.8345 18.578 34.5769 18.9807 37.3204C19.3323 39.7159 19.684 42.1124 19.5772 44.5381C19.3328 50.0898 17.7039 54.6726 14.905 58.4471C14.6888 58.7386 14.7499 59.1502 15.0414 59.3663C15.333 59.5825 15.7445 59.5214 15.9607 59.2299C18.9293 55.2266 20.6354 50.386 20.8903 44.5959C20.9966 42.1811 20.6438 39.7923 20.2912 37.4051C19.888 34.6752 19.4851 31.9473 19.7694 29.1849C20.3444 23.5983 26.0946 18.9453 32.0659 18.9453C34.851 18.9453 42.057 20.4534 44.3492 27.9205C45.7856 32.5998 46.1774 38.9326 45.8295 45.0849C45.4816 51.2364 44.3994 57.12 42.9442 60.8928C42.8136 61.2314 42.9822 61.6118 43.3208 61.7424C43.6594 61.873 44.0398 61.7044 44.1704 61.3658C45.6929 57.4186 46.7895 51.386 47.1417 45.1591C47.4938 38.9329 47.1068 32.4249 45.6056 27.5348C43.0612 19.2461 35.0851 17.631 32.0659 17.631Z"
            }), d.jsx("path", {
                d: "M21.9529 56.4512C22.2569 56.6494 22.3426 57.0566 22.1444 57.3606C21.7369 57.9854 21.3784 58.6391 21.0199 59.2928C20.6614 59.9465 20.3028 60.6004 19.8953 61.2253C19.697 61.5293 19.2898 61.615 18.9858 61.4167C18.6819 61.2184 18.5962 60.8113 18.7944 60.5073C19.2019 59.8825 19.5604 59.2288 19.9189 58.5751C20.2774 57.9213 20.636 57.2675 21.0435 56.6426C21.2418 56.3386 21.649 56.2529 21.9529 56.4512Z"
            }), d.jsx("path", {
                d: "M27.5799 24.4525C27.8816 24.2508 27.9625 23.8426 27.7608 23.541C27.559 23.2393 27.1509 23.1583 26.8492 23.3601C24.247 25.1006 22.6505 27.494 22.6505 31.0002C22.6505 33.088 23.0203 34.7946 23.3997 36.5449C23.9674 39.1641 24.3524 41.7777 24.2832 44.468C24.1992 47.7349 23.56 50.7201 22.3313 53.564C22.1873 53.8971 22.3407 54.2839 22.6739 54.4278C23.0071 54.5718 23.3938 54.4184 23.5378 54.0852C24.8369 51.0784 25.509 47.9266 25.5971 44.5018C25.6689 41.7062 25.2732 38.9892 24.6845 36.267C24.3042 34.509 23.9648 32.9394 23.9648 31.0002C23.9648 27.9961 25.2863 25.9866 27.5799 24.4525Z"
            }), d.jsx("path", {
                d: "M30.1447 22.1436C32.8717 21.5877 35.8061 22.2746 37.966 24.0228C41.8241 27.1455 42.3372 32.8403 42.753 37.4549L42.7742 37.69C43.3115 43.6385 42.6964 49.4163 41.4575 55.2186C41.3817 55.5736 41.0326 55.7999 40.6776 55.7241C40.3227 55.6483 40.0964 55.2991 40.1722 54.9442C41.3926 49.2288 41.9873 43.5885 41.4652 37.8082C41.4479 37.6169 41.4307 37.4228 41.4133 37.2264L41.4131 37.2235C41.0438 33.0534 40.5812 27.8304 37.1392 25.0444C35.2926 23.5498 32.7599 22.9518 30.4073 23.4314C30.0517 23.5039 29.7046 23.2744 29.6321 22.9188C29.5596 22.5632 29.7891 22.2161 30.1447 22.1436Z"
            }), d.jsx("path", {
                d: "M40.5287 58.4885C40.6183 58.1368 40.4057 57.7791 40.054 57.6896C39.7023 57.6 39.3446 57.8126 39.2551 58.1643C38.8578 59.7247 38.2456 61.1333 37.4695 62.4301C37.2831 62.7415 37.3844 63.145 37.6958 63.3314C38.0072 63.5178 38.4108 63.4165 38.5972 63.1051C39.4336 61.7075 40.0977 60.1816 40.5287 58.4885Z"
            }), d.jsx("path", {
                d: "M37.3152 48.9521C37.6756 48.9948 37.9332 49.3215 37.8906 49.682C37.2699 54.9267 35.8688 59.6042 33.6205 63.6613C33.4446 63.9787 33.0446 64.0934 32.7272 63.9175C32.4097 63.7416 32.295 63.3417 32.4709 63.0242C34.6226 59.1416 35.9811 54.6339 36.5854 49.5275C36.6281 49.1671 36.9548 48.9095 37.3152 48.9521Z"
            }), d.jsx("path", {
                d: "M37.1798 30.6556C36.7242 28.2212 34.6349 26.3591 32.0985 26.3591C28.6638 26.3591 26.254 29.8212 27.1032 33.0422C28.54 38.7279 28.7759 44.2077 27.8032 49.4855L27.8025 49.4893C26.9584 54.228 25.3374 58.4908 23.1263 62.1031C22.9368 62.4127 23.0342 62.8172 23.3437 63.0067C23.6533 63.1962 24.0578 63.0988 24.2473 62.7893C26.5488 59.0292 28.2249 54.6109 29.0961 49.7218C30.106 44.2403 29.8558 38.5684 28.3765 32.7168L28.3748 32.7099C27.7378 30.3005 29.5133 27.6734 32.0985 27.6734C33.9641 27.6734 35.5393 29.0459 35.8871 30.8929C36.8436 36.4411 37.3418 41.5862 36.9871 46.016C36.9581 46.3778 37.2279 46.6945 37.5897 46.7235C37.9515 46.7525 38.2682 46.4827 38.2972 46.1209C38.6649 41.5294 38.1459 36.2576 37.1815 30.6648C37.1809 30.6617 37.1804 30.6586 37.1798 30.6556Z"
            }), d.jsx("path", {
                d: "M30.1376 59.1171C30.4604 59.283 30.5876 59.6792 30.4217 60.002L28.6804 63.3906C28.5145 63.7134 28.1184 63.8406 27.7956 63.6747C27.4728 63.5088 27.3456 63.1127 27.5114 62.7899L29.2527 59.4013C29.4186 59.0785 29.8147 58.9513 30.1376 59.1171Z"
            }), d.jsx("path", {
                d: "M32.5872 31.2892C32.5042 30.9359 32.1505 30.7168 31.7972 30.7998C31.4439 30.8828 31.2247 31.2365 31.3077 31.5898C33.5238 41.0232 33.2194 49.3066 30.5201 56.363C30.3905 56.702 30.5602 57.0819 30.8991 57.2115C31.2381 57.3412 31.618 57.1715 31.7477 56.8326C34.5622 49.475 34.8483 40.9141 32.5872 31.2892Z"
            })]
        }), d.jsx("defs", {
            children: d.jsx("clipPath", {
                id: "clip0_113_33841",
                children: d.jsx("rect", {
                    width: "64",
                    height: "64",
                    fill: "white",
                    transform: "translate(0.483887)"
                })
            })
        })]
    }),
    ju = {
        component: () => {
            let {
                app: t,
                lastScreen: e,
                currentScreen: r,
                navigateBack: n,
                data: i,
                setModalData: s,
                navigate: a
            } = Ne(), {
                loginWithPasskey: o,
                signupWithPasskey: c,
                closePrivyModal: l,
                createAnalyticsEvent: u
            } = $e(), {
                user: h,
                logout: f
            } = $t(), {
                passkeySignupFlow: p
            } = (i == null ? void 0 : i.passkeyAuthModalData) ? ? {}, [g, m] = v.useState("loading"), [y, w] = v.useState(null), x = v.useRef([]), E = b => {
                x.current = [b, ...x.current]
            };
            v.useEffect(() => () => {
                x.current.forEach(b => clearTimeout(b)), x.current = []
            }, []);
            let _ = async () => {
                m("loading");
                try {
                    p ? await c() : await o(), m("success")
                } catch (b) {
                    w(b), m("error")
                }
            };
            return v.useEffect(() => {
                if (g === "success" && h) {
                    if (t != null && t.legal.requireUsersAcceptTerms && !h.hasAcceptedTerms) return void E(setTimeout(() => {
                        a(Hd)
                    }, 900));
                    if (!yl(h, t == null ? void 0 : t.embeddedWallets)) return void E(setTimeout(() => {
                        l({
                            shouldCallAuthOnSuccess: !0,
                            isSuccess: !0
                        })
                    }, Ir));
                    E(setTimeout(() => {
                        s({
                            createWallet: {
                                onSuccess: () => {},
                                onFailure: b => {
                                    console.error(b), u({
                                        eventName: "embedded_wallet_creation_failure_logout",
                                        payload: {
                                            error: b,
                                            screen: "PasskeyStatusScreen"
                                        }
                                    }), f()
                                },
                                callAuthOnSuccessOnClose: !0
                            }
                        }), a(bc)
                    }, 900))
                }
            }, [h, g]), v.useEffect(() => {
                _()
            }, []), d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    backFn: e && r !== e ? n : void 0
                }), d.jsxs(_Ie, {
                    children: [d.jsx(Fi, {
                        children: d.jsxs("div", {
                            children: [d.jsx(Ia, {
                                success: g === "success",
                                fail: g === "error"
                            }), d.jsx(B0, {
                                style: {
                                    width: "38px",
                                    height: "38px"
                                }
                            })]
                        })
                    }), d.jsxs(ls, {
                        children: [d.jsx("h3", {
                            children: (() => {
                                switch (g) {
                                    case "loading":
                                        return "Waiting for passkey";
                                    case "success":
                                        return "Success";
                                    case "error":
                                        return "Something went wrong"
                                }
                            })()
                        }), d.jsx("p", {
                            style: {
                                whiteSpace: "pre-wrap"
                            },
                            children: (() => {
                                switch (g) {
                                    case "loading":
                                        return p ? "Please follow prompts to register your passkey." : `Please follow prompts to verify your passkey.
You will have to sign up with another method first to register a passkey for your account.`;
                                    case "success":
                                        return "You've successfully logged in with your passkey.";
                                    case "error":
                                        if (y instanceof Qn) {
                                            if (y.privyErrorCode === ee.CANNOT_LINK_MORE_OF_TYPE) return "Cannot link more passkeys to account.";
                                            if (y.privyErrorCode === ee.PASSKEY_NOT_ALLOWED) return `Passkey request timed out or rejected by user.
You will have to sign up with another method first to register a passkey for your account.`
                                        }
                                        return `An unknown error occurred.
You will have to sign up with another method first to register a passkey for your account.`
                                }
                            })()
                        })]
                    }), (() => {
                        switch (g) {
                            case "loading":
                            case "success":
                                return d.jsx(Qe, {
                                    onClick: () => {},
                                    disabled: !0,
                                    children: "Continue"
                                });
                            case "error":
                                return d.jsx(Qe, {
                                    onClick: _,
                                    disabled: !1,
                                    children: "Retry"
                                })
                        }
                    })()]
                }), d.jsx(Wt, {})]
            })
        }
    };
let _Ie = z.div.withConfig({
    displayName: "Container",
    componentId: "sc-46c03a59-0"
})(["display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;width:100%;"]);
const CIe = {
        component: () => {
            let {
                enabled: t,
                token: e
            } = qi(), {
                lastScreen: r,
                currentScreen: n,
                navigateBack: i,
                navigate: s,
                setModalData: a
            } = Ne(), {
                initSignupWithPasskey: o,
                initLoginWithPasskey: c
            } = $e();
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    backFn: r && n !== r ? i : void 0
                }), d.jsx(O0, {
                    children: d.jsxs(AIe, {
                        children: [d.jsx(M0, {}), d.jsx(B0, {})]
                    })
                }), d.jsx(Cr, {
                    children: "Log in or create a new account?"
                }), d.jsx(Ar, {
                    children: "Create a new account with a passkey or use a passkey to log in to an existing account."
                }), d.jsxs(Bo, {
                    children: [d.jsx(Qe, {
                        onClick: async () => {
                            t && !e ? (a({
                                passkeyAuthModalData: {
                                    passkeySignupFlow: !0
                                },
                                captchaModalData: {
                                    callback: l => o({
                                        captchaToken: l,
                                        withPrivyUi: !0
                                    }),
                                    userIntentRequired: !1,
                                    onSuccessNavigateTo: ju,
                                    onErrorNavigateTo: Sr
                                }
                            }), s(Sa)) : (await o({
                                withPrivyUi: !0
                            }), a({
                                passkeyAuthModalData: {
                                    passkeySignupFlow: !0
                                }
                            }), s(ju))
                        },
                        children: "Create new account"
                    }), d.jsx(u1, {
                        onClick: async () => {
                            t && !e ? (a({
                                passkeyAuthModalData: {
                                    passkeySignupFlow: !1
                                },
                                captchaModalData: {
                                    callback: l => c({
                                        captchaToken: l,
                                        withPrivyUi: !0
                                    }),
                                    userIntentRequired: !1,
                                    onSuccessNavigateTo: ju,
                                    onErrorNavigateTo: Sr
                                }
                            }), s(Sa)) : (await c({
                                withPrivyUi: !0
                            }), a({
                                passkeyAuthModalData: {
                                    passkeySignupFlow: !1
                                }
                            }), s(ju))
                        },
                        children: "Log in with a passkey"
                    })]
                }), d.jsx(ot, {})]
            })
        }
    },
    AIe = z.div.withConfig({
        displayName: "DoubleIconWrapper",
        componentId: "sc-f058c8a2-0"
    })(["display:flex;align-items:center;justify-content:center;width:180px;height:90px;border-radius:50%;svg + svg{margin-left:12px;}> svg{z-index:2;color:var(--privy-color-accent);stroke:var(--privy-color-accent);fill:var(--privy-color-accent);}"]),
    JF = () => {
        let {
            enabled: t,
            token: e
        } = qi(), {
            navigate: r,
            setModalData: n,
            app: i,
            data: s
        } = Ne(), {
            initLoginWithPasskey: a
        } = $e(), o = () => {
            i.loginConfig.passkeysForSignupEnabled ? r(CIe) : (async () => t && !e ? (n({
                passkeyAuthModalData: {
                    passkeySignupFlow: !1
                },
                captchaModalData: {
                    callback: c => a({
                        captchaToken: c,
                        withPrivyUi: !0
                    }),
                    userIntentRequired: !1,
                    onSuccessNavigateTo: ju,
                    onErrorNavigateTo: Sr
                }
            }), r(Sa)) : (await a({
                withPrivyUi: !0
            }), n({
                passkeyAuthModalData: {
                    passkeySignupFlow: !1
                }
            }), r(ju)))()
        };
        return v.useMemo(() => {
            var l;
            let c = (l = s == null ? void 0 : s.login) == null ? void 0 : l.loginMethods;
            return c ? c.filter(u => u !== "passkey").length : Object.entries(i.loginMethods).filter(([u, h]) => h).filter(([u]) => u !== "passkey").length
        }, [i.loginMethods, s == null ? void 0 : s.login]) === 0 ? d.jsxs(Pr, {
            onClick: o,
            children: [d.jsx(sx, {}), " Continue with passkey"]
        }) : d.jsx(IIe, {
            onClick: o,
            children: "I have a passkey"
        })
    };
let kIe = pi(["&&{width:100%;font-size:0.875rem;line-height:1rem;display:flex;gap:0.5rem;justify-content:center;align-items:center;padding:6px 8px;background-color:var(--privy-color-background);transition:background-color 200ms ease;color:var(--privy-color-accent) !important;:focus{outline:none;box-shadow:none;}}"]);
const IIe = z.button.withConfig({
        displayName: "StyledLink",
        componentId: "sc-1c6127e5-0"
    })(["", ""], kIe),
    $Ie = ({
        value: t,
        onChange: e
    }) => d.jsx("select", {
        value: t,
        onChange: e,
        children: Jre.map(r => d.jsxs("option", {
            value: r.code,
            children: [r.code, " +", r.callCode]
        }, r.code))
    }),
    fw = v.forwardRef((t, e) => {
        let {
            app: r
        } = Ne(), [n, i] = v.useState(!1), {
            accountType: s
        } = ml(), [a, o] = v.useState(""), [c, l] = v.useState((r == null ? void 0 : r.intl.defaultCountry) ? ? "US"), u = tg(a, c), h = Zre(c), f = Qre(c), p = H6(c), g = !u, [m, y] = v.useState(!1), w = p.length, x = b => {
            let A = b.target.value;
            l(A), o(""), t.onChange && t.onChange({
                rawPhoneNumber: a,
                qualifiedPhoneNumber: m2(a, A),
                countryCode: A,
                isValid: tg(a, c)
            })
        }, E = (b, A) => {
            try {
                let I = b.replace(/\D/g, "") === a.replace(/\D/g, "") ? b : h.input(b);
                o(I), t.onChange && t.onChange({
                    rawPhoneNumber: I,
                    qualifiedPhoneNumber: m2(b, A),
                    countryCode: A,
                    isValid: tg(b, A)
                })
            } catch (I) {
                console.error("Error processing phone number:", I)
            }
        }, _ = () => {
            y(!0);
            let b = m2(a, c);
            t.onSubmit({
                rawPhoneNumber: a,
                qualifiedPhoneNumber: b,
                countryCode: c,
                isValid: tg(a, c)
            }).finally(() => y(!1))
        };
        return v.useEffect(() => {
            if (t.defaultValue) {
                let b = Xre(t.defaultValue);
                h.reset(), x({
                    target: {
                        value: b.countryCode
                    }
                }), E(b.phone, b.countryCode)
            }
        }, [t.defaultValue]), d.jsxs(d.Fragment, {
            children: [d.jsx(SIe, {
                children: d.jsxs(TIe, {
                    $callingCodeLength: w,
                    $stacked: t.stacked,
                    children: [d.jsx($Ie, {
                        value: c,
                        onChange: x
                    }), d.jsx("input", {
                        ref: e,
                        id: "phone-number-input",
                        className: "login-method-button",
                        type: "tel",
                        placeholder: f,
                        onFocus: () => i(!0),
                        onChange: b => {
                            E(b.target.value, c)
                        },
                        onKeyUp: b => {
                            b.key === "Enter" && _()
                        },
                        value: a,
                        autoComplete: "tel"
                    }), s !== "phone" || n || t.hideRecent ? t.stacked || t.noIncludeSubmitButton ? d.jsx("span", {}) : d.jsx(j0, {
                        isSubmitting: m,
                        onClick: _,
                        disabled: g,
                        children: "Submit"
                    }) : d.jsx(Ta, {
                        color: "gray",
                        children: "Recent"
                    })]
                })
            }), t.stacked && !t.noIncludeSubmitButton ? d.jsx(Qe, {
                loading: m,
                loadingText: null,
                onClick: _,
                disabled: g,
                children: "Submit"
            }) : null]
        })
    });
let SIe = z.div.withConfig({
        displayName: "InputContainer",
        componentId: "sc-2a729487-0"
    })(["width:100%;"]),
    TIe = z.label.withConfig({
        displayName: "PhoneNumberInput",
        componentId: "sc-2a729487-1"
    })(["--country-code-dropdown-width:calc(54px + calc(12 * ", "px));--phone-input-extra-padding-left:calc(12px + calc(3 * ", "px));display:block;position:relative;width:100%;@media (min-width:441px){--country-code-dropdown-width:calc(52px + calc(10 * ", "px));}&& > select{font-size:16px;height:24px;position:absolute;margin:13px calc(var(--country-code-dropdown-width) / 4);line-height:24px;width:var(--country-code-dropdown-width);background-color:var(--privy-color-background);background-size:auto;background-position-x:right;cursor:pointer;@media (min-width:441px){font-size:14px;width:var(--country-code-dropdown-width);}:focus{outline:none;box-shadow:none;}}&& > input{font-size:16px;line-height:24px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:calc(100% - var(--country-code-dropdown-width));padding:12px 88px 12px calc(var(--country-code-dropdown-width) + var(--phone-input-extra-padding-left));padding-right:", ";flex-grow:1;background:var(--privy-color-background);border:1px solid var(--privy-color-foreground-4);border-radius:var(--privy-border-radius-mdlg);width:100%;:focus{outline:none;border-color:var(--privy-color-accent);}:autofill,:-webkit-autofill{background:var(--privy-color-background);}@media (min-width:441px){font-size:14px;padding-right:78px;}}&& > :last-child{right:16px;position:absolute;top:50%;transform:translate(0,-50%);}&& > button:last-child{right:0px;line-height:24px;padding:13px 17px;:focus{outline:none;border-color:var(--privy-color-accent);}}&& > input::placeholder{color:var(--privy-color-foreground-3);}"], t => t.$callingCodeLength, t => t.$callingCodeLength, t => t.$callingCodeLength, t => t.$stacked ? "16px" : "88px");
const QF = ({
    isEditable: t,
    setIsEditable: e,
    defaultValue: r
}) => {
    let n = v.useRef(null),
        {
            authenticated: i
        } = $t(),
        {
            navigate: s,
            setModalData: a,
            currentScreen: o,
            data: c
        } = Ne(),
        {
            initLoginWithSms: l
        } = $e(),
        {
            enabled: u,
            token: h
        } = qi(),
        {
            whatsAppEnabled: f
        } = Gt();
    return d.jsxs(d.Fragment, {
        children: [d.jsx(ch, {
            $if: !t,
            children: d.jsx(fw, {
                ref: n,
                onSubmit: async function({
                    qualifiedPhoneNumber: p
                }) {
                    var g;
                    if (!u || h || i) try {
                        await l({
                            phoneNumber: p,
                            captchaToken: h,
                            withPrivyUi: !0,
                            disableSignup: (g = c == null ? void 0 : c.login) == null ? void 0 : g.disableSignup
                        }), s(uc)
                    } catch (m) {
                        a({
                            errorModalData: {
                                error: m,
                                previousScreen: o || Xn
                            }
                        }), s(Sr)
                    } else a({
                        captchaModalData: {
                            callback: m => {
                                var y;
                                return l({
                                    phoneNumber: p,
                                    captchaToken: m,
                                    withPrivyUi: !0,
                                    disableSignup: (y = c == null ? void 0 : c.login) == null ? void 0 : y.disableSignup
                                })
                            },
                            userIntentRequired: !1,
                            onSuccessNavigateTo: uc,
                            onErrorNavigateTo: Sr
                        }
                    }), s(Sa)
                },
                defaultValue: r
            })
        }), d.jsx(ch, {
            $if: t,
            children: d.jsxs(Pr, {
                onClick: () => {
                    e(), setTimeout(() => {
                        var p;
                        (p = n.current) == null || p.focus()
                    }, 0)
                },
                children: [d.jsx(Ca, {}), " Continue with ", f ? "WhatsApp" : "SMS"]
            })
        })]
    })
};
let PIe = {
    apple: {
        logo: d.jsx(tU, {}),
        displayName: "Apple"
    },
    discord: {
        logo: d.jsx(rU, {}),
        displayName: "Discord"
    },
    github: {
        logo: d.jsx(nU, {}),
        displayName: "GitHub"
    },
    google: {
        logo: d.jsx(iU, {}),
        displayName: "Google"
    },
    linkedin: {
        logo: d.jsx(oU, {}),
        displayName: "LinkedIn"
    },
    spotify: {
        logo: d.jsx(cU, {}),
        displayName: "Spotify"
    },
    instagram: {
        logo: d.jsx(sU, {}),
        displayName: "Instagram"
    },
    twitter: {
        logo: d.jsx(dU, {}),
        displayName: "Twitter"
    },
    tiktok: {
        logo: d.jsx(lU, {}),
        displayName: "TikTok"
    },
    line: {
        logo: d.jsx(aU, {}),
        displayName: "LINE"
    }
};
const Xr = ({
    provider: t
}) => {
    let {
        enabled: e,
        token: r
    } = qi(), {
        navigate: n,
        setModalData: i,
        data: s
    } = Ne(), [a, o] = v.useState(!1), {
        initLoginWithOAuth: c
    } = $e(), {
        accountType: l
    } = ml(), u = v.useMemo(() => l && l !== "guest" && l !== "authorization_key" && l !== "cross_app" ? lw(l) : null, [l]), {
        displayName: h,
        logo: f
    } = PIe[t];
    return d.jsxs(Pr, {
        onClick: () => {
            var p;
            o(!0), setTimeout(() => {
                o(!1)
            }, 2e3), e && !r ? (i({
                captchaModalData: {
                    callback: g => {
                        var m;
                        return c(t, g, (m = s == null ? void 0 : s.login) == null ? void 0 : m.disableSignup)
                    },
                    userIntentRequired: !0,
                    onSuccessNavigateTo: null,
                    onErrorNavigateTo: Sr
                }
            }), n(Sa)) : c(t, void 0, (p = s == null ? void 0 : s.login) == null ? void 0 : p.disableSignup)
        },
        disabled: a,
        children: [f, " ", h, (u == null ? void 0 : u.loginMethod) === t && d.jsx(NIe, {
            color: "gray",
            children: "Recent"
        })]
    })
};
let NIe = z(Ta).withConfig({
    displayName: "StyledChip",
    componentId: "sc-209315e7-0"
})(["margin-left:auto;"]);

function XF(t) {
    return d.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        viewBox: "0 0 240 240",
        ...t,
        children: [d.jsx("defs", {
            children: d.jsxs("linearGradient", {
                x1: "120",
                y1: "240",
                x2: "120",
                gradientUnits: "userSpaceOnUse",
                id: "telegram-linear-gradient",
                children: [d.jsx("stop", {
                    offset: "0",
                    stopColor: "#1d93d2"
                }), d.jsx("stop", {
                    offset: "1",
                    stopColor: "#38b0e3"
                })]
            })
        }), d.jsx("title", {
            children: "Telegram_logo"
        }), d.jsx("circle", {
            cx: "120",
            cy: "120",
            r: "120",
            fill: "url(#telegram-linear-gradient)"
        }), d.jsx("path", {
            d: "M81.229,128.772l14.237,39.406s1.78,3.687,3.686,3.687,30.255-29.492,30.255-29.492l31.525-60.89L81.737,118.6Z",
            fill: "#c8daea"
        }), d.jsx("path", {
            d: "M100.106,138.878l-2.733,29.046s-1.144,8.9,7.754,0,17.415-15.763,17.415-15.763",
            fill: "#a9c6d8"
        }), d.jsx("path", {
            d: "M81.486,130.178,52.2,120.636s-3.5-1.42-2.373-4.64c.232-.664.7-1.229,2.1-2.2,6.489-4.523,120.106-45.36,120.106-45.36s3.208-1.081,5.1-.362a2.766,2.766,0,0,1,1.885,2.055,9.357,9.357,0,0,1,.254,2.585c-.009.752-.1,1.449-.169,2.542-.692,11.165-21.4,94.493-21.4,94.493s-1.239,4.876-5.678,5.043A8.13,8.13,0,0,1,146.1,172.5c-8.711-7.493-38.819-27.727-45.472-32.177a1.27,1.27,0,0,1-.546-.9c-.093-.469.417-1.05.417-1.05s52.426-46.6,53.821-51.492c.108-.379-.3-.566-.848-.4-3.482,1.281-63.844,39.4-70.506,43.607A3.21,3.21,0,0,1,81.486,130.178Z",
            fill: "#fff"
        })]
    })
}
const hm = {
    component: () => {
        let {
            authenticated: t,
            logout: e,
            ready: r,
            user: n
        } = $t(), {
            app: i,
            setModalData: s,
            navigate: a,
            resetNavigation: o,
            data: c
        } = Ne(), {
            initLoginWithTelegram: l,
            loginWithTelegram: u,
            updateWallets: h,
            setReadyToTrue: f,
            closePrivyModal: p,
            createAnalyticsEvent: g,
            getAuthMeta: m
        } = $e(), [y, w] = v.useState(!1), [x, E] = v.useState(void 0), _ = qi();
        async function b() {
            var T, C, $, P, N, R, D, S, O, M, U, k, F, q;
            try {
                let W = await async function() {
                    let K;
                    if (!t) {
                        if (_.enabled && _.status === "error") throw new Ky(_.error, null, ee.CAPTCHA_FAILURE);
                        return _.enabled && _.status !== "success" && (_.execute(), K = await _.waitForResult()), K
                    }
                }();
                await u({
                    captchaToken: W
                }), w(!0), f(!0)
            } catch (W) {
                if ((W == null ? void 0 : W.privyErrorCode) === ee.ALLOWLIST_REJECTED) return E(void 0), o(), void a(dw);
                if ((W == null ? void 0 : W.privyErrorCode) === ee.USER_LIMIT_REACHED) return console.error(new l0(W).toString()), E(void 0), o(), void a(F0);
                if ((W == null ? void 0 : W.privyErrorCode) === ee.USER_DOES_NOT_EXIST) return E(void 0), o(), void a(D0);
                if ((W == null ? void 0 : W.privyErrorCode) === ee.ACCOUNT_TRANSFER_REQUIRED && ((C = (T = W.data) == null ? void 0 : T.data) != null && C.nonce)) return E(void 0), o(), s({
                    accountTransfer: {
                        nonce: (P = ($ = W.data) == null ? void 0 : $.data) == null ? void 0 : P.nonce,
                        account: (R = (N = W.data) == null ? void 0 : N.data) == null ? void 0 : R.subject,
                        telegramAuthResult: (D = m()) == null ? void 0 : D.telegramAuthResult,
                        telegramWebAppData: (S = m()) == null ? void 0 : S.telegramWebAppData,
                        displayName: (U = (M = (O = W.data) == null ? void 0 : O.data) == null ? void 0 : M.account) == null ? void 0 : U.displayName,
                        linkMethod: "telegram",
                        embeddedWalletAddress: (q = (F = (k = W.data) == null ? void 0 : k.data) == null ? void 0 : F.otherUser) == null ? void 0 : q.embeddedWalletAddress
                    }
                }), void a(qd);
                let {
                    retryable: K,
                    detail: H
                } = s$(W);
                E({
                    retryable: K,
                    detail: H,
                    message: "Authentication failed"
                })
            }
        }
        v.useEffect(() => {
            b()
        }, []), v.useEffect(() => {
            if (!(r && t && y && n)) return;
            if (i != null && i.legal.requireUsersAcceptTerms && !n.hasAcceptedTerms) {
                let C = setTimeout(() => {
                    a(Hd)
                }, Ir);
                return () => clearTimeout(C)
            }
            if (yl(n, i.embeddedWallets)) {
                let C = setTimeout(() => {
                    s({
                        createWallet: {
                            onSuccess: () => {},
                            onFailure: $ => {
                                console.error($), g({
                                    eventName: "embedded_wallet_creation_failure_logout",
                                    payload: {
                                        error: $,
                                        provider: "telegram",
                                        screen: "TelegramAuthScreen"
                                    }
                                }), e()
                            },
                            callAuthOnSuccessOnClose: !0
                        }
                    }), a(bc)
                }, Ir);
                return () => clearTimeout(C)
            }
            h();
            let T = setTimeout(() => p({
                shouldCallAuthOnSuccess: !0,
                isSuccess: !0
            }), Ir);
            return () => clearTimeout(T)
        }, [r, t, y, n]);
        let A = y ? "Successfully connected with Telegram" : x ? x.message : "Verifying connection to Telegram",
            I = "";
        return I = y ? "You’re good to go!" : x ? x.detail : "Just a few moments more", d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {}), d.jsx(er, {}), d.jsxs(OIe, {
                children: [d.jsx(Fi, {
                    children: d.jsxs("div", {
                        children: [d.jsx(Ia, {
                            success: y,
                            fail: !!x
                        }), d.jsx(XF, {
                            style: {
                                width: "38px",
                                height: "38px"
                            }
                        })]
                    })
                }), d.jsxs(ls, {
                    children: [d.jsx("h3", {
                        children: A
                    }), d.jsx("p", {
                        children: I
                    })]
                }), x && (x != null && x.retryable) ? d.jsx(b8, {
                    onClick: async () => {
                        var T, C;
                        try {
                            E(void 0), (T = c == null ? void 0 : c.telegramAuthModalData) != null && T.seamlessAuth || await l(void 0, (C = c == null ? void 0 : c.login) == null ? void 0 : C.disableSignup), await b()
                        } catch ($) {
                            let {
                                retryable: P,
                                detail: N
                            } = s$($);
                            E({
                                retryable: P,
                                detail: N,
                                message: "Authentication failed"
                            })
                        }
                    },
                    disabled: !y && !(x != null && x.retryable),
                    children: "Retry"
                }) : null]
            }), d.jsx(nr, {}), d.jsx(Wt, {})]
        })
    },
    isCaptchaRequired: !0
};
let OIe = z.div.withConfig({
    displayName: "ConnectContainer",
    componentId: "sc-491d0b9b-0"
})(["display:flex;flex-direction:column;align-items:center;justify-content:center;margin-left:27px;margin-right:27px;gap:24px;"]);
const eB = () => {
    let {
        enabled: t,
        token: e
    } = qi(), {
        navigate: r,
        setModalData: n,
        data: i
    } = Ne(), [s, a] = v.useState(!1), {
        initLoginWithTelegram: o
    } = $e(), {
        accountType: c
    } = ml();
    async function l(u) {
        var h;
        try {
            await o(u, (h = i == null ? void 0 : i.login) == null ? void 0 : h.disableSignup), n({
                telegramAuthModalData: {
                    seamlessAuth: !1
                }
            }), r(hm)
        } catch (f) {
            console.error(f), a(!1)
        }
    }
    return d.jsxs(Pr, {
        onClick: async function() {
            if (a(!0), t && !e) return n({
                captchaModalData: {
                    callback: l,
                    userIntentRequired: !0,
                    onSuccessNavigateTo: null,
                    onErrorNavigateTo: Sr
                }
            }), void r(Sa);
            await l(e)
        },
        disabled: s,
        children: [d.jsx(XF, {}), "Telegram", c === "telegram" && d.jsx(jIe, {
            color: "gray",
            children: "Recent"
        })]
    })
};
let jIe = z(Ta).withConfig({
    displayName: "StyledChip",
    componentId: "sc-d81b85b5-0"
})(["margin-left:auto;"]);
const tB = ({
        onClick: t,
        text: e
    }) => d.jsxs(Pr, {
        onClick: t,
        children: [d.jsx(P0, {}), d.jsx(lc, {
            children: e
        }), d.jsx(s8, {})]
    }),
    rB = ({
        onClick: t,
        text: e,
        icon: r
    }) => d.jsxs(Pr, {
        onClick: t,
        children: [r, d.jsx(lc, {
            children: e
        }), d.jsx(s8, {})]
    }),
    nB = ({
        connectOnly: t
    }) => {
        var xe;
        let {
            closePrivyModal: e
        } = $e(), {
            data: r,
            setModalData: n,
            onUserCloseViaDialogOrKeybindRef: i,
            navigate: s
        } = Ne(), a = Gt(), o = r == null ? void 0 : r.login, c = a.appearance.walletList, l = (o == null ? void 0 : o.walletChainType) ? ? a.appearance.walletChainType, {
            accountType: u,
            walletClientType: h,
            chainType: f
        } = ml(), {
            wallets: p
        } = HF({
            walletList: c,
            walletChainType: l
        }), g = v.useMemo(() => u && u !== "guest" && u !== "authorization_key" && u !== "cross_app" ? lw(u) : null, [u]), {
            email: m,
            sms: y,
            google: w,
            twitter: x,
            discord: E,
            github: _,
            spotify: b,
            instagram: A,
            tiktok: I,
            line: T,
            linkedin: C,
            apple: $,
            wallet: P,
            farcaster: N,
            telegram: R
        } = v.useMemo(() => o != null && o.loginMethods ? ene(o.loginMethods, !0) : null, [o]) ? ? a.loginMethods, {
            passkey: D
        } = a.loginMethods, S = [m && "email", y && "sms", w && "google", x && "twitter", E && "discord", _ && "github", b && "spotify", A && "instagram", I && "tiktok", T && "line", C && "linkedin", $ && "apple", N && "farcaster", R && "telegram"].filter(ie => !!ie), O = S.length > 0, M = v.useMemo(() => P && !O ? "web3-first" : P && (a == null ? void 0 : a.appearance.loginGroupPriority) || "web2-first", [P, O, a == null ? void 0 : a.appearance.loginGroupPriority]), U = a == null ? void 0 : a.appearance.hideDirectWeb2Inputs, [k, F] = v.useState("default"), [q, W] = v.useState(v1({
            mostRecentlyUsedAccountType: u,
            smsAvailable: y,
            emailAvailable: m,
            prefilledType: (xe = o == null ? void 0 : o.prefill) == null ? void 0 : xe.type
        }));
        v.useEffect(() => {
            var ie;
            W(v1({
                mostRecentlyUsedAccountType: u,
                smsAvailable: y,
                emailAvailable: m,
                prefilledType: (ie = o == null ? void 0 : o.prefill) == null ? void 0 : ie.type
            }))
        }, [m, y, u]);
        let K = () => {
            e({
                shouldCallAuthOnSuccess: !0
            }), setTimeout(() => {
                F("default")
            }, 150)
        };
        i.current = K;
        let H = [];
        h && P ? H.push(h) : g != null && g.loginMethod && S.includes(g.loginMethod) && H.push(g.loginMethod);
        let j = ie => {
                var Ae, Le;
                if (ie === "email") return d.jsx(aB, {
                    isEditable: q === "email",
                    setIsEditable: () => {
                        W("email")
                    },
                    defaultValue: ((Ae = o == null ? void 0 : o.prefill) == null ? void 0 : Ae.type) === "email" ? o.prefill.value : void 0
                }, ie);
                if (ie === "sms") return d.jsx(QF, {
                    isEditable: q === "sms",
                    setIsEditable: () => {
                        W("sms")
                    },
                    defaultValue: ((Le = o == null ? void 0 : o.prefill) == null ? void 0 : Le.type) === "phone" ? o.prefill.value : void 0
                }, ie);
                if (ie === "apple") return d.jsx(Xr, {
                    provider: "apple"
                }, ie);
                if (ie === "discord") return d.jsx(Xr, {
                    provider: "discord"
                }, ie);
                if (ie === "farcaster") return d.jsx(ZF, {}, ie);
                if (ie === "github") return d.jsx(Xr, {
                    provider: "github"
                }, ie);
                if (ie === "google") return d.jsx(Xr, {
                    provider: "google"
                }, ie);
                if (ie === "linkedin") return d.jsx(Xr, {
                    provider: "linkedin"
                }, ie);
                if (ie === "tiktok") return d.jsx(Xr, {
                    provider: "tiktok"
                }, ie);
                if (ie === "line") return d.jsx(Xr, {
                    provider: "line"
                }, ie);
                if (ie === "spotify") return d.jsx(Xr, {
                    provider: "spotify"
                }, ie);
                if (ie === "instagram") return d.jsx(Xr, {
                    provider: "instagram"
                }, ie);
                if (ie === "twitter") return d.jsx(Xr, {
                    provider: "twitter"
                }, ie);
                if (ie === "telegram") return d.jsx(eB, {}, ie);
                let Ee = p.findIndex(({
                        id: Te
                    }) => Te === ts.normalize(ie)),
                    ft = f === "solana" ? "solana-only" : "ethereum-only";
                return d.jsx(P4, {
                    recent: !0,
                    index: Ee,
                    data: {
                        wallets: p,
                        walletChainType: ft,
                        handleWalletClick(Te) {
                            n(Ue => ({ ...Ue,
                                externalConnectWallet: {
                                    walletList: c,
                                    walletChainType: ft,
                                    preSelectedWalletId: Te.id
                                }
                            })), s(t ? N4 : um)
                        }
                    }
                })
            },
            V = p.filter(ie => ie.id !== ts.normalize(h || "")),
            Y = V.map((ie, Ee) => d.jsx(P4, {
                index: Ee,
                data: {
                    walletChainType: l,
                    wallets: V,
                    handleWalletClick(ft) {
                        n(Ae => ({ ...Ae,
                            externalConnectWallet: {
                                walletList: c,
                                walletChainType: l,
                                preSelectedWalletId: ft.id
                            }
                        })), s(t ? N4 : um)
                    }
                }
            }, ie.id)),
            X = S.filter(ie => ie !== (g == null ? void 0 : g.loginMethod)).flatMap(j),
            ne = H.flatMap(j);
        M === "web3-first" && k === "default" ? Y.unshift(...ne) : M === "web2-first" && X.unshift(...ne);
        let ae = S.filter(ie => ie !== "email" && ie !== "sms"),
            ue = MIe({
                priority: M,
                email: m,
                sms: y,
                social: ae
            }),
            he = DIe({
                priority: M,
                email: m,
                sms: y,
                social: ae
            }),
            fe = d.jsx(tB, {
                text: LIe({
                    priority: M
                }),
                onClick: () => {
                    n({ ...r,
                        externalConnectWallet: {
                            walletChainType: (o == null ? void 0 : o.walletChainType) ? ? a.appearance.walletChainType
                        }
                    }), s(um)
                }
            }),
            de = d.jsx(rB, {
                text: ue,
                icon: he,
                onClick: () => F("web2-overflow")
            }),
            ye = U ? 0 : 1,
            Be = P && Y.length > 0,
            ce = X.length === 0 && P && Y.length === 0,
            Ie = 5 - (Be ? 1 : 0);
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                title: a.appearance.landingHeader,
                onClose: K,
                backFn: k === "default" ? void 0 : () => {
                    F("default")
                }
            }), k === "default" && d.jsx(RIe, {}), k === "default" && (typeof a.appearance.loginMessage == "string" ? d.jsx(DU, {
                children: a.appearance.loginMessage
            }) : a.appearance.loginMessage), d.jsx(jU, {
                style: {
                    overflow: "hidden",
                    padding: 2
                },
                children: d.jsxs(zp, {
                    children: [k === "default" && M === "web2-first" && d.jsxs(d.Fragment, {
                        children: [X.length > Ie ? X.slice(0, Ie - 1) : X, X.length > Ie && de, Be && fe, ce && d.jsx(O4, {
                            chainType: a.appearance.walletChainType
                        })]
                    }), k === "default" && M === "web3-first" && d.jsxs(d.Fragment, {
                        children: [P && d.jsxs(d.Fragment, {
                            children: [Y.length > Ie ? Y.slice(0, Ie - 1) : Y, Y.length > Ie && fe]
                        }), X.length > ye && de, X.length === ye && X[0], ce && d.jsx(O4, {
                            chainType: a.appearance.walletChainType
                        })]
                    }), k === "web2-overflow" && d.jsx(d.Fragment, {
                        children: M === "web3-first" ? X : X.slice(3)
                    }), D && k === "default" && d.jsx(JF, {})]
                })
            }), a && d.jsx(Yy, {
                app: a
            }), d.jsx(ot, {})]
        })
    };
let RIe = z($F).withConfig({
        displayName: "StyledAppLogoHeader",
        componentId: "sc-75fbce5c-0"
    })(["margin-bottom:16px;"]),
    MIe = ({
        priority: t,
        email: e,
        sms: r,
        social: n
    }) => t === "web2-first" ? "Other socials" : e && r && n.length > 0 || e && n.length > 0 ? "Log in with email or socials" : r && n.length > 0 ? "Log in with sms or socials" : e && r ? "Continue with email or sms" : e ? "Continue with email" : r ? "Continue with sms" : "Log in with a social account",
    DIe = ({
        priority: t,
        email: e,
        sms: r,
        social: n
    }) => t === "web2-first" || n.length > 0 ? d.jsx(i8, {}) : e && r ? d.jsx(fIe, {}) : e ? d.jsx(Ld, {}) : r ? d.jsx(Ca, {}) : null,
    LIe = ({
        priority: t
    }) => t === "web2-first" ? "Continue with a wallet" : "Other wallets";
const v1 = ({
        mostRecentlyUsedAccountType: t,
        smsAvailable: e,
        emailAvailable: r,
        prefilledType: n
    }) => r && (t === "email" && n !== "phone" || n === "email") || !e || t !== "phone" && n !== "phone" ? "email" : "sms",
    iB = {
        component: () => {
            let {
                app: t
            } = Ne();
            return t.loginMethodsAndOrder && t.loginMethodsAndOrder.primary.length > 0 ? d.jsx(cB, {
                connectOnly: !0
            }) : d.jsx(nB, {
                connectOnly: !0
            })
        }
    };
let z$ = Array(6).fill("");
var mf, yf, UIe = ((mf = UIe || {})[mf.RESET_AFTER_DELAY = 0] = "RESET_AFTER_DELAY", mf[mf.CLEAR_ON_NEXT_VALID_INPUT = 1] = "CLEAR_ON_NEXT_VALID_INPUT", mf),
    FIe = ((yf = FIe || {})[yf.EMAIL = 0] = "EMAIL", yf[yf.SMS = 1] = "SMS", yf);
const uc = {
    component: () => {
        var S, O, M;
        let {
            app: t,
            navigate: e,
            lastScreen: r,
            navigateBack: n,
            setModalData: i,
            onUserCloseViaDialogOrKeybindRef: s
        } = Ne(), {
            closePrivyModal: a,
            resendEmailCode: o,
            resendSmsCode: c,
            getAuthMeta: l,
            loginWithCode: u,
            updateWallets: h,
            createAnalyticsEvent: f
        } = $e(), {
            authenticated: p,
            logout: g,
            user: m
        } = $t(), {
            whatsAppEnabled: y
        } = Gt(), [w, x] = v.useState(z$), [E, _] = v.useState(!1), [b, A] = v.useState(null), [I, T] = v.useState(null), [C, $] = v.useState(0);
        s.current = () => null;
        let P = (S = l()) != null && S.email ? 0 : 1;
        v.useEffect(() => {
            if (C) {
                let U = setTimeout(() => {
                    $(C - 1)
                }, 1e3);
                return () => clearTimeout(U)
            }
        }, [C]), v.useEffect(() => {
            if (p && E && m) {
                if (t != null && t.legal.requireUsersAcceptTerms && !m.hasAcceptedTerms) {
                    let U = setTimeout(() => {
                        e(Hd)
                    }, 900);
                    return () => clearTimeout(U)
                }
                if (yl(m, t.embeddedWallets)) {
                    let U = setTimeout(() => {
                        i({
                            createWallet: {
                                onSuccess: () => {},
                                onFailure: k => {
                                    console.error(k), f({
                                        eventName: "embedded_wallet_creation_failure_logout",
                                        payload: {
                                            error: k,
                                            screen: "AwaitingPasswordlessCodeScreen"
                                        }
                                    }), g()
                                },
                                callAuthOnSuccessOnClose: !0
                            }
                        }), e(bc)
                    }, 900);
                    return () => clearTimeout(U)
                } {
                    h();
                    let U = setTimeout(() => a({
                        shouldCallAuthOnSuccess: !0,
                        isSuccess: !0
                    }), Ir);
                    return () => clearTimeout(U)
                }
            }
        }, [p, E, m]), v.useEffect(() => {
            if (b && I === 0) {
                let U = setTimeout(() => {
                    x(z$), A(null);
                    let k = document.querySelector("input[name=code-0]");
                    k == null || k.focus()
                }, 1400);
                return () => clearTimeout(U)
            }
        }, [b]);
        let N = U => {
                var H;
                U.preventDefault();
                let k = U.currentTarget.value.replace(" ", "");
                if (k === "") return;
                if (isNaN(Number(k))) return A("Code should be numeric"), void T(1);
                A(null), T(null);
                let F = Number((H = U.currentTarget.name) == null ? void 0 : H.charAt(5)),
                    q = [...k || [""]].slice(0, 6 - F),
                    W = [...w.slice(0, F), ...q, ...w.slice(F + q.length)];
                x(W);
                let K = Math.min(Math.max(F + q.length, 0), 5);
                if (!isNaN(Number(U.currentTarget.value))) {
                    let j = document.querySelector(`input[name=code-${K}]`);
                    j == null || j.focus()
                }
                if (W.every(j => j && !isNaN(+j))) {
                    let j = document.querySelector(`input[name=code-${K}]`);
                    j == null || j.blur(), u(W.join("")).then(() => _(!0)).catch(V => {
                        var Y, X, ne, ae, ue, he, fe, de, ye, Be, ce, Ie;
                        if (V instanceof es && V.privyErrorCode === ee.INVALID_CREDENTIALS) A("Invalid or expired verification code");
                        else if (V instanceof es && V.privyErrorCode === ee.CANNOT_LINK_MORE_OF_TYPE) A(V.message);
                        else {
                            if (V instanceof es && V.privyErrorCode === ee.USER_LIMIT_REACHED) return console.error(new l0(V).toString()), void e(F0);
                            if (V instanceof es && V.privyErrorCode === ee.USER_DOES_NOT_EXIST) return void e(D0);
                            if (V instanceof es && V.privyErrorCode === ee.LINKED_TO_ANOTHER_USER) return i({
                                errorModalData: {
                                    error: V,
                                    previousScreen: r ? ? uc
                                }
                            }), void e(Sr, !1);
                            if (V instanceof es && V.privyErrorCode === ee.DISALLOWED_PLUS_EMAIL) return i({
                                inlineError: {
                                    error: V
                                }
                            }), void e(iB, !1);
                            if (V instanceof es && V.privyErrorCode === ee.ACCOUNT_TRANSFER_REQUIRED && ((X = (Y = V.data) == null ? void 0 : Y.data) != null && X.nonce)) return i({
                                accountTransfer: {
                                    nonce: (ae = (ne = V.data) == null ? void 0 : ne.data) == null ? void 0 : ae.nonce,
                                    account: P === 0 ? (ue = l()) == null ? void 0 : ue.email : (he = l()) == null ? void 0 : he.phoneNumber,
                                    displayName: (ye = (de = (fe = V.data) == null ? void 0 : fe.data) == null ? void 0 : de.account) == null ? void 0 : ye.displayName,
                                    linkMethod: P === 0 ? "email" : "sms",
                                    embeddedWalletAddress: (Ie = (ce = (Be = V.data) == null ? void 0 : Be.data) == null ? void 0 : ce.otherUser) == null ? void 0 : Ie.embeddedWalletAddress
                                }
                            }), void e(qd);
                            A("Issue verifying code")
                        }
                        T(0)
                    })
                }
            },
            R = P == 0 ? d.jsx(Ld, {
                color: "var(--privy-color-accent)",
                strokeWidth: 2,
                height: "48px",
                width: "48px"
            }) : d.jsx(Ca, {
                color: "var(--privy-color-accent)",
                strokeWidth: 2,
                height: "40px",
                width: "40px"
            }),
            D = d.jsxs("p", P == 0 ? {
                children: ["Please check ", d.jsx(q$, {
                    children: (O = l()) == null ? void 0 : O.email
                }), " for an email from privy.io and enter your code below."]
            } : {
                children: ["Please check ", d.jsx(q$, {
                    children: (M = l()) == null ? void 0 : M.phoneNumber
                }), " for a", y ? " WhatsApp" : "", " message from ", (t == null ? void 0 : t.name) || "Privy", " and enter your code below."]
            });
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                backFn: () => n()
            }, "header"), d.jsxs(BIe, {
                children: [d.jsx($r, {
                    title: "Enter confirmation code",
                    description: D,
                    icon: R
                }), d.jsxs(E8, {
                    children: [d.jsxs(WIe, {
                        children: [d.jsx(zIe, {
                            $fail: !!b,
                            $success: E,
                            children: d.jsx("span", {
                                children: b || (E ? "Success!" : "")
                            })
                        }), d.jsx("div", {
                            children: w.map((U, k) => d.jsx("input", {
                                name: `code-${k}`,
                                type: "text",
                                value: w[k],
                                onChange: N,
                                onKeyUp: F => {
                                    F.key === "Backspace" && (q => {
                                        if (I === 1 && (A(null), T(null)), x([...w.slice(0, q), "", ...w.slice(q + 1)]), q > 0) {
                                            let W = document.querySelector(`input[name=code-${q-1}]`);
                                            W == null || W.focus()
                                        }
                                    })(k)
                                },
                                inputMode: "numeric",
                                autoFocus: k === 0,
                                pattern: "[0-9]",
                                className: `${E?"success":""} ${b?"fail":""}`,
                                autoComplete: gr.isMobile ? "one-time-code" : "off"
                            }, k))
                        })]
                    }), d.jsxs(qIe, {
                        children: [d.jsxs("span", {
                            children: ["Didn't get ", P == 0 ? "an email" : "a message", "?"]
                        }), C ? d.jsxs(VIe, {
                            children: [d.jsx(N7e, {
                                color: "var(--privy-color-foreground)",
                                strokeWidth: 1.33,
                                height: "12px",
                                width: "12px"
                            }), d.jsx("span", {
                                children: "Code sent"
                            })]
                        }) : d.jsx(HIe, {
                            children: d.jsx("button", {
                                onClick: async () => {
                                    $(30), P == 0 ? await o() : await c()
                                },
                                children: "Resend code"
                            })
                        })]
                    })]
                })]
            }), d.jsx(ot, {})]
        })
    }
};
let BIe = z.div.withConfig({
        displayName: "PasswordlessCodeContainer",
        componentId: "sc-2171637e-0"
    })(["display:flex;flex-direction:column;align-items:flex-start;justify-content:center;margin:auto;gap:16px;flex-grow:1;"]),
    WIe = z.div.withConfig({
        displayName: "CodeInput",
        componentId: "sc-2171637e-1"
    })(["display:flex;flex-direction:column;width:100%;gap:8px;> div:last-child{display:flex;justify-content:center;gap:0.5rem;width:100%;border-radius:var(--privy-border-radius-md);> input{border:1px solid var(--privy-color-foreground-4);background:var(--privy-color-background);border-radius:var(--privy-border-radius-md);padding:8px 10px;height:58px;width:46px;text-align:center;font-size:18px;}> input:focus{border:1px solid var(--privy-color-accent);}> input:invalid{border:1px solid var(--privy-color-error);}> input.success{border:1px solid var(--privy-color-success);}> input.fail{border:1px solid var(--privy-color-error);animation:shake 180ms;animation-iteration-count:2;}}@keyframes shake{0%{transform:translate(1px,0px);}33%{transform:translate(-1px,0px);}67%{transform:translate(-1px,0px);}100%{transform:translate(1px,0px);}}"]),
    zIe = z.div.withConfig({
        displayName: "InputHelp",
        componentId: "sc-2171637e-2"
    })(["line-height:20px;height:20px;font-size:13px;color:", ";display:flex;justify-content:flex-end;width:100%;"], t => t.$success ? "var(--privy-color-success)" : t.$fail ? "var(--privy-color-error)" : "var(--privy-color-foreground-3)"),
    qIe = z.div.withConfig({
        displayName: "HelpText",
        componentId: "sc-2171637e-3"
    })(["font-size:13px;color:var(--privy-color-foreground);display:flex;gap:8px;align-items:center;width:100%;margin-top:16px;padding-bottom:32px;"]),
    HIe = z.div.withConfig({
        displayName: "ResendButtonContainer",
        componentId: "sc-2171637e-4"
    })(["color:var(--privy-color-accent);padding:2px 0;> button{text-decoration:underline;}"]),
    VIe = z.div.withConfig({
        displayName: "Badge",
        componentId: "sc-2171637e-5"
    })(["display:flex;align-items:center;justify-content:center;border-radius:var(--privy-border-radius-sm);padding:2px 8px;gap:4px;background:var(--privy-color-background-2);color:var(--privy-color-foreground-2);"]),
    q$ = z.span.withConfig({
        displayName: "BoldWrappingSpan",
        componentId: "sc-2171637e-6"
    })(["font-weight:500;word-break:break-all;"]);
const sB = v.forwardRef((t, e) => {
    let [r, n] = v.useState(t.defaultValue || ""), [i, s] = v.useState(""), [a, o] = v.useState(!1), {
        authenticated: c
    } = $t(), {
        initLoginWithEmail: l
    } = $e(), {
        navigate: u,
        setModalData: h,
        currentScreen: f,
        data: p
    } = Ne(), {
        enabled: g,
        token: m
    } = qi(), [y, w] = v.useState(!1), {
        accountType: x
    } = ml(), E = Gt();
    v.useEffect(() => {
        var I, T;
        !r && E.disablePlusEmails && ((I = p == null ? void 0 : p.inlineError) == null ? void 0 : I.error) instanceof Qn && ((T = p == null ? void 0 : p.inlineError) == null ? void 0 : T.error.privyErrorCode) === ee.DISALLOWED_PLUS_EMAIL && !i && s("Please enter a valid email address without a '+'."), i && s("")
    }, [r]);
    let _ = pU(r),
        b = a || !_,
        A = () => {
            h({
                login: p == null ? void 0 : p.login,
                inlineError: void 0
            }), !g || m || c ? (I => {
                var T;
                o(!0), l({
                    email: r,
                    captchaToken: I,
                    disableSignup: (T = p == null ? void 0 : p.login) == null ? void 0 : T.disableSignup,
                    withPrivyUi: !0
                }).then(() => {
                    u(uc)
                }).catch(C => {
                    h({
                        errorModalData: {
                            error: C,
                            previousScreen: f || Xn
                        }
                    }), u(Sr)
                }).finally(() => {
                    o(!1)
                })
            })(m) : (h({
                captchaModalData: {
                    callback: I => l({
                        email: r,
                        captchaToken: I,
                        withPrivyUi: !0
                    }),
                    userIntentRequired: !1,
                    onSuccessNavigateTo: uc,
                    onErrorNavigateTo: Sr
                }
            }), u(Sa))
        };
    return d.jsxs(d.Fragment, {
        children: [d.jsxs(GIe, {
            children: [i && d.jsx(dc, {
                style: {
                    display: "block",
                    marginTop: "0.25rem",
                    textAlign: "left"
                },
                children: i
            }), d.jsxs(KIe, {
                stacked: t.stacked,
                $error: !!i,
                children: [d.jsx(Ld, {}), d.jsx("input", {
                    ref: e,
                    id: "email-input",
                    className: "login-method-button",
                    type: "email",
                    placeholder: "your@email.com",
                    onFocus: () => w(!0),
                    onChange: I => n(I.target.value),
                    onKeyUp: I => {
                        I.key === "Enter" && A()
                    },
                    value: r,
                    autoComplete: "email"
                }), x !== "email" || y ? t.stacked ? d.jsx("span", {}) : d.jsx(j0, {
                    isSubmitting: a,
                    onClick: A,
                    disabled: b,
                    children: "Submit"
                }) : d.jsx(Ta, {
                    color: "gray",
                    children: "Recent"
                })]
            })]
        }), t.stacked ? d.jsx(Qe, {
            loadingText: null,
            loading: a,
            disabled: b,
            onClick: A,
            children: "Submit"
        }) : null]
    })
});
let GIe = BF,
    KIe = Rke;
const aB = ({
        isEditable: t,
        setIsEditable: e,
        defaultValue: r
    }) => {
        let n = v.useRef(null);
        return d.jsxs(d.Fragment, {
            children: [d.jsx(ch, {
                $if: !t,
                children: d.jsx(sB, {
                    ref: n,
                    defaultValue: r
                })
            }), d.jsx(ch, {
                $if: t,
                children: d.jsxs(Pr, {
                    onClick: () => {
                        e(), setTimeout(() => {
                            var i;
                            (i = n.current) == null || i.focus()
                        }, 0)
                    },
                    children: [d.jsx(Ld, {}), " Continue with Email"]
                })
            })]
        })
    },
    oB = ({
        icon: t,
        name: e
    }) => typeof t == "string" ? d.jsx("img", {
        alt: `${e||"wallet"} logo`,
        src: t,
        style: {
            height: 24,
            width: 24,
            borderRadius: 4
        }
    }) : t === void 0 ? d.jsx(P0, {}) : t ? d.jsx(t, {}) : null;

function R4(t) {
    var r, n;
    let e = t.toLowerCase();
    return !!((n = (r = window == null ? void 0 : window.webkit) == null ? void 0 : r.messageHandlers) != null && n.ReactNativeWebView) || !!(window != null && window.ReactNativeWebView) || ["fbav", "fban", "instagram", "snapchat", "linkedinapp"].some(i => e.includes(i))
}
const M4 = {
    component: () => {
        var A, I, T, C, $, P, N;
        let t, {
                navigateBack: e,
                navigate: r,
                lastScreen: n,
                currentScreen: i,
                data: s,
                setModalData: a
            } = Ne(),
            {
                walletConnectionStatus: o,
                closePrivyModal: c
            } = $e(),
            [l, u] = v.useState(void 0),
            [h, f] = v.useState(0),
            p = mc(((A = o == null ? void 0 : o.connector) == null ? void 0 : A.walletClientType) || "unknown"),
            g = (o == null ? void 0 : o.status) === "connected",
            m = (o == null ? void 0 : o.status) === "switching_to_supported_chain";
        v.useEffect(() => {
            var R, D;
            if (g) {
                let S;
                if ((R = s == null ? void 0 : s.externalConnectWallet) != null && R.onCompleteNavigateTo) {
                    let O = s.externalConnectWallet.onCompleteNavigateTo,
                        M = (D = o.connectedWallet) == null ? void 0 : D.address;
                    S = setTimeout(() => {
                        var U;
                        s.funding && a({ ...s,
                            funding: { ...s.funding,
                                connectedWalletAddress: M
                            }
                        }), r(O({
                            walletChainType: (U = o.connector) == null ? void 0 : U.chainType
                        }))
                    }, Ir)
                } else S = setTimeout(c, Ir);
                return () => clearTimeout(S)
            }
        }, [g]), v.useEffect(() => {
            o != null && o.connectError && (R => {
                u(qF(R))
            })(o == null ? void 0 : o.connectError)
        }, [o]);
        let y = ((I = o == null ? void 0 : o.connector) == null ? void 0 : I.connectorType) || "injected",
            w = ((T = o == null ? void 0 : o.connector) == null ? void 0 : T.walletClientType) || "unknown",
            x = ((C = p == null ? void 0 : p.metadata) == null ? void 0 : C.shortName) || (p == null ? void 0 : p.name) || (($ = o == null ? void 0 : o.connector) == null ? void 0 : $.walletBranding.name) || "Browser Extension",
            E = ((P = p == null ? void 0 : p.image_url) == null ? void 0 : P.md) || ((N = o == null ? void 0 : o.connector) == null ? void 0 : N.walletBranding.icon) || (R => d.jsx(f8, { ...R
            })),
            _ = x === "Browser Extension" ? x.toLowerCase() : x;
        t = g ? `Successfully connected with ${_}` : l ? l.message : m ? "Switching networks" : `Waiting for ${_}`;
        let b = "Don’t see your wallet? Check your other browser windows.";
        return g ? b = "You’re good to go!" : h >= 2 && l ? b = "Unable to connect wallet" : l ? b = l.detail : m ? b = "Switch your wallet to the requested network." : w === "metamask" && gr.isMobile ? b = "Click to continue to open and connect MetaMask." : w === "metamask" ? b = "For the best experience, connect only one wallet at a time." : y === "wallet_connect_v2" ? b = "Open your mobile wallet app to continue" : y === "coinbase_wallet" && (b = "Open the Coinbase app on your phone to continue."), d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                backFn: i === n ? void 0 : e
            }), d.jsxs(YIe, {
                children: [d.jsx(w1, {
                    walletLogo: E,
                    success: g,
                    fail: !!l
                }), d.jsxs(ls, {
                    children: [d.jsx("h3", {
                        children: t
                    }), d.jsx("p", {
                        children: b
                    })]
                }), l == Hc.ERROR_USER_EXISTS ? d.jsx(Qe, {
                    onClick: e,
                    children: "Use a different wallet"
                }) : !g && (l != null && l.retryable) && h < 2 ? d.jsx(Qe, {
                    onClick: () => {
                        f(h + 1), u(void 0), o == null || o.connectRetry()
                    },
                    disabled: !g && (!(l != null && l.retryable) || h >= 2),
                    children: "Retry"
                }) : !g && l && h >= 2 ? d.jsx(Qe, {
                    onClick: e,
                    children: "Use a different wallet"
                }) : null]
            }), d.jsx(Wt, {})]
        })
    }
};
let YIe = z.div.withConfig({
    displayName: "ConnectContainer",
    componentId: "sc-604d07cd-0"
})(["display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;width:100%;"]);
const ZIe = ({
        style: t,
        ...e
    }) => d.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        width: "17",
        height: "17",
        viewBox: "0 0 17 17",
        style: {
            height: "1.25rem",
            width: "1.25rem",
            ...t
        },
        ...e,
        children: d.jsx("path", {
            strokeLinecap: "round",
            strokeLinejoin: "round",
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M16.5 8.67993C16.5 9.82986 15.853 10.8287 14.9032 11.3322C15.2188 12.3599 14.97 13.5237 14.1569 14.3368C13.3437 15.1499 12.18 15.3987 11.1523 15.0831C10.6488 16.0329 9.64993 16.6799 8.5 16.6799C7.35007 16.6799 6.35126 16.0329 5.84771 15.0831C4.82003 15.3987 3.65627 15.1499 2.84314 14.3368C2.03001 13.5237 1.78124 12.3599 2.09681 11.3322C1.14699 10.8287 0.5 9.82986 0.5 8.67993C0.5 7.53 1.14699 6.53119 2.0968 6.02764C1.78125 4.99996 2.03003 3.83621 2.84315 3.02309C3.65627 2.20997 4.82002 1.96119 5.8477 2.27675C6.35125 1.32692 7.35007 0.679932 8.5 0.679932C9.64992 0.679932 10.6487 1.32691 11.1523 2.27672C12.18 1.96115 13.3437 2.20993 14.1569 3.02305C14.97 3.83618 15.2188 4.99996 14.9032 6.02764C15.853 6.53119 16.5 7.53 16.5 8.67993ZM12.2659 6.68856C12.5654 6.40238 12.5761 5.92763 12.29 5.62818C12.0038 5.32873 11.529 5.31797 11.2296 5.60416C9.73022 7.03711 8.40877 8.65489 7.3018 10.4211L5.78033 8.89963C5.48744 8.60673 5.01256 8.60673 4.71967 8.89963C4.42678 9.19252 4.42678 9.66739 4.71967 9.96029L6.92031 12.1609C7.08544 12.3261 7.31807 12.4048 7.54957 12.374C7.78106 12.3432 7.98499 12.2064 8.1012 12.0038C9.23027 10.0356 10.6362 8.24613 12.2659 6.68856Z",
            fill: "var(--privy-color-accent)"
        })
    }),
    JIe = z.div.withConfig({
        displayName: "TodoList",
        componentId: "sc-491785d-0"
    })(["display:flex;flex-direction:column;justify-content:flex-start;gap:4px;"]),
    H$ = z.div.withConfig({
        displayName: "TodoSpacer",
        componentId: "sc-491785d-1"
    })(["&&&{margin-left:7px;border-left:2px solid var(--privy-color-foreground-4);height:12px;}"]),
    jv = ({
        children: t
    }) => d.jsxs(QIe, {
        children: [d.jsx(ZIe, {
            style: {
                width: "16px",
                height: "16px"
            }
        }), t]
    });
let QIe = z.div.withConfig({
        displayName: "TodoItemWrapper",
        componentId: "sc-491785d-2"
    })(["display:flex;justify-content:flex-start;justify-items:center;text-align:left;gap:8px;&&{a{text-decoration:underline;color:var(--privy-color-accent);}svg{margin-top:auto;margin-bottom:auto;}}"]),
    XIe = ({
        name: t,
        installLink: e
    }) => d.jsxs(ol, {
        children: [d.jsx(I8, {
            title: `Create a ${t} wallet`.replace(/wallet wallet/gi, "wallet"),
            description: "Follow the instructions below to get started."
        }), d.jsxs(JIe, {
            children: [d.jsx(jv, {
                children: d.jsxs("div", {
                    children: [d.jsx("span", {
                        children: "Install the "
                    }), " ", d.jsxs("a", {
                        href: e,
                        target: "_blank",
                        children: [t, " browser extension"]
                    })]
                })
            }), d.jsx(H$, {}), d.jsx(jv, {
                children: "Set up your first wallet"
            }), d.jsx(H$, {}), d.jsx(jv, {
                children: "Store your recovery phrase in a safe place!"
            })]
        }), d.jsx(b8, {
            onClick: () => window.location.reload(),
            style: {
                marginTop: "20px"
            },
            children: "Reload the page to use your wallet"
        })]
    });
const e$e = {
        component: () => {
            let {
                navigateBack: t,
                data: e
            } = Ne();
            if (!(e != null && e.installWalletModalData)) throw Error("Wallet data is missing");
            let {
                walletConfig: r
            } = e.installWalletModalData;
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    backFn: t
                }, "header"), d.jsx(er, {}), d.jsx(XIe, { ...r
                }), d.jsx(nr, {}), d.jsxs(Wt, {
                    children: [d.jsx("span", {
                        children: "Still not sure? "
                    }), d.jsx("a", {
                        target: "_blank",
                        href: "https://solana.com/docs/intro/wallets",
                        children: "Learn more"
                    })]
                })]
            })
        }
    },
    t$e = {
        component: () => {
            let {
                ready: t
            } = $t(), {
                data: e
            } = Ne(), [r, n] = v.useState(!1);
            if (!(e != null && e.installWalletModalData)) throw Error("Wallet data is missing");
            let {
                walletConfig: i,
                connectOnly: s,
                chainType: a
            } = e.installWalletModalData, o = i.getMobileRedirect({
                useUniversalLink: !r,
                isSolana: a === "solana",
                connectOnly: s
            }), c = i.name.replace(/ wallet/gi, ""), l = {
                title: `Redirecting to ${c} Mobile Wallet`,
                description: `We'll take you to the ${c} Mobile Wallet app to continue your login experience.`,
                footnote: ""
            };
            return t && (l.description = `For the best experience, we'll automatically log you into the ${c} Mobile Wallet in-app browser.`, l.footnote = "You can always return here to login via other methods."), r && (l.title = "Still here?", l.description = `You may need to install the ${i.name} mobile app.`, l.footnote = `Once you're done, you can connect with ${i.name} wallet to complete the login.`), d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {}, "header"), d.jsx(er, {}), d.jsx(tw, {
                    title: l.title,
                    description: l.description
                }), d.jsxs(zd, {
                    children: [d.jsx(uCe, {
                        href: o,
                        onClick: () => setTimeout(() => n(!0), 1e3),
                        loading: t && !o,
                        children: r ? "Go to App Store" : "Continue"
                    }), l.footnote ? d.jsx("p", {
                        children: l.footnote
                    }) : null]
                }), d.jsx(nr, {}), d.jsx(ot, {})]
            })
        }
    },
    Ha = ({
        provider: t,
        displayName: e,
        logo: r,
        connectOnly: n,
        connector: i
    }) => {
        var m, y, w;
        let s, {
                navigate: a,
                setModalData: o
            } = Ne(),
            {
                connectWallet: c
            } = $e(),
            l = ml(),
            u = mc(t),
            h = i.connectorType === "wallet_connect_v2" ? t : i.walletClientType,
            f = window.matchMedia("(display-mode: standalone)").matches,
            p = AU({
                connectorType: i.connectorType,
                walletClientType: h
            });
        s = p && p.chainTypes.includes(i.chainType) ? () => {
            p.isInstalled || i.chainType === "solana" && "isInstalled" in i && i.isInstalled ? (c(i, h), a(n ? M4 : Yo)) : gr.isMobile ? (o({
                installWalletModalData: {
                    walletConfig: p,
                    chainType: i.chainType,
                    connectOnly: n
                }
            }), a(t$e)) : (o({
                installWalletModalData: {
                    walletConfig: p,
                    chainType: i.chainType,
                    connectOnly: n
                }
            }), a(e$e))
        } : i.connectorType !== "coinbase_wallet" || ((m = i.coinbaseWalletConfig.preference) == null ? void 0 : m.options) !== "eoaOnly" || !gr.isMobile || f || fU() ? () => {
            (!R4(window.navigator.userAgent) || event != null && event.isTrusted) && (c(i, h), a(n ? M4 : Yo))
        } : () => {
            window.location.href = `https://go.cb-w.com/dapp?cb_url=${encodeURI(window.location.href)}`
        };
        let g = e || ((y = u == null ? void 0 : u.metadata) == null ? void 0 : y.shortName) || (u == null ? void 0 : u.name) || i.walletClientType;
        return d.jsxs(r$e, {
            onClick: s,
            children: [d.jsx(oB, {
                icon: r || ((w = u == null ? void 0 : u.image_url) == null ? void 0 : w.md),
                name: g
            }), d.jsx("span", {
                children: g
            }), d.jsxs(n$e, {
                id: "chip-container",
                children: [(l == null ? void 0 : l.walletClientType) === h && (l == null ? void 0 : l.chainType) === i.chainType ? d.jsx(V$, {
                    color: "gray",
                    children: "Recent"
                }) : d.jsx("span", {
                    id: "connect-text",
                    children: "Connect"
                }), i.chainType === "solana" && d.jsx(V$, {
                    color: "gray",
                    children: "Solana"
                })]
            })]
        })
    };
let r$e = z(Pr).withConfig({
        displayName: "ConnectWalletButton",
        componentId: "sc-3baa344c-0"
    })(["> #chip-container > #connect-text{font-weight:500;color:var(--privy-color-accent);opacity:0;transition:opacity 0.1s ease-out;}:hover > #chip-container > #connect-text{opacity:1;}@media (max-width:440px){> #chip-container > #connect-text{display:none;}}"]),
    V$ = z(Ta).withConfig({
        displayName: "StyledChip",
        componentId: "sc-3baa344c-1"
    })(["margin-left:auto;"]),
    n$e = z.div.withConfig({
        displayName: "ChipContainer",
        componentId: "sc-3baa344c-2"
    })(["display:flex;flex-wrap:wrap;gap:8px;margin-left:auto;"]);
const i$e = ["coinbase_wallet", "base_account"];
let s$e = ["metamask", "okx_wallet", "rainbow", "uniswap", "bybit_wallet", "ronin_wallet", "haha_wallet", "uniswap_extension", "zerion", "rabby_wallet", "cryptocom", "binance"];
const a$e = ["safe"],
    o$e = ["phantom", "backpack", "solflare", "universal_profile"],
    c$e = ({
        wallets: t
    }) => {
        let {
            app: e
        } = Ne();
        return t.length === 0 ? d.jsx(O4, {
            chainType: e.appearance.walletChainType,
            withPadding: !0
        }) : d.jsx(d.Fragment, {
            children: t
        })
    },
    D8 = ({
        walletList: t,
        walletChainType: e,
        connectors: r,
        connectOnly: n,
        ignore: i,
        walletConnectEnabled: s,
        forceWallet: a
    }) => {
        var f, p;
        let o = [],
            c = [],
            l = [],
            u = r.filter(g => e === "ethereum-only" ? g.chainType === "ethereum" : e !== "solana-only" || g.chainType === "solana"),
            h = u.find(g => g.connectorType === "wallet_connect_v2");
        for (let [g, m] of (a ? [a.wallet] : t).entries()) {
            if (m === "detected_ethereum_wallets" || m === "detected_wallets")
                for (let [y, w] of u.filter(({
                        chainType: x,
                        connectorType: E,
                        walletClientType: _
                    }) => x !== "solana" && (_ === "uniswap_wallet_extension" || _ === "uniswap_extension" ? !i.includes("uniswap") : _ === "crypto.com_wallet_extension" || _ === "crypto.com_onchain" ? !i.includes("cryptocom") : E === "injected" && !i.includes(_))).entries()) {
                    let {
                        walletClientType: x,
                        walletBranding: E,
                        chainType: _
                    } = w;
                    (x === "unknown" ? c : o).push(d.jsx(Ha, {
                        connectOnly: n,
                        provider: x,
                        logo: E.icon,
                        displayName: E.name,
                        connector: w
                    }, `${g}-${m}-${x}-${_}-${y}`))
                }
            if (m === "detected_solana_wallets" || m === "detected_wallets")
                for (let [y, w] of u.filter(({
                        chainType: x,
                        walletClientType: E
                    }) => {
                        if (x === "solana") return e !== "ethereum-only" && !i.includes(E)
                    }).entries()) {
                    let {
                        walletClientType: x,
                        walletBranding: E,
                        chainType: _
                    } = w;
                    (x === "unknown" ? c : o).push(d.jsx(Ha, {
                        connectOnly: n,
                        provider: x,
                        logo: E.icon,
                        displayName: E.name,
                        connector: w
                    }, `${g}-${m}-${x}-${_}-${y}`))
                }
            if (o$e.includes(m)) {
                let y = u.find(w => w.connectorType === "injected" && w.walletClientType === m || w.connectorType === m);
                if (y && o.push(d.jsx(Ha, {
                        connectOnly: n,
                        provider: m,
                        connector: y
                    }, `${g}-${m}`)), e === "solana-only" || e === "ethereum-and-solana") {
                    let w = u.find(({
                        chainType: x,
                        walletClientType: E
                    }) => x === "solana" && E === m);
                    w && o.push(d.jsx(Ha, {
                        connectOnly: n,
                        provider: m,
                        connector: w
                    }, `${m}-solana`))
                }
            } else if (s$e.includes(m)) {
                let y = u.find(w => m === "uniswap" ? w.walletClientType === "uniswap_wallet_extension" || w.walletClientType === "uniswap_extension" : m === "cryptocom" ? w.walletClientType === "crypto.com_wallet_extension" || w.walletClientType === "crypto.com_onchain" : w.connectorType === "injected" && w.walletClientType === m);
                if (s && !y && (y = h), y && o.push(d.jsx(Ha, {
                        connectOnly: n,
                        provider: m,
                        connector: y,
                        logo: y.connectorType === "injected" ? y.walletBranding.icon : void 0,
                        displayName: y.connectorType === "injected" ? y.walletBranding.name : void 0
                    }, `${g}-${m}`)), e === "solana-only" || e === "ethereum-and-solana") {
                    let w = u.find(({
                        chainType: x,
                        walletClientType: E
                    }) => x === "solana" && E === m);
                    w && o.push(d.jsx(Ha, {
                        connectOnly: n,
                        provider: m,
                        connector: w
                    }, `${m}-solana`))
                }
            } else if (i$e.includes(m)) {
                let y = u.find(({
                    connectorType: w
                }) => w === m);
                y && o.push(d.jsx(Ha, {
                    connectOnly: n,
                    provider: m,
                    connector: y,
                    displayName: y.walletClientType === "coinbase_wallet" ? "Coinbase" : "Base",
                    logo: y.walletClientType === "coinbase_wallet" ? yU : wU
                }, `${g}-${m}`))
            } else if (a$e.includes(m)) h && l.push(d.jsx(Ha, {
                connectOnly: n,
                provider: m,
                connector: h
            }, `${g}-${m}`));
            else if (m === "wallet_connect") h && l.push(d.jsx(Ha, {
                connectOnly: n,
                provider: m,
                connector: h,
                logo: h.walletBranding.icon,
                displayName: "WalletConnect"
            }, `${g}-${m}`));
            else if (m === (a == null ? void 0 : a.wallet)) {
                let y = a.chainType === "ethereum" && t.includes("detected_ethereum_wallets"),
                    w = a.chainType === "solana" && t.includes("detected_solana_wallets");
                if (t.includes("detected_wallets") || y || w) {
                    let x = u.find(({
                        walletClientType: E
                    }) => E === m);
                    x && o.push(d.jsx(Ha, {
                        connectOnly: n,
                        provider: m,
                        displayName: (f = x.walletBranding) == null ? void 0 : f.name,
                        logo: (p = x.walletBranding) == null ? void 0 : p.icon,
                        connector: x
                    }, `${g}-${m}`))
                }
            }
        }
        return [...c, ...o, ...l]
    },
    cB = ({
        connectOnly: t
    }) => {
        var N, R, D;
        let {
            closePrivyModal: e,
            connectors: r
        } = $e(), {
            app: n,
            onUserCloseViaDialogOrKeybindRef: i,
            data: s
        } = Ne(), {
            appearance: {
                palette: {
                    colorScheme: a
                }
            }
        } = Gt(), {
            accountType: o,
            walletClientType: c,
            chainType: l
        } = ml(), u = v.useMemo(() => o && o !== "guest" && o !== "authorization_key" && o !== "cross_app" ? lw(o) : null, [o]), h = ((N = n.loginMethodsAndOrder) == null ? void 0 : N.primary) ? ? [], f = ((R = n.loginMethodsAndOrder) == null ? void 0 : R.overflow) ? ? [], p = v.useMemo(() => [...h, ...f], [h, f]), g = n.loginMethods.passkey, m = s == null ? void 0 : s.login, y = [];
        c && p.includes(c) ? y.push(c) : o && p.includes(u == null ? void 0 : u.loginMethod) && y.push(u == null ? void 0 : u.loginMethod);
        let [w, x] = v.useState("default"), [E, _] = v.useState(v1({
            mostRecentlyUsedAccountType: o,
            smsAvailable: p.includes("sms"),
            emailAvailable: p.includes("email"),
            prefilledType: (D = m == null ? void 0 : m.prefill) == null ? void 0 : D.type
        }));
        v.useEffect(() => {
            var S;
            _(v1({
                mostRecentlyUsedAccountType: o,
                smsAvailable: p.includes("sms"),
                emailAvailable: p.includes("email"),
                prefilledType: (S = m == null ? void 0 : m.prefill) == null ? void 0 : S.type
            }))
        }, [p, o]), v.useEffect(() => {
            o === "phone" && _("sms");
            let S = p.indexOf("sms"),
                O = p.indexOf("email");
            S > -1 && S < O && _("sms")
        }, [o, h, f]);
        let b = () => {
            e({
                shouldCallAuthOnSuccess: !0
            }), setTimeout(() => {
                x("default")
            }, 150)
        };
        i.current = b;
        let A = S => {
                var O, M;
                return S === "email" ? d.jsx(aB, {
                    isEditable: E === "email",
                    setIsEditable: () => {
                        _("email")
                    },
                    defaultValue: ((O = m == null ? void 0 : m.prefill) == null ? void 0 : O.type) === "email" ? m.prefill.value : void 0
                }, S) : S === "sms" ? d.jsx(QF, {
                    isEditable: E === "sms",
                    setIsEditable: () => {
                        _("sms")
                    },
                    defaultValue: ((M = m == null ? void 0 : m.prefill) == null ? void 0 : M.type) === "phone" ? m.prefill.value : void 0
                }, S) : S === "apple" ? d.jsx(Xr, {
                    provider: "apple"
                }, S) : S === "discord" ? d.jsx(Xr, {
                    provider: "discord"
                }, S) : S === "farcaster" ? d.jsx(ZF, {}, S) : S === "github" ? d.jsx(Xr, {
                    provider: "github"
                }, S) : S === "google" ? d.jsx(Xr, {
                    provider: "google"
                }, S) : S === "linkedin" ? d.jsx(Xr, {
                    provider: "linkedin"
                }, S) : S === "spotify" ? d.jsx(Xr, {
                    provider: "spotify"
                }, S) : S === "instagram" ? d.jsx(Xr, {
                    provider: "instagram"
                }, S) : S === "tiktok" ? d.jsx(Xr, {
                    provider: "tiktok"
                }, S) : S === "line" ? d.jsx(Xr, {
                    provider: "line"
                }, S) : S === "twitter" ? d.jsx(Xr, {
                    provider: "twitter"
                }, S) : S === "telegram" ? d.jsx(eB, {}, S) : S.startsWith("privy:") ? d.jsx(ike, {
                    appId: S.replace("privy:", "")
                }, S) : D8({
                    walletList: n.appearance.walletList,
                    walletChainType: (m == null ? void 0 : m.walletChainType) ? ? n.appearance.walletChainType,
                    connectors: r,
                    connectOnly: t,
                    ignore: p,
                    walletConnectEnabled: n.externalWallets.walletConnect.enabled,
                    forceWallet: {
                        wallet: S,
                        chainType: l ? ? "ethereum"
                    }
                })
            },
            I = y.flatMap(A),
            T = h.filter(S => S !== c && S !== (u == null ? void 0 : u.loginMethod)).flatMap(A),
            C = f.filter(S => S !== c && S !== (u == null ? void 0 : u.loginMethod)).flatMap(A),
            [$, P] = ((S, O) => {
                let M = [],
                    U = [];
                for (let [k, F] of S.entries()) k < O ? M.push(F) : U.push(F);
                return [M, U]
            })([...I, ...T, ...C], l$e({
                primary: T.length + I.length,
                overflow: C.length
            }));
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                title: n.appearance.landingHeader,
                onClose: b,
                backFn: w === "default" ? void 0 : () => {
                    x("default")
                }
            }), w === "default" && d.jsx(d$e, {}), w === "default" && (typeof n.appearance.loginMessage == "string" ? d.jsx(DU, {
                children: n.appearance.loginMessage
            }) : n.appearance.loginMessage), d.jsx(jU, {
                style: {
                    overflow: "hidden"
                },
                children: d.jsxs(RU, {
                    $colorScheme: a,
                    children: [w === "default" && d.jsxs(d.Fragment, {
                        children: [$, P.length > 0 && d.jsx(rB, {
                            text: "More options",
                            icon: d.jsx(i8, {}),
                            onClick: () => x("overflow")
                        })]
                    }), w === "overflow" && d.jsx(d.Fragment, {
                        children: P
                    }), g && w === "default" && d.jsx(JF, {})]
                })
            }), n && d.jsx(Yy, {
                app: n
            }), d.jsx(ot, {})]
        })
    };
let l$e = ({
        primary: t,
        overflow: e
    }) => t < 5 ? t : t === 5 && e === 0 ? 5 : 4,
    d$e = z($F).withConfig({
        displayName: "StyledAppLogoHeader",
        componentId: "sc-d846420a-0"
    })(["margin-bottom:16px;"]);
const Xn = {
        component: () => {
            let {
                app: t
            } = Ne();
            return t.loginMethodsAndOrder && t.loginMethodsAndOrder.primary.length > 0 ? d.jsx(cB, {
                connectOnly: !1
            }) : d.jsx(nB, {
                connectOnly: !1
            })
        },
        isCaptchaRequired: !0,
        isUnauthenticatedScreem: !0
    },
    lB = {
        component: () => {
            let [t, e] = v.useState(null), [r, n] = v.useState(!1), [i, s] = v.useState(null), [a, o] = v.useState(""), {
                authenticated: c,
                getAccessToken: l,
                user: u
            } = $t(), {
                walletProxy: h,
                refreshSessionAndUser: f,
                closePrivyModal: p,
                createAnalyticsEvent: g
            } = $e(), {
                app: m,
                navigate: y,
                data: w,
                onUserCloseViaDialogOrKeybindRef: x
            } = Ne(), {
                onSuccess: E,
                onFailure: _
            } = w.setWalletPassword, b = Rs(u), A = (t == null ? void 0 : t.recoveryMethod) === "user-passcode", I = (b == null ? void 0 : b.recoveryMethod) === "user-passcode";
            v.useEffect(() => {
                c || (y(Xn), _(new nie("User must be authenticated before setting a password on a Privy wallet")))
            }, [c]);
            let T = () => i ? (_(i), void p({
                shouldCallAuthOnSuccess: !1
            })) : A ? (E(t), void p({
                shouldCallAuthOnSuccess: !1
            })) : (_(new Xc("Exited before password was added to wallet")), void p({
                shouldCallAuthOnSuccess: !1
            }));
            return x.current = T, d.jsx(kF, {
                appName: (m == null ? void 0 : m.name) || "privy",
                config: {
                    initiatedBy: "user",
                    onCancel: T
                },
                error: i ? "An error has occurred, please try again." : void 0,
                buttonLoading: r,
                buttonHideAnimations: !1,
                password: a,
                isResettingPassword: I,
                onPasswordGenerate: () => o(AF()),
                onPasswordChange: o,
                onSubmit: async () => {
                    A ? (E(t), p({
                        shouldCallAuthOnSuccess: !1
                    })) : (n(!0), s(null), await (async () => {
                        let C = await l();
                        if (C && u && (b != null && b.address) && a && h) try {
                            g({
                                eventName: "embedded_wallet_set_recovery_started",
                                payload: {
                                    walletAddress: b.address,
                                    existingRecoveryMethod: b.recoveryMethod,
                                    targetRecoveryMethod: "user-passcode",
                                    isResettingPassword: I
                                }
                            });
                            let {
                                entropyId: $,
                                entropyIdVerifier: P
                            } = Sn(u);
                            if (!(await h.setRecovery({
                                    accessToken: C,
                                    entropyId: $,
                                    entropyIdVerifier: P,
                                    recoveryPassword: a,
                                    recoveryMethod: "user-passcode"
                                })).entropyId) return s(new Xc("Error setting password on privy wallet")), void g({
                                eventName: "embedded_wallet_set_recovery_failed",
                                payload: {
                                    walletAddress: b.address,
                                    existingRecoveryMethod: b.recoveryMethod,
                                    targetRecoveryMethod: "user-passcode",
                                    isResettingPassword: I,
                                    reason: "error setting password"
                                }
                            });
                            let N = await f(),
                                R = Rs(N);
                            if (!R) return s(new Xc("Error setting password on privy wallet")), void g({
                                eventName: "embedded_wallet_set_recovery_failed",
                                payload: {
                                    walletAddress: b.address,
                                    existingRecoveryMethod: b.recoveryMethod,
                                    targetRecoveryMethod: "user-passcode",
                                    isResettingPassword: I,
                                    reason: "wallet disconnected"
                                }
                            });
                            e(R), g({
                                eventName: "embedded_wallet_set_recovery_completed",
                                payload: {
                                    walletAddress: b.address,
                                    existingRecoveryMethod: b.recoveryMethod,
                                    targetRecoveryMethod: "user-passcode",
                                    isResettingPassword: I
                                }
                            })
                        } catch ($) {
                            console.warn($), s($ instanceof Error ? $ : Error("Error setting password on privy wallet")), g({
                                eventName: "embedded_wallet_set_password_failed",
                                payload: {
                                    walletAddress: b.address,
                                    reason: $
                                }
                            })
                        }
                    })(), n(!1))
                },
                onClose: T
            })
        }
    },
    u$e = {
        component: () => {
            let {
                closePrivyModal: t
            } = $e(), {
                data: e,
                navigate: r,
                onUserCloseViaDialogOrKeybindRef: n
            } = Ne(), {
                onFailure: i
            } = e.setWalletPassword, s = () => {
                i(new Xc("Exited before password was added to wallet")), t({
                    shouldCallAuthOnSuccess: !1
                })
            };
            return n.current = s, d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    onClose: s
                }), d.jsx(er, {}), d.jsxs(wc, {
                    children: [d.jsxs(TCe, {
                        children: [d.jsx(i8, {
                            stroke: "var(--privy-color-accent)",
                            width: "64px",
                            height: "64px"
                        }), d.jsx(PCe, {
                            style: {
                                width: 24,
                                height: 24,
                                position: "absolute",
                                bottom: 0,
                                right: 0
                            },
                            children: d.jsx(HL, {
                                width: "12px",
                                height: "12px",
                                fill: "white"
                            })
                        })]
                    }), d.jsxs($r, {
                        title: "Secure Your Account",
                        children: ["Please set a password to secure your account.", d.jsx("p", {
                            children: "Losing access to this password and this device will make your account inaccessible."
                        })]
                    })]
                }), d.jsx(Qe, {
                    onClick: () => {
                        r(lB)
                    },
                    children: "Add password"
                }), d.jsx(nr, {}), d.jsx(ot, {})]
            })
        }
    },
    h$e = {
        component: () => {
            let [t, e] = v.useState(!0), {
                authenticated: r,
                getAccessToken: n,
                user: i
            } = $t(), {
                walletProxy: s,
                closePrivyModal: a,
                createAnalyticsEvent: o
            } = $e(), {
                navigate: c,
                data: l,
                onUserCloseViaDialogOrKeybindRef: u
            } = Ne(), [h, f] = v.useState(void 0), [p, g] = v.useState(""), [m, y] = v.useState(!1), {
                entropyId: w,
                entropyIdVerifier: x,
                onCompleteNavigateTo: E,
                onSuccess: _,
                onFailure: b
            } = l.recoverWallet, A = (I = "User exited before their wallet could be recovered") => {
                a({
                    shouldCallAuthOnSuccess: !1
                }), b(typeof I == "string" ? new Xc(I) : I)
            };
            return u.current = A, v.useEffect(() => {
                if (!r) return A("User must be authenticated and have a Privy wallet before it can be recovered")
            }, [r]), d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    onClose: A
                }), d.jsx(er, {}), d.jsxs(p$e, {
                    children: [d.jsxs(f$e, {
                        children: [d.jsx(hd, {
                            height: 48,
                            width: 48,
                            stroke: "var(--privy-color-accent)"
                        }), d.jsx("h3", {
                            style: {
                                color: "var(--privy-color-foreground)"
                            },
                            children: "Enter your password"
                        }), d.jsx("p", {
                            style: {
                                color: "var(--privy-color-foreground-2)"
                            },
                            children: "Please provision your account on this new device. To continue, enter your recovery password."
                        })]
                    }), d.jsxs("div", {
                        children: [d.jsxs(iw, {
                            children: [d.jsx(P8, {
                                type: t ? "password" : "text",
                                onChange: I => (T => {
                                    T && f(T)
                                })(I.target.value),
                                disabled: m,
                                style: {
                                    paddingRight: "2.3rem"
                                }
                            }), d.jsx(aw, {
                                style: {
                                    right: "0.75rem"
                                },
                                children: t ? d.jsx(ow, {
                                    onClick: () => e(!1)
                                }) : d.jsx(cw, {
                                    onClick: () => e(!0)
                                })
                            })]
                        }), !!p && d.jsx(g$e, {
                            children: p
                        })]
                    }), d.jsxs("div", {
                        children: [d.jsxs(SCe, {
                            children: [d.jsx("h4", {
                                children: "Why is this necessary?"
                            }), d.jsx("p", {
                                children: "You previously set a password for this wallet. This helps ensure only you can access it"
                            })]
                        }), d.jsx(m$e, {
                            loading: m || !s,
                            disabled: !h,
                            onClick: async () => {
                                y(!0);
                                let I = await n(),
                                    T = $s(i, w);
                                if (!I || !T || h === null) return A("User must be authenticated and have a Privy wallet before it can be recovered");
                                try {
                                    o({
                                        eventName: "embedded_wallet_recovery_started",
                                        payload: {
                                            walletAddress: T.address
                                        }
                                    }), await (s == null ? void 0 : s.recover({
                                        accessToken: I,
                                        entropyId: w,
                                        entropyIdVerifier: x,
                                        recoveryPassword: h
                                    })), g(""), E ? c(E) : a({
                                        shouldCallAuthOnSuccess: !1
                                    }), _ == null || _(T), o({
                                        eventName: "embedded_wallet_recovery_completed",
                                        payload: {
                                            walletAddress: T.address
                                        }
                                    })
                                } catch (C) {
                                    (function($) {
                                        return jh($) && ($.type === "invalid_recovery_pin" || $.type === "invalid_request_arguments")
                                    })(C) ? g("Invalid recovery password, please try again."): g("An error has occurred, please try again.")
                                } finally {
                                    y(!1)
                                }
                            },
                            $hideAnimations: !w && m,
                            children: "Recover your account"
                        })]
                    })]
                }), d.jsx(nr, {}), d.jsx(ot, {})]
            })
        }
    },
    f$e = z.div.withConfig({
        displayName: "Header",
        componentId: "sc-3736fa5b-0"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;margin:20px 0;gap:4px;& h3{font-size:18px;font-style:normal;font-weight:600;line-height:24px;}& p{max-width:300px;font-size:14px;font-style:normal;font-weight:400;line-height:20px;}"]);
let p$e = z.div.withConfig({
        displayName: "Content",
        componentId: "sc-3736fa5b-1"
    })(["display:flex;flex-direction:column;justify-content:space-between;"]),
    g$e = z.div.withConfig({
        displayName: "ErrorMessage",
        componentId: "sc-3736fa5b-2"
    })(["line-height:20px;height:20px;font-size:13px;color:var(--privy-color-error);text-align:left;margin-top:0.5rem;"]),
    m$e = z(Qe).withConfig({
        displayName: "NoAnimationPrimaryButton",
        componentId: "sc-3736fa5b-3"
    })(["", ""], ({
        $hideAnimations: t
    }) => t && pi(["&&{transition:none;}"]));
const y$e = {
        component: () => {
            let {
                app: t,
                navigate: e,
                data: r,
                onUserCloseViaDialogOrKeybindRef: n
            } = Ne(), [i, s] = v.useState(""), [a, o] = v.useState(!1), [c, l] = v.useState(), [u, h] = v.useState(null), {
                create: f
            } = S8(), {
                authenticated: p,
                user: g
            } = $t(), {
                closePrivyModal: m,
                isNewUserThisSession: y,
                initializeWalletProxy: w
            } = $e(), {
                onSuccess: x,
                onFailure: E,
                callAuthOnSuccessOnClose: _,
                shouldCreateEth: b,
                shouldCreateSol: A
            } = r.createWallet, [I, T] = v.useState(null), C = new di(async () => {
                try {
                    let $;
                    if (b && A) $ = await f({
                        recoveryMethod: "user-passcode",
                        recoveryPassword: c,
                        chainType: "ethereum",
                        walletIndex: 0,
                        latestUser: g
                    }), $ = await f({
                        chainType: "solana",
                        walletIndex: 0,
                        latestUser: $.user
                    });
                    else if (A) $ = await f({
                        recoveryMethod: "user-passcode",
                        recoveryPassword: c,
                        chainType: "solana",
                        walletIndex: 0,
                        latestUser: g
                    });
                    else {
                        if (!b) throw Error("Invalid args to create wallet");
                        $ = await f({
                            recoveryMethod: "user-passcode",
                            recoveryPassword: c,
                            chainType: "ethereum",
                            walletIndex: 0,
                            latestUser: g
                        })
                    }
                    T($), y ? e(T8) : (x($), m({
                        shouldCallAuthOnSuccess: _
                    }))
                } catch ($) {
                    s($.message)
                }
            });
            return v.useEffect(() => {
                u || w(3e4).then($ => h($))
            }, [u]), v.useEffect(() => {
                if (!p || !g) return e(Xn), void E(Error("User must be authenticated before creating a Privy wallet"))
            }, [p]), n.current = () => null, d.jsx(kF, {
                config: {
                    initiatedBy: "automatic"
                },
                appName: (t == null ? void 0 : t.name) || "privy",
                loading: !u,
                buttonLoading: a,
                buttonHideAnimations: !I && a,
                isResettingPassword: !1,
                error: i,
                password: c || "",
                onClose: () => {
                    I && I.account.recoveryMethod !== "user-passcode" ? (E(new Xc("User created a wallet but failed to set a password for it")), m({
                        shouldCallAuthOnSuccess: !1
                    })) : I ? (x(I), m({
                        shouldCallAuthOnSuccess: _
                    })) : (E(new Xc("User wallet creation failed")), m({
                        shouldCallAuthOnSuccess: !1
                    }))
                },
                onPasswordChange: l,
                onPasswordGenerate: () => l(AF()),
                onSubmit: async () => (o(!0), C.execute().then(() => new Promise($ => setTimeout($, 250))).finally(() => o(!1)))
            })
        }
    },
    w$e = z.div.withConfig({
        displayName: "WithCircleBorder",
        componentId: "sc-e4fc5563-0"
    })(["&&{border-width:4px;}display:flex;justify-content:center;align-items:center;padding:1rem;aspect-ratio:1;border-style:solid;border-color:", ";border-radius:50%;"], t => t.$color ? ? "var(--privy-color-accent)"),
    Pa = z.span.withConfig({
        displayName: "Title",
        componentId: "sc-66de63c-0"
    })(["color:var(--privy-color-foreground);font-size:1.125rem;font-weight:600;line-height:1.875rem;text-align:center;"]),
    b$e = {
        component: () => {
            var y;
            let {
                user: t,
                getAccessToken: e
            } = $t(), {
                walletProxy: r,
                refreshSessionAndUser: n,
                closePrivyModal: i
            } = $e(), s = Ne(), {
                entropyId: a,
                entropyIdVerifier: o
            } = (y = s.data) == null ? void 0 : y.recoverWallet, [c, l] = v.useState(!1), [u, h] = v.useState(null), [f, p] = v.useState(null);

            function g() {
                var w, x, E, _;
                if (!c) {
                    if (f) return (x = (w = s.data) == null ? void 0 : w.setWalletPassword) == null || x.onFailure(f), void i();
                    if (!u) return (_ = (E = s.data) == null ? void 0 : E.setWalletPassword) == null || _.onFailure(Error("User exited set recovery flow")), void i()
                }
            }
            s.onUserCloseViaDialogOrKeybindRef.current = g;
            let m = !(!c && !u);
            return d.jsxs(d.Fragment, f ? {
                children: [d.jsx(Pe, {
                    onClose: g
                }, "header"), d.jsx(w$e, {
                    $color: "var(--privy-color-error)",
                    style: {
                        alignSelf: "center"
                    },
                    children: d.jsx(yo, {
                        height: 38,
                        width: 38,
                        stroke: "var(--privy-color-error)"
                    })
                }), d.jsx(Pa, {
                    style: {
                        marginTop: "0.5rem"
                    },
                    children: "Something went wrong"
                }), d.jsx(lc, {
                    style: {
                        minHeight: "2rem"
                    }
                }), d.jsx(qp, {
                    onClick: () => p(null),
                    children: "Try again"
                }), d.jsx(ot, {})]
            } : {
                children: [d.jsx(Pe, {
                    onClose: g
                }, "header"), d.jsx(FL, {
                    style: {
                        width: "3rem",
                        height: "3rem",
                        alignSelf: "center"
                    }
                }), d.jsx(Pa, {
                    style: {
                        marginTop: "0.5rem"
                    },
                    children: "Automatically secure your account"
                }), d.jsx($a, {
                    style: {
                        marginTop: "1rem"
                    },
                    children: "When you log into a new device, you’ll only need to authenticate to access your account. Never get logged out if you forget your password."
                }), d.jsx(lc, {
                    style: {
                        minHeight: "2rem"
                    }
                }), d.jsx(qp, {
                    loading: c,
                    disabled: m,
                    onClick: () => async function() {
                        l(!0);
                        try {
                            let w = await e(),
                                x = $s(t, a);
                            if (!w || !r || !x) return;
                            if (!(await r.setRecovery({
                                    accessToken: w,
                                    entropyId: a,
                                    entropyIdVerifier: o,
                                    existingRecoveryMethod: x.recoveryMethod,
                                    recoveryMethod: "privy"
                                })).entropyId) throw Error("Unable to set recovery on wallet");
                            let E = await n();
                            if (!E) throw Error("Unable to set recovery on wallet");
                            let _ = $s(E, x.address);
                            if (!_) throw Error("Unabled to set recovery on wallet");
                            h(!!E), setTimeout(() => {
                                var b, A;
                                (A = (b = s.data) == null ? void 0 : b.setWalletPassword) == null || A.onSuccess(_), i()
                            }, Ir)
                        } catch (w) {
                            p(w)
                        } finally {
                            l(!1)
                        }
                    }(),
                    children: u ? "Success" : "Confirm"
                }), d.jsx(ot, {})]
            })
        }
    };

function dB({
    isCreatingWallet: t,
    skipSplashScreen: e
}) {
    return t ? y$e : e ? lB : u$e
}

function uB({
    walletAction: t,
    availableRecoveryMethods: e,
    legacySetWalletPasswordFlow: r,
    isResettingPassword: n,
    showAutomaticRecovery: i
}) {
    return i ? b$e : r || e.length === 1 ? dB({
        isCreatingWallet: t === "create",
        skipSplashScreen: n
    }) : k4
}

function hB(t) {
    switch (t) {
        case "user-passcode":
            return h$e;
        case "google-drive":
        case "icloud":
            return yF;
        default:
            throw Error("Recovery method not supported")
    }
}
const fB = ({
    children: t,
    theme: e
}) => d.jsxs(v$e, {
    $theme: e,
    children: [d.jsx(d_e, {
        width: "1.25rem",
        color: e === "dark" ? "var(--privy-color-accent-light)" : "var(--privy-color-accent-dark)",
        style: {
            minWidth: "1.25rem"
        }
    }), t]
});
let v$e = z.div.withConfig({
    displayName: "Container",
    componentId: "sc-c3403117-0"
})(["display:flex;gap:0.5rem;background-color:var(--privy-color-warn-light);color:var(--privy-color-foreground);align-items:flex-start;text-align:left;font-size:0.8125rem;font-weight:400;line-height:1.125rem;padding:0.75rem;&&{border-radius:var(--privy-border-radius-sm);}"]);
const pB = z.div.withConfig({
        displayName: "Column",
        componentId: "sc-cfc52180-0"
    })(["display:flex;flex-direction:column;"]),
    Yi = z.span.withConfig({
        displayName: "LabelXs",
        componentId: "sc-4c43f9fd-0"
    })(["color:var(--privy-color-foreground-3);font-size:0.75rem;font-weight:500;line-height:1.125rem;"]),
    gB = pi(["&&{border-width:1px;padding:0.5rem 1rem;}width:100%;text-align:left;border:solid 1px var(--privy-color-foreground-4);border-radius:var(--privy-border-radius-md);display:flex;justify-content:space-between;align-items:center;", ""], t => t.$state === "error" ? "border-color: var(--privy-color-error);" : ""),
    pw = z.div.withConfig({
        displayName: "Box",
        componentId: "sc-1660059c-0"
    })(["", ""], gB),
    gw = ({
        errMsg: t,
        balance: e,
        address: r,
        isLoading: n,
        className: i,
        title: s,
        isPulsing: a,
        showIcon: o,
        statusColor: c = "green"
    }) => {
        let l;
        return l = c || (t ? "red" : "green"), d.jsxs(d.Fragment, {
            children: [d.jsxs(pw, {
                className: i,
                $state: t ? "error" : void 0,
                children: [d.jsxs(pB, {
                    children: [d.jsx(Yi, {
                        children: s || "Pay with"
                    }), d.jsx(Rt, {
                        address: r,
                        showCopyIcon: o || !!t
                    })]
                }), e !== void 0 && d.jsx(Ta, {
                    isLoading: n,
                    isPulsing: a,
                    color: l,
                    children: e
                })]
            }), t && d.jsx(dc, {
                style: {
                    marginTop: "0.25rem"
                },
                children: t
            })]
        })
    };

function mB({
    rpcConfig: t,
    appId: e,
    address: r,
    chain: n
}) {
    let {
        chains: i
    } = $e(), [s, a] = v.useState(0 n), [o, c] = v.useState(!1), l = v.useMemo(() => {
        let h = n || i[0];
        if (h) return nc({
            chain: n,
            transport: rc(cc(h, t, e))
        })
    }, [n, t, e]), u = v.useCallback(async () => {
        if (!r || !l) return;
        c(!0);
        let h = await l.getBalance({
            address: r
        }).catch(console.error);
        return h ? (a(h), c(!1), h) : void 0
    }, [l, r, a]);
    return v.useEffect(() => {
        u().catch(console.error)
    }, []), {
        balance: s,
        isLoading: o,
        reloadBalance: u
    }
}
const Na = "sdk_fiat_on_ramp_completed_with_status",
    L8 = async ({
        chain: t,
        address: e,
        appId: r,
        rpcConfig: n,
        erc20Address: i
    }) => ({
        balance: await nc({
            chain: t,
            transport: rc(cc(t, n, r))
        }).readContract({
            address: i,
            abi: x$e,
            functionName: "balanceOf",
            args: [e]
        }).catch(() => 0 n),
        chain: t
    });
let x$e = [{
    constant: !0,
    inputs: [{
        name: "_owner",
        type: "address"
    }],
    name: "balanceOf",
    outputs: [{
        name: "balance",
        type: "uint256"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
}];
const W0 = Symbol("solana-funding-plugin"),
    E$e = async ({
        emitPrivyEvent: t,
        getAccessToken: e,
        initializeWalletProxy: r,
        refreshSessionAndUser: n,
        user: i,
        appConfig: s
    }, {
        privateKey: a,
        chainType: o
    }) => {
        if (s.embeddedWallets.mode === "user-controlled-server-wallets-only") throw t("linkAccount", "onError", ee.UNSUPPORTED_WALLET_TYPE, {
            linkMethod: "siwe"
        }), new J("Importing wallets is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");
        if (!i) throw t("linkAccount", "onError", ee.MUST_BE_AUTHENTICATED, {
            linkMethod: "siwe"
        }), new J("User must be authenticated before linking an account.");
        let [c, l] = await Promise.all([e(), r(15e3)]);
        if (!l || !c) throw t("linkAccount", "onError", ee.MUST_BE_AUTHENTICATED, {
            linkMethod: "siwe"
        }), new J("User must be authenticated before linking an account.");
        await l.importWallet({
            privateKey: a,
            accessToken: c,
            chainType: o
        });
        let u = await n(),
            h = o === "solana" ? ry(u) : R3(u);
        if (!h) throw t("createWallet", "onError", ee.UNKNOWN_EMBEDDED_WALLET_ERROR), Error("Failed to import wallet");
        return t("createWallet", "onSuccess", {
            wallet: h
        }), h
    };
class _$e {
    async handleSignMessage(e) {
        if (!e.params || typeof e.params.message != "string") throw Error("Message must be provided as a string for Solana signMessage RPC");
        let r = await this.signMessage(On(e.params.message, "base64"));
        return {
            signature: On(r).toString("base64")
        }
    }
    async request(e) {
        if (console.debug("EmbeddedSolanaProvider.request() called with args", e), !await ir()) throw Error("User must be authenticated to use embedded Solana wallet");
        if (!await NPe({
                address: this.address
            })) throw new J("Unable to connect to Solana embedded wallet");
        if (e.method === "signMessage") return await this.handleSignMessage(e);
        throw Error("Embedded Solana provider does not yet support this RPC method.")
    }
    constructor(e, r, n) {
        this.walletProxy = e, this.address = r, this.signMessage = n
    }
}
async function D4({
    tx: t,
    accessToken: e,
    walletProxy: r,
    entropyId: n,
    entropyIdVerifier: i,
    transactingWalletAddress: s,
    transactingWalletIndex: a
}) {
    let o = h1(t, s),
        c = al(t) ? On(t.message.serialize()) : t.serializeMessage(),
        {
            response: l
        } = await r.rpc({
            accessToken: e,
            entropyId: n,
            entropyIdVerifier: i,
            chainType: "solana",
            hdWalletIndex: a,
            request: {
                method: "signMessage",
                params: {
                    message: c.toString("base64")
                }
            }
        }),
        u = On(l.data.signature, "base64");
    return t.addSignature(o, u), t
}
const C$e = t => t.reduce((e, r) => !e || e.walletIndex < r.walletIndex ? r : e, null);
let G$ = async ({
        accessToken: t,
        appConfig: e,
        privy: r,
        emitPrivyEvent: n,
        proxy: i,
        refreshSessionAndUser: s,
        recoverEmbeddedWallet: a,
        user: o,
        walletIndex: c,
        setModalData: l,
        openModal: u,
        chainType: h,
        setUser: f
    }) => {
        if (c < 0) throw n("createWallet", "onError", ee.EMBEDDED_WALLET_CREATE_ERROR), Error(`A negative walletIndex (${c}) is invalid.`);
        let p = Rs(o);
        if (c > 0 && !p) throw n("createWallet", "onError", ee.EMBEDDED_WALLET_NOT_FOUND), Error("Must have an existing embedded wallet to create an additional wallet.");
        if (e.embeddedWallets.requireUserOwnedRecoveryOnCreate && e.embeddedWallets.mode === "user-controlled-server-wallets-only") throw n("createWallet", "onError", ee.EMBEDDED_WALLET_CREATE_ERROR), Error("User owned recovery not yet supported for this app.");
        if (!p && e.embeddedWallets.requireUserOwnedRecoveryOnCreate) return await K$({
            emitPrivyEvent: n,
            setModalData: l,
            openModal: u,
            chainType: h
        });
        let g = $8(o, {
            chainType: h,
            walletIndex: c
        })[0];
        if (g) return {
            user: o,
            account: g
        };
        if (c === 0 && !i) return K$({
            emitPrivyEvent: n,
            setModalData: l,
            openModal: u,
            chainType: h
        });
        if (!i) throw n("createWallet", "onError", ee.UNKNOWN_EMBEDDED_WALLET_ERROR), Error("Failed to connect to wallet proxy");
        return mF({
            appConfig: e,
            walletIndex: c,
            chainType: h,
            user: o,
            accessToken: t,
            proxy: i,
            refreshSessionAndUser: s,
            privy: r,
            recoverEmbeddedWallet: a,
            setUser: f
        })
    },
    K$ = async ({
        emitPrivyEvent: t,
        setModalData: e,
        openModal: r,
        chainType: n
    }) => new Promise((i, s) => {
        e({
            createWallet: {
                onSuccess: ({
                    user: a,
                    account: o
                }) => {
                    t("createWallet", "onSuccess", {
                        wallet: o
                    }), i({
                        user: a,
                        account: o
                    })
                },
                onFailure: a => {
                    t("createWallet", "onError", ee.UNKNOWN_EMBEDDED_WALLET_ERROR), s(a)
                },
                callAuthOnSuccessOnClose: !1,
                shouldCreateEth: n === "ethereum",
                shouldCreateSol: n === "solana"
            }
        }), r(bc)
    });
const yB = () => {
    let t = Gt(),
        e = yc(),
        {
            setModalData: r
        } = Ne(),
        {
            getAccessToken: n
        } = $t(),
        {
            initializeWalletProxy: i,
            recoverEmbeddedWallet: s,
            setUser: a,
            openModal: o,
            refreshSessionAndUser: c,
            privy: l
        } = $e();
    return {
        create: async ({
            chainType: u,
            options: h,
            latestUser: f
        }) => {
            let p = f;
            if (p || (p = await c()), !p) throw e("createWallet", "onError", ee.MUST_BE_AUTHENTICATED), Error("User must be authenticated before creating a Privy wallet");
            return await (async ({
                appConfig: g,
                getAccessToken: m,
                initializeWalletProxy: y,
                user: w,
                privy: x,
                emitPrivyEvent: E,
                recoverEmbeddedWallet: _,
                setModalData: b,
                openModal: A,
                setUser: I,
                options: T,
                timeoutDuration: C,
                refreshSessionAndUser: $,
                chainType: P
            }) => {
                var O, M;
                let [N, R] = await Promise.all([y(C), m()]);
                if (!R || !w) throw E("createWallet", "onError", ee.MUST_BE_AUTHENTICATED), Error("User must be authenticated before creating a Privy wallet");
                if (!N && ((O = g.customAuth) != null && O.enabled)) throw E("createWallet", "onError", ee.UNKNOWN_EMBEDDED_WALLET_ERROR), Error("Failed to connect to wallet proxy");
                if (T && "walletIndex" in T && typeof T.walletIndex == "number") {
                    if (g.embeddedWallets.mode === "user-controlled-server-wallets-only") throw E("createWallet", "onError", ee.INVALID_DATA), Error("Invalid input, use `createAdditional` instead of `walletIndex` to create additional wallets.");
                    return G$({
                        accessToken: R,
                        appConfig: g,
                        privy: x,
                        emitPrivyEvent: E,
                        openModal: A,
                        proxy: N,
                        refreshSessionAndUser: $,
                        recoverEmbeddedWallet: _,
                        setModalData: b,
                        user: w,
                        walletIndex: T.walletIndex,
                        chainType: P,
                        setUser: I
                    })
                }
                let D = T && "createAdditional" in T && T.createAdditional,
                    S = $8(w, {
                        chainType: P
                    });
                if (S[0] && !D) throw E("createWallet", "onError", ee.EMBEDDED_WALLET_ALREADY_EXISTS), Error("User already has an embedded wallet.");
                return G$({
                    accessToken: R,
                    appConfig: g,
                    privy: x,
                    emitPrivyEvent: E,
                    openModal: A,
                    proxy: N,
                    recoverEmbeddedWallet: _,
                    setModalData: b,
                    user: w,
                    walletIndex: (((M = C$e(S)) == null ? void 0 : M.walletIndex) ? ? -1) + 1,
                    chainType: P,
                    refreshSessionAndUser: $,
                    setUser: I
                })
            })({
                appConfig: t,
                privy: l,
                getAccessToken: n,
                refreshSessionAndUser: c,
                initializeWalletProxy: i,
                user: p,
                emitPrivyEvent: e,
                recoverEmbeddedWallet: s,
                setModalData: r,
                openModal: o,
                setUser: a,
                options: h,
                timeoutDuration: XL,
                chainType: u
            })
        }
    }
};

function A$e(t) {
    let {
        create: e
    } = yB();
    return Wd("createWallet", t), {
        createWallet: async r => {
            r && "target" in r && r && (r = void 0);
            let {
                account: n
            } = await e({
                chainType: "ethereum",
                options: r
            });
            return n
        }
    }
}
const k$e = () => {
        let {
            getAccessToken: t,
            user: e
        } = $t(), {
            refreshSessionAndUser: r,
            initializeWalletProxy: n
        } = $e(), i = yc(), s = Gt();
        return {
            importWallet: v.useCallback(({
                privateKey: a
            }) => E$e({
                getAccessToken: t,
                user: e,
                initializeWalletProxy: n,
                refreshSessionAndUser: r,
                emitPrivyEvent: i,
                appConfig: s
            }, {
                privateKey: a,
                chainType: "ethereum"
            }), [e, t, r, n, i])
        }
    },
    mw = () => {
        let {
            importWallet: t
        } = k$e(), {
            createWallet: e
        } = A$e();
        return { ...v.useContext(Td),
            importWallet: t,
            createWallet: e
        }
    },
    U8 = t => t.filter(e => e.method === "wallets" || (e.method === "exchange" ? e.provider === "coinbase" : e.method === "card" || e.method === "payment-request" ? e.provider === "coinbase" || e.provider === "moonpay" : (e.method, !1))),
    wB = t => !!t.fundingConfig && U8(t.fundingConfig.options).length >= 1,
    I$e = ({
        children: t,
        theme: e
    }) => d.jsxs($$e, {
        $theme: e,
        children: [d.jsx(yo, {
            width: "3rem",
            color: "var(--privy-color-error)"
        }), t]
    });
let $$e = z.div.withConfig({
    displayName: "Container",
    componentId: "sc-5400b18f-0"
})(["display:flex;gap:0.5rem;", " align-items:flex-start;text-align:left;padding:0.5rem 0.75rem;font-size:0.75rem;font-weight:400;line-height:1.125rem;padding:0.5rem 0.75rem;&&{border:1px solid var(--privy-color-error);border-radius:var(--privy-border-radius-sm);}"], t => t.$theme === "dark" ? "color: var(--privy-color-error);" : "background-color: var(--privy-color-error-light);");
const S$e = t => d.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 210.2",
        xmlSpace: "preserve",
        ...t,
        children: d.jsx("path", {
            d: "M93.6,27.1C87.6,34.2,78,39.8,68.4,39c-1.2-9.6,3.5-19.8,9-26.1c6-7.3,16.5-12.5,25-12.9  C103.4,10,99.5,19.8,93.6,27.1 M102.3,40.9c-13.9-0.8-25.8,7.9-32.4,7.9c-6.7,0-16.8-7.5-27.8-7.3c-14.3,0.2-27.6,8.3-34.9,21.2  c-15,25.8-3.9,64,10.6,85c7.1,10.4,15.6,21.8,26.8,21.4c10.6-0.4,14.8-6.9,27.6-6.9c12.9,0,16.6,6.9,27.8,6.7  c11.6-0.2,18.9-10.4,26-20.8c8.1-11.8,11.4-23.3,11.6-23.9c-0.2-0.2-22.4-8.7-22.6-34.3c-0.2-21.4,17.5-31.6,18.3-32.2  C123.3,42.9,107.7,41.3,102.3,40.9 M182.6,11.9v155.9h24.2v-53.3h33.5c30.6,0,52.1-21,52.1-51.4c0-30.4-21.1-51.2-51.3-51.2H182.6z   M206.8,32.3h27.9c21,0,33,11.2,33,30.9c0,19.7-12,31-33.1,31h-27.8V32.3z M336.6,169c15.2,0,29.3-7.7,35.7-19.9h0.5v18.7h22.4V90.2  c0-22.5-18-37-45.7-37c-25.7,0-44.7,14.7-45.4,34.9h21.8c1.8-9.6,10.7-15.9,22.9-15.9c14.8,0,23.1,6.9,23.1,19.6v8.6l-30.2,1.8  c-28.1,1.7-43.3,13.2-43.3,33.2C298.4,155.6,314.1,169,336.6,169z M343.1,150.5c-12.9,0-21.1-6.2-21.1-15.7c0-9.8,7.9-15.5,23-16.4  l26.9-1.7v8.8C371.9,140.1,359.5,150.5,343.1,150.5z M425.1,210.2c23.6,0,34.7-9,44.4-36.3L512,54.7h-24.6l-28.5,92.1h-0.5  l-28.5-92.1h-25.3l41,113.5l-2.2,6.9c-3.7,11.7-9.7,16.2-20.4,16.2c-1.9,0-5.6-0.2-7.1-0.4v18.7C417.3,210,423.3,210.2,425.1,210.2z"
        })
    }),
    T$e = t => d.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 80 38.1",
        xmlSpace: "preserve",
        ...t,
        children: [d.jsx("path", {
            style: {
                fill: "#5F6368"
            },
            d: "M37.8,19.7V29h-3V6h7.8c1.9,0,3.7,0.7,5.1,2c1.4,1.2,2.1,3,2.1,4.9c0,1.9-0.7,3.6-2.1,4.9c-1.4,1.3-3.1,2-5.1,2  L37.8,19.7L37.8,19.7z M37.8,8.8v8h5c1.1,0,2.2-0.4,2.9-1.2c1.6-1.5,1.6-4,0.1-5.5c0,0-0.1-0.1-0.1-0.1c-0.8-0.8-1.8-1.3-2.9-1.2  L37.8,8.8L37.8,8.8z"
        }), d.jsx("path", {
            style: {
                fill: "#5F6368"
            },
            d: "M56.7,12.8c2.2,0,3.9,0.6,5.2,1.8s1.9,2.8,1.9,4.8V29H61v-2.2h-0.1c-1.2,1.8-2.9,2.7-4.9,2.7  c-1.7,0-3.2-0.5-4.4-1.5c-1.1-1-1.8-2.4-1.8-3.9c0-1.6,0.6-2.9,1.8-3.9c1.2-1,2.9-1.4,4.9-1.4c1.8,0,3.2,0.3,4.3,1v-0.7  c0-1-0.4-2-1.2-2.6c-0.8-0.7-1.8-1.1-2.9-1.1c-1.7,0-3,0.7-3.9,2.1l-2.6-1.6C51.8,13.8,53.9,12.8,56.7,12.8z M52.9,24.2  c0,0.8,0.4,1.5,1,1.9c0.7,0.5,1.5,0.8,2.3,0.8c1.2,0,2.4-0.5,3.3-1.4c1-0.9,1.5-2,1.5-3.2c-0.9-0.7-2.2-1.1-3.9-1.1  c-1.2,0-2.2,0.3-3,0.9C53.3,22.6,52.9,23.3,52.9,24.2z"
        }), d.jsx("path", {
            style: {
                fill: "#5F6368"
            },
            d: "M80,13.3l-9.9,22.7h-3l3.7-7.9l-6.5-14.7h3.2l4.7,11.3h0.1l4.6-11.3H80z"
        }), d.jsx("path", {
            style: {
                fill: "#4285F4"
            },
            d: "M25.9,17.7c0-0.9-0.1-1.8-0.2-2.7H13.2v5.1h7.1c-0.3,1.6-1.2,3.1-2.6,4v3.3H22C24.5,25.1,25.9,21.7,25.9,17.7z"
        }), d.jsx("path", {
            style: {
                fill: "#34A853"
            },
            d: "M13.2,30.6c3.6,0,6.6-1.2,8.8-3.2l-4.3-3.3c-1.2,0.8-2.7,1.3-4.5,1.3c-3.4,0-6.4-2.3-7.4-5.5H1.4v3.4  C3.7,27.8,8.2,30.6,13.2,30.6z"
        }), d.jsx("path", {
            style: {
                fill: "#FBBC04"
            },
            d: "M5.8,19.9c-0.6-1.6-0.6-3.4,0-5.1v-3.4H1.4c-1.9,3.7-1.9,8.1,0,11.9L5.8,19.9z"
        }), d.jsx("path", {
            style: {
                fill: "#EA4335"
            },
            d: "M13.2,9.4c1.9,0,3.7,0.7,5.1,2l0,0l3.8-3.8c-2.4-2.2-5.6-3.5-8.8-3.4c-5,0-9.6,2.8-11.8,7.3l4.4,3.4  C6.8,11.7,9.8,9.4,13.2,9.4z"
        })]
    }),
    Y$ = t => {
        let [e, r] = v.useState();
        return v.useEffect(() => {
            t().then(n => {
                r(n)
            }).catch(() => {})
        }, []), e
    },
    P$e = ({ ...t
    }) => d.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        ...t,
        children: [d.jsx("rect", {
            width: "18",
            height: "18",
            x: "3",
            y: "3",
            rx: "2"
        }), d.jsx("path", {
            d: "M3 9a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2"
        }), d.jsx("path", {
            d: "M3 11h3c.8 0 1.6.3 2.1.9l1.1.9c1.6 1.6 4.1 1.6 5.7 0l1.1-.9c.5-.5 1.3-.9 2.1-.9H21"
        })]
    }),
    bB = async ({
        address: t,
        chain: e,
        rpcConfig: r,
        privyAppId: n
    }) => {
        try {
            let i = nc({
                    chain: e,
                    transport: rc(cc(e, r, n))
                }),
                [s, a] = await Promise.all([i.readContract({
                    abi: Z$,
                    address: t,
                    functionName: "symbol"
                }), i.readContract({
                    abi: Z$,
                    address: t,
                    functionName: "decimals"
                })]);
            return {
                decimals: a,
                symbol: s
            }
        } catch (i) {
            return console.log(i), null
        }
    };
let Z$ = [{
    inputs: [],
    name: "decimals",
    outputs: [{
        internalType: "uint8",
        name: "",
        type: "uint8"
    }],
    stateMutability: "view",
    type: "function"
}, {
    inputs: [],
    name: "symbol",
    outputs: [{
        internalType: "string",
        name: "",
        type: "string"
    }],
    stateMutability: "view",
    type: "function"
}];
const Mh = ({
    size: t
}) => d.jsx(N$e, {
    $size: t,
    children: d.jsxs(O$e, {
        children: [d.jsx(j$e, {}), d.jsx(R$e, {})]
    })
});
let N$e = z.div.withConfig({
        displayName: "LoadingContainer",
        componentId: "sc-3ddaba1c-0"
    })(["--spinner-size:", ";display:flex;justify-content:center;align-items:center;flex-grow:1;@media all and (display-mode:standalone){margin-bottom:30px;}"], t => t.$size ? t.$size : "96px"),
    O$e = z.div.withConfig({
        displayName: "SpinnerContainer",
        componentId: "sc-3ddaba1c-1"
    })(["position:relative;height:var(--spinner-size);width:var(--spinner-size);opacity:1;animation:fadein 200ms ease;"]),
    j$e = z.div.withConfig({
        displayName: "CircleFixed",
        componentId: "sc-3ddaba1c-2"
    })(["position:absolute;top:0;right:0;bottom:0;left:0;width:var(--spinner-size);height:var(--spinner-size);&&{border:4px solid #f1f2f9;border-radius:50%;}"]),
    R$e = z.div.withConfig({
        displayName: "CircleRotate",
        componentId: "sc-3ddaba1c-3"
    })(["position:absolute;top:0;right:0;bottom:0;left:0;width:var(--spinner-size);height:var(--spinner-size);animation:spin 1200ms linear infinite;&&{border:4px solid;border-color:#cbcde1 transparent transparent transparent;border-radius:50%;}@keyframes spin{from{transform:rotate(0deg);}to{transform:rotate(360deg);}}"]);
const Dh = z.span.withConfig({
        displayName: "Rows",
        componentId: "sc-b764aab6-0"
    })(["display:flex;flex-direction:column;gap:0.35rem;width:100%;"]),
    Oe = z.span.withConfig({
        displayName: "Row",
        componentId: "sc-b764aab6-1"
    })(["display:flex;width:100%;justify-content:space-between;gap:0.5rem;"]),
    qe = z.span.withConfig({
        displayName: "LabelSm",
        componentId: "sc-6c002d6-0"
    })(["color:var(--privy-color-foreground-3);font-size:0.875rem;font-weight:400;line-height:1.375rem;"]),
    M$e = z(qe).withConfig({
        displayName: "LabelSmPrimary",
        componentId: "sc-6c002d6-1"
    })(["color:var(--privy-color-accent);"]),
    Je = z.span.withConfig({
        displayName: "Value",
        componentId: "sc-72aa026-0"
    })(["color:var(--privy-color-foreground);font-size:0.875rem;font-weight:500;line-height:1.375rem;word-break:break-all;text-align:right;", ""], uw),
    D$e = t => d.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        version: "1.1",
        id: "Layer_1",
        x: "0px",
        y: "0px",
        viewBox: "0 0 397.7 311.7",
        enableBackground: "new 0 0 397.7 311.7",
        xmlSpace: "preserve",
        ...t,
        children: [d.jsxs("linearGradient", {
            id: "SVGID_1_",
            gradientUnits: "userSpaceOnUse",
            x1: "360.8791",
            y1: "351.4553",
            x2: "141.213",
            y2: "-69.2936",
            gradientTransform: "matrix(1 0 0 -1 0 314)",
            children: [d.jsx("stop", {
                offset: "0",
                stopColor: "#00FFA3"
            }), d.jsx("stop", {
                offset: "1",
                stopColor: "#DC1FFF"
            })]
        }), d.jsx("path", {
            d: "M64.6,237.9c2.4-2.4,5.7-3.8,9.2-3.8h317.4c5.8,0,8.7,7,4.6,11.1l-62.7,62.7c-2.4,2.4-5.7,3.8-9.2,3.8H6.5  c-5.8,0-8.7-7-4.6-11.1L64.6,237.9z",
            fill: "url(#SVGID_1_)"
        }), d.jsxs("linearGradient", {
            id: "SVGID_2_",
            gradientUnits: "userSpaceOnUse",
            x1: "264.8291",
            y1: "401.6014",
            x2: "45.163",
            y2: "-19.1475",
            gradientTransform: "matrix(1 0 0 -1 0 314)",
            children: [d.jsx("stop", {
                offset: "0",
                stopColor: "#00FFA3"
            }), d.jsx("stop", {
                offset: "1",
                stopColor: "#DC1FFF"
            })]
        }), d.jsx("path", {
            d: "M64.6,3.8C67.1,1.4,70.4,0,73.8,0h317.4c5.8,0,8.7,7,4.6,11.1l-62.7,62.7c-2.4,2.4-5.7,3.8-9.2,3.8H6.5  c-5.8,0-8.7-7-4.6-11.1L64.6,3.8z",
            fill: "url(#SVGID_2_)"
        }), d.jsxs("linearGradient", {
            id: "SVGID_3_",
            gradientUnits: "userSpaceOnUse",
            x1: "312.5484",
            y1: "376.688",
            x2: "92.8822",
            y2: "-44.061",
            gradientTransform: "matrix(1 0 0 -1 0 314)",
            children: [d.jsx("stop", {
                offset: "0",
                stopColor: "#00FFA3"
            }), d.jsx("stop", {
                offset: "1",
                stopColor: "#DC1FFF"
            })]
        }), d.jsx("path", {
            d: "M333.1,120.1c-2.4-2.4-5.7-3.8-9.2-3.8H6.5c-5.8,0-8.7,7-4.6,11.1l62.7,62.7c2.4,2.4,5.7,3.8,9.2,3.8h317.4  c5.8,0,8.7-7,4.6-11.1L333.1,120.1z",
            fill: "url(#SVGID_3_)"
        })]
    });
let L$e = {
    [ja.id]: t => d.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        version: "1.1",
        id: "Layer_1",
        x: "0px",
        y: "0px",
        viewBox: "0 0 2500 2500",
        xmlSpace: "preserve",
        ...t,
        children: d.jsx("g", {
            id: "Layer_x0020_1",
            children: d.jsxs("g", {
                id: "_2405588477232",
                children: [d.jsx("rect", {
                    fill: "none",
                    width: "2500",
                    height: "2500"
                }), d.jsx("g", {
                    children: d.jsxs("g", {
                        children: [d.jsx("path", {
                            fill: "#213147",
                            d: "M226,760v980c0,63,33,120,88,152l849,490c54,31,121,31,175,0l849-490c54-31,88-89,88-152V760      c0-63-33-120-88-152l-849-490c-54-31-121-31-175,0L314,608c-54,31-87,89-87,152H226z"
                        }), d.jsx("g", {
                            children: d.jsxs("g", {
                                children: [d.jsx("g", {
                                    children: d.jsx("path", {
                                        fill: "#12AAFF",
                                        d: "M1435,1440l-121,332c-3,9-3,19,0,29l208,571l241-139l-289-793C1467,1422,1442,1422,1435,1440z"
                                    })
                                }), d.jsx("g", {
                                    children: d.jsx("path", {
                                        fill: "#12AAFF",
                                        d: "M1678,882c-7-18-32-18-39,0l-121,332c-3,9-3,19,0,29l341,935l241-139L1678,883V882z"
                                    })
                                })]
                            })
                        }), d.jsx("g", {
                            children: d.jsx("path", {
                                fill: "#9DCCED",
                                d: "M1250,155c6,0,12,2,17,5l918,530c11,6,17,18,17,30v1060c0,12-7,24-17,30l-918,530c-5,3-11,5-17,5       s-12-2-17-5l-918-530c-11-6-17-18-17-30V719c0-12,7-24,17-30l918-530c5-3,11-5,17-5l0,0V155z M1250,0c-33,0-65,8-95,25L237,555       c-59,34-95,96-95,164v1060c0,68,36,130,95,164l918,530c29,17,62,25,95,25s65-8,95-25l918-530c59-34,95-96,95-164V719       c0-68-36-130-95-164L1344,25c-29-17-62-25-95-25l0,0H1250z"
                            })
                        }), d.jsx("polygon", {
                            fill: "#213147",
                            points: "642,2179 727,1947 897,2088 738,2234     "
                        }), d.jsxs("g", {
                            children: [d.jsx("path", {
                                fill: "#FFFFFF",
                                d: "M1172,644H939c-17,0-33,11-39,27L401,2039l241,139l550-1507c5-14-5-28-19-28L1172,644z"
                            }), d.jsx("path", {
                                fill: "#FFFFFF",
                                d: "M1580,644h-233c-17,0-33,11-39,27L738,2233l241,139l620-1701c5-14-5-28-19-28V644z"
                            })]
                        })]
                    })
                })]
            })
        })
    }),
    [yh.id]: t => d.jsxs("svg", {
        width: "1503",
        height: "1504",
        viewBox: "0 0 1503 1504",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...t,
        children: [d.jsx("rect", {
            x: "287",
            y: "258",
            width: "928",
            height: "844",
            fill: "white"
        }), d.jsx("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M1502.5 752C1502.5 1166.77 1166.27 1503 751.5 1503C336.734 1503 0.5 1166.77 0.5 752C0.5 337.234 336.734 1 751.5 1C1166.27 1 1502.5 337.234 1502.5 752ZM538.688 1050.86H392.94C362.314 1050.86 347.186 1050.86 337.962 1044.96C327.999 1038.5 321.911 1027.8 321.173 1015.99C320.619 1005.11 328.184 991.822 343.312 965.255L703.182 330.935C718.495 303.999 726.243 290.531 736.021 285.55C746.537 280.2 759.083 280.2 769.599 285.55C779.377 290.531 787.126 303.999 802.438 330.935L876.42 460.079L876.797 460.738C893.336 489.635 901.723 504.289 905.385 519.669C909.443 536.458 909.443 554.169 905.385 570.958C901.695 586.455 893.393 601.215 876.604 630.549L687.573 964.702L687.084 965.558C670.436 994.693 661.999 1009.46 650.306 1020.6C637.576 1032.78 622.263 1041.63 605.474 1046.62C590.161 1050.86 573.004 1050.86 538.688 1050.86ZM906.75 1050.86H1115.59C1146.4 1050.86 1161.9 1050.86 1171.13 1044.78C1181.09 1038.32 1187.36 1027.43 1187.92 1015.63C1188.45 1005.1 1181.05 992.33 1166.55 967.307C1166.05 966.455 1165.55 965.588 1165.04 964.706L1060.43 785.75L1059.24 783.735C1044.54 758.877 1037.12 746.324 1027.59 741.472C1017.08 736.121 1004.71 736.121 994.199 741.472C984.605 746.453 976.857 759.552 961.544 785.934L857.306 964.891L856.949 965.507C841.69 991.847 834.064 1005.01 834.614 1015.81C835.352 1027.62 841.44 1038.5 851.402 1044.96C860.443 1050.86 875.94 1050.86 906.75 1050.86Z",
            fill: "#E84142"
        })]
    }),
    [Fs.id]: t => d.jsxs("svg", {
        width: "146",
        height: "146",
        viewBox: "0 0 146 146",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...t,
        children: [d.jsx("circle", {
            cx: "73",
            cy: "73",
            r: "73",
            fill: "#0052FF"
        }), d.jsx("path", {
            d: "M73.323 123.729C101.617 123.729 124.553 100.832 124.553 72.5875C124.553 44.343 101.617 21.4463 73.323 21.4463C46.4795 21.4463 24.4581 42.0558 22.271 68.2887H89.9859V76.8864H22.271C24.4581 103.119 46.4795 123.729 73.323 123.729Z",
            fill: "white"
        })]
    }),
    [H1.id]: t => d.jsxs("svg", {
        fill: "none",
        height: "400",
        viewBox: "0 0 400 400",
        width: "400",
        xmlns: "http://www.w3.org/2000/svg",
        ...t,
        children: [d.jsx("path", {
            d: "m0 0h400v400h-400z",
            fill: "#fcff52"
        }), d.jsx("path", {
            d: "m300 100h-200v200h199.996v-69.813h-33.191c-11.442 25.468-37.194 43.206-66.665 43.206-40.63 0-73.533-33.187-73.533-73.533s32.903-73.249 73.533-73.249c30.043 0 55.795 18.313 67.24 44.349h32.62z",
            fill: "#000"
        })]
    }),
    [KP.id]: t => d.jsxs("svg", {
        width: "200",
        height: "208",
        viewBox: "0 0 200 208",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...t,
        children: [d.jsx("rect", {
            width: "199.4",
            height: "207.623",
            fill: "#121212"
        }), d.jsxs("g", {
            "clip-path": "url(#clip0_2303_643)",
            children: [d.jsx("path", {
                d: "M132.369 155.99H49.7001V68.8854H68.6148V139.109H132.369V155.981V155.99Z",
                fill: "white"
            }), d.jsx("path", {
                d: "M132.369 85.7575C141.687 85.7575 149.241 78.2036 149.241 68.8855C149.241 59.5673 141.687 52.0134 132.369 52.0134C123.05 52.0134 115.497 59.5673 115.497 68.8855C115.497 78.2036 123.05 85.7575 132.369 85.7575Z",
                fill: "white"
            })]
        }), d.jsx("defs", {
            children: d.jsx("clipPath", {
                id: "clip0_2303_643",
                children: d.jsx("rect", {
                    width: "99.5407",
                    height: "103.977",
                    fill: "white",
                    transform: "translate(49.7001 52.0134)"
                })
            })
        })]
    }),
    [Bs.id]: t => d.jsxs("svg", {
        version: "1.1",
        id: "Layer_1",
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        x: "0px",
        y: "0px",
        viewBox: "0 0 327.5 533.3",
        enableBackground: "new 0 0 327.5 533.3;",
        xmlSpace: "preserve",
        ...t,
        children: [d.jsx("path", {
            fill: "#8492B2",
            d: "M163.7,197.2V0L0,271.6L163.7,197.2z"
        }), d.jsx("path", {
            fill: "#62688F",
            d: "M163.7,368.4V197.2L0,271.6L163.7,368.4z M163.7,197.2l163.7,74.4L163.7,0V197.2z"
        }), d.jsx("path", {
            fill: "#454A75",
            d: "M163.7,197.2v171.2l163.7-96.8L163.7,197.2z"
        }), d.jsx("path", {
            fill: "#8492B2",
            d: "M163.7,399.4L0,302.7l163.7,230.7V399.4z"
        }), d.jsx("path", {
            fill: "#62688F",
            d: "M327.5,302.7l-163.8,96.7v134L327.5,302.7z"
        })]
    }),
    [go.id]: t => d.jsxs("svg", {
        width: "500",
        height: "500",
        viewBox: "0 0 500 500",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...t,
        children: [d.jsx("circle", {
            cx: "250",
            cy: "250",
            r: "250",
            fill: "#FF0420"
        }), d.jsx("path", {
            d: "M177.133 316.446C162.247 316.446 150.051 312.943 140.544 305.938C131.162 298.808 126.471 288.676 126.471 275.541C126.471 272.789 126.784 269.411 127.409 265.408C129.036 256.402 131.35 245.581 134.352 232.947C142.858 198.547 164.812 181.347 200.213 181.347C209.845 181.347 218.476 182.973 226.107 186.225C233.738 189.352 239.742 194.106 244.12 200.486C248.498 206.74 250.688 214.246 250.688 223.002C250.688 225.629 250.375 228.944 249.749 232.947C247.873 244.08 245.621 254.901 242.994 265.408C238.616 282.546 231.048 295.368 220.29 303.874C209.532 312.255 195.147 316.446 177.133 316.446ZM179.76 289.426C186.766 289.426 192.707 287.362 197.586 283.234C202.59 279.106 206.155 272.789 208.281 264.283C211.158 252.524 213.348 242.266 214.849 233.51C215.349 230.883 215.599 228.194 215.599 225.441C215.599 214.058 209.657 208.366 197.774 208.366C190.768 208.366 184.764 210.43 179.76 214.558C174.882 218.687 171.379 225.004 169.253 233.51C167.001 241.891 164.749 252.149 162.498 264.283C161.997 266.784 161.747 269.411 161.747 272.163C161.747 283.672 167.752 289.426 179.76 289.426Z",
            fill: "white"
        }), d.jsx("path", {
            d: "M259.303 314.57C257.927 314.57 256.863 314.132 256.113 313.256C255.487 312.255 255.3 311.13 255.55 309.879L281.444 187.914C281.694 186.538 282.382 185.412 283.508 184.536C284.634 183.661 285.822 183.223 287.073 183.223H336.985C350.87 183.223 362.003 186.1 370.384 191.854C378.891 197.609 383.144 205.927 383.144 216.81C383.144 219.937 382.769 223.19 382.018 226.567C378.891 240.953 372.574 251.586 363.067 258.466C353.685 265.346 340.8 268.786 324.413 268.786H299.082L290.451 309.879C290.2 311.255 289.512 312.38 288.387 313.256C287.261 314.132 286.072 314.57 284.822 314.57H259.303ZM325.727 242.892C330.98 242.892 335.546 241.453 339.424 238.576C343.427 235.699 346.054 231.571 347.305 226.192C347.68 224.065 347.868 222.189 347.868 220.563C347.868 216.935 346.805 214.183 344.678 212.307C342.551 210.305 338.924 209.305 333.795 209.305H311.278L304.148 242.892H325.727Z",
            fill: "white"
        })]
    }),
    [fs.id]: t => d.jsxs("svg", {
        width: "360",
        height: "360",
        viewBox: "0 0 360 360",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...t,
        children: [d.jsx("rect", {
            width: "360",
            height: "360",
            rx: "180",
            fill: "#6C00F6"
        }), d.jsx("path", {
            d: "M157.743 154.241L141.052 144.58L90.9766 173.561V231.519L141.052 260.5L191.13 231.519V141.359L218.948 125.26L246.77 141.359V173.561L218.948 189.66L202.257 180.002V205.759L218.948 215.42L269.024 186.439V128.481L218.948 99.5L168.873 128.481V218.641L141.052 234.74L113.233 218.641V186.439L141.052 170.34L157.743 179.998V154.241Z",
            fill: "white"
        })]
    }),
    [$6.id]: t => d.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "30",
        height: "30",
        viewBox: "0 0 30 30",
        fill: "none",
        ...t,
        children: [d.jsx("g", {
            clipPath: "url(#clip0)",
            children: d.jsx("g", {
                clipPath: "url(#clip1)",
                children: d.jsx("path", {
                    d: "M14.9188 29.8373C6.67944 29.8373 0.00012207 23.1581 0.00012207 14.9187C0.00012207 6.67931 6.67944 0 14.9188 0C23.1581 0 29.8373 6.67931 29.8373 14.9187C29.8373 23.1581 23.1581 29.8373 14.9188 29.8373Z",
                    fill: "url(#paint0)"
                })
            })
        }), d.jsxs("defs", {
            children: [d.jsxs("radialGradient", {
                id: "paint0",
                cx: "0",
                cy: "0",
                r: "1",
                gradientUnits: "userSpaceOnUse",
                gradientTransform: "translate(21.6921 8.02215) rotate(180) scale(25.2008)",
                children: [d.jsx("stop", {
                    offset: "0.00682297",
                    stopColor: "#F2CEFE"
                }), d.jsx("stop", {
                    offset: "0.1913",
                    stopColor: "#AFBAF1"
                }), d.jsx("stop", {
                    offset: "0.4982",
                    stopColor: "#4281D3"
                }), d.jsx("stop", {
                    offset: "0.666667",
                    stopColor: "#2E427D"
                }), d.jsx("stop", {
                    offset: "0.822917",
                    stopColor: "#230101"
                }), d.jsx("stop", {
                    offset: "1",
                    stopColor: "#8F6B40"
                })]
            }), d.jsx("clipPath", {
                id: "clip0",
                children: d.jsx("rect", {
                    width: "30",
                    height: "30",
                    fill: "white"
                })
            }), d.jsx("clipPath", {
                id: "clip1",
                children: d.jsx("rect", {
                    width: "30",
                    height: "30",
                    fill: "white"
                })
            })]
        })]
    })
};
const vB = ({
        chainId: t,
        ...e
    }) => {
        if (t === "solana") return d.jsx(D$e, { ...e
        });
        let r = L$e[t];
        return d.jsx(r || UL, { ...e
        })
    },
    yw = ({
        wallet: t,
        displayName: e,
        addressToFund: r,
        chainId: n,
        chainName: i,
        isBridging: s,
        isErc20Flow: a,
        totalPriceInNativeCurrency: o,
        totalPriceInUsd: c,
        gasPriceInNativeCurrency: l,
        gasPriceInUsd: u
    }) => {
        var f;
        let h = mc(t.walletClientType);
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Bi, {}), d.jsx(Mh, {}), d.jsx(ol, {
                style: {
                    marginTop: "16px"
                },
                children: d.jsx(oB, {
                    icon: (f = h == null ? void 0 : h.image_url) == null ? void 0 : f.md,
                    name: t.walletClientType
                })
            }), d.jsx($r, {
                style: {
                    marginTop: "8px",
                    marginBottom: "12px"
                },
                title: `${s?"Bridging":"Confirming"} with ${e}`
            }), !s && !a && d.jsxs(Dh, {
                children: [d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Total"
                    }), d.jsx(Je, {
                        children: c || o
                    })]
                }), d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "To"
                    }), d.jsx(Je, {
                        children: d.jsx(Rt, {
                            address: r,
                            showCopyIcon: !1
                        })
                    })]
                }), d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Network"
                    }), d.jsx(Je, {
                        children: d.jsxs(U$e, {
                            children: [d.jsx(vB, {
                                chainId: n,
                                height: 16,
                                width: 16
                            }), " ", i]
                        })
                    })]
                }), l && d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Estimated fee"
                    }), d.jsx(Je, {
                        children: u || l
                    })]
                })]
            }), d.jsx(C8, {
                height: 24
            }), d.jsx(ot, {})]
        })
    };
let U$e = z.div.withConfig({
    displayName: "NetworkColumn",
    componentId: "sc-ec6320ce-0"
})(["display:flex;flex-direction:row;align-items:center;gap:4px;"]);
const xB = {
        component: () => {
            var S, O;
            let {
                closePrivyModal: t,
                createAnalyticsEvent: e
            } = $e(), {
                navigate: r,
                setModalData: n,
                app: i,
                data: s
            } = Ne(), {
                wallets: a
            } = z0(), o = Rh(), [c, l] = v.useState(0 n), [u, h] = v.useState(null), [f, p] = v.useState(!1), [g, m] = v.useState(!1), y = v.useRef(!1);
            if (!(s != null && s.funding) || s.funding.chainType !== "solana") throw Error("Invalid funding data");
            let {
                address: w,
                amount: x,
                cluster: E,
                connectedWalletAddress: _
            } = s.funding, b = function({
                name: M,
                rpcUrl: U
            }) {
                if (U) return U;
                switch (M) {
                    case "mainnet-beta":
                        return "https://api.mainnet-beta.solana.com";
                    case "testnet":
                        return "https://api.testnet.solana.com";
                    case "devnet":
                        return "https://api.devnet.solana.com"
                }
            }(E), {
                tokenPrice: A
            } = Oh("solana"), {
                fundingAmountInBaseUnit: I,
                totalPriceInUsd: T,
                totalPriceInNativeCurrency: C,
                feePriceInNativeCurrency: $,
                feePriceInUsd: P
            } = VU({
                amount: x,
                fee: c,
                tokenPrice: A,
                isUsdc: s.funding.isUSDC
            }), N = _ ? a.find(({
                address: M
            }) => M === _) : a[0], R = mc((N == null ? void 0 : N.walletClientType) || "unknown"), D = (R == null ? void 0 : R.name) || "wallet";
            return v.useEffect(() => {
                (async () => {
                    var M, U, k;
                    if ((N == null ? void 0 : N.type) === "solana" && N.sendTransaction && !f && !y.current) {
                        y.current = !0;
                        try {
                            let F = o(W0);
                            if (!F) throw new J("Unable to load solana plugin");
                            let {
                                connection: q,
                                transaction: W
                            } = (M = s.funding) != null && M.isUSDC ? await F.createSplTransferTransaction({
                                from: N.address,
                                to: w,
                                amount: I,
                                mintAddress: Vg[E.name],
                                cluster: E
                            }) : await F.createTransferTransaction({
                                from: N.address,
                                to: w,
                                amount: I,
                                cluster: E
                            }), K = await W.getEstimatedFee(q);
                            K != null && l(BigInt(K)), p(!0);
                            let H = await q.simulateTransaction(W);
                            if (H.value.err) return (U = H.value.logs) != null && U.find(X => /insufficient (lamports|funds)/gi.test(X)) ? void h(new J(`Wallet ${Yn(N.address,void 0,void 0,"solana")} does not have enough funds.`, void 0, ee.INSUFFICIENT_BALANCE)) : (console.error("Transaction failed:", H.value.err), void h(new J("Something went wrong", void 0, ee.TRANSACTION_FAILURE)));
                            let j = await N.sendTransaction(W, q),
                                {
                                    value: V,
                                    token: Y
                                } = (k = s.funding) != null && k.isUSDC ? {
                                    value: Nn(I, 6),
                                    token: "USDC"
                                } : {
                                    value: Nn(I, 9),
                                    token: "SOL"
                                };
                            e({
                                eventName: Na,
                                payload: {
                                    provider: "external",
                                    status: "success",
                                    txHash: j,
                                    rpcEndpoint: b,
                                    address: N.address,
                                    value: V,
                                    chainType: "solana",
                                    clusterName: E.name,
                                    token: Y,
                                    destinationAddress: w,
                                    destinationValue: V,
                                    destinationChainType: "solana",
                                    destinationClusterName: E.name,
                                    destinationToken: Y
                                }
                            }), p(!1), m(!0)
                        } catch (F) {
                            if (console.error(F), p(!1), /user rejected the request/gi.test(F.message || "")) return void h(new J("Transaction was rejected by the user", void 0, ee.TRANSACTION_FAILURE));
                            h(new J("Something went wrong", void 0, ee.TRANSACTION_FAILURE))
                        }
                    }
                })().catch(console.error).finally(() => y.current = !1)
            }, []), v.useEffect(() => {
                u && (n({
                    funding: s == null ? void 0 : s.funding,
                    sendTransaction: s == null ? void 0 : s.sendTransaction,
                    errorModalData: {
                        error: u,
                        previousScreen: Lh
                    }
                }), r(Sr, !1))
            }, [u]), v.useEffect(() => {
                if (!g) return;
                let M = setTimeout(t, Hy);
                return () => clearTimeout(M)
            }, [g]), g ? d.jsxs(d.Fragment, {
                children: [d.jsx(Bi, {}), d.jsx(er, {}), d.jsxs(wc, {
                    children: [d.jsx(gc, {
                        color: "var(--privy-color-success)",
                        width: "64px",
                        height: "64px"
                    }), d.jsx($r, {
                        title: "Success!",
                        description: `You’ve successfully added ${x} ${(S=s.funding)!=null&&S.isUSDC?"USDC":"SOL"} to your ${i.name} wallet. It may take a minute before the funds are available to use.`
                    })]
                }), d.jsx(nr, {}), d.jsx(ot, {})]
            }) : N && f ? d.jsx(yw, {
                wallet: N,
                displayName: D,
                addressToFund: w,
                isBridging: !1,
                isErc20Flow: !!((O = s.funding) != null && O.isUSDC),
                totalPriceInUsd: T,
                totalPriceInNativeCurrency: C,
                gasPriceInUsd: P,
                gasPriceInNativeCurrency: $,
                chainId: "solana",
                chainName: E.name
            }) : d.jsxs(d.Fragment, {
                children: [d.jsx(Bi, {}), d.jsx(Mh, {}), d.jsx("div", {
                    style: {
                        marginTop: "1rem"
                    }
                }), d.jsx(ot, {})]
            })
        }
    },
    L4 = [{
        constant: !1,
        inputs: [{
            name: "_to",
            type: "address"
        }, {
            name: "_value",
            type: "uint256"
        }],
        name: "transfer",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }];
let F$e = 2 n ** 256 n - 1 n;
const x1 = ({
        amount: t,
        decimals: e
    }) => t === F$e ? "Maximum" : Intl.NumberFormat(void 0, {
        maximumFractionDigits: e
    }).format(Number(t) / 10 ** e),
    EB = ({
        chains: t,
        appId: e,
        address: r,
        rpcConfig: n,
        includeUsdc: i
    }) => Promise.all(t.map(async s => {
        let a = nc({
                chain: s,
                transport: rc(cc(s, n, e))
            }),
            o = await a.getBalance({
                address: r
            }).catch(() => 0 n),
            c = null,
            l = tne[s.id];
        if (i && l) {
            let {
                balance: u
            } = await L8({
                address: r,
                chain: s,
                rpcConfig: n,
                appId: e,
                erc20Address: l
            });
            c = u
        }
        return {
            balance: o,
            erc20Balance: c,
            erc20Address: l,
            chain: s
        }
    })),
    B$e = ({
        balance: t,
        className: e,
        chain: r
    }) => d.jsx(pw, {
        className: e,
        $state: void 0,
        children: d.jsx(U4, {
            balance: t,
            chain: r
        })
    }),
    U4 = ({
        balance: t,
        chain: e
    }) => d.jsxs(d.Fragment, {
        children: [d.jsxs(W$e, {
            children: [d.jsx(q$e, {
                chainId: "id" in e ? e.id : "solana"
            }), d.jsx(Je, {
                children: e.name
            })]
        }), d.jsxs(Ta, {
            isLoading: !1,
            isPulsing: !1,
            color: "gray",
            children: [d.jsx(z$e, {
                children: d.jsx(P0, {})
            }), t]
        })]
    });
let W$e = z.div.withConfig({
        displayName: "Container",
        componentId: "sc-d24ae982-0"
    })(["display:flex;align-items:center;"]),
    z$e = z.div.withConfig({
        displayName: "IconContainer",
        componentId: "sc-d24ae982-1"
    })(["height:0.75rem;width:0.75rem;margin-right:0.2rem;"]),
    q$e = z(vB).withConfig({
        displayName: "StyledNetworkIcon",
        componentId: "sc-d24ae982-2"
    })(["height:1.25rem;width:1.25rem;display:inline-block;margin-right:0.5rem;border-radius:4px;"]);
const H$e = ({
    options: t,
    onSelect: e,
    selected: r,
    className: n
}) => d.jsxs(ahe, {
    as: V$e,
    children: [d.jsxs(CR, {
        as: Y$e,
        children: [d.jsx(U4, {
            balance: r.balance,
            chain: r.chain
        }), d.jsx(F4, {
            height: 16
        })]
    }), d.jsx(AR, {
        as: G$e,
        className: n,
        children: t.map((i, s) => d.jsx(kR, {
            as: K$e,
            onClick: () => e(s),
            children: d.jsx(U4, {
                balance: i.balance,
                chain: i.chain
            })
        }, s))
    })]
});
let V$e = z.div.withConfig({
        displayName: "Wrapper",
        componentId: "sc-31c00f79-0"
    })(["width:100%;position:relative;"]),
    G$e = z.div.withConfig({
        displayName: "Popover",
        componentId: "sc-31c00f79-1"
    })(["width:100%;margin-top:0.5rem;position:absolute;background-color:var(--privy-color-background);border-radius:var(--privy-border-radius-md);overflow-x:hidden;overflow-y:auto;box-shadow:0px 1px 2px 0px rgba(16,24,40,0.05);max-height:11.75rem;&&{border:solid 1px var(--privy-color-foreground-4);}z-index:1;"]),
    K$e = z.button.withConfig({
        displayName: "Button",
        componentId: "sc-31c00f79-2"
    })(["width:100%;display:flex;justify-content:space-between;&&{padding:1rem;}:not(:last-child){border-bottom:solid 1px var(--privy-color-foreground-4);}:hover{background:var(--privy-color-background-2);}"]),
    F4 = z(cy).withConfig({
        displayName: "StyledChevronIcon",
        componentId: "sc-31c00f79-3"
    })(["height:1rem;margin-left:0.5rem;"]),
    Y$e = z.button.withConfig({
        displayName: "StyledMenuButton",
        componentId: "sc-31c00f79-4"
    })(["", " span{margin-left:auto;}", "{transition:rotate 100ms ease-in;}&[aria-expanded='true']{", "{rotate:-180deg;}}"], gB, F4, F4),
    J$ = ({
        passkeys: t,
        expanded: e,
        onUnlink: r,
        onExpand: n
    }) => {
        let [i, s] = v.useState([]), a = e ? t.length : 2, o = c => c.authenticatorName ? c.createdWithBrowser ? `${c.authenticatorName} on ${c.createdWithBrowser}` : c.authenticatorName : c.createdWithBrowser ? c.createdWithOs ? `${c.createdWithBrowser} on ${c.createdWithOs}` : `${c.createdWithBrowser}` : "Unknown device";
        return d.jsxs("div", {
            children: [d.jsx(nSe, {
                children: "Your passkeys"
            }), d.jsxs(_B, {
                children: [t.slice(0, a).map(c => d.jsxs(aSe, {
                    children: [d.jsxs("div", {
                        children: [d.jsx(iSe, {
                            children: o(c)
                        }), d.jsxs(sSe, {
                            children: ["Last used: ", (c.latestVerifiedAt ? ? c.verifiedAt).toLocaleString()]
                        })]
                    }), d.jsx(cSe, {
                        disabled: i.includes(c.credentialId),
                        onClick: () => (async l => {
                            s(u => u.concat([l])), await r(l), s(u => u.filter(h => h !== l))
                        })(c.credentialId),
                        children: i.includes(c.credentialId) ? d.jsx(pl, {}) : d.jsx(C_e, {
                            height: "1.6em"
                        })
                    })]
                }, c.credentialId)), t.length > 2 && !e && d.jsx(eSe, {
                    onClick: n,
                    children: "View all"
                })]
            })]
        })
    },
    Z$e = () => d.jsxs(_B, {
        children: [d.jsxs(co, {
            children: [d.jsx(oo, {
                children: d.jsx(VL, {})
            }), "Log in with Touch ID, Face ID, or a security key."]
        }), d.jsxs(co, {
            children: [d.jsx(oo, {
                children: d.jsx(HL, {})
            }), "More secure than a password."]
        }), d.jsxs(co, {
            children: [d.jsx(oo, {
                children: d.jsx(LL, {})
            }), "Takes seconds to set up and use."]
        })]
    });
const J$e = {
        component: () => {
            let {
                user: t,
                unlinkPasskey: e
            } = $t(), {
                linkWithPasskey: r,
                closePrivyModal: n
            } = $e(), i = t == null ? void 0 : t.linkedAccounts.filter(g => g.type === "passkey"), [s, a] = v.useState(!1), [o, c] = v.useState(""), [l, u] = v.useState(!1), [h, f] = v.useState(!1);
            v.useEffect(() => {
                i.length === 0 && f(!1)
            }, [i.length]);
            let p = async g => (a(!0), await e(g).then(() => u(!0)).catch(m => {
                m instanceof Qn && m.privyErrorCode === ee.MISSING_MFA_CREDENTIALS ? c("Cannot unlink a passkey enrolled in MFA") : c("Unknown error occurred.")
            }).finally(() => {
                a(!1)
            }));
            return d.jsxs(d.Fragment, l ? {
                children: [d.jsx(Pe, {
                    onClose: () => n()
                }, "header"), d.jsx(Oi, {
                    style: {
                        marginBottom: "1.5rem"
                    },
                    children: d.jsx(gc, {})
                }), d.jsx(Q$, {
                    style: {
                        marginBottom: "1.5rem"
                    },
                    children: "Passkeys updated"
                }), d.jsx(tSe, {
                    children: " "
                }), d.jsx(Bo, {
                    children: d.jsx(Qe, {
                        onClick: () => n(),
                        children: "Done"
                    })
                }), d.jsx(Wt, {})]
            } : h ? {
                children: [d.jsx(Pe, {
                    backFn: () => f(!1),
                    onClose: () => n()
                }, "header"), d.jsx(J$, {
                    passkeys: i,
                    expanded: h,
                    onUnlink: p,
                    onExpand: () => f(!0)
                }), d.jsx(Wt, {})]
            } : {
                children: [d.jsx(Pe, {
                    onClose: () => n()
                }, "header"), d.jsx(O0, {
                    children: d.jsxs(F8, {
                        children: [d.jsx(M0, {}), d.jsx(B0, {})]
                    })
                }), d.jsx(Q$, {
                    children: "Secure your account with a passkey"
                }), d.jsx(rSe, {}), i.length === 0 ? d.jsx(Z$e, {}) : d.jsx(J$, {
                    passkeys: i,
                    expanded: h,
                    onUnlink: p,
                    onExpand: () => f(!0)
                }), d.jsxs(Bo, {
                    style: {
                        marginTop: "12px"
                    },
                    children: [o && d.jsx(Q$e, {
                        $fail: !0,
                        children: o
                    }), d.jsx(Qe, {
                        onClick: () => {
                            a(!0), r().then(() => u(!0)).catch(g => {
                                if (g instanceof Qn) {
                                    if (g.privyErrorCode === ee.CANNOT_LINK_MORE_OF_TYPE) return void c("Cannot link more passkeys to account.");
                                    if (g.privyErrorCode === ee.PASSKEY_NOT_ALLOWED) return void c("Passkey request timed out or rejected by user.")
                                }
                                c("Unknown error occurred.")
                            }).finally(() => {
                                a(!1)
                            })
                        },
                        loading: s,
                        children: "Add new passkey"
                    })]
                }), d.jsx(Wt, {})]
            })
        }
    },
    F8 = z.div.withConfig({
        displayName: "DoubleIconWrapper",
        componentId: "sc-d6832d36-0"
    })(["display:flex;align-items:center;justify-content:center;width:180px;height:90px;border-radius:50%;svg + svg{margin-left:12px;}> svg{z-index:2;color:var(--privy-color-accent) !important;stroke:var(--privy-color-accent) !important;fill:var(--privy-color-accent) !important;}"]);
let Q$e = z.div.withConfig({
        displayName: "InputHelp",
        componentId: "sc-d6832d36-1"
    })(["line-height:20px;height:20px;font-size:13px;color:", ";display:flex;justify-content:flex-beginngin;width:100%;"], t => t.$fail ? "var(--privy-color-error)" : "var(--privy-color-foreground-3)"),
    X$e = pi(["&&{width:100%;font-size:0.875rem;line-height:1rem;@media (min-width:440px){font-size:14px;}display:flex;gap:12px;justify-content:center;padding:6px 8px;background-color:var(--privy-color-background);transition:background-color 200ms ease;color:var(--privy-color-accent) !important;:focus{outline:none;box-shadow:none;}}"]);
const eSe = z.button.withConfig({
    displayName: "LinkButton",
    componentId: "sc-d6832d36-2"
})(["", ""], X$e);
let _B = z.div.withConfig({
        displayName: "List",
        componentId: "sc-d6832d36-3"
    })(["display:flex;flex-direction:column;align-items:stretch;gap:0.8rem;padding:0.5rem 0rem 0rem;flex-grow:1;width:100%;"]),
    Q$ = z.div.withConfig({
        displayName: "ModalTitle",
        componentId: "sc-d6832d36-4"
    })(["font-size:18px;line-height:18px;text-align:center;font-weight:600;"]),
    tSe = z.div.withConfig({
        displayName: "ModalSubTitle",
        componentId: "sc-d6832d36-5"
    })(["font-size:0.875rem;text-align:center;margin-top:10px;"]),
    rSe = z.div.withConfig({
        displayName: "SectionSpacer",
        componentId: "sc-d6832d36-6"
    })(["height:32px;"]),
    nSe = z.div.withConfig({
        displayName: "PasskeyListTitle",
        componentId: "sc-d6832d36-7"
    })(["line-height:20px;height:20px;font-size:1em;font-weight:450;display:flex;justify-content:flex-beginning;width:100%;"]),
    iSe = z.div.withConfig({
        displayName: "PasskeyItemTitle",
        componentId: "sc-d6832d36-8"
    })(["font-size:1em;line-height:1.3em;font-weight:500;color:var(--privy-color-foreground-2);padding:0.2em 0;"]),
    sSe = z.div.withConfig({
        displayName: "PasskeyItemSubtitle",
        componentId: "sc-d6832d36-9"
    })(["font-size:0.875rem;line-height:1rem;color:#64668b;padding:0.2em 0;"]),
    aSe = z.div.withConfig({
        displayName: "PasskeyListItem",
        componentId: "sc-d6832d36-10"
    })(["display:flex;align-items:center;justify-content:space-between;padding:1em;gap:10px;font-size:0.875rem;line-height:1rem;text-align:left;border-radius:8px;border:1px solid #e2e3f0 !important;width:100%;height:5em;"]),
    oSe = pi([":focus,:hover,:active{outline:none;}display:flex;width:2em;height:2em;justify-content:center;align-items:center;svg{color:var(--privy-color-error);}svg:hover{color:var(--privy-color-foreground-3);}"]),
    cSe = z.button.withConfig({
        displayName: "PasskeyItemUnlinkButton",
        componentId: "sc-d6832d36-11"
    })(["", ""], oSe);
const lSe = z.div.withConfig({
        displayName: "FundingMethodContainer",
        componentId: "sc-eaaa12a-0"
    })(["display:flex;flex-direction:column;gap:12px;padding-top:24px;padding-bottom:24px;"]),
    Nf = z.div.withConfig({
        displayName: "IconContainer",
        componentId: "sc-eaaa12a-1"
    })(["width:24px;height:24px;display:flex;justify-content:center;align-items:center;svg{border-radius:var(--privy-border-radius-sm);}"]),
    CB = z.div.withConfig({
        displayName: "FundingQuantityWrapper",
        componentId: "sc-eaaa12a-2"
    })(["display:flex;flex-direction:column;justify-content:center;align-items:flex-start;gap:8px;"]),
    AB = z.div.withConfig({
        displayName: "FundingQuantity",
        componentId: "sc-eaaa12a-3"
    })(["display:flex;align-items:center;gap:4px;width:100%;padding:0 16px;border-width:1px !important;border-radius:12px;cursor:text;&:focus-within{border-color:var(--privy-color-accent);}"]),
    kB = z.input.withConfig({
        displayName: "FundingAmountInput",
        componentId: "sc-eaaa12a-5"
    })(["background-color:var(--privy-color-background);width:100%;&:focus{outline:none !important;border:none !important;box-shadow:none !important;}&&{font-size:26px;}"]),
    dSe = z(kB).withConfig({
        displayName: "FundingAmountInputLarge",
        componentId: "sc-eaaa12a-6"
    })(["&&{font-size:42px;}"]),
    IB = z.div.withConfig({
        displayName: "FundingCurrency",
        componentId: "sc-eaaa12a-8"
    })(["font-size:18px;"]),
    $B = z.div.withConfig({
        displayName: "FundingDollars",
        componentId: "sc-eaaa12a-9"
    })(["font-size:12px;color:var(--privy-color-foreground-3);height:20px;"]),
    uSe = z.div.withConfig({
        displayName: "InfoButtonText",
        componentId: "sc-eaaa12a-13"
    })([""]),
    hSe = z.a.withConfig({
        displayName: "InfoButtonLink",
        componentId: "sc-eaaa12a-14"
    })(["&&{color:var(--privy-color-accent);}cursor:pointer;"]),
    SB = ({
        displayName: t,
        errorMessage: e,
        configuredFundingChain: r,
        formattedBalance: n,
        fundingAmount: i,
        fundingCurrency: s,
        fundingAmountInUsd: a,
        options: o,
        selectedOption: c,
        isPreparing: l,
        isSubmitting: u,
        addressToFund: h,
        fundingWalletAddress: f,
        onSubmit: p,
        onSelect: g,
        onAmountChange: m,
        erc20ContractInfo: y
    }) => {
        let w = v.useRef(null);
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Bi, {}), d.jsx(er, {}), d.jsx(Pa, {
                children: "Transfer from another network"
            }), d.jsxs($a, {
                children: ["You need more funds on the ", r.name, " network. Bridge from another blockchain network."]
            }), d.jsxs(CB, {
                style: {
                    marginTop: "2rem"
                },
                children: [d.jsxs(AB, {
                    onClick: () => {
                        var x;
                        return (x = w.current) == null ? void 0 : x.focus()
                    },
                    children: [d.jsx(kB, {
                        ref: w,
                        value: i,
                        onChange: x => {
                            let E = x.target.value;
                            if (/^[0-9.]*$/.test(E) && E.split(".").length - 1 <= 1) {
                                let _ = /\.$/.test(E) ? "." : "",
                                    b = Number(E.replace(/\.$/, "") || "0");
                                if (Number.isNaN(b)) return void m("0");
                                m(b.toString() + _)
                            }
                        }
                    }), d.jsx(IB, {
                        children: s
                    })]
                }), a && d.jsx($B, {
                    children: a
                })]
            }), d.jsxs(Oe, {
                style: {
                    marginTop: "1.5rem"
                },
                children: [d.jsx(qe, {
                    children: "From"
                }), d.jsx(qe, {
                    children: A_(f)
                })]
            }), d.jsx(H$e, {
                selected: {
                    chain: c.chain,
                    balance: c.isErc20Quote ? x1({
                        amount: c.erc20Balance ? ? 0 n,
                        decimals: (y == null ? void 0 : y.decimals) ? ? 6
                    }) + ` ${(y==null?void 0:y.symbol)||""}` : ba(c.balance, c.chain.nativeCurrency.symbol, 3, !0)
                },
                options: o.map(({
                    chain: x,
                    balance: E,
                    isErc20Quote: _,
                    erc20Balance: b
                }) => ({
                    chain: x,
                    balance: _ ? x1({
                        amount: b ? ? 0 n,
                        decimals: (y == null ? void 0 : y.decimals) ? ? 6
                    }) + ` ${(y==null?void 0:y.symbol)||""}` : ba(E, x.nativeCurrency.symbol, 3, !0)
                })),
                onSelect: g
            }), d.jsxs(Oe, {
                style: {
                    marginTop: "1.5rem"
                },
                children: [d.jsx(qe, {
                    children: "To"
                }), d.jsx(qe, {
                    children: A_(h)
                })]
            }), d.jsx(B$e, {
                chain: r,
                balance: n
            }), d.jsx(dc, {
                style: {
                    marginTop: "1rem"
                },
                children: e
            }), d.jsxs(qp, {
                style: {
                    marginTop: "1rem"
                },
                loading: u || l,
                disabled: l || u,
                onClick: p,
                children: ["Confirm with ", t]
            }), d.jsx(nr, {}), d.jsx(ot, {})]
        })
    },
    TB = {
        component: () => {
            var We, dt, He, ut, Ye;
            let {
                rpcConfig: t,
                appId: e,
                closePrivyModal: r,
                createAnalyticsEvent: n
            } = $e(), {
                navigate: i,
                setModalData: s,
                app: a,
                data: o
            } = Ne(), {
                wallets: c
            } = gl(), [l, u] = v.useState(!1), [h, f] = v.useState(0 n), [p, g] = v.useState(!1), [m, y] = v.useState(null), [w, x] = v.useState(null), [E, _] = v.useState([]), [b, A] = v.useState(0), [I, T] = v.useState(!1), [C, $] = v.useState(!1), [P, N] = v.useState(!1), [R, D] = v.useState(!1), [S, O] = v.useState(), [M, U] = v.useState();
            if (!(o != null && o.funding) || o.funding.chainType !== "ethereum") throw Error("Invalid funding data");
            let {
                erc20ContractInfo: k,
                chain: F,
                connectedWalletAddress: q
            } = o.funding, W = o.funding.address, K = o.funding.erc20Address, [H, j] = v.useState(o.funding.amount);
            v.useEffect(() => {
                K && !k && y(Error("Unable to fetch token details"))
            }, []);
            let V = !!K && !!k,
                Y = V ? BigInt(parseFloat(H) * 10 ** k.decimals) : YT(H),
                X = q ? c.find(({
                    address: we
                }) => we === q) : c[0],
                ne = mc((X == null ? void 0 : X.walletClientType) || "unknown"),
                ae = (ne == null ? void 0 : ne.name) || "wallet",
                [ue, he] = v.useState(null);
            v.useEffect(() => {
                (async () => {
                    if (!X) return;
                    let we = await X.getEthereumProvider();
                    he(qP({
                        account: X.address,
                        transport: AP(we)
                    }).extend(A6))
                })().catch(console.error)
            }, [X]);
            let [fe, de] = v.useState(0 n);
            v.useEffect(() => {
                nc({
                    chain: F,
                    transport: rc(cc(F, t, e))
                }).getBalance({
                    address: W
                }).then(de).catch(console.error)
            }, []);
            let [ye, Be] = v.useState(0 n);
            v.useEffect(() => {
                V && L8({
                    chain: F,
                    address: W,
                    appId: e,
                    rpcConfig: t,
                    erc20Address: K
                }).then(we => Be(we.balance)).catch(console.error)
            }, []);
            let {
                tokenPrice: ce
            } = Oh(F.id), [Ie, xe] = v.useState({
                to: W,
                chain: F,
                value: Y,
                data: void 0
            });
            v.useEffect(() => {
                (async () => {
                    let we, vt;
                    if (!ue || !X || I || P) return;
                    T(!0);
                    let Lt = nc({
                        chain: Ie.chain,
                        transport: rc(cc(Ie.chain, t, e))
                    });
                    if (V && !Ie.data) return await Lt.simulateContract({
                        address: K,
                        chain: Ie.chain,
                        abi: L4,
                        functionName: "transfer",
                        args: [W, Y],
                        account: X.address
                    }).catch(_t => {
                        console.warn("Simulated token transfer failed with error, fetching bridge options.", _t)
                    }) ? (T(!1), void xe({
                        to: K,
                        chain: Ie.chain,
                        data: hs({
                            abi: L4,
                            functionName: "transfer",
                            args: [W, Y]
                        }),
                        value: "0x0"
                    })) : (T(!1), void g(!0));
                    try {
                        we = await Lt.prepareTransactionRequest({
                            account: X.address,
                            to: Ie.to,
                            chain: Ie.chain,
                            data: Ie.data,
                            value: BigInt(Ie.value ? ? 0)
                        })
                    } catch (_t) {
                        if (console.error(_t), E.length > 1) x(_t.shortMessage ? ? "Something went wrong");
                        else if (C && E.length === 0) return void y(new J(`Wallet ${Yn(X.address)} does not have enough funds.`, void 0, ee.INSUFFICIENT_BALANCE))
                    }
                    if (!we) return T(!1), void g(!0);
                    T(!1), N(!0), u(!0), f(we.gas);
                    try {
                        await ue.switchChain({
                            id: Ie.chain.id
                        })
                    } catch {
                        await ue.addChain({
                            chain: Ie.chain
                        }), await ue.switchChain({
                            id: Ie.chain.id
                        })
                    }
                    try {
                        vt = await ue.sendTransaction(we)
                    } catch (_t) {
                        if (console.error(_t), _t.name === "TransactionExecutionError")
                            if (E.length < 1) {
                                let tr = _t.shortMessage;
                                (_t.shortMessage.includes("rejected the request") || _t.details.includes("rejected the request")) && (tr = "User rejected the request."), y(new J(tr, void 0, ee.TRANSACTION_FAILURE))
                            } else x(_t.shortMessage ? ? "Something went wrong")
                    }
                    if (vt) return await ue.waitForTransactionReceipt({
                        hash: vt
                    }), N(!1), C ? (O(vt), void U("pending")) : (D(!0), void n({
                        eventName: Na,
                        payload: {
                            provider: "external",
                            status: "success",
                            txHash: vt,
                            address: X.address,
                            chainId: Ie.chain.id,
                            chainType: "ethereum",
                            value: Ie.value ? Nn(BigInt(Ie.value), (k == null ? void 0 : k.decimals) ? ? 18) : void 0,
                            token: (k == null ? void 0 : k.symbol) ? ? K ? ? "ETH",
                            destinationAddress: W,
                            destinationChainId: F.id,
                            destinationChainType: "ethereum",
                            destinationValue: Y ? Nn(Y, (k == null ? void 0 : k.decimals) ? ? 18) : void 0,
                            destinationToken: (k == null ? void 0 : k.symbol) ? ? K ? ? F.nativeCurrency.name
                        }
                    }));
                    N(!1)
                })().catch(console.error)
            }, [ue, Ie]), v.useEffect(() => {
                (async () => {
                    var Ot;
                    if (!p || !ue || !X) return;
                    let we = S6(a.chains).filter(mt => mt.id !== F.id && !!mt.testnet == !!F.testnet);
                    V && we.unshift(F);
                    let vt = await EB({
                            chains: we,
                            address: X.address,
                            appId: e,
                            rpcConfig: t,
                            includeUsdc: (Ot = o.funding) == null ? void 0 : Ot.isUSDC
                        }),
                        Lt = V ? vt.filter(mt => mt.balance > 0 n) : vt.filter(mt => mt.balance > Y);
                    if (Lt.length < 1) return void y(new J(`Wallet ${Yn(X.address)} does not have enough funds.`, void 0, ee.INSUFFICIENT_BALANCE));
                    Lt.sort((mt, ur) => Number(V ? (ur.erc20Balance ? ? 0 n) - (mt.erc20Balance ? ? 0 n) : ur.balance - mt.balance));
                    let _t = Lt.flatMap(mt => {
                            let ur = [{ ...mt,
                                isErc20Quote: !1,
                                isTestnet: !!F.testnet,
                                input: Gu({
                                    amount: Y.toString(),
                                    user: X.address,
                                    recipient: W,
                                    destinationChainId: F.id,
                                    destinationCurrency: K,
                                    originChainId: mt.chain.id
                                })
                            }];
                            return V && K && (mt.erc20Balance ? ? 0 n) >= Y && ur.push({ ...mt,
                                isErc20Quote: !0,
                                isTestnet: !!F.testnet,
                                input: Gu({
                                    amount: Y.toString(),
                                    user: X.address,
                                    recipient: W,
                                    destinationChainId: F.id,
                                    destinationCurrency: K,
                                    originChainId: mt.chain.id,
                                    originCurrency: mt.erc20Address
                                })
                            }), ur
                        }),
                        tr = (await Promise.allSettled(_t.map(async mt => ({ ...mt,
                            quote: await Vp(mt)
                        })))).filter(mt => mt.status === "fulfilled").map(mt => mt.value);
                    if (tr.length < 1) return void y(new J(`Wallet ${Yn(X.address)} does not have enough funds.`, void 0, ee.INSUFFICIENT_BALANCE));
                    let dr = tr.map(mt => ({
                        bridgeTx: y1(mt.quote),
                        balance: mt.balance,
                        chain: mt.chain,
                        erc20Balance: mt.erc20Balance,
                        isErc20Quote: mt.isErc20Quote
                    })).filter(mt => !!mt.bridgeTx);
                    if (dr.length > 1) return void _(dr);
                    let Yt = dr[0];
                    Yt ? ($(!0), xe({
                        data: Yt.bridgeTx.data,
                        to: Yt.bridgeTx.to,
                        value: Yt.bridgeTx.value,
                        chain: Yt.chain
                    })) : y(new J(`Wallet ${Yn(X.address)} does not have enough funds.`, void 0, ee.INSUFFICIENT_BALANCE))
                })().catch(console.error)
            }, [p]), M8({
                transactionHash: S,
                wallet: X,
                isTestnet: !!F.testnet,
                bridgingStatus: M,
                setBridgingStatus: U,
                onSuccess({
                    transactionHash: we,
                    wallet: vt
                }) {
                    $(!1), D(!0), n({
                        eventName: Na,
                        payload: {
                            provider: "external",
                            status: "success",
                            txHash: we,
                            address: vt.address,
                            chainId: Ie.chain.id,
                            chainType: "ethereum",
                            value: Ie.value ? Nn(BigInt(Ie.value), (k == null ? void 0 : k.decimals) ? ? 18) : void 0,
                            token: (k == null ? void 0 : k.symbol) ? ? K ? ? "ETH",
                            destinationAddress: W,
                            destinationChainId: F.id,
                            destinationChainType: "ethereum",
                            destinationValue: Y ? Nn(Y, (k == null ? void 0 : k.decimals) ? ? 18) : void 0,
                            destinationToken: (k == null ? void 0 : k.symbol) ? ? K ? ? F.nativeCurrency.name
                        }
                    })
                },
                onFailure({
                    error: we
                }) {
                    $(!1), y(we)
                }
            }), v.useEffect(() => {
                m && (s({
                    funding: o == null ? void 0 : o.funding,
                    sendTransaction: o == null ? void 0 : o.sendTransaction,
                    errorModalData: {
                        error: m,
                        previousScreen: Lh
                    }
                }), i(Sr, !1))
            }, [m]);
            let ie = !V && ce ? qU(H ? ? "0", ce) : void 0,
                Ee = V ? h : v8([h, Y]),
                ft = Ee && ce ? td(Ee, ce) : void 0,
                Ae = Ee ? ba(Ee, (We = o == null ? void 0 : o.funding) != null && We.erc20Address ? ((He = (dt = o == null ? void 0 : o.funding) == null ? void 0 : dt.erc20ContractInfo) == null ? void 0 : He.symbol) || "ETH" : ((ut = o == null ? void 0 : o.funding) == null ? void 0 : ut.chain.nativeCurrency.symbol) || "ETH") : void 0,
                Le = h && ce ? td(h, ce) : void 0,
                Te = h ? ba(h, ((Ye = F == null ? void 0 : F.nativeCurrency) == null ? void 0 : Ye.symbol) || "ETH") : void 0;
            if (v.useEffect(() => {
                    if (!R) return;
                    let we = setTimeout(r, Hy);
                    return () => clearTimeout(we)
                }, [R]), R) return d.jsxs(d.Fragment, {
                children: [d.jsx(Bi, {}), d.jsx(er, {}), d.jsxs(wc, {
                    children: [d.jsx(gc, {
                        color: "var(--privy-color-success)",
                        width: "64px",
                        height: "64px"
                    }), d.jsx($r, {
                        title: "Success!",
                        description: `You’ve successfully added ${H} ${V?k.symbol:F.nativeCurrency.symbol} to your ${a.name} wallet. It may take a minute before the funds are available to use.`
                    })]
                }), d.jsx(nr, {}), d.jsx(ot, {})]
            });
            let Ue = V ? `${x1({amount:ye,decimals:k.decimals})}  ${k.symbol}` : ba(fe, F.nativeCurrency.symbol, 3, !0),
                De = E[b];
            return E.length > 1 && De ? d.jsx(SB, {
                displayName: ae,
                configuredFundingChain: F,
                erc20ContractInfo: k,
                formattedBalance: Ue,
                fundingAmount: H,
                fundingCurrency: V ? k.symbol : F.nativeCurrency.symbol,
                fundingAmountInUsd: ie,
                options: E,
                selectedOption: De,
                isPreparing: I,
                isSubmitting: P,
                addressToFund: W,
                fundingWalletAddress: (X == null ? void 0 : X.address) || "",
                errorMessage: w,
                onSubmit: () => {
                    var we;
                    ((we = o.funding) == null ? void 0 : we.amount) !== H ? async function() {
                        if (X && De) try {
                            let vt = await Vp({
                                    isTestnet: !!F.testnet,
                                    input: Gu({
                                        amount: Y.toString(),
                                        user: X.address,
                                        recipient: W,
                                        destinationChainId: F.id,
                                        destinationCurrency: K,
                                        originChainId: De.chain.id
                                    })
                                }),
                                Lt = y1(vt);
                            if (!Lt) throw Error("Invalid transaction request");
                            $(!0), xe({
                                data: Lt.data,
                                to: Lt.to,
                                value: Lt.value,
                                chain: De.chain
                            })
                        } catch (vt) {
                            console.error(vt), y(new J("Unable to fetch quotes for bridging", vt, ee.INSUFFICIENT_BALANCE))
                        }
                    }().catch(console.error) : xe({
                        to: De.bridgeTx.to,
                        data: De.bridgeTx.data,
                        value: De.bridgeTx.value,
                        chain: De.chain
                    })
                },
                onSelect: we => {
                    we !== b && (x(null), A(we))
                },
                onAmountChange: j
            }) : l && h && X && (o != null && o.funding) ? d.jsx(yw, {
                wallet: X,
                displayName: ae,
                addressToFund: W,
                isBridging: C,
                isErc20Flow: V,
                totalPriceInUsd: ft,
                totalPriceInNativeCurrency: Ae,
                gasPriceInUsd: Le,
                gasPriceInNativeCurrency: Te,
                chainId: F.id,
                chainName: F.name
            }) : d.jsxs(d.Fragment, {
                children: [d.jsx(Bi, {}), d.jsx(Mh, {}), d.jsx("div", {
                    style: {
                        marginTop: "1rem"
                    }
                }), d.jsx(ot, {})]
            })
        }
    },
    PB = {
        component: function() {
            let {
                closePrivyModal: t,
                createAnalyticsEvent: e
            } = $e(), {
                navigate: r,
                setModalData: n,
                app: i,
                data: s
            } = Ne(), {
                wallets: a
            } = z0(), o = v.useRef(!1), c = Rh(), [l, u] = v.useState(!1), [h, f] = v.useState(!1), [p, g] = v.useState(null), [m, y] = v.useState(), [w, x] = v.useState();
            if (!(s != null && s.funding) || s.funding.chainType !== "ethereum") throw Error("Invalid funding data");
            let {
                amount: E,
                connectedWalletAddress: _,
                chain: b,
                cluster: A,
                isUSDC: I
            } = s.funding, T = s.funding.address, C = s.funding.erc20Address, $ = s.funding.isUSDC ? "USDC" : b.nativeCurrency.symbol, P = A ? ? {
                name: "mainnet-beta"
            }, N = _ ? a.find(({
                address: S
            }) => S === _) : a[0], R = mc((N == null ? void 0 : N.walletClientType) || "unknown"), D = (R == null ? void 0 : R.name) || "wallet";
            return v.useEffect(() => {
                (async function() {
                    var k;
                    if (!N || !b || o.current) return;
                    let S = c(W0);
                    if (!S) return void g(new J("Unable to solana plugin"));
                    o.current = !0, b != null && b.testnet && console.warn("Solana testnets are not supported for bridging");
                    let O = I ? 1e6 * parseFloat(E) : YT(E),
                        M = await Vp({
                            isTestnet: !!b.testnet,
                            input: Gu({
                                amount: O.toString(),
                                user: N.address,
                                recipient: T,
                                destinationChainId: b.id,
                                originChainId: b4,
                                originCurrency: I ? "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" : v4,
                                destinationCurrency: I ? C : void 0
                            })
                        }).catch(console.error);
                    if (!M) return void g(new J(`Unable to fetch quotes for bridging. Wallet ${gv(N.address)} does not have enough funds.`, void 0, ee.INSUFFICIENT_BALANCE));
                    let U = await S.createBridgeTransactionFromRelayQuote({
                        quote: M,
                        from: N.address,
                        cluster: P
                    });
                    if (U) try {
                        u(!0);
                        let {
                            connection: F,
                            transaction: q
                        } = U, W = await F.simulateTransaction(q);
                        if (W.value.err) return (k = W.value.logs) != null && k.find(j => /insufficient (lamports|funds)/gi.test(j)) ? void g(new J(`Wallet ${gv(N==null?void 0:N.address)} does not have enough funds. ${M.details.currencyIn.amountFormatted} ${$} are needed to complete the transaction.`, void 0, ee.INSUFFICIENT_BALANCE)) : (console.error("Transaction failed:", W.value.err), void g(new J("Something went wrong", void 0, ee.TRANSACTION_FAILURE)));
                        let K = await N.sendTransaction(q, F),
                            H = await F.confirmTransaction(K);
                        if (H.value.err) return console.error("Transaction failed:", H.value.err), void g(new J("Something went wrong", void 0, ee.TRANSACTION_FAILURE));
                        y(K), x("pending")
                    } catch (F) {
                        if (console.error(F), /user rejected the request/gi.test(F.message || "")) return void g(new J("Transaction was rejected by the user", void 0, ee.TRANSACTION_FAILURE));
                        g(new J("Something went wrong", void 0, ee.TRANSACTION_FAILURE))
                    } else g(new J(`Unable to select bridge option from quotes. Wallet ${gv(N.address)} does not have enough funds.`, void 0, ee.INSUFFICIENT_BALANCE))
                })().catch(console.error)
            }, []), M8({
                transactionHash: m,
                wallet: N,
                isTestnet: !1,
                bridgingStatus: w,
                setBridgingStatus: x,
                onSuccess({
                    transactionHash: S,
                    wallet: O
                }) {
                    u(!1), f(!0), e({
                        eventName: Na,
                        payload: {
                            provider: "external",
                            status: "success",
                            txHash: S,
                            address: O.address,
                            chainType: "solana",
                            clusterName: P.name,
                            token: "SOL",
                            destinationAddress: T,
                            destinationChainId: b.id,
                            destinationChainType: "ethereum",
                            destinationValue: E,
                            destinationToken: I ? "USDC" : "ETH"
                        }
                    })
                },
                onFailure({
                    error: S
                }) {
                    u(!1), g(S)
                }
            }), v.useEffect(() => {
                if (!h) return;
                let S = setTimeout(t, Hy);
                return () => clearTimeout(S)
            }, [h]), v.useEffect(() => {
                p && (n({
                    funding: s == null ? void 0 : s.funding,
                    sendTransaction: s == null ? void 0 : s.sendTransaction,
                    errorModalData: {
                        error: p,
                        previousScreen: Lh
                    }
                }), r(Sr, !1))
            }, [p]), h ? d.jsxs(d.Fragment, {
                children: [d.jsx(Bi, {}), d.jsx(er, {}), d.jsxs(wc, {
                    children: [d.jsx(gc, {
                        color: "var(--privy-color-success)",
                        width: "64px",
                        height: "64px"
                    }), d.jsx($r, {
                        title: "Success!",
                        description: `You’ve successfully added ${E} ${$} to your ${i.name} wallet. It may take a minute before the funds are available to use.`
                    })]
                }), d.jsx(nr, {}), d.jsx(ot, {})]
            }) : l && N ? d.jsx(yw, {
                wallet: N,
                displayName: D,
                addressToFund: T,
                isBridging: l,
                isErc20Flow: !1,
                chainId: b.id,
                chainName: b.name,
                totalPriceInUsd: void 0,
                totalPriceInNativeCurrency: void 0,
                gasPriceInUsd: void 0,
                gasPriceInNativeCurrency: void 0
            }) : d.jsxs(d.Fragment, {
                children: [d.jsx(Bi, {}), d.jsx(Mh, {}), d.jsx("div", {
                    style: {
                        marginTop: "1rem"
                    }
                }), d.jsx(ot, {})]
            })
        }
    },
    X$ = {
        component: () => {
            var f;
            let {
                data: t,
                setModalData: e
            } = Ne(), r = t == null ? void 0 : t.funding, n = r.chainType === "solana", i = v.useRef(null), {
                tokenPrice: s
            } = Oh(n ? "solana" : r.chain.id), a = n ? void 0 : r, o = !(!(a != null && a.erc20Address) || a != null && a.erc20ContractInfo), c = n ? r.isUSDC ? "USDC" : "SOL" : r.erc20Address ? (f = r.erc20ContractInfo) == null ? void 0 : f.symbol : r.chain.nativeCurrency.symbol || "ETH", l = parseFloat(r.amount), u = !isNaN(l) && l > 0, h = s ? qU(r.amount, s) : void 0;
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Bi, {}), d.jsx(Pa, {
                    children: "Confirm or edit amount"
                }), d.jsxs(Qy, {
                    style: {
                        marginTop: "32px"
                    },
                    children: [d.jsx(CB, {
                        children: o ? d.jsx(Mh, {
                            size: "50px"
                        }) : d.jsxs(d.Fragment, {
                            children: [d.jsxs(AB, {
                                onClick: () => {
                                    var p;
                                    return (p = i.current) == null ? void 0 : p.focus()
                                },
                                children: [d.jsx(dSe, {
                                    ref: i,
                                    value: r.amount,
                                    onChange: p => {
                                        let g = p.target.value;
                                        /^[0-9.]*$/.test(g) && g.split(".").length - 1 <= 1 && e({ ...t,
                                            funding: { ...r,
                                                amount: g
                                            }
                                        })
                                    }
                                }), d.jsx(IB, {
                                    children: c
                                })]
                            }), !(a != null && a.erc20Address) && d.jsx($B, {
                                children: h && u ? `${h} USD` : ""
                            })]
                        })
                    }), d.jsx(qp, {
                        style: {
                            marginTop: "1rem"
                        },
                        disabled: !u,
                        onClick: r.onContinueWithExternalWallet,
                        children: "Continue"
                    })]
                }), d.jsx(ot, {})]
            })
        }
    },
    Lh = {
        component: () => {
            var b, A, I, T;
            let t, {
                    connectors: e
                } = $e(),
                {
                    app: r,
                    setModalData: n,
                    data: i,
                    navigate: s
                } = Ne(),
                {
                    wallets: a
                } = gl(),
                {
                    wallets: o
                } = z0(),
                [c, l] = v.useState("default"),
                u = ((b = i == null ? void 0 : i.funding) == null ? void 0 : b.chainType) === "solana",
                h = !!((A = i == null ? void 0 : i.funding) != null && A.crossChainBridgingEnabled);
            t = ((I = i == null ? void 0 : i.funding) == null ? void 0 : I.chainType) === "ethereum" ? i.funding.erc20Address && !i.funding.isUSDC ? "ethereum-only" : h && !i.funding.chain.testnet ? "ethereum-and-solana" : "ethereum-only" : h && !((T = i.funding) != null && T.isUSDC) ? "ethereum-and-solana" : "solana-only";
            let f = a.filter(C => C.walletClientType !== "privy"),
                p = f.map(C => C.walletClientType),
                g = o.filter(C => C.walletClientType !== "privy"),
                m = g.map(C => C.walletClientType),
                y = [],
                w = { ...i.funding
                };
            w.usingDefaultFundingMethod && (w.usingDefaultFundingMethod = !1);
            let x = ({
                address: C,
                walletChainType: $
            }) => {
                n({ ...i,
                    funding: { ...w,
                        connectedWalletAddress: C,
                        onContinueWithExternalWallet: () => s(_({
                            destChainType: u ? "solana" : "ethereum",
                            sourceChainType: $
                        }))
                    }
                }), s(X$)
            };
            t !== "solana-only" && y.push(...f.map((C, $) => d.jsx(eS, {
                onClick: () => x({
                    address: C.address,
                    walletChainType: "ethereum"
                }),
                icon: C.meta.icon,
                name: C.meta.name,
                chainType: C.type
            }, $))), t !== "ethereum-only" && y.push(...g.map((C, $) => d.jsx(eS, {
                onClick: () => x({
                    address: C.address,
                    walletChainType: "solana"
                }),
                icon: C.meta.icon,
                name: C.meta.name,
                chainType: C.type
            }, $))), y.push(...D8({
                walletList: r.appearance.walletList.filter(C => !f.some($ => $.walletClientType === C) && !g.some($ => $.walletClientType === C)),
                walletChainType: t,
                connectors: e,
                connectOnly: !0,
                ignore: [...r.appearance.walletList, ...p, ...m],
                walletConnectEnabled: r.externalWallets.walletConnect.enabled
            }));
            let E = d.jsx(tB, {
                    text: "More wallets",
                    onClick: () => l("overflow")
                }),
                _ = ({
                    sourceChainType: C,
                    destChainType: $
                }) => C === "ethereum" && $ === "solana" ? WB : C === "ethereum" && $ === "ethereum" ? TB : C === "solana" && $ === "ethereum" ? PB : xB;
            return v.useEffect(() => {
                n({ ...i,
                    externalConnectWallet: {
                        onCompleteNavigateTo: ({
                            walletChainType: C
                        }) => (n({ ...i,
                            funding: { ...w,
                                onContinueWithExternalWallet: () => {
                                    s(_({
                                        destChainType: u ? "solana" : "ethereum",
                                        sourceChainType: C ? ? "ethereum"
                                    }))
                                }
                            }
                        }), X$)
                    }
                })
            }, []), d.jsxs(d.Fragment, c === "overflow" ? {
                children: [d.jsx(Pe, {
                    backFn: () => l("default")
                }, "header"), d.jsxs(zp, {
                    children: [d.jsx($a, {
                        style: {
                            color: "var(--privy-color-foreground-3)",
                            textAlign: "left"
                        },
                        children: "More wallets"
                    }), y]
                }), d.jsx(ot, {})]
            } : {
                children: [d.jsx(Bi, {}), d.jsx($r, {
                    title: "Transfer from wallet",
                    description: "Connect a wallet to deposit funds or send funds manually to your wallet address."
                }), d.jsxs(zp, {
                    children: [y.length > 4 ? y.slice(0, 3) : y, y.length > 4 && E]
                }), d.jsx(ot, {})]
            })
        }
    };
let eS = ({
    onClick: t,
    icon: e,
    name: r,
    chainType: n
}) => d.jsxs(Pr, {
    onClick: t,
    children: [d.jsx(Nf, {
        style: {
            width: 20
        },
        children: d.jsx("img", {
            src: e
        })
    }), r, d.jsx(Ta, {
        color: "gray",
        style: {
            marginLeft: "auto"
        },
        children: "Connected"
    }), n === "solana" && d.jsx(Ta, {
        color: "gray",
        children: "Solana"
    })]
});
const fSe = {
    component: () => {
        let {
            data: t,
            setModalData: e,
            navigate: r,
            navigateBack: n
        } = Ne(), {
            closePrivyModal: i,
            createAnalyticsEvent: s,
            client: a
        } = $e(), [o, c] = v.useState("pending-in-flow"), l = v.useRef(0), u = { ...t == null ? void 0 : t.funding,
            showAlternateFundingMethod: !0
        };
        u.usingDefaultFundingMethod && (u.usingDefaultFundingMethod = !1);
        let {
            partnerUserId: h,
            popup: f
        } = (t == null ? void 0 : t.coinbaseOnrampStatus) ? ? {};
        return v.useEffect(() => {
            if (o === "pending-in-flow" || o === "pending-after-flow") {
                let p = setInterval(async () => {
                    if (h) try {
                        let {
                            status: g
                        } = await a.getCoinbaseOnRampStatus({
                            partnerUserId: h
                        });
                        if (g === "success") return void c("success");
                        if (g === "failure") throw Error("There was an error completing Coinbase Onramp flow.");
                        if (l.current >= 3) return e({
                            funding: u
                        }), void r(Ui);
                        f != null && f.closed && (l.current = l.current + 1, c("pending-after-flow"))
                    } catch (g) {
                        console.error(g), c("error"), s({
                            eventName: Na,
                            payload: {
                                status: "failure",
                                provider: "coinbase-onramp",
                                error: g.message
                            }
                        }), e({
                            funding: { ...u,
                                errorMessage: "Something went wrong adding funds. Please try again or use another method."
                            }
                        }), r(Ui)
                    }
                }, 1500);
                return () => clearInterval(p)
            }
        }, [h, f, o]), d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                title: "Fund account",
                backFn: () => {
                    e({
                        funding: u
                    }), n()
                }
            }, "header"), d.jsx(pSe, {
                status: o,
                onClickCta: i
            }), d.jsx(ot, {})]
        })
    }
};
let pSe = ({
        status: t,
        onClickCta: e
    }) => {
        let {
            title: r,
            body: n,
            cta: i
        } = v.useMemo(() => (s => {
            switch (s) {
                case "success":
                    return {
                        title: "You've funded your account!",
                        body: "It may take a few minutes for the assets to appear.",
                        cta: "Continue"
                    };
                case "pending-after-flow":
                    return {
                        title: "In Progress",
                        body: "Almost done. Retrieving transaction status from Coinbase",
                        cta: ""
                    };
                case "error":
                case "pending-in-flow":
                    return {
                        title: "In Progress",
                        body: "Go back to Coinbase Onramp to finish funding your account.",
                        cta: ""
                    }
            }
        })(t), [t]);
        return d.jsxs(d.Fragment, {
            children: [d.jsxs(ySe, {
                children: [d.jsx(gSe, {
                    isSucccess: t === "success"
                }), d.jsxs(ls, {
                    children: [d.jsx("h3", {
                        children: r
                    }), d.jsx(mSe, {
                        children: n
                    })]
                })]
            }), i && d.jsx(Qe, {
                onClick: e,
                children: i
            })]
        })
    },
    gSe = ({
        isSucccess: t
    }) => {
        if (!t) {
            let n = "var(--privy-color-foreground-4)";
            return d.jsxs("div", {
                style: {
                    position: "relative"
                },
                children: [d.jsx(Ls, {
                    color: n,
                    style: {
                        position: "absolute"
                    }
                }), d.jsx(w8, {
                    color: n
                }), d.jsx(m9e, {
                    style: {
                        position: "absolute",
                        width: "2.8rem",
                        height: "2.8rem",
                        top: "1.2rem",
                        left: "1.2rem"
                    }
                })]
            })
        }
        let e = (n => n ? vd : () => d.jsx(qy, {
                width: "3rem",
                height: "3rem",
                style: {
                    backgroundColor: "var(--privy-color-foreground-4)",
                    color: "var(--privy-color-background)",
                    borderRadius: "100%",
                    padding: "0.5rem",
                    margin: "0.5rem"
                }
            }))(t),
            r = (n => n ? "var(--privy-color-success)" : "var(--privy-color-foreground-4)")(t);
        return d.jsx("div", {
            style: {
                borderColor: r,
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                borderRadius: "100%",
                borderWidth: 2,
                padding: "0.5rem",
                marginBottom: "0.5rem"
            },
            children: e && d.jsx(e, {
                width: "4rem",
                height: "4rem",
                color: r
            })
        })
    },
    mSe = z.p.withConfig({
        displayName: "StatusBody",
        componentId: "sc-ebf88779-0"
    })(["font-size:1rem;color:var(--privy-color-foreground-3);margin-bottom:1rem;display:flex;flex-direction:column;gap:1rem;"]),
    ySe = z.div.withConfig({
        displayName: "ConnectContainer",
        componentId: "sc-ebf88779-1"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;margin-left:1.75rem;margin-right:1.75rem;padding:2rem 0;"]),
    wSe = {
        [Bs.id]: "ethereum",
        [Fs.id]: "base",
        [go.id]: "optimism",
        [fs.id]: "polygon",
        [ja.id]: "arbitrum"
    };
const tS = (t, e, r, n, i, s) => new Promise(async (a, o) => {
        let c = ew();
        if (!c) return void o(Error("Unable to initialize flow"));
        let l = e.chainType === "ethereum" ? function(g) {
                let m = wSe[g];
                if (!m) throw new J(`Unsupported chainId: ${g} for Coinbase Onramp`);
                return m
            }(e.chain.id) : "solana",
            u = e.isUSDC ? "USDC" : e.chainType === "ethereum" ? "ETH" : "SOL",
            h = await t.initCoinbaseOnRamp({
                addresses: [{
                    address: e.address,
                    blockchains: [l]
                }],
                assets: [u]
            }),
            {
                url: f
            } = ane({
                appId: t.getAppId(),
                input: h,
                amount: e.amount,
                blockchain: l,
                asset: u,
                experience: s
            });
        c.location = f.toString();
        let p = { ...i == null ? void 0 : i.funding,
            showAlternateFundingMethod: !0
        };
        e.usingDefaultFundingMethod && (p.usingDefaultFundingMethod = !1), r({
            funding: p,
            coinbaseOnrampStatus: {
                popup: c
            }
        }), n(fSe), t.createAnalyticsEvent({
            eventName: "sdk_fiat_on_ramp_started",
            payload: {
                provider: "coinbase-onramp",
                value: e.amount,
                chainType: e.chainType,
                chainId: e.chainType === "ethereum" ? e.chain.id : e.cluster.name
            }
        }), setTimeout(() => {
            r({
                funding: p,
                coinbaseOnrampStatus: {
                    partnerUserId: h.partner_user_id,
                    popup: c
                }
            })
        }, 5e3), a()
    }),
    bSe = ({
        size: t = 61,
        ...e
    }) => d.jsx("svg", {
        width: t,
        height: t,
        viewBox: "0 0 61 61",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...e,
        children: d.jsxs("g", {
            id: "moonpay_symbol_wht 2",
            children: [d.jsx("rect", {
                x: "1.3374",
                y: "1",
                width: "59",
                height: "59",
                rx: "11.5",
                fill: "#7715F5"
            }), d.jsx("path", {
                id: "Vector",
                d: "M43.8884 23.3258C45.0203 23.3258 46.1268 22.9901 47.068 22.3613C48.0091 21.7324 48.7427 20.8386 49.1759 19.7928C49.6091 18.747 49.7224 17.5962 49.5016 16.4861C49.2807 15.3759 48.7357 14.3561 47.9353 13.5557C47.1349 12.7553 46.1151 12.2102 45.0049 11.9893C43.8947 11.7685 42.7439 11.8819 41.6982 12.3151C40.6524 12.7482 39.7585 13.4818 39.1297 14.423C38.5008 15.3641 38.1651 16.4707 38.1651 17.6026C38.165 18.3542 38.3131 19.0985 38.6007 19.7929C38.8883 20.4873 39.3098 21.1182 39.8413 21.6496C40.3728 22.1811 41.0037 22.6027 41.6981 22.8903C42.3925 23.1778 43.1367 23.3259 43.8884 23.3258ZM26.3395 49.1017C23.5804 49.1017 20.8832 48.2836 18.5891 46.7507C16.295 45.2178 14.5069 43.039 13.4511 40.49C12.3952 37.9409 12.1189 35.1359 12.6572 32.4298C13.1955 29.7237 14.5241 27.238 16.4751 25.287C18.4262 23.336 20.9118 22.0074 23.6179 21.4691C26.324 20.9308 29.129 21.2071 31.6781 22.2629C34.2272 23.3189 36.406 25.1069 37.9389 27.401C39.4717 29.6952 40.2899 32.3923 40.2899 35.1514C40.2899 36.9835 39.9291 38.7975 39.2281 40.49C38.527 42.1826 37.4994 43.7205 36.204 45.0159C34.9086 46.3113 33.3707 47.3389 31.6781 48.04C29.9856 48.741 28.1715 49.1018 26.3395 49.1017Z",
                fill: "white"
            })]
        })
    }),
    NB = {
        component: () => {
            let {
                app: t,
                data: e,
                setModalData: r,
                navigateBack: n
            } = Ne(), {
                closePrivyModal: i
            } = $e(), {
                externalTransactionId: s
            } = e == null ? void 0 : e.moonpayStatus, a = function(o, c = !1) {
                let [l, u] = v.useState(null), {
                    createAnalyticsEvent: h
                } = $e(), {
                    data: f,
                    navigate: p,
                    setModalData: g
                } = Ne(), m = f == null ? void 0 : f.funding, y = v.useRef(0);
                return v.useEffect(() => {
                    let w = setInterval(async () => {
                        var x, E;
                        if (o) try {
                            let [_] = await async function(A, I) {
                                return nO(`${I?s9e:i9e}/transactions/ext/${A}`, {
                                    query: {
                                        apiKey: I ? o9e : a9e
                                    }
                                })
                            }(o, c), b = _.status === "waitingAuthorization" && _.paymentMethod === "credit_debit_card" ? "pending" : _.status;
                            if (["failed", "completed", "awaitingAuthorization"].includes(b) && (h({
                                    eventName: Na,
                                    payload: {
                                        status: b,
                                        provider: rS,
                                        paymentMethod: _.paymentMethod,
                                        cardPaymentType: _.cardPaymentType,
                                        currency: (x = _.currency) == null ? void 0 : x.code,
                                        baseCurrencyAmount: _.baseCurrencyAmount,
                                        quoteCurrencyAmount: _.quoteCurrencyAmount,
                                        feeAmount: _.feeAmount,
                                        extraFeeAmount: _.extraFeeAmount,
                                        networkFeeAmount: _.networkFeeAmount,
                                        isSandbox: c
                                    }
                                }), clearInterval(w)), b === "failed" || b === "serviceFailure") return g({
                                funding: { ...m,
                                    errorMessage: "Something went wrong adding funds from Moonpay. Please try again or use another method to fund your wallet."
                                }
                            }), void p(Ui);
                            u(b)
                        } catch (_) {
                            ((E = _.response) == null ? void 0 : E.status) !== 404 && (y.current += 1), y.current >= 3 && (h({
                                eventName: Na,
                                payload: {
                                    status: "serviceFailure",
                                    provider: rS
                                }
                            }), clearInterval(w), g({
                                funding: { ...m,
                                    errorMessage: "Something went wrong adding funds from Moonpay. Please try again or use another method to fund your wallet."
                                }
                            }), p(Ui))
                        }
                    }, 3e3);
                    return () => clearInterval(w)
                }, [o, y]), l
            }(s || null, t.fundingMethodConfig.moonpay.useSandbox ? ? !1);
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    title: "Fund account",
                    backFn: () => {
                        let o = { ...e == null ? void 0 : e.funding,
                            showAlternateFundingMethod: !0
                        };
                        o.usingDefaultFundingMethod && (o.usingDefaultFundingMethod = !1), r({
                            funding: o
                        }), n()
                    }
                }), d.jsx(vSe, {
                    status: a,
                    onClickCta: i
                }), d.jsx(ot, {})]
            })
        }
    };
let vSe = ({
        status: t,
        onClickCta: e
    }) => {
        let {
            title: r,
            body: n,
            cta: i
        } = v.useMemo(() => (s => {
            switch (s) {
                case "completed":
                    return {
                        title: "You've funded your account!",
                        body: "It may take a few minutes for the assets to appear.",
                        cta: "Continue"
                    };
                case "waitingAuthorization":
                    return {
                        title: "Processing payment",
                        body: "This may take up to a few hours. You will receive an email when the purchase is complete.",
                        cta: "Continue"
                    };
                default:
                    return {
                        title: "In Progress",
                        body: "Go back to MoonPay to finish funding your account.",
                        cta: ""
                    }
            }
        })(t), [t]);
        return d.jsxs(d.Fragment, {
            children: [d.jsxs(_Se, {
                children: [d.jsx(xSe, {
                    status: t
                }), d.jsxs(ls, {
                    children: [d.jsx("h3", {
                        children: r
                    }), d.jsx(ESe, {
                        children: n
                    })]
                })]
            }), i && d.jsx(Qe, {
                onClick: e,
                children: i
            })]
        })
    },
    xSe = ({
        status: t
    }) => {
        if (!t || t === "pending") {
            let n = "var(--privy-color-foreground-4)";
            return d.jsxs("div", {
                style: {
                    position: "relative"
                },
                children: [d.jsx(Ls, {
                    color: n,
                    style: {
                        position: "absolute"
                    }
                }), d.jsx(w8, {
                    color: n
                }), d.jsx(bSe, {
                    size: "3rem",
                    style: {
                        position: "absolute",
                        top: "1rem",
                        left: "1rem"
                    }
                })]
            })
        }
        let e = (n => {
                switch (n) {
                    case "completed":
                        return vd;
                    case "waitingAuthorization":
                        return () => d.jsx(qy, {
                            width: "3rem",
                            height: "3rem",
                            style: {
                                backgroundColor: "var(--privy-color-foreground-4)",
                                color: "var(--privy-color-background)",
                                borderRadius: "100%",
                                padding: "0.5rem",
                                margin: "0.5rem"
                            }
                        });
                    default:
                        return
                }
            })(t),
            r = (n => n ? {
                completed: "var(--privy-color-success)",
                failed: "var(--privy-color-error)",
                serviceFailure: "var(--privy-color-error)",
                waitingAuthorization: "var(--privy-color-accent)",
                pending: "var(--privy-color-foreground-4)"
            }[n] : "var(--privy-color-foreground-4)")(t);
        return d.jsx("div", {
            style: {
                borderColor: r,
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                borderRadius: "100%",
                borderWidth: 2,
                padding: "0.5rem",
                marginBottom: "0.5rem"
            },
            children: e && d.jsx(e, {
                width: "4rem",
                height: "4rem",
                color: r
            })
        })
    },
    ESe = z.p.withConfig({
        displayName: "StatusBody",
        componentId: "sc-7f0a56e4-0"
    })(["font-size:1rem;color:var(--privy-color-foreground-3);margin-bottom:1rem;display:flex;flex-direction:column;gap:1rem;"]),
    _Se = z.div.withConfig({
        displayName: "ConnectContainer",
        componentId: "sc-7f0a56e4-1"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;margin-left:1.75rem;margin-right:1.75rem;padding:2rem 0;"]);
const CSe = async (t, e, r, n, i, s, a, o) => {
    var p, g;
    let c = ew();
    if (!c) throw Error("Unable to initialize flow");
    let l = e.chainType === "ethereum" ? ((p = e.moonpayConfigOverride) == null ? void 0 : p.currencyCode) ? ? Rre(e.chain.id, n) : e.isUSDC ? "USDC_SOL" : "SOL",
        {
            signedUrl: u,
            externalTransactionId: h
        } = await t.signMoonpayOnRampUrl({
            address: e.address,
            useSandbox: r.fundingMethodConfig.moonpay.useSandbox ? ? !1,
            config: {
                uiConfig: {
                    accentColor: r.appearance.palette.accent,
                    theme: r.appearance.palette.colorScheme
                },
                ...e.moonpayConfigOverride,
                paymentMethod: o,
                currencyCode: l,
                quoteCurrencyAmount: ((g = e.moonpayConfigOverride) == null ? void 0 : g.quoteCurrencyAmount) ? ? ISe(e.amount)
            }
        });
    t.createAnalyticsEvent({
        eventName: "sdk_fiat_on_ramp_started",
        payload: {
            provider: "moonpay",
            value: e.amount,
            chainType: e.chainType,
            chainId: e.chainType === "ethereum" ? e.chain.id : e.cluster.name
        }
    }), c.location = u;
    let f = { ...a == null ? void 0 : a.funding,
        showAlternateFundingMethod: !0
    };
    e.usingDefaultFundingMethod && (f.usingDefaultFundingMethod = !1), i({
        moonpayStatus: {},
        funding: f
    }), s(NB), setTimeout(() => {
        i({
            moonpayStatus: {
                externalTransactionId: h
            },
            funding: f
        })
    }, 8e3)
};
let OB = async t => typeof window < "u" && "PaymentRequest" in window && await new window.PaymentRequest([{
    supportedMethods: t
}], {
    id: "0",
    total: {
        label: "Item",
        amount: {
            currency: "USD",
            value: "1.00"
        }
    }
}).canMakePayment();
const ASe = () => OB("https://apple.com/apple-pay"),
    kSe = () => OB("https://google.com/pay"),
    Ui = {
        component: () => {
            var x, E;
            let {
                wallets: t
            } = gl(), {
                wallets: e
            } = z0(), {
                navigate: r,
                data: n,
                setModalData: i
            } = Ne(), {
                client: s
            } = $e(), a = Gt(), o = n == null ? void 0 : n.funding, c = Y$(ASe), l = Y$(kSe), u = o.chainType === "solana", h = u ? void 0 : o, f = v.useMemo(() => ((_, b, A, I, T, C) => {
                var U;
                let $, P, N = A.chainType === "solana",
                    R = N ? void 0 : A,
                    D = A.isUSDC ? "USDC" : R != null && R.erc20Address ? void 0 : "native-currency",
                    S = !!N || D && jre(Number(A.chain.id), D),
                    O = !!N || D && one(Number(A.chain.id), D),
                    M = [];
                for (let k of (A.preferredCardProvider && A.supportedOptions.sort(F => F.provider === A.preferredCardProvider ? -1 : 1), A.supportedOptions)) k.method === "card" && k.provider === "coinbase" && O && M.push(() => tS(b, A, I, T, C, "buy")), k.method === "card" && k.provider === "moonpay" && S && D && M.push(() => CSe(b, A, _, D, I, T, C, "credit_debit_card"));
                for (let k of A.supportedOptions) k.method === "exchange" && k.provider === "coinbase" && O && ($ = () => tS(b, A, I, T, C, "buy"));
                for (let k of ((U = C == null ? void 0 : C.funding) == null ? void 0 : U.supportedOptions) ? ? []) k.method === "wallets" && (P = () => T(Lh));
                return {
                    onFundWithCard: M,
                    onFundWithExchange: $,
                    onFundWithWallet: P
                }
            })(a, s, o, i, r, n), [a, s, o, n, i, r]);
            v.useEffect(() => {
                if (o != null && o.defaultFundingMethod && o.usingDefaultFundingMethod) switch (i({
                    funding: { ...o,
                        usingDefaultFundingMethod: !1
                    }
                }), o == null ? void 0 : o.defaultFundingMethod) {
                    case "card":
                        f.onFundWithCard[0] && f.onFundWithCard[0]();
                        break;
                    case "exchange":
                        f.onFundWithExchange && f.onFundWithExchange();
                        break;
                    case "wallet":
                        f.onFundWithWallet && f.onFundWithWallet();
                        break;
                    case "manual":
                        r(E1)
                }
            }, []), v.useEffect(() => {
                h != null && h.erc20Address && !h.erc20ContractInfo && bB({
                    address: h.erc20Address,
                    chain: h.chain,
                    rpcConfig: a.rpcConfig,
                    privyAppId: a.id
                }).then(_ => {
                    i({ ...n,
                        funding: { ...h,
                            erc20ContractInfo: _ ? {
                                symbol: _.symbol,
                                decimals: _.decimals
                            } : void 0
                        }
                    })
                }).catch(console.error)
            }, [h == null ? void 0 : h.erc20Address, h == null ? void 0 : h.chain]);
            let p = u ? e.find(({
                    address: _
                }) => _ === o.address) : t.find(({
                    address: _
                }) => Zr(_) === Zr(o.address)),
                g = mc((p == null ? void 0 : p.walletClientType) || "unknown"),
                m = (g == null ? void 0 : g.name) || "wallet",
                y = p && p.walletClientType !== "privy" ? m : a.name,
                w = !(!(h != null && h.erc20Address) || h != null && h.erc20ContractInfo);
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Bi, {}), d.jsxs("h3", {
                    children: ["Add funds to your", " ", y != null && y.toLowerCase().endsWith("wallet") ? y : y + " wallet"]
                }), d.jsxs(lSe, {
                    children: [o.errorMessage && d.jsx(I$e, {
                        theme: a.appearance.palette.colorScheme,
                        children: o.errorMessage
                    }), ((x = f.onFundWithCard) == null ? void 0 : x[0]) && d.jsxs(Pr, {
                        disabled: w,
                        onClick: f.onFundWithCard[0],
                        children: [d.jsx(Nf, {
                            children: d.jsx(t_e, {
                                style: {
                                    width: 24
                                }
                            })
                        }), "Pay with card", c ? d.jsx(S$e, {
                            style: {
                                marginLeft: "auto",
                                maxWidth: "100%",
                                width: "auto",
                                height: "0.875rem"
                            }
                        }) : l ? d.jsx(T$e, {
                            style: {
                                marginLeft: "auto",
                                maxWidth: "100%",
                                width: "auto",
                                height: "0.875rem"
                            }
                        }) : null]
                    }), f.onFundWithExchange && d.jsxs(Pr, {
                        disabled: w,
                        onClick: f.onFundWithExchange,
                        children: [d.jsx(Nf, {
                            children: d.jsx(qy, {
                                style: {
                                    width: 24
                                }
                            })
                        }), "Transfer from an exchange"]
                    }), f.onFundWithWallet && d.jsxs(Pr, {
                        disabled: w,
                        onClick: f.onFundWithWallet,
                        children: [d.jsx(Nf, {
                            children: d.jsx(P$e, {
                                style: {
                                    width: 24
                                }
                            })
                        }), "Transfer from wallet"]
                    }), d.jsxs(Pr, {
                        disabled: w,
                        onClick: () => r(E1),
                        children: [d.jsx(Nf, {
                            children: d.jsx(E_e, {
                                style: {
                                    width: 24
                                }
                            })
                        }), "Receive funds"]
                    }), (o == null ? void 0 : o.showAlternateFundingMethod) && ((E = f.onFundWithCard) == null ? void 0 : E[1]) && d.jsx(fB, {
                        theme: a.appearance.palette.colorScheme,
                        children: d.jsxs(uSe, {
                            children: ["Having trouble or facing location restrictions?", " ", d.jsx(hSe, {
                                onClick: f.onFundWithCard[1],
                                children: "Try a different provider."
                            })]
                        })
                    })]
                }), d.jsx(ot, {})]
            })
        }
    },
    rS = "moonpay";

function ISe(t) {
    return parseFloat(t)
}

function $Se(t) {
    return !!t && t.config !== void 0 && t.provider !== void 0
}

function Rv(t) {
    return !!t && (t.chain !== void 0 || t.amount !== void 0)
}
const nS = {
        [Bs.id]: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        [I6.id]: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
        [go.id]: "0x0b2c639c533813f4aa9d7837caf62653d097ff85",
        [V1.id]: "0x5fd84259d66Cd46123540766Be93DFE6D43130D7",
        [fs.id]: "0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",
        [i0.id]: "0x41e94eb019c0762f9bfcf9fb1e58725bfb0e7582",
        [Fs.id]: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
        [q1.id]: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
        [yh.id]: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
        [k6.id]: "0x5425890298aed601595a70ab815c96711a31bc65",
        [ja.id]: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
        [z1.id]: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d"
    },
    iS = ({
        address: t,
        appConfig: e,
        fundWalletConfig: r,
        methodScreen: n,
        chainIdOverride: i,
        comingFromSendTransactionScreen: s = !1
    }) => {
        var g;
        let a, o;
        if (!e.fundingConfig) throw Error("Wallet funding is not enabled");
        let c = U8(e.fundingConfig.options);
        if (c.length < 1) throw Error("Wallet funding is not enabled");
        a = i || (Rv(r) && r.chain ? r.chain.id : uF(e.fundingConfig.defaultRecommendedCurrency.chain));
        let l = e.chains.find(m => m.id === a);
        if (!l) throw new J(`Funding chain ${a} is not in PrivyProvider chains list`);
        let u = Rv(r) && r.amount ? r.amount : e.fundingConfig.defaultRecommendedAmount,
            h = !1;

        function f() {
            if (!a) return;
            let m = nS[a];
            c.find(y => y.method === "wallets") && !m && console.warn("Attempting to fund with USDC on chain where USDC address is not known. Funding via external wallet will be disabled."), o = m, h = !0
        }
        Rv(r) && "asset" in r ? r.asset === "USDC" ? f() : typeof r.asset != "string" && "erc20" in r.asset && (h = ((m, y) => m === nS[y.id])(o = r.asset.erc20, l)) : e.fundingConfig.defaultRecommendedCurrency.asset === "USDC" && f();
        let p = r == null ? void 0 : r.defaultFundingMethod;
        return {
            chainType: "ethereum",
            address: t,
            amount: u,
            chain: l,
            erc20Address: o,
            erc20ContractInfo: h ? {
                symbol: "USDC",
                decimals: 6
            } : void 0,
            isUSDC: h,
            methodScreen: n,
            supportedOptions: c,
            comingFromSendTransactionScreen: s,
            defaultFundingMethod: p,
            usingDefaultFundingMethod: !!p,
            preferredCardProvider: (g = r == null ? void 0 : r.card) == null ? void 0 : g.preferredProvider,
            crossChainBridgingEnabled: e.fundingConfig.crossChainBridgingEnabled ? ? !1,
            cluster: {
                name: "mainnet-beta",
                rpcUrl: e.solanaClusters["mainnet-beta"].rpcUrl
            },
            ...$Se(r) ? {
                moonpayConfigOverride: r.config
            } : {},
            uiConfig: r && "uiConfig" in r ? r.uiConfig : void 0
        }
    };

function SSe({
    address: t,
    fundWalletConfig: e,
    appConfig: r,
    comingFromSendTransactionScreen: n,
    methodScreen: i
}) {
    var c, l, u, h;
    if (!r.fundingConfig) throw Error("Wallet funding is not enabled");
    let s = U8(r.fundingConfig.options);
    if (s.length < 1) throw Error("Wallet funding is not enabled");
    if ((e == null ? void 0 : e.asset) === "USDC" && ((c = e == null ? void 0 : e.cluster) == null ? void 0 : c.name) === "testnet") throw Error("USDC funding is not supported on the Solana testnet");
    let a = (e == null ? void 0 : e.amount) ? ? r.fundingConfig.defaultRecommendedAmount,
        o = e == null ? void 0 : e.defaultFundingMethod;
    return {
        chainType: "solana",
        address: t,
        supportedOptions: s,
        amount: a,
        isUSDC: (e == null ? void 0 : e.asset) === "USDC",
        methodScreen: i,
        comingFromSendTransactionScreen: n,
        cluster: {
            name: ((l = e == null ? void 0 : e.cluster) == null ? void 0 : l.name) ? ? "mainnet-beta",
            rpcUrl: r.solanaClusters[((u = e == null ? void 0 : e.cluster) == null ? void 0 : u.name) ? ? "mainnet-beta"].rpcUrl
        },
        crossChainBridgingEnabled: r.fundingConfig.crossChainBridgingEnabled ? ? !1,
        defaultFundingMethod: o,
        preferredCardProvider: (h = e == null ? void 0 : e.card) == null ? void 0 : h.preferredProvider,
        usingDefaultFundingMethod: !!o,
        uiConfig: e == null ? void 0 : e.uiConfig
    }
}
const TSe = ({
    children: t,
    theme: e
}) => d.jsxs(PSe, {
    $theme: e,
    children: [d.jsx(yo, {
        width: "1.25rem",
        color: e === "dark" ? "#FDE68A" : "var(--privy-color-warn)"
    }), t]
});
let PSe = z.div.withConfig({
    displayName: "Container",
    componentId: "sc-97f152b3-0"
})(["display:flex;gap:0.5rem;background-color:", ";", " align-items:flex-start;text-align:left;padding:0.5rem 0.75rem;font-size:0.8125rem;font-weight:400;line-height:1.125rem;padding:0.75rem;&&{border-radius:var(--privy-border-radius-sm);}"], t => t.$theme === "dark" ? "var(--privy-color-background-2)" : "var(--privy-color-warn-light)", t => t.$theme === "dark" ? "color: #FDE68A;" : "");

function NSe(t) {
    let [e, r] = v.useState(t.dimensions.width), [n, i] = v.useState(void 0), s = v.useRef(null);
    v.useEffect(() => {
        if (s.current && e === void 0) {
            let {
                width: c
            } = s.current.getBoundingClientRect();
            r(c)
        }
        let o = getComputedStyle(document.documentElement);
        i({
            background: o.getPropertyValue("--privy-color-background"),
            background2: o.getPropertyValue("--privy-color-background-2"),
            foreground3: o.getPropertyValue("--privy-color-foreground-3"),
            foregroundAccent: o.getPropertyValue("--privy-color-foreground-accent"),
            accent: o.getPropertyValue("--privy-color-accent"),
            accentDark: o.getPropertyValue("--privy-color-accent-dark"),
            success: o.getPropertyValue("--privy-color-success"),
            colorScheme: o.getPropertyValue("color-scheme")
        })
    }, []);
    let a = t.chainType === "ethereum" && !t.imported && !t.isUnifiedWallet;
    return d.jsx("div", {
        ref: s,
        children: e && d.jsxs(jSe, {
            children: [d.jsx("iframe", {
                style: {
                    position: "absolute",
                    zIndex: 1
                },
                width: e,
                height: t.dimensions.height,
                allow: "clipboard-write self *",
                src: gU(t.origin, `/apps/${t.appId}/embedded-wallets/export`, t.isUnifiedWallet ? {
                    v: "1-unified",
                    wallet_id: t.walletId,
                    client_id: t.appClientId,
                    width: `${e}px`,
                    caid: t.clientAnalyticsId,
                    phrase_export: a,
                    ...n
                } : {
                    v: "1",
                    entropy_id: t.entropyId,
                    entropy_id_verifier: t.entropyIdVerifier,
                    hd_wallet_index: t.hdWalletIndex,
                    chain_type: t.chainType,
                    client_id: t.appClientId,
                    width: `${e}px`,
                    caid: t.clientAnalyticsId,
                    phrase_export: a,
                    ...n
                }, {
                    token: t.accessToken
                })
            }), d.jsx(sS, {
                children: "Loading..."
            }), a && d.jsx(sS, {
                children: "Loading..."
            })]
        })
    })
}
const B4 = {
    component: () => {
        let [t, e] = v.useState(null), {
            authenticated: r,
            user: n
        } = $t(), {
            closePrivyModal: i,
            createAnalyticsEvent: s,
            clientAnalyticsId: a,
            client: o
        } = $e(), c = Gt(), {
            data: l,
            onUserCloseViaDialogOrKeybindRef: u
        } = Ne(), {
            onFailure: h,
            onSuccess: f,
            origin: p,
            appId: g,
            appClientId: m,
            entropyId: y,
            entropyIdVerifier: w,
            walletId: x,
            hdWalletIndex: E,
            chainType: _,
            address: b,
            isUnifiedWallet: A,
            imported: I
        } = l.keyExport, T = $ => {
            i({
                shouldCallAuthOnSuccess: !1
            }), h(typeof $ == "string" ? Error($) : $)
        }, C = () => {
            i({
                shouldCallAuthOnSuccess: !1
            }), f(), s({
                eventName: "embedded_wallet_key_export_completed",
                payload: {
                    walletAddress: b
                }
            })
        };
        return v.useEffect(() => {
            if (!r) return T("User must be authenticated before exporting their wallet");
            o.getAccessToken().then(e).catch(T)
        }, [r, n]), u.current = C, d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                onClose: C
            }), d.jsxs(OSe, {
                children: [d.jsx(Pa, {
                    children: "Export wallet"
                }), d.jsxs($a, {
                    children: ["Copy either your private key or seed phrase to export your wallet.", " ", d.jsx("a", {
                        href: "https://privy-io.notion.site/Transferring-your-account-9dab9e16c6034a7ab1ff7fa479b02828",
                        target: "blank",
                        rel: "noopener noreferrer",
                        children: "Learn more"
                    })]
                }), d.jsx(TSe, {
                    theme: c.appearance.palette.colorScheme,
                    children: "Never share your private key or seed phrase with anyone."
                }), d.jsx(gw, {
                    isLoading: !1,
                    isPulsing: !1,
                    title: "Your wallet",
                    address: b,
                    showIcon: !0
                }), d.jsx("div", {
                    style: {
                        width: "100%"
                    },
                    children: t && d.jsx(NSe, {
                        origin: p,
                        appId: g,
                        appClientId: m,
                        accessToken: t,
                        clientAnalyticsId: a,
                        entropyId: y,
                        entropyIdVerifier: w,
                        walletId: x,
                        hdWalletIndex: E,
                        isUnifiedWallet: A,
                        imported: I,
                        chainType: _,
                        dimensions: {
                            height: "44px"
                        }
                    })
                })]
            }), d.jsx(ot, {})]
        })
    }
};
let OSe = z.div.withConfig({
        displayName: "EmbeddedWalletScreenContainer",
        componentId: "sc-7b921328-0"
    })(["display:flex;flex-direction:column;gap:1.25rem;text-align:left;"]),
    jSe = z.div.withConfig({
        displayName: "ButtonContainer",
        componentId: "sc-7b921328-1"
    })(["overflow:visible;position:relative;overflow:none;height:44px;display:flex;gap:12px;"]),
    sS = z.div.withConfig({
        displayName: "LoadingButton",
        componentId: "sc-7b921328-2"
    })(["display:flex;align-items:center;justify-content:center;width:100%;height:100%;font-size:16px;font-weight:500;border-radius:var(--privy-border-radius-md);background-color:var(--privy-color-background-2);color:var(--privy-color-foreground-3);"]);
const Lc = {
    component: () => {
        let {
            authenticated: t,
            user: e,
            getAccessToken: r
        } = $t(), {
            closePrivyModal: n,
            createAnalyticsEvent: i,
            walletProxy: s
        } = $e(), {
            navigate: a,
            data: o,
            setModalData: c,
            onUserCloseViaDialogOrKeybindRef: l
        } = Ne(), u = v.useMemo(() => Date.now(), []), [h, f] = v.useState(!1), {
            onCompleteNavigateTo: p,
            onFailure: g,
            shouldForceMFA: m,
            entropyId: y,
            entropyIdVerifier: w,
            recoveryMethod: x,
            connectingWalletAddress: E,
            isUnifiedWallet: _ = !1
        } = o == null ? void 0 : o.connectWallet, b = I => {
            h || (f(!0), g(typeof I == "string" ? Error(I) : I))
        };
        v.useEffect(() => {
            let I;
            return t ? s ? ((async () => {
                let T = await r();
                if (!T) return b("User must be authenticated and have a Privy wallet before it can be connected");
                try {
                    _ || await s.connect({
                        accessToken: T,
                        entropyId: y,
                        entropyIdVerifier: w
                    }), m && await s.verifyMfa({
                        accessToken: T
                    });
                    let C = (Date.now() - u) / 1e3;
                    p === B4 && C < 1 ? I = setTimeout(() => {
                        a(p, !1)
                    }, 1e3 * (1 - C)) : a(p, !1)
                } catch (C) {
                    if (Hp(C) && x === "privy") {
                        let $ = await r();
                        if (!$) return b("User must be authenticated and have a Privy wallet before it can be recovered");
                        try {
                            i({
                                eventName: "embedded_wallet_pinless_recovery_started",
                                payload: {
                                    walletAddress: E
                                }
                            });
                            let P = await (s == null ? void 0 : s.recover({
                                accessToken: $,
                                entropyId: y,
                                entropyIdVerifier: w
                            }));
                            P != null && P.entropyId || b(Error("Unable to recover wallet")), p ? a(p) : n({
                                shouldCallAuthOnSuccess: !1
                            }), i({
                                eventName: "embedded_wallet_recovery_completed",
                                payload: {
                                    walletAddress: E
                                }
                            }), a(p)
                        } catch {
                            b("An error has occurred, please try again.")
                        }
                    } else Hp(C) && x !== "privy" && x !== "privy-v2" ? (c({ ...o,
                        recoverWallet: {
                            entropyId: y,
                            entropyIdVerifier: w,
                            onCompleteNavigateTo: p,
                            onFailure: g
                        },
                        recoveryOAuthStatus: {
                            provider: x,
                            action: "recover",
                            isInAccountCreateFlow: !1,
                            shouldCreateEth: !1,
                            shouldCreateSol: !1
                        }
                    }), a(hB(x))) : b(C)
                }
            })(), () => clearTimeout(I)) : void 0 : b("User must be authenticated and have a Privy wallet before it can be connected")
        }, [t, e, s]);
        let A = () => {
            b("User exited before wallet could be connected"), n({
                shouldCallAuthOnSuccess: !1
            })
        };
        return l.current = A, d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                onClose: A
            }), h ? d.jsxs(d.Fragment, {
                children: [d.jsxs(wc, {
                    children: [d.jsx(zy, {
                        fill: "var(--privy-color-error)",
                        width: "64px",
                        height: "64px"
                    }), d.jsx($r, {
                        title: "Something went wrong",
                        description: "We’re on it. Please try again later."
                    })]
                }), d.jsx(Qe, {
                    onClick: () => n({
                        shouldCallAuthOnSuccess: !1
                    }),
                    children: "Close"
                })]
            }) : d.jsx(LF, {}), d.jsx(RSe, {})]
        })
    }
};
let RSe = z.div.withConfig({
    displayName: "BottomSpacing",
    componentId: "sc-1ec92f42-0"
})(["height:44px;"]);
const jB = z(qe).withConfig({
    displayName: "InteractiveLabel",
    componentId: "sc-b57d0824-0"
})(["cursor:pointer;display:inline-flex;gap:8px;align-items:center;color:var(--privy-color-accent);svg{fill:var(--privy-color-accent);}"]);
var aS = ({
    iconUrl: t,
    value: e,
    symbol: r,
    usdValue: n,
    nftName: i,
    nftCount: s,
    decimals: a,
    $isLoading: o
}) => {
    if (o) return d.jsx(oS, {
        $isLoading: o
    });
    let c = e && n && a ? function(l, u, h) {
        let f = parseFloat(l),
            p = parseFloat(h);
        if (f === 0 || p === 0 || Number.isNaN(f) || Number.isNaN(p)) return l;
        let g = Math.ceil(-Math.log10(.01 / (p / f))),
            m = Math.pow(10, g = Math.max(g = Math.min(g, u), 1));
        return (Math.floor(f * m) / m).toFixed(g).replace(/\.?0+$/, "")
    }(e, a, n) : e;
    return d.jsxs("div", {
        children: [d.jsxs(oS, {
            $isLoading: o,
            children: [t && d.jsx(DSe, {
                src: t,
                alt: "Token icon"
            }), s && s > 1 ? s + "x" : void 0, " ", i, c, " ", r]
        }), n && d.jsxs(MSe, {
            $isLoading: o,
            children: ["$", n]
        })]
    })
};
let oS = z.span.withConfig({
    displayName: "Value",
    componentId: "sc-e57378e9-0"
})(["color:var(--privy-color-foreground);font-size:0.875rem;font-weight:500;line-height:1.375rem;word-break:break-all;text-align:right;display:flex;justify-content:flex-end;", ""], uw);
const MSe = z.span.withConfig({
    displayName: "Subvalue",
    componentId: "sc-e57378e9-1"
})(["color:var(--privy-color-foreground-2);font-size:12px;font-weight:400;line-height:18px;word-break:break-all;text-align:right;display:flex;justify-content:flex-end;", ""], uw);
let DSe = z.img.withConfig({
    displayName: "TokenIcon",
    componentId: "sc-e57378e9-2"
})(["height:14px;width:14px;margin-right:4px;object-fit:contain;"]);
const LSe = t => {
    var o, c, l, u, h, f, p, g;
    let {
        chain: e,
        transactionDetails: r,
        isTokenContractInfoLoading: n,
        symbol: i
    } = t, {
        action: s,
        functionName: a
    } = r;
    return d.jsx(pw, {
        children: d.jsxs(Dh, {
            children: [s !== "transaction" && d.jsxs(Oe, {
                children: [d.jsx(qe, {
                    children: "Action"
                }), d.jsx(Je, {
                    children: a
                })]
            }), a === "mint" && "args" in r && r.args.filter(m => m).map((m, y) => {
                var w, x;
                return d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: `Param ${y}`
                    }), d.jsx(Je, {
                        children: typeof m == "string" && gi(m) ? d.jsx(Rt, {
                            address: m,
                            url: (x = (w = e == null ? void 0 : e.blockExplorers) == null ? void 0 : w.default) == null ? void 0 : x.url,
                            showCopyIcon: !1
                        }) : m == null ? void 0 : m.toString()
                    })]
                }, y)
            }), a === "setApprovalForAll" && r.operator && d.jsxs(Oe, {
                children: [d.jsx(qe, {
                    children: "Operator"
                }), d.jsx(Je, {
                    children: d.jsx(Rt, {
                        address: r.operator,
                        url: (c = (o = e == null ? void 0 : e.blockExplorers) == null ? void 0 : o.default) == null ? void 0 : c.url,
                        showCopyIcon: !1
                    })
                })]
            }), a === "setApprovalForAll" && r.approved !== void 0 && d.jsxs(Oe, {
                children: [d.jsx(qe, {
                    children: "Set approval to"
                }), d.jsx(Je, {
                    children: r.approved ? "true" : "false"
                })]
            }), a === "transfer" || a === "transferFrom" || a === "safeTransferFrom" || a === "approve" ? d.jsxs(d.Fragment, {
                children: ["formattedAmount" in r && r.formattedAmount && d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Amount"
                    }), d.jsxs(Je, {
                        $isLoading: n,
                        children: [r.formattedAmount, " ", i]
                    })]
                }), "tokenId" in r && r.tokenId && d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Token ID"
                    }), d.jsx(Je, {
                        children: r.tokenId.toString()
                    })]
                })]
            }) : null, a === "safeBatchTransferFrom" && d.jsxs(d.Fragment, {
                children: ["amounts" in r && r.amounts && d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Amounts"
                    }), d.jsx(Je, {
                        children: r.amounts.join(", ")
                    })]
                }), "tokenIds" in r && r.tokenIds && d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Token IDs"
                    }), d.jsx(Je, {
                        children: r.tokenIds.join(", ")
                    })]
                })]
            }), a === "approve" && r.spender && d.jsxs(Oe, {
                children: [d.jsx(qe, {
                    children: "Spender"
                }), d.jsx(Je, {
                    children: d.jsx(Rt, {
                        address: r.spender,
                        url: (u = (l = e == null ? void 0 : e.blockExplorers) == null ? void 0 : l.default) == null ? void 0 : u.url,
                        showCopyIcon: !1
                    })
                })]
            }), (a === "transferFrom" || a === "safeTransferFrom" || a === "safeBatchTransferFrom") && r.transferFrom && d.jsxs(Oe, {
                children: [d.jsx(qe, {
                    children: "Transferring from"
                }), d.jsx(Je, {
                    children: d.jsx(Rt, {
                        address: r.transferFrom,
                        url: (f = (h = e == null ? void 0 : e.blockExplorers) == null ? void 0 : h.default) == null ? void 0 : f.url,
                        showCopyIcon: !1
                    })
                })]
            }), (a === "transferFrom" || a === "safeTransferFrom" || a === "safeBatchTransferFrom") && r.transferTo && d.jsxs(Oe, {
                children: [d.jsx(qe, {
                    children: "Transferring to"
                }), d.jsx(Je, {
                    children: d.jsx(Rt, {
                        address: r.transferTo,
                        url: (g = (p = e == null ? void 0 : e.blockExplorers) == null ? void 0 : p.default) == null ? void 0 : g.url,
                        showCopyIcon: !1
                    })
                })]
            })]
        })
    })
};
let USe = {
    success: "background: var(--privy-color-success-lightest, #dcfce7);",
    warn: "background: var(--privy-color-warn-lightest, #fff7e6);",
    error: "background: var(--privy-color-error-lightest, #fde8e8);"
};
const cS = z.div.withConfig({
        displayName: "Pill",
        componentId: "sc-8c138024-0"
    })(["border-radius:var(--privy-border-radius-md,8px);padding:12px;text-align:left;margin-top:23px;", ""], t => USe[t.variant]),
    FSe = ({
        variant: t,
        setPreventMaliciousTransaction: e,
        preventMaliciousTransaction: r
    }) => t === "warn" ? d.jsx(cS, {
        variant: t,
        children: d.jsxs("div", {
            className: "flex flex-row",
            children: [d.jsx(lS, {
                $variant: t
            }), d.jsxs("p", {
                children: [d.jsx("b", {
                    children: "Warning: Suspicious transaction"
                }), d.jsx("br", {}), "This has been flagged as a potentially deceptive request. Approving could put your assets or funds at risk."]
            })]
        })
    }) : t === "error" ? d.jsx(cS, {
        variant: t,
        children: d.jsxs("div", {
            className: "flex flex-col",
            children: [d.jsxs("div", {
                className: "flex flex-row",
                children: [d.jsx(lS, {
                    $variant: t
                }), d.jsxs("p", {
                    children: [d.jsx("b", {
                        children: "This is a malicious transaction"
                    }), d.jsx("br", {}), "This transaction transfers tokens to a known malicious address. Proceeding may result in the loss of valuable assets."]
                })]
            }), d.jsxs("div", {
                className: "mt-3 flex flex-row gap-2",
                children: [d.jsx(vF, {
                    color: "var(--privy-color-error)",
                    checked: !r,
                    readOnly: !0,
                    onClick: () => e(!r)
                }), d.jsx("p", {
                    children: "I understand and want to proceed anyways."
                })]
            })]
        })
    }) : void 0;
let lS = z(yo).withConfig({
    displayName: "StyledExclamationTriangleIcon",
    componentId: "sc-91effb27-0"
})(["width:20px;height:20px;stroke-width:2px;flex-shrink:0;display:inline-block;margin-right:8px;", ";"], ({
    $variant: t
}) => t === "error" ? "color: var(--privy-color-error)" : "color: var(--privy-color-warn)");
const BSe = ({
        transactionIndex: t,
        maxIndex: e
    }) => typeof t != "number" || e === 0 ? "" : ` (${t+1} / ${e+1})`,
    WSe = ({
        img: t,
        submitError: e,
        prepareError: r,
        onClose: n,
        action: i,
        title: s,
        subtitle: a,
        txValue: o,
        to: c,
        tokenAddress: l,
        network: u,
        missingFunds: h,
        fee: f,
        from: p,
        cta: g,
        disabled: m,
        chain: y,
        isSubmitting: w,
        isPreparing: x,
        isTokenPriceLoading: E,
        isTokenContractInfoLoading: _,
        isSponsored: b,
        symbol: A,
        balance: I,
        onClick: T,
        transactionDetails: C,
        transactionIndex: $,
        maxIndex: P,
        onBack: N,
        chainName: R,
        validation: D,
        hasScanDetails: S,
        setIsScanDetailsOpen: O,
        preventMaliciousTransaction: M,
        setPreventMaliciousTransaction: U,
        tokensSent: k,
        tokensReceived: F,
        isScanning: q,
        isCancellable: W,
        functionName: K
    }) => {
        var ne, ae, ue, he, fe, de;
        let {
            showTransactionDetails: H,
            setShowTransactionDetails: j,
            hasMoreDetails: V,
            isErc20Ish: Y
        } = (ye => {
            let [Be, ce] = v.useState(!1), Ie = !0, xe = !1;
            return (!ye || ye.isErc20Ish || ye.action === "transaction") && (Ie = !1), Ie && (xe = Object.entries(ye || {}).some(([ie, Ee]) => Ee && !["action", "isErc20Ish", "isNFTIsh"].includes(ie))), {
                showTransactionDetails: Be,
                setShowTransactionDetails: ce,
                hasMoreDetails: Ie && xe,
                isErc20Ish: ye == null ? void 0 : ye.isErc20Ish
            }
        })(C), X = Y && _ || x || E || q;
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                onClose: n,
                backFn: N
            }), t && d.jsx(DB, {
                children: t
            }), d.jsxs(Pa, {
                style: {
                    marginTop: t ? "1.5rem" : 0
                },
                children: [s, d.jsx(BSe, {
                    maxIndex: P,
                    transactionIndex: $
                })]
            }), d.jsx($a, {
                children: a
            }), d.jsxs(Dh, {
                style: {
                    marginTop: "2rem"
                },
                children: [(!!k[0] || X) && d.jsxs(Oe, {
                    children: [F.length > 0 ? d.jsx(qe, {
                        children: "Send"
                    }) : d.jsx(qe, {
                        children: i === "approve" ? "Approval amount" : "Amount"
                    }), d.jsx("div", {
                        className: "flex flex-col",
                        children: k.map((ye, Be) => d.jsx(aS, {
                            iconUrl: ye.iconUrl,
                            value: K === "setApprovalForAll" ? "All" : ye.value,
                            usdValue: ye.usdValue,
                            symbol: ye.symbol,
                            nftName: ye.nftName,
                            nftCount: ye.nftCount,
                            decimals: ye.decimals
                        }, Be))
                    })]
                }), F.length > 0 && d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Receive"
                    }), d.jsx("div", {
                        className: "flex flex-col",
                        children: F.map((ye, Be) => d.jsx(aS, {
                            iconUrl: ye.iconUrl,
                            value: ye.value,
                            usdValue: ye.usdValue,
                            symbol: ye.symbol,
                            nftName: ye.nftName,
                            nftCount: ye.nftCount,
                            decimals: ye.decimals
                        }, Be))
                    })]
                }), C && "spender" in C && (C != null && C.spender) ? d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Spender"
                    }), d.jsx(Je, {
                        children: d.jsx(Rt, {
                            address: C.spender,
                            url: (ae = (ne = y == null ? void 0 : y.blockExplorers) == null ? void 0 : ne.default) == null ? void 0 : ae.url
                        })
                    })]
                }) : null, c && d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "To"
                    }), d.jsx(Je, {
                        children: d.jsx(Rt, {
                            address: c,
                            url: (he = (ue = y == null ? void 0 : y.blockExplorers) == null ? void 0 : ue.default) == null ? void 0 : he.url,
                            showCopyIcon: !0
                        })
                    })]
                }), l && d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Token address"
                    }), d.jsx(Je, {
                        children: d.jsx(Rt, {
                            address: l,
                            url: (de = (fe = y == null ? void 0 : y.blockExplorers) == null ? void 0 : fe.default) == null ? void 0 : de.url
                        })
                    })]
                }), d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Network"
                    }), d.jsx(Je, {
                        children: u
                    })]
                }), d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Estimated fee"
                    }), d.jsx(Je, {
                        $isLoading: x || E || b === void 0,
                        children: b ? "Sponsored" : f
                    })]
                }), V && !S && d.jsxs(d.Fragment, {
                    children: [d.jsx(Oe, {
                        className: "cursor-pointer",
                        onClick: () => j(!H),
                        children: d.jsxs(M$e, {
                            className: "flex items-center gap-x-1",
                            children: ["Details", " ", d.jsx(cy, {
                                style: {
                                    width: "0.75rem",
                                    marginLeft: "0.25rem",
                                    transform: H ? "rotate(180deg)" : void 0
                                }
                            })]
                        })
                    }), H && C && d.jsx(LSe, {
                        action: i,
                        chain: y,
                        transactionDetails: C,
                        isTokenContractInfoLoading: _,
                        symbol: A
                    })]
                }), S && d.jsx(Oe, {
                    children: d.jsxs(jB, {
                        onClick: () => O(!0),
                        children: [d.jsx("span", {
                            className: "text-color-primary",
                            children: "Details"
                        }), d.jsx(voe, {
                            height: "14px",
                            width: "14px",
                            strokeWidth: "2"
                        })]
                    })
                })]
            }), d.jsx(lc, {}), e ? d.jsx(dc, {
                style: {
                    marginTop: "2rem"
                },
                children: e.message
            }) : r && $ === 0 ? d.jsx(dc, {
                style: {
                    marginTop: "2rem"
                },
                children: r.shortMessage ? ? MB
            }) : null, d.jsx(FSe, {
                variant: D,
                preventMaliciousTransaction: M,
                setPreventMaliciousTransaction: U
            }), d.jsx(RB, {
                $useSmallMargins: !(!r && !e && D !== "warn" && D !== "error"),
                title: Number(o) > 0 ? void 0 : b !== !1 ? "Your wallet" : void 0,
                address: p,
                balance: I,
                isLoading: x || E,
                errMsg: x || r || e || !h ? void 0 : `Add funds on ${(y==null?void 0:y.name)??R} to complete transaction.`
            }), d.jsx(Qe, {
                style: {
                    marginTop: "1rem"
                },
                loading: w,
                disabled: m || x,
                onClick: T,
                children: g
            }), W && d.jsx(j0, {
                style: {
                    marginTop: "1rem"
                },
                onClick: n,
                isSubmitting: !1,
                children: "Not now"
            }), d.jsx(ot, {})]
        })
    },
    zSe = ({
        img: t,
        title: e,
        subtitle: r,
        cta: n,
        instructions: i,
        network: s,
        blockExplorerUrl: a,
        isMissingFunds: o,
        submitError: c,
        parseError: l,
        total: u,
        swap: h,
        transactingWalletAddress: f,
        fee: p,
        balance: g,
        disabled: m,
        isSubmitting: y,
        isPreparing: w,
        isTokenPriceLoading: x,
        onClick: E,
        onClose: _,
        onBack: b
    }) => {
        let A = w || x,
            [I, T] = v.useState(!1);
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                onClose: _,
                backFn: b
            }), t && d.jsx(DB, {
                children: t
            }), d.jsx(Pa, {
                style: {
                    marginTop: t ? "1.5rem" : 0
                },
                children: e
            }), d.jsx($a, {
                children: r
            }), d.jsxs(Dh, {
                style: {
                    marginTop: "2rem",
                    marginBottom: ".5rem"
                },
                children: [(u || A) && d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Amount"
                    }), d.jsx(Je, {
                        $isLoading: A,
                        children: u
                    })]
                }), h && d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Swap"
                    }), d.jsx(Je, {
                        children: h
                    })]
                }), s && d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Network"
                    }), d.jsx(Je, {
                        children: s
                    })]
                }), (p || A) && d.jsxs(Oe, {
                    children: [d.jsx(qe, {
                        children: "Estimated fee"
                    }), d.jsx(Je, {
                        $isLoading: A,
                        children: p
                    })]
                })]
            }), d.jsx(Oe, {
                children: d.jsxs(jB, {
                    onClick: () => T(C => !C),
                    children: [d.jsx("span", {
                        children: "Advanced"
                    }), d.jsx(cy, {
                        height: "16px",
                        width: "16px",
                        strokeWidth: "2",
                        style: {
                            transition: "all 300ms",
                            transform: I ? "rotate(180deg)" : void 0
                        }
                    })]
                })
            }), I && d.jsx(d.Fragment, {
                children: i.map((C, $) => C.type === "sol-transfer" ? d.jsxs(_s, {
                    children: [d.jsx(Oe, {
                        children: d.jsxs(Yi, {
                            children: ["Transfer ", C.withSeed ? "with seed" : ""]
                        })
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Amount"
                        }), d.jsxs(Je, {
                            children: [ri({
                                amount: C.value,
                                decimals: C.token.decimals
                            }), " ", C.token.symbol]
                        })]
                    }), !!C.toAccount && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Destination"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.toAccount,
                                url: a
                            })
                        })]
                    })]
                }, $) : C.type === "spl-transfer" ? d.jsxs(_s, {
                    children: [d.jsx(Oe, {
                        children: d.jsxs(Yi, {
                            children: ["Transfer ", C.token.symbol]
                        })
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Amount"
                        }), d.jsx(Je, {
                            children: C.value.toString()
                        })]
                    }), !!C.fromAta && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Source"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.fromAta,
                                url: a
                            })
                        })]
                    }), !!C.toAta && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Destination"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.toAta,
                                url: a
                            })
                        })]
                    }), !!C.token.address && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Token"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.token.address,
                                url: a
                            })
                        })]
                    })]
                }, $) : C.type === "ata-creation" ? d.jsxs(_s, {
                    children: [d.jsx(Oe, {
                        children: d.jsx(Yi, {
                            children: "Create token account"
                        })
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Program ID"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.program,
                                url: a
                            })
                        })]
                    }), !!C.owner && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Owner"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.owner,
                                url: a
                            })
                        })]
                    })]
                }, $) : C.type === "create-account" ? d.jsxs(_s, {
                    children: [d.jsx(Oe, {
                        children: d.jsxs(Yi, {
                            children: ["Create account ", C.withSeed ? "with seed" : ""]
                        })
                    }), !!C.account && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Account"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.account,
                                url: a
                            })
                        })]
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Amount"
                        }), d.jsxs(Je, {
                            children: [ri({
                                amount: C.value,
                                decimals: 9
                            }), " SOL"]
                        })]
                    })]
                }, $) : C.type === "spl-init-account" ? d.jsxs(_s, {
                    children: [d.jsx(Oe, {
                        children: d.jsx(Yi, {
                            children: "Initialize token account"
                        })
                    }), !!C.account && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Account"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.account,
                                url: a
                            })
                        })]
                    }), !!C.mint && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Mint"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.mint,
                                url: a
                            })
                        })]
                    }), !!C.owner && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Owner"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.owner,
                                url: a
                            })
                        })]
                    })]
                }, $) : C.type === "spl-close-account" ? d.jsxs(_s, {
                    children: [d.jsx(Oe, {
                        children: d.jsx(Yi, {
                            children: "Close token account"
                        })
                    }), !!C.source && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Source"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.source,
                                url: a
                            })
                        })]
                    }), !!C.destination && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Destination"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.destination,
                                url: a
                            })
                        })]
                    }), !!C.owner && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Owner"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.owner,
                                url: a
                            })
                        })]
                    })]
                }, $) : C.type === "spl-sync-native" ? d.jsxs(_s, {
                    children: [d.jsx(Oe, {
                        children: d.jsx(Yi, {
                            children: "Sync native"
                        })
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Program ID"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.program,
                                url: a
                            })
                        })]
                    })]
                }, $) : C.type === "raydium-swap-base-input" ? d.jsxs(_s, {
                    children: [d.jsx(Oe, {
                        children: d.jsxs(Yi, {
                            children: ["Raydium swap", " ", C.tokenIn && C.tokenOut ? `${C.tokenIn.symbol} → ${C.tokenOut.symbol}` : ""]
                        })
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Amount in"
                        }), d.jsx(Je, {
                            children: C.amountIn.toString()
                        })]
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Minimum amount out"
                        }), d.jsx(Je, {
                            children: C.minimumAmountOut.toString()
                        })]
                    }), C.mintIn && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Token in"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.mintIn,
                                url: a
                            })
                        })]
                    }), C.mintOut && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Token out"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.mintOut,
                                url: a
                            })
                        })]
                    })]
                }, $) : C.type === "raydium-swap-base-output" ? d.jsxs(_s, {
                    children: [d.jsx(Oe, {
                        children: d.jsxs(Yi, {
                            children: ["Raydium swap", " ", C.tokenIn && C.tokenOut ? `${C.tokenIn.symbol} → ${C.tokenOut.symbol}` : ""]
                        })
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Max amount in"
                        }), d.jsx(Je, {
                            children: C.maxAmountIn.toString()
                        })]
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Amount out"
                        }), d.jsx(Je, {
                            children: C.amountOut.toString()
                        })]
                    }), C.mintIn && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Token in"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.mintIn,
                                url: a
                            })
                        })]
                    }), C.mintOut && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Token out"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.mintOut,
                                url: a
                            })
                        })]
                    })]
                }, $) : C.type === "jupiter-swap-shared-accounts-route" ? d.jsxs(_s, {
                    children: [d.jsx(Oe, {
                        children: d.jsxs(Yi, {
                            children: ["Jupiter swap", " ", C.tokenIn && C.tokenOut ? `${C.tokenIn.symbol} → ${C.tokenOut.symbol}` : ""]
                        })
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "In amount"
                        }), d.jsx(Je, {
                            children: C.inAmount.toString()
                        })]
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Quoted out amount"
                        }), d.jsx(Je, {
                            children: C.quotedOutAmount.toString()
                        })]
                    }), C.mintIn && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Token in"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.mintIn,
                                url: a
                            })
                        })]
                    }), C.mintOut && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Token out"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.mintOut,
                                url: a
                            })
                        })]
                    })]
                }, $) : C.type === "jupiter-swap-exact-out-route" ? d.jsxs(_s, {
                    children: [d.jsx(Oe, {
                        children: d.jsxs(Yi, {
                            children: ["Jupiter swap", " ", C.tokenIn && C.tokenOut ? `${C.tokenIn.symbol} → ${C.tokenOut.symbol}` : ""]
                        })
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Quoted in amount"
                        }), d.jsx(Je, {
                            children: C.quotedInAmount.toString()
                        })]
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Amount out"
                        }), d.jsx(Je, {
                            children: C.outAmount.toString()
                        })]
                    }), C.mintIn && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Token in"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.mintIn,
                                url: a
                            })
                        })]
                    }), C.mintOut && d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Token out"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.mintOut,
                                url: a
                            })
                        })]
                    })]
                }, $) : d.jsxs(_s, {
                    children: [d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Program ID"
                        }), d.jsx(Je, {
                            children: d.jsx(Rt, {
                                address: C.program,
                                url: a
                            })
                        })]
                    }), d.jsxs(Oe, {
                        children: [d.jsx(qe, {
                            children: "Data"
                        }), d.jsx(Je, {
                            children: C.discriminator
                        })]
                    })]
                }, $))
            }), d.jsx(lc, {}), c ? d.jsx(dc, {
                style: {
                    marginTop: "2rem"
                },
                children: c.message
            }) : l ? d.jsx(dc, {
                style: {
                    marginTop: "2rem"
                },
                children: MB
            }) : null, d.jsx(RB, {
                $useSmallMargins: !(!l && !c),
                title: "Your wallet",
                address: f,
                balance: g,
                isLoading: w || x,
                errMsg: w || l || c || !o ? void 0 : "Add funds on Solana to complete transaction."
            }), d.jsx(Qe, {
                style: {
                    marginTop: "1rem"
                },
                loading: y,
                disabled: m || w,
                onClick: E,
                children: n
            }), d.jsx(ot, {})]
        })
    };
let RB = z(gw).withConfig({
        displayName: "StyledWalletInfoCard",
        componentId: "sc-bb761902-0"
    })(["", ""], t => t.$useSmallMargins ? "margin-top: 0.5rem;" : "margin-top: 2rem;"),
    _s = z(Dh).withConfig({
        displayName: "InstructionRows",
        componentId: "sc-bb761902-1"
    })(["margin-top:0.5rem;border:1px solid var(--privy-color-foreground-4);border-radius:var(--privy-border-radius-sm);padding:0.5rem;"]),
    MB = "There was an error preparing your transaction. Your transaction request will likely fail.",
    DB = z.div.withConfig({
        displayName: "ImageContainer",
        componentId: "sc-bb761902-2"
    })(["display:flex;width:100%;justify-content:center;max-height:40px;> img{object-fit:contain;border-radius:var(--privy-border-radius-sm);}"]),
    qSe = () => d.jsxs(KSe, {
        children: [d.jsx(ZSe, {}), d.jsx(YSe, {})]
    });
const LB = ({
    transactionError: t,
    chainId: e,
    onClose: r,
    onRetry: n,
    network: i,
    connection: s,
    transactionHash: a
}) => {
    let {
        chains: o
    } = $e(), [c, l] = v.useState(!1), {
        errorCode: u,
        errorMessage: h
    } = ((p, g) => {
        if (g === "ethereum") return {
            errorCode: p.details ? ? p.message,
            errorMessage: p.shortMessage
        };
        let m = p.txSignature,
            y = (p == null ? void 0 : p.transactionMessage) || "Something went wrong.";
        if (Array.isArray(p.logs)) {
            let w = p.logs.find(x => /insufficient (lamports|funds)/gi.test(x));
            w && (y = w)
        }
        return {
            transactionHash: m,
            errorMessage: y
        }
    })(t, i), f = (({
        chains: p,
        chainId: g,
        network: m,
        connection: y,
        transactionHash: w
    }) => {
        var x, E;
        return m === "ethereum" ? ((E = (x = p.find(_ => _.id === g)) == null ? void 0 : x.blockExplorers) == null ? void 0 : E.default.url) ? ? "https://etherscan.io" : function(_, b) {
            return `https://explorer.solana.com/tx/${_}?cluster=${b}`
        }(w || "", Nh((y == null ? void 0 : y.rpcEndpoint) || ""))
    })({
        chains: o,
        chainId: e,
        network: i,
        connection: s,
        transactionHash: a
    });
    return d.jsxs(d.Fragment, {
        children: [d.jsx(Pe, {
            onClose: r
        }), d.jsxs(HSe, {
            children: [d.jsx(qSe, {}), d.jsx(VSe, {
                children: u
            }), d.jsx(GSe, {
                children: "Please try again."
            }), d.jsxs(uS, {
                children: [d.jsx(dS, {
                    children: "Error message"
                }), d.jsx(hS, {
                    $clickable: !1,
                    children: h
                })]
            }), a && d.jsxs(uS, {
                children: [d.jsx(dS, {
                    children: "Transaction hash"
                }), d.jsxs(QSe, {
                    children: ["Copy this hash to view details about the transaction on a", " ", d.jsx("u", {
                        children: d.jsx("a", {
                            href: f,
                            children: "block explorer"
                        })
                    }), "."]
                }), d.jsxs(hS, {
                    $clickable: !0,
                    onClick: async () => {
                        await navigator.clipboard.writeText(a), l(!0)
                    },
                    children: [a, d.jsx(tTe, {
                        clicked: c
                    })]
                })]
            }), d.jsx(JSe, {
                onClick: () => n({
                    resetNonce: !!a
                }),
                children: "Retry transaction"
            })]
        }), d.jsx(Wt, {})]
    })
};
let HSe = z.div.withConfig({
        displayName: "TransactionErrorScreenContainer",
        componentId: "sc-92716bea-0"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;"]),
    VSe = z.span.withConfig({
        displayName: "ErrorCode",
        componentId: "sc-92716bea-1"
    })(["color:var(--privy-color-foreground);text-align:center;font-size:1.125rem;font-weight:500;line-height:1.25rem;text-align:center;margin:10px;"]),
    GSe = z.span.withConfig({
        displayName: "Subtitle",
        componentId: "sc-92716bea-2"
    })(["margin-top:4px;margin-bottom:10px;color:var(--privy-color-foreground-3);text-align:center;font-size:0.875rem;font-style:normal;font-weight:400;line-height:20px;letter-spacing:-0.008px;"]),
    KSe = z.div.withConfig({
        displayName: "CircleContainer",
        componentId: "sc-92716bea-3"
    })(["position:relative;width:60px;height:60px;margin:10px;display:flex;justify-content:center;align-items:center;"]),
    YSe = z(Wy).withConfig({
        displayName: "StyledExclamationCircleIcon",
        componentId: "sc-92716bea-4"
    })(["position:absolute;width:35px;height:35px;color:var(--privy-color-error);"]),
    ZSe = z.div.withConfig({
        displayName: "StyledRedCircle",
        componentId: "sc-92716bea-5"
    })(["position:absolute;width:60px;height:60px;border-radius:50%;background-color:var(--privy-color-error);opacity:0.1;"]),
    JSe = z(Qe).withConfig({
        displayName: "RetryButton",
        componentId: "sc-92716bea-6"
    })(["&&{margin-top:24px;}transition:color 350ms ease,background-color 350ms ease;"]),
    dS = z.span.withConfig({
        displayName: "TextBoxTitle",
        componentId: "sc-92716bea-7"
    })(["width:100%;text-align:left;font-size:0.825rem;color:var(--privy-color-foreground);padding:4px;"]),
    uS = z.div.withConfig({
        displayName: "TextBoxContainer",
        componentId: "sc-92716bea-8"
    })(["width:100%;margin:5px;display:flex;flex-direction:column;justify-content:center;align-items:center;"]),
    QSe = z.text.withConfig({
        displayName: "HelperText",
        componentId: "sc-92716bea-9"
    })(["position:relative;width:100%;padding:5px;font-size:0.8rem;color:var(--privy-color-foreground-3);text-align:left;word-wrap:break-word;"]),
    hS = z.span.withConfig({
        displayName: "TextBox",
        componentId: "sc-92716bea-10"
    })(["position:relative;width:100%;background-color:var(--privy-color-background-2);padding:8px 12px;border-radius:10px;margin-top:5px;font-size:14px;color:var(--privy-color-foreground-3);text-align:left;word-wrap:break-word;", ""], t => t.$clickable && `cursor: pointer;
  transition: background-color 0.3s;
  padding-right: 45px;

  &:hover {
    background-color: var(--privy-color-foreground-4);
  }`),
    XSe = z(Z7e).withConfig({
        displayName: "StyledClipboardIcon",
        componentId: "sc-92716bea-11"
    })(["position:absolute;top:13px;right:13px;width:24px;height:24px;"]),
    eTe = z(DL).withConfig({
        displayName: "StyledClipboardCheckIcon",
        componentId: "sc-92716bea-12"
    })(["position:absolute;top:13px;right:13px;width:24px;height:24px;"]),
    tTe = ({
        clicked: t
    }) => d.jsx(t ? eTe : XSe, {});
const rTe = ({
        instruction: t,
        fees: e,
        transactionInfo: r,
        solPrice: n,
        rpcEndpoint: i
    }) => d.jsxs(Dh, {
        children: [(r == null ? void 0 : r.action) && d.jsxs(Oe, {
            children: [d.jsx(qe, {
                children: "Action"
            }), d.jsx(Je, {
                children: r.action
            })]
        }), (t == null ? void 0 : t.total) != null && d.jsxs(Oe, {
            children: [d.jsx(qe, {
                children: "Total"
            }), d.jsx(Je, {
                children: t.total
            })]
        }), !(t != null && t.total) && (t == null ? void 0 : t.amount) != null && d.jsxs(Oe, {
            children: [d.jsx(qe, {
                children: "Total"
            }), d.jsx(Je, {
                children: d.jsx(x$, {
                    quantities: [t.amount, e],
                    tokenPrice: n
                })
            })]
        }), d.jsxs(Oe, {
            children: [d.jsx(qe, {
                children: "Fees"
            }), d.jsx(Je, {
                children: d.jsx(x$, {
                    quantities: [e],
                    tokenPrice: n
                })
            })]
        }), (t == null ? void 0 : t.to) && d.jsxs(Oe, {
            children: [d.jsx(qe, {
                children: "To"
            }), d.jsx(Je, {
                children: d.jsx(x4, {
                    walletAddress: t.to,
                    rpcEndpoint: i,
                    network: "solana"
                })
            })]
        })]
    }),
    nTe = ({
        fees: t,
        onClose: e,
        receiptHeader: r,
        receiptDescription: n,
        transactionInfo: i,
        solPrice: s,
        rpcEndpoint: a,
        signOnly: o,
        instruction: c
    }) => d.jsxs(d.Fragment, {
        children: [d.jsx(Pe, {
            onClose: e
        }), d.jsx(Fi, {
            style: {
                marginBottom: "16px"
            },
            children: d.jsxs("div", {
                children: [d.jsx(TF, {
                    color: "var(--privy-color-success-light)"
                }), d.jsx(gc, {
                    height: 38,
                    width: 38,
                    strokeWidth: 2,
                    stroke: "var(--privy-color-success)"
                })]
            })
        }), d.jsx($r, {
            title: r ? ? `Transaction ${o?"signed":"complete"}!`,
            description: n ? ? "You're all set."
        }), d.jsx(rTe, {
            solPrice: s,
            instruction: c,
            fees: t,
            transactionInfo: i,
            rpcEndpoint: a
        }), d.jsx(lc, {}), d.jsx(iTe, {
            loading: !1,
            onClick: e,
            children: "Close"
        }), d.jsx(nr, {}), d.jsx(ot, {})]
    });
let iTe = z(Qe).withConfig({
    displayName: "SubmitButton",
    componentId: "sc-df6d4eec-0"
})(["&&{margin-top:24px;}transition:color 350ms ease,background-color 350ms ease;"]);
const sTe = {
        component: () => {
            var q, W, K, H, j, V, Y, X, ne, ae, ue, he, fe, de, ye, Be, ce, Ie;
            let {
                data: t,
                onUserCloseViaDialogOrKeybindRef: e,
                setModalData: r,
                navigate: n
            } = Ne(), {
                client: i,
                closePrivyModal: s,
                walletProxy: a,
                showFiatPrices: o
            } = $e(), c = Gt(), {
                user: l
            } = $t(), [u, h] = v.useState((q = t == null ? void 0 : t.sendSolanaTransaction) == null ? void 0 : q.transactionRequest), [f, p] = v.useState(), [g, m] = v.useState(), [y, w] = v.useState({
                value: 0 n,
                isLoading: !1
            }), [x, E] = v.useState(!1), [_, b] = v.useState(), [A, I] = v.useState(), T = (W = t == null ? void 0 : t.sendSolanaTransaction) == null ? void 0 : W.connection, C = (K = t == null ? void 0 : t.sendSolanaTransaction) == null ? void 0 : K.transactingWallet, $ = !!((H = t == null ? void 0 : t.sendSolanaTransaction) != null && H.signOnly), P = C != null && C.imported ? ry(l) : Rs(l), N = Nh((T == null ? void 0 : T.rpcEndpoint) || ""), {
                solPrice: R,
                isSolPriceLoading: D
            } = rF({
                enabled: o
            }), S = v.useMemo(() => {
                if (!f) return;
                let xe = f.spender,
                    ie = tl(f.fee),
                    Ee = tl(y.value, 3, !0),
                    ft = f.instructions.filter(Le => ["sol-transfer", "spl-transfer", "raydium-swap-base-input", "raydium-swap-base-output", "jupiter-swap-shared-accounts-route", "jupiter-swap-exact-out-route"].includes(Le.type)),
                    Ae = ft.at(0);
                return !Ae || ft.length > 1 ? {
                    fee: ie,
                    spender: xe,
                    balance: Ee
                } : Ae.type === "sol-transfer" ? {
                    fee: ie,
                    spender: xe,
                    balance: Ee,
                    total: tl(Ae.value)
                } : Ae.type === "spl-transfer" ? {
                    fee: ie,
                    spender: xe,
                    balance: Ee,
                    total: `${ri({amount:Ae.value,decimals:Ae.token.decimals})} ${Ae.token.symbol}`
                } : Ae.type === "raydium-swap-base-input" && Ae.tokenIn && Ae.tokenOut ? {
                    fee: ie,
                    spender: xe,
                    balance: Ee,
                    swap: `${`${ri({amount:Ae.amountIn,decimals:Ae.tokenIn.decimals})} ${Ae.tokenIn.symbol}`} → ${`${ri({amount:Ae.minimumAmountOut,decimals:Ae.tokenOut.decimals})} ${Ae.tokenOut.symbol}`}`
                } : Ae.type === "raydium-swap-base-output" && Ae.tokenIn && Ae.tokenOut ? {
                    fee: ie,
                    spender: xe,
                    balance: Ee,
                    swap: `${`${ri({amount:Ae.maxAmountIn,decimals:Ae.tokenIn.decimals})} ${Ae.tokenIn.symbol}`} → ${`${ri({amount:Ae.amountOut,decimals:Ae.tokenOut.decimals})} ${Ae.tokenOut.symbol}`}`
                } : Ae.type === "jupiter-swap-shared-accounts-route" && Ae.tokenIn && Ae.tokenOut ? {
                    fee: ie,
                    spender: xe,
                    balance: Ee,
                    swap: `${`${ri({amount:Ae.inAmount,decimals:Ae.tokenIn.decimals})} ${Ae.tokenIn.symbol}`} → ${`${ri({amount:Ae.quotedOutAmount,decimals:Ae.tokenOut.decimals})} ${Ae.tokenOut.symbol}`}`
                } : Ae.type === "jupiter-swap-exact-out-route" && Ae.tokenIn && Ae.tokenOut ? {
                    fee: ie,
                    spender: xe,
                    balance: Ee,
                    swap: `${`${ri({amount:Ae.quotedInAmount,decimals:Ae.tokenIn.decimals})} ${Ae.tokenIn.symbol}`} → ${`${ri({amount:Ae.outAmount,decimals:Ae.tokenOut.decimals})} ${Ae.tokenOut.symbol}`}`
                } : {
                    fee: ie,
                    spender: xe,
                    balance: Ee
                }
            }, [f, C == null ? void 0 : C.address, y]), O = v.useMemo(() => {
                let xe;
                if (!f || !o || !R || D) return;

                function ie(...Ae) {
                    return Qf(Ae.reduce((Le, Te) => Le + Te, 0 n), R ? ? 0)
                }(C == null ? void 0 : C.address) === f.spender && (xe = ie(f.fee));
                let Ee = ie(y.value),
                    ft = f.instructions.filter(Ae => Ae.type === "sol-transfer" || Ae.type === "spl-transfer").at(0);
                return !ft || f.instructions.length > 1 ? {
                    fee: xe,
                    balance: Ee
                } : ft.type === "sol-transfer" ? {
                    fee: xe,
                    balance: Ee,
                    total: ie(ft.value, (C == null ? void 0 : C.address) === f.spender ? f.fee : 0 n)
                } : ft.type === "spl-transfer" ? {
                    fee: xe,
                    balance: Ee,
                    total: `${ri({amount:ft.value,decimals:ft.token.decimals})} ${ft.token.symbol}`
                } : {
                    fee: xe,
                    balance: Ee
                }
            }, [f, o, R, D, C == null ? void 0 : C.address, y]);
            if (v.useEffect(() => {
                    (async function() {
                        if (u && T && i) try {
                            m(void 0);
                            let xe = await ECe({
                                tx: u,
                                connection: T,
                                client: i,
                                checkFunds: !$
                            });
                            p(xe)
                        } catch (xe) {
                            console.error("Failed to prepare transaction", xe), m(xe)
                        }
                    })()
                }, [u, T, i, $]), v.useEffect(() => {
                    (async function() {
                        if (!C || !T) return;
                        w({
                            value: y.value,
                            isLoading: !0
                        });
                        let xe = new cne({
                            name: "mainnet-beta",
                            rpcUrl: T.rpcEndpoint
                        });
                        w({
                            value: await xe.getBalance(C.address).catch(() => 0 n) ? ? 0 n,
                            isLoading: !1
                        })
                    })().catch(console.error)
                }, [f, T]), !(u && (t != null && t.sendSolanaTransaction) && C && T)) {
                let xe = Error("Invalid transaction request");
                return d.jsx(L0, {
                    error: xe,
                    onClick: () => {
                        var ie;
                        (ie = t == null ? void 0 : t.sendSolanaTransaction) == null || ie.onFailure(xe), s({
                            shouldCallAuthOnSuccess: !1
                        })
                    }
                })
            }
            let M = () => {
                var xe, ie;
                if (!x) return _ ? (xe = t == null ? void 0 : t.sendSolanaTransaction) == null || xe.onSuccess(_) : (ie = t == null ? void 0 : t.sendSolanaTransaction) == null || ie.onFailure(A ? ? g ? ? Error("User exited the modal before submitting the transaction")), s({
                    shouldCallAuthOnSuccess: !1
                })
            };
            e.current = M;
            let U = (X = (Y = (V = (j = t.sendSolanaTransaction) == null ? void 0 : j.uiOptions) == null ? void 0 : V.transactionInfo) == null ? void 0 : Y.contractInfo) != null && X.imgUrl ? d.jsx("img", {
                    src: t.sendSolanaTransaction.uiOptions.transactionInfo.contractInfo.imgUrl,
                    alt: t.sendSolanaTransaction.uiOptions.transactionInfo.contractInfo.imgAltText
                }) : null,
                k = !!(t.funding && t.funding.supportedOptions.length > 0),
                F = !(f != null && f.hasFunds) && k;
            if (_) {
                let xe = f == null ? void 0 : f.instructions.filter(Ee => Ee.type === "sol-transfer" || Ee.type === "spl-transfer"),
                    ie = (xe == null ? void 0 : xe.length) === 1 ? xe == null ? void 0 : xe.at(0) : void 0;
                return d.jsx(nTe, {
                    fees: _.fees,
                    onClose: M,
                    transactionInfo: (ne = t.sendSolanaTransaction) == null ? void 0 : ne.uiOptions.transactionInfo,
                    solPrice: R,
                    receiptHeader: (ae = t.sendSolanaTransaction) == null ? void 0 : ae.uiOptions.successHeader,
                    receiptDescription: (ue = t.sendSolanaTransaction) == null ? void 0 : ue.uiOptions.successDescription,
                    rpcEndpoint: T.rpcEndpoint,
                    signOnly: $,
                    instruction: (ie == null ? void 0 : ie.type) === "sol-transfer" ? {
                        to: ie.toAccount,
                        amount: ie.value
                    } : {
                        to: (ie == null ? void 0 : ie.toAccount) || (ie == null ? void 0 : ie.toAta),
                        total: S == null ? void 0 : S.total
                    }
                })
            }
            return A ? d.jsx(LB, {
                transactionError: A,
                connection: T,
                onClose: M,
                network: "solana",
                onRetry: async () => {
                    I(void 0);
                    let {
                        blockhash: xe
                    } = await T.getLatestBlockhash();
                    al(u) ? u.message.recentBlockhash = xe : u.recentBlockhash = xe, h(u)
                }
            }) : d.jsx(zSe, {
                img: U,
                title: ((de = (fe = (he = t.sendSolanaTransaction) == null ? void 0 : he.uiOptions) == null ? void 0 : fe.transactionInfo) == null ? void 0 : de.title) || "Confirm transaction",
                subtitle: ((Be = (ye = t.sendSolanaTransaction) == null ? void 0 : ye.uiOptions) == null ? void 0 : Be.description) || `${c.name} wants your permission to approve the following transaction.`,
                cta: F ? "Add funds" : ((Ie = (ce = t.sendSolanaTransaction) == null ? void 0 : ce.uiOptions) == null ? void 0 : Ie.buttonText) || "Approve",
                instructions: (f == null ? void 0 : f.instructions) ? ? [],
                network: N == "mainnet-beta" ? "Solana" : N,
                blockExplorerUrl: c.solanaClusters[N].blockExplorerUrl,
                total: o ? O == null ? void 0 : O.total : S == null ? void 0 : S.total,
                fee: o ? O == null ? void 0 : O.fee : S == null ? void 0 : S.fee,
                balance: o ? O == null ? void 0 : O.balance : S == null ? void 0 : S.balance,
                swap: S == null ? void 0 : S.swap,
                transactingWalletAddress: C.address,
                disabled: !(f != null && f.hasFunds) && !k,
                isSubmitting: x,
                isPreparing: !f || y.isLoading,
                isTokenPriceLoading: o && D,
                isMissingFunds: !(f != null && f.hasFunds),
                submitError: A ? ? void 0,
                parseError: g,
                onClick: F ? async () => {
                    if (C) {
                        if (!k) throw Error("Funding wallet is not enabled");
                        r({ ...t,
                            funding: { ...t.funding,
                                methodScreen: Ui
                            }
                        }), n(Ui)
                    }
                } : async () => {
                    try {
                        if (E(!0), x || !C || !a || !l || !P) return;
                        let xe = await t.sendSolanaTransaction.onConfirm();
                        b(xe)
                    } catch (xe) {
                        console.warn({
                            transaction: u,
                            error: xe
                        }), I(xe)
                    } finally {
                        E(!1)
                    }
                },
                onClose: M
            })
        }
    },
    aTe = ({
        privy: t,
        appConfig: e,
        getAccessToken: r,
        isHeadlessSigning: n,
        emitPrivyEvent: i,
        setModalData: s,
        openModal: a,
        walletProxy: o,
        user: c,
        signWithUserSigner: l,
        recoverEmbeddedWallet: u,
        connectedExternalWallet: h
    }, {
        transaction: f,
        connection: p,
        transactionOptions: g,
        fundWalletConfig: m,
        uiOptions: y,
        address: w,
        signOnly: x
    }) => new Promise(async (E, _) => {
        let {
            requesterAppId: b
        } = y || {}, A = "sendSolanaTransaction", I = w ? $s(c, w) : Sd(c);
        if (!I && w && h) try {
            {
                let $ = await h.sendTransaction(f, p, g),
                    P = await p.getParsedTransaction($, {
                        maxSupportedTransactionVersion: 0
                    }),
                    N = v$($, f, P ? ? null);
                return i(A, "onSuccess", {
                    response: N
                }), void E(N)
            }
        } catch ($) {
            throw i(A, "onError", ee.TRANSACTION_FAILURE), _($), $
        }
        if (!I) return i(A, "onError", ee.EMBEDDED_WALLET_NOT_FOUND), void _(new J("No wallet found for address", ee.EMBEDDED_WALLET_NOT_FOUND));
        if (!c) return i(A, "onError", ee.MUST_BE_AUTHENTICATED), void _(new J("User must be authenticated before signing with a Privy wallet", ee.MUST_BE_AUTHENTICATED));
        let T = fn(I);
        if (!await u({
                address: I.address
            }).catch(() => !1)) throw i(A, "onError", ee.EMBEDDED_WALLET_NOT_FOUND), new J(`Cannot sendSolanaTransaction before embedded wallet ${I.address} is connected`, ee.EMBEDDED_WALLET_NOT_FOUND);
        let C = async () => {
            let $ = await r();
            if (!$ || !o) throw i(A, "onError", ee.EMBEDDED_WALLET_NOT_FOUND), _(new J("Must have valid access token and Privy wallet to send transaction", ee.EMBEDDED_WALLET_NOT_FOUND)), new J("Must have valid access token and Privy wallet to send transaction", ee.EMBEDDED_WALLET_NOT_FOUND);
            try {
                let P, N;
                if (!await u({
                        address: I.address
                    })) throw i(A, "onError", ee.UNKNOWN_CONNECT_WALLET_ERROR), _(new J("Unable to connect to wallet", ee.UNKNOWN_CONNECT_WALLET_ERROR)), new J("Unable to connect to wallet", ee.UNKNOWN_CONNECT_WALLET_ERROR);
                if (n({
                        showWalletUIs: y == null ? void 0 : y.showWalletUIs
                    }) && !x) try {
                    if (!await GU(f, p)) throw i(A, "onError", ee.INSUFFICIENT_BALANCE), _(new J("Solana wallet has insufficient funds for this transaction.", ee.INSUFFICIENT_BALANCE)), new J("Solana wallet has insufficient funds for this transaction.", ee.INSUFFICIENT_BALANCE)
                } catch (S) {
                    throw console.error(S), i(A, "onError", ee.TRANSACTION_FAILURE), _(new J(S instanceof Error ? S.message : "Transaction failed.", ee.TRANSACTION_FAILURE)), new J(S instanceof Error ? S.message : "Transaction failed.", ee.TRANSACTION_FAILURE)
                }
                let {
                    entropyId: R,
                    entropyIdVerifier: D
                } = Sn(c);
                if (T) {
                    let S = al(f) ? On(f.message.serialize()) : f.serializeMessage(),
                        O = await Ni(t, l, {
                            chain_type: "solana",
                            method: "signMessage",
                            params: {
                                message: S.toString("base64"),
                                encoding: "base64"
                            },
                            wallet_id: I.id
                        });
                    if (!O.data || !("signature" in O.data)) throw Error("Failed to sign transaction");
                    f.addSignature(h1(f, I.address), On(O.data.signature, "base64")), P = f
                } else P = await D4({
                    accessToken: $,
                    tx: f,
                    walletProxy: o,
                    entropyId: R,
                    entropyIdVerifier: D,
                    transactingWalletAddress: I.address,
                    transactingWalletIndex: I.walletIndex ? ? 0
                }); {
                    let {
                        signature: S,
                        receipt: O
                    } = await async function({
                        tx: M,
                        connection: U,
                        transactionOptions: k
                    }) {
                        let F;
                        try {
                            let q = M.serialize();
                            F = await U.sendRawTransaction(q, k);
                            let W = await U.confirmTransaction(F);
                            if (W.value.err || W.value.err) {
                                let K = W.value.err || W.value.err;
                                throw typeof K == "string" ? Error(K) : K
                            }
                            return {
                                signature: F,
                                signedTransaction: M,
                                receipt: await U.getParsedTransaction(F, {
                                    maxSupportedTransactionVersion: 0
                                })
                            }
                        } catch (q) {
                            throw q.txSignature = F, q
                        }
                    }({
                        tx: P,
                        connection: p,
                        transactionOptions: g
                    });
                    N = v$(S, f, O), i("sendSolanaTransaction", "onSuccess", {
                        response: N
                    })
                }
                return E(N), N
            } catch (P) {
                throw i(A, "onError", ee.TRANSACTION_FAILURE), _(P), P
            }
        };
        if (n({
                showWalletUIs: y == null ? void 0 : y.showWalletUIs
            })) C();
        else {
            let {
                entropyId: $,
                entropyIdVerifier: P
            } = Sn(c, I), N = {
                recoveryMethod: I.recoveryMethod,
                connectingWalletAddress: I.address,
                entropyId: $,
                entropyIdVerifier: P,
                isUnifiedWallet: T,
                onCompleteNavigateTo: sTe,
                onFailure: D => {
                    i(A, "onError", ee.UNKNOWN_CONNECT_WALLET_ERROR), _(D)
                }
            }, R = wB(e) ? SSe({
                address: I.address,
                appConfig: e,
                methodScreen: Ui,
                fundWalletConfig: m,
                comingFromSendTransactionScreen: !0
            }) : void 0;
            s({
                connectWallet: N,
                sendSolanaTransaction: {
                    transactionRequest: f,
                    connection: p,
                    transactionOptions: g,
                    transactingWallet: I,
                    onConfirm: C,
                    onSuccess: D => {
                        i("sendSolanaTransaction", "onSuccess", {
                            response: D
                        }), E(D)
                    },
                    onFailure: D => {
                        i(A, "onError", ee.TRANSACTION_FAILURE), _(D)
                    },
                    uiOptions: y || {},
                    requesterAppId: b,
                    signOnly: x
                },
                funding: R
            }), a(Lc)
        }
    });

function oTe(t) {
    let e = Gt(),
        {
            getAccessToken: r,
            user: n
        } = mw(),
        {
            setModalData: i
        } = Ne(),
        {
            isHeadlessSigning: s,
            openModal: a,
            walletProxy: o,
            recoverEmbeddedWallet: c,
            privy: l,
            solanaWallets: u
        } = $e(),
        h = yc(),
        {
            signWithUserSigner: f
        } = G6();
    return Wd("sendSolanaTransaction", t), {
        sendTransaction: async ({
            transaction: p,
            connection: g,
            uiOptions: m,
            transactionOptions: y,
            fundWalletConfig: w,
            address: x
        }) => {
            let E = x ? u.find(_ => _.address === x && _.walletClientType !== "privy") : void 0;
            return await aTe({
                privy: l,
                appConfig: e,
                getAccessToken: r,
                isHeadlessSigning: s,
                emitPrivyEvent: h,
                setModalData: i,
                openModal: a,
                walletProxy: o,
                user: n,
                signWithUserSigner: f,
                recoverEmbeddedWallet: c,
                connectedExternalWallet: E
            }, {
                transaction: p,
                connection: g,
                transactionOptions: y,
                uiOptions: m,
                fundWalletConfig: w,
                address: x,
                signOnly: !1
            })
        }
    }
}
const cTe = z.img.withConfig({
    displayName: "StyledLogo",
    componentId: "sc-68c1b1ea-0"
})(["&&{height:", ";width:", ";border-radius:16px;margin-bottom:12px;}"], t => t.size === "sm" ? "65px" : "140px", t => t.size === "sm" ? "65px" : "140px");
let lTe = ({
    data: t
}) => {
    let e = r => typeof r == "object" && r !== null ? d.jsx(dTe, {
        children: Object.entries(r).map(([n, i]) => d.jsxs("li", {
            children: [d.jsxs("strong", {
                children: [n, ":"]
            }), " ", e(i)]
        }, n))
    }) : d.jsx("span", {
        children: String(r)
    });
    return d.jsx("div", {
        children: e(t)
    })
};
const W4 = z.div.withConfig({
    displayName: "Message",
    componentId: "sc-ccf49562-0"
})(["margin-top:1.5rem;background-color:var(--privy-color-background-2);border-radius:var(--privy-border-radius-md);padding:12px;text-align:left;max-height:310px;overflow:scroll;white-space:pre-wrap;width:100%;-ms-overflow-style:none;scrollbar-width:none;&::-webkit-scrollbar{display:none;}"]);
let dTe = z.ul.withConfig({
    displayName: "MessageList",
    componentId: "sc-ccf49562-1"
})(["margin-left:12px !important;white-space:nowrap;&:first-child{margin-left:0 !important;}strong{font-weight:500 !important;}"]);
const UB = ({
    data: t
}) => d.jsx(W4, {
    children: d.jsx(lTe, {
        data: t
    })
});
let uTe = t => {
        if (!Jn(t)) return t;
        try {
            let e = sz(t);
            return e.includes("�") ? t : e
        } catch {
            return t
        }
    },
    hTe = t => JSON.stringify(t, null, 2),
    fTe = t => {
        let {
            types: e,
            primaryType: r,
            ...n
        } = t.typedData;
        return d.jsxs(d.Fragment, {
            children: [d.jsx(UB, {
                data: n
            }), d.jsx(hw, {
                text: hTe(t.typedData),
                itemName: "full payload to clipboard"
            }), " "]
        })
    };
const z4 = {
    component: () => {
        let {
            authenticated: t
        } = $t(), {
            initializeWalletProxy: e,
            closePrivyModal: r
        } = $e(), {
            navigate: n,
            data: i,
            onUserCloseViaDialogOrKeybindRef: s
        } = Ne(), [a, o] = v.useState(!0), [c, l] = v.useState(""), [u, h] = v.useState(), [f, p] = v.useState(null), [g, m] = v.useState(!1), y = f !== null;
        v.useEffect(() => {
            t || n(Xn)
        }, [t]), v.useEffect(() => {
            e(XL).then(C => {
                o(!1), C || (l("An error has occurred, please try again."), h(new ni(new Hu(c, da.E32603_DEFAULT_INTERNAL_ERROR.eipCode))))
            })
        }, []);
        let {
            method: w,
            data: x,
            confirmAndSign: E,
            onSuccess: _,
            onFailure: b,
            uiOptions: A
        } = i.signMessage, I = {
            title: (A == null ? void 0 : A.title) || "Sign message",
            description: (A == null ? void 0 : A.description) || "Signing this message will not cost you any fees.",
            buttonText: (A == null ? void 0 : A.buttonText) || "Sign and continue"
        }, T = C => {
            C ? _(C) : b(u || new ni(new Hu("The user rejected the request.", da.E4001_USER_REJECTED_REQUEST.eipCode))), r({
                shouldCallAuthOnSuccess: !1
            }), setTimeout(() => {
                p(null), l(""), h(void 0)
            }, 200)
        };
        return s.current = () => {
            T(f)
        }, d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                onClose: () => T(f)
            }), d.jsx(er, {}), A != null && A.iconUrl && typeof A.iconUrl == "string" ? d.jsx(mTe, {
                children: d.jsx(cTe, {
                    size: "sm",
                    src: A.iconUrl,
                    alt: "app image"
                })
            }) : null, d.jsx(Pa, {
                children: I.title
            }), d.jsx($a, {
                children: I.description
            }), w === "personal_sign" && d.jsx(W4, {
                children: uTe(x)
            }), w === "eth_signTypedData_v4" && d.jsx(fTe, {
                typedData: x
            }), w === "solana_signMessage" && d.jsx(W4, {
                children: x
            }), d.jsx(yTe, {}), d.jsx(pTe, {
                $fail: !0,
                children: c
            }), d.jsx(qp, {
                disabled: g || y || a,
                loading: g,
                onClick: async () => {
                    m(!0), l("");
                    try {
                        let C = await E();
                        p(C), m(!1), setTimeout(() => {
                            T(C)
                        }, Ir)
                    } catch (C) {
                        console.error(C), l("An error has occurred, please try again."), h(new ni(new Hu(c, da.E32603_DEFAULT_INTERNAL_ERROR.eipCode))), m(!1)
                    }
                },
                children: g ? "Signing..." : y ? d.jsxs(gTe, {
                    children: [d.jsx(KF, {
                        style: {
                            height: "0.9rem",
                            width: "0.9rem"
                        },
                        strokeWidth: 2
                    }), " ", d.jsx("span", {
                        children: "Success"
                    })]
                }) : I.buttonText
            }), (A == null ? void 0 : A.isCancellable) && d.jsx(j0, {
                style: {
                    marginTop: "1rem"
                },
                onClick: () => T(null),
                isSubmitting: !1,
                children: "Not now"
            }), d.jsx(nr, {}), d.jsx(ot, {})]
        })
    }
};
let pTe = z.div.withConfig({
        displayName: "InputHelp",
        componentId: "sc-af56055-0"
    })(["line-height:20px;height:20px;font-size:13px;color:", ";display:flex;justify-content:flex-start;width:100%;margin-top:16px;margin-bottom:4px;"], t => t.$fail ? "var(--privy-color-error)" : "var(--privy-color-foreground-3)"),
    gTe = z.span.withConfig({
        displayName: "ContentWithIcon",
        componentId: "sc-af56055-1"
    })(["display:flex;align-items:center;gap:8px;"]),
    mTe = z.div.withConfig({
        displayName: "IconContainer",
        componentId: "sc-af56055-2"
    })(["display:flex;flex-direction:column;justify-content:center;align-items:center;width:100%;height:82px;"]),
    yTe = z.div.withConfig({
        displayName: "Grow",
        componentId: "sc-af56055-3"
    })(["flex-grow:1;"]);

function wTe(t) {
    let {
        isHeadlessSigning: e,
        walletProxy: r,
        initializeWalletProxy: n,
        recoverEmbeddedWallet: i,
        openModal: s,
        privy: a,
        solanaWallets: o
    } = $e(), {
        user: c,
        getAccessToken: l
    } = mw(), u = yc(), {
        setModalData: h
    } = Ne(), {
        signWithUserSigner: f
    } = G6();
    return Wd("signSolanaMessage", t), {
        signMessage: ({
            message: p,
            options: g
        }) => new Promise(async (m, y) => {
            var I;
            let w = g != null && g.address ? $s(c, g.address) : Sd(c);
            if (!w && (g != null && g.address)) {
                let T = o.find(C => C.address === g.address && C.walletClientType !== "privy");
                if (T) try {
                    let C = await T.signMessage(p);
                    u("signSolanaMessage", "onSuccess", {
                        signature: C
                    }), m(C)
                } catch (C) {
                    u("signSolanaMessage", "onError", ee.UNABLE_TO_SIGN), y(C)
                }
            }
            if (!w) return u("signSolanaMessage", "onError", ee.UNABLE_TO_SIGN), void y(Error("No embedded or connected wallet found for address."));
            if (!c) return u("signSolanaMessage", "onError", ee.MUST_BE_AUTHENTICATED), void y(Error("User must be authenticated before signing with a Privy wallet"));
            let {
                entropyId: x,
                entropyIdVerifier: E
            } = Sn(c, w), _ = fn(w), b = On(p).toString("base64");
            if (b.length < 1) return u("signMessage", "onError", ee.INVALID_MESSAGE), void y(Error("Message must be a non-empty string"));
            let A = async () => {
                let T;
                if (!c) throw Error("User must be authenticated before signing with a Privy wallet");
                let C = await l();
                if (!C) throw Error("User must be authenticated to use their embedded wallet.");
                let $ = r ? ? await n(15e3);
                if (!$) throw Error("Failed to initialize embedded wallet proxy.");
                if (!await i({
                        address: w.address
                    })) throw Error("Unable to connect to wallet");
                if (_) {
                    let P = await Ni(a, f, {
                        chain_type: "solana",
                        method: "signMessage",
                        params: {
                            message: b,
                            encoding: "base64"
                        },
                        wallet_id: w.id
                    });
                    if (!P.data || !("signature" in P.data)) throw Error("Failed to sign message");
                    T = P.data.signature
                } else {
                    let {
                        response: P
                    } = await $.rpc({
                        accessToken: C,
                        entropyId: x,
                        entropyIdVerifier: E,
                        chainType: "solana",
                        hdWalletIndex: w.walletIndex ? ? 0,
                        request: {
                            method: "signMessage",
                            params: {
                                message: b
                            }
                        }
                    });
                    T = P.data.signature
                }
                return T
            };
            if (e({
                    showWalletUIs: (I = g == null ? void 0 : g.uiOptions) == null ? void 0 : I.showWalletUIs
                })) try {
                let T = await A(),
                    C = new Uint8Array(On(T, "base64"));
                u("signSolanaMessage", "onSuccess", {
                    signature: C
                }), m(C)
            } catch (T) {
                y(T)
            } else h({
                signMessage: {
                    method: "solana_signMessage",
                    data: b,
                    confirmAndSign: A,
                    onSuccess: T => {
                        let C = new Uint8Array(On(T, "base64"));
                        u("signSolanaMessage", "onSuccess", {
                            signature: C
                        }), m(C)
                    },
                    onFailure: T => {
                        y(T)
                    },
                    uiOptions: g == null ? void 0 : g.uiOptions
                },
                connectWallet: {
                    recoveryMethod: w.recoveryMethod,
                    connectingWalletAddress: w.address,
                    entropyId: x,
                    entropyIdVerifier: E,
                    isUnifiedWallet: _,
                    onCompleteNavigateTo: z4,
                    onFailure: T => {
                        u("signSolanaMessage", "onError", ee.UNKNOWN_CONNECT_WALLET_ERROR), y(T)
                    }
                }
            }), s(Lc)
        })
    }
}
const z0 = () => {
        let {
            exportSolanaWallet: t,
            solanaWallets: e,
            walletProxy: r,
            recoverEmbeddedWallet: n,
            privy: i
        } = $e(), {
            sendTransaction: s
        } = oTe(), {
            signMessage: a
        } = wTe(), {
            create: o
        } = yB(), {
            signWithUserSigner: c
        } = G6(), {
            user: l,
            getAccessToken: u
        } = mw(), {
            ready: h
        } = gl(), f = v.useMemo(() => {
            if (!r) return e;
            let p = [...fO(l), ry(l)].filter(g => !!g).map(g => ({
                type: "solana",
                imported: g.imported,
                address: g.address,
                connectedAt: Date.now(),
                walletClientType: "privy",
                connectorType: "embedded",
                walletIndex: g.walletIndex ? ? void 0,
                meta: {
                    name: "Privy Wallet",
                    icon: void 0,
                    id: "io.privy.solana.wallet"
                },
                linked: !0,
                fund() {
                    throw new J("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")
                },
                unlink: () => {
                    throw new J("Cannot unlink an embedded Solana wallet")
                },
                async getProvider() {
                    return new _$e(r, g.address, this.signMessage)
                },
                signMessage: async m => await a({
                    message: m,
                    options: {
                        address: g.address,
                        uiOptions: {
                            showWalletUIs: !1
                        }
                    }
                }),
                async sendTransaction(m, y, w) {
                    let {
                        signature: x
                    } = await s({
                        transaction: m,
                        connection: y,
                        transactionOptions: w,
                        address: g.address
                    });
                    return x
                },
                async signTransaction(m) {
                    let y = await u();
                    if (!y || !r) throw new J("Must have valid access token and Privy wallet to send transaction", ee.MUST_BE_AUTHENTICATED);
                    if (!await n({
                            address: g.address
                        }).catch(() => !1)) throw new J("Wallet couldn't be connected", ee.UNKNOWN_CONNECT_WALLET_ERROR);
                    let {
                        entropyId: w,
                        entropyIdVerifier: x
                    } = Sn(l, g);
                    if (fn(g)) {
                        let E = al(m) ? On(m.message.serialize()) : m.serializeMessage(),
                            _ = await Ni(i, c, {
                                chain_type: "solana",
                                method: "signMessage",
                                params: {
                                    message: E.toString("base64"),
                                    encoding: "base64"
                                },
                                wallet_id: g.id
                            });
                        if (_.data && "signature" in _.data) return m.addSignature(h1(m, g.address), On(_.data.signature, "base64")), m;
                        throw Error("Failed to sign transaction")
                    }
                    return await D4({
                        tx: m,
                        accessToken: y,
                        walletProxy: r,
                        entropyId: w,
                        entropyIdVerifier: x,
                        transactingWalletAddress: g.address,
                        transactingWalletIndex: g.walletIndex ? ? 0
                    })
                },
                async signAllTransactions(m) {
                    let y = await u();
                    if (!y || !r) throw new J("Must have valid access token and Privy wallet to send transaction", ee.MUST_BE_AUTHENTICATED);
                    if (!await n({
                            address: g.address
                        }).catch(() => !1)) throw new J("Wallet couldn't be connected", ee.UNKNOWN_CONNECT_WALLET_ERROR);
                    let {
                        entropyId: w,
                        entropyIdVerifier: x
                    } = Sn(l, g);
                    if (fn(g)) return await Promise.all(m.map(async E => {
                        let _ = al(E) ? On(E.message.serialize()) : E.serializeMessage(),
                            b = await Ni(i, c, {
                                chain_type: "solana",
                                method: "signMessage",
                                params: {
                                    message: _.toString("base64"),
                                    encoding: "base64"
                                },
                                wallet_id: g.id
                            });
                        if (b.data && "signature" in b.data) return E.addSignature(h1(E, g.address), On(b.data.signature, "base64")), E;
                        throw Error("Failed to sign transaction")
                    }));
                    for (let E of m) await D4({
                        tx: E,
                        accessToken: y,
                        walletProxy: r,
                        entropyId: w,
                        entropyIdVerifier: x,
                        transactingWalletAddress: g.address,
                        transactingWalletIndex: g.walletIndex ? ? 0
                    });
                    return m
                },
                loginOrLink: async () => {
                    throw new J("Cannot login or link with an embedded Solana wallet")
                },
                disconnect: () => {},
                isConnected: async () => !0
            }));
            return e.concat(p)
        }, [l, r, u, e]);
        return {
            ready: !(!h || !r),
            createWallet: async p => {
                p && "target" in p && p && (p = void 0);
                let {
                    account: g
                } = await o({
                    chainType: "solana",
                    options: p
                });
                return g
            },
            exportWallet: t,
            wallets: f
        }
    },
    E1 = {
        component: () => {
            var P, N, R;
            let {
                wallets: t
            } = gl(), {
                wallets: e
            } = z0(), {
                data: r,
                setModalData: n,
                navigate: i,
                lastScreen: s
            } = Ne(), {
                rpcConfig: a,
                appId: o,
                createAnalyticsEvent: c,
                closePrivyModal: l
            } = $e(), u = Gt(), [h, f] = v.useState(void 0), [p, g] = v.useState(!1), m = Rh(), y = r == null ? void 0 : r.funding, {
                reloadBalance: w
            } = mB({
                rpcConfig: a,
                appId: o,
                address: y.chainType === "ethereum" ? y.address : void 0,
                chain: y.chainType === "ethereum" ? y.chain : void 0
            }), x = y.chainType === "solana", E = x ? y.isUSDC ? "USDC" : "SOL" : y.erc20Address ? (P = y.erc20ContractInfo) == null ? void 0 : P.symbol : y.chain.nativeCurrency.symbol, _ = x ? e.find(({
                address: D
            }) => D === y.address) : t.find(({
                address: D
            }) => Yn(D) === Yn(y.address));
            if (!y) return n({
                errorModalData: {
                    error: Error("Couldn't find funding config"),
                    previousScreen: s || Ui
                },
                funding: r == null ? void 0 : r.funding,
                sendTransaction: r == null ? void 0 : r.sendTransaction
            }), i(Sr), d.jsx(d.Fragment, {});
            v.useEffect(() => {
                let D = x ? async function() {
                        if (y.chainType !== "solana") return;
                        let O = m(W0);
                        O ? (y.isUSDC ? O.getTokenBalance({
                            address: y.address,
                            cluster: y.cluster,
                            mintAddress: Vg[y.cluster.name]
                        }).then(({
                            amount: M
                        }) => M) : O.getBalance({
                            address: y.address,
                            cluster: y.cluster
                        })).then(M => {
                            let U = BigInt(M);
                            h && U > h && (g(!0), c({
                                eventName: Na,
                                payload: {
                                    provider: "manual",
                                    status: "success",
                                    chainType: "solana",
                                    address: _ == null ? void 0 : _.address,
                                    value: y.isUSDC ? Nn(U - h, 6) : Nn(U - h, 9),
                                    token: y.isUSDC ? "USDC" : "SOL"
                                }
                            })), f(U)
                        }) : console.warn("Unable to load solana plugin, skipping balance")
                    } : async function() {
                        y.chainType === "ethereum" && (async () => {
                            if (!y.erc20Address) return await w() ? ? BigInt(0); {
                                let {
                                    balance: O
                                } = await L8({
                                    chain: y.chain,
                                    address: y.address,
                                    erc20Address: y.erc20Address,
                                    rpcConfig: a,
                                    appId: o
                                });
                                return O
                            }
                        })().then(O => {
                            var M, U;
                            h && O > h && (g(!0), c({
                                eventName: Na,
                                payload: {
                                    provider: "manual",
                                    status: "success",
                                    chainType: "ethereum",
                                    address: _ == null ? void 0 : _.address,
                                    chainId: y.chain.id,
                                    value: Nn(O - h, ((M = y.erc20ContractInfo) == null ? void 0 : M.decimals) ? ? 18),
                                    token: ((U = y.erc20ContractInfo) == null ? void 0 : U.symbol) ? ? y.erc20Address ? ? "ETH"
                                }
                            })), f(O)
                        }).catch(() => f(void 0))
                    },
                    S = setInterval(D, 2e3);
                return D(), () => clearInterval(S)
            }, [h]);
            let b = v.useMemo(() => h !== void 0 && h >= parseFloat(y.amount), [h, y.amount]),
                A = v.useMemo(() => {
                    var D;
                    return h == null ? "" : y.isUSDC ? ri({
                        amount: h,
                        decimals: 6
                    }) : x ? tl(h, 3, !0, !0) : ((D = y.erc20ContractInfo) == null ? void 0 : D.decimals) != null ? ri({
                        amount: h,
                        decimals: y.erc20ContractInfo.decimals
                    }) : lne({
                        wei: h
                    })
                }, [h, x, y]),
                I = y.chainType === "ethereum" ? y.chain.name : vTe[y.cluster.name],
                T = v.useMemo(() => {
                    var D, S;
                    return ((D = y.uiConfig) == null ? void 0 : D.receiveFundsTitle) === "" ? null : d.jsx(Pa, {
                        children: ((S = y.uiConfig) == null ? void 0 : S.receiveFundsTitle) ? ? `Receive ${y.amount} ${E??""}`.trim()
                    })
                }, [(N = y.uiConfig) == null ? void 0 : N.receiveFundsTitle, y.amount, E]),
                C = v.useMemo(() => {
                    var D, S;
                    return ((D = y.uiConfig) == null ? void 0 : D.receiveFundsSubtitle) === "" ? null : d.jsx($a, {
                        children: ((S = y.uiConfig) == null ? void 0 : S.receiveFundsSubtitle) ? ? `Scan this code or copy your wallet address to receive funds on ${I}.`
                    })
                }, [(R = y.uiConfig) == null ? void 0 : R.receiveFundsSubtitle, I]),
                $ = y.chainType === "solana" && y.isUSDC && Vg[y.cluster.name] ? `?spl-token=${Vg[y.cluster.name]}` : "";
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Bi, {}), T, C, d.jsxs(Qy, {
                    style: {
                        gap: "1rem",
                        margin: T || C ? "1rem 0" : "0"
                    },
                    children: [d.jsx(U0, {
                        url: `${y.chainType}:${y.address}${$}`,
                        size: 200,
                        squareLogoElement: bTe
                    }), d.jsxs(fB, {
                        theme: u.appearance.palette.colorScheme,
                        children: ["Make sure to send funds on ", I, "."]
                    }), d.jsx(gw, {
                        title: "Your wallet",
                        errMsg: void 0,
                        showIcon: !0,
                        isLoading: !y || h === void 0,
                        isPulsing: !b,
                        balance: `${A} ${E}`,
                        address: y.address,
                        statusColor: b ? "green" : "gray"
                    }), p && d.jsx(Qe, {
                        onClick: () => l({
                            shouldCallAuthOnSuccess: !1,
                            isSuccess: !0
                        }),
                        children: "Continue"
                    })]
                }), d.jsx(ot, {})]
            })
        }
    };
let bTe = ({ ...t
    }) => d.jsx(EU, {
        color: "black",
        ...t
    }),
    vTe = {
        devnet: "Devnet",
        "mainnet-beta": "Solana",
        testnet: "Testnet"
    },
    xTe = [{
        constant: !0,
        inputs: [{
            name: "_owner",
            type: "address"
        }],
        name: "balanceOf",
        outputs: [{
            name: "balance",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }],
    ETe = z.div.withConfig({
        displayName: "Container",
        componentId: "sc-b3a607dd-0"
    })(["display:flex;flex-direction:column;min-height:72px;"]);
var _Te = ({
    onBack: t,
    details: e
}) => d.jsxs(ETe, {
    children: [d.jsx(Pe, {
        backFn: t
    }), d.jsx(UB, {
        data: e
    }), d.jsx(ot, {})]
});
let CTe = ({
    gasUsed: t,
    effectiveGasPrice: e
}) => {
    if (t && e) try {
        return cn(t * e)
    } catch {
        return
    }
};
const ATe = ({
    txn: t,
    receipt: e,
    transactionInfo: r,
    onClose: n,
    tokenPrice: i,
    tokenSymbol: s,
    receiptHeader: a,
    receiptDescription: o
}) => d.jsxs(d.Fragment, {
    children: [d.jsx(Pe, {
        onClose: n
    }), d.jsx(I8, {
        title: a ? ? "Transaction complete!",
        description: o ? ? "You're all set."
    }), d.jsx(tF, {
        tokenPrice: i,
        from: e.from,
        to: e.to,
        gas: CTe(e),
        txn: t,
        transactionInfo: r,
        tokenSymbol: s
    }), d.jsx(lc, {}), d.jsx(kTe, {
        loading: !1,
        onClick: n,
        children: "All Done"
    }), d.jsx(nr, {}), d.jsx(ot, {})]
});
let kTe = z(Qe).withConfig({
    displayName: "SubmitButton",
    componentId: "sc-f70d0f7a-0"
})(["&&{margin-top:24px;}transition:color 350ms ease,background-color 350ms ease;"]);
const ITe = [{
        constant: !1,
        inputs: [{
            name: "_salt",
            type: "bytes32"
        }, {
            name: "_initializer",
            type: "bytes"
        }],
        name: "deployAccount",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }],
    $Te = [{
        name: "from",
        type: "address"
    }, {
        name: "param2",
        type: "address"
    }, {
        name: "param3",
        type: "bytes"
    }, {
        name: "param4",
        type: "tuple",
        components: []
    }, {
        type: "tuple",
        components: [{
            name: "param5",
            type: "address"
        }, {
            name: "param6",
            type: "uint256"
        }, {
            name: "param7",
            type: "uint256"
        }, {
            name: "encodedInitData",
            type: "bytes"
        }]
    }],
    STe = [{
        constant: !1,
        inputs: [{
            name: "spender",
            type: "address"
        }, {
            name: "value",
            type: "uint256"
        }],
        name: "approve",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }],
    TTe = [{
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "mint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "mint",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }],
        name: "mint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }],
        name: "mint",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "data",
            type: "bytes"
        }],
        name: "mint",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "data",
            type: "bytes"
        }],
        name: "mint",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256[]",
            name: "tokenIds",
            type: "uint256[]"
        }, {
            internalType: "uint256[]",
            name: "quantities",
            type: "uint256[]"
        }, {
            internalType: "bytes",
            name: "data",
            type: "bytes"
        }],
        name: "mintBatch",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256[]",
            name: "tokenIds",
            type: "uint256[]"
        }, {
            internalType: "uint256[]",
            name: "quantities",
            type: "uint256[]"
        }, {
            internalType: "bytes",
            name: "data",
            type: "bytes"
        }],
        name: "mintBatch",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
        }],
        name: "mint",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "quantity",
            type: "uint256"
        }],
        name: "mint",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }],
        name: "safeMint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }],
        name: "safeMint",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "string",
            name: "uri",
            type: "string"
        }],
        name: "safeMint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "string",
            name: "uri",
            type: "string"
        }],
        name: "safeMint",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "safeMint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "safeMint",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }, {
            internalType: "string",
            name: "uri",
            type: "string"
        }],
        name: "safeMint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }, {
            internalType: "string",
            name: "uri",
            type: "string"
        }],
        name: "safeMint",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "batchMint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "batchMint",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }],
    PTe = [{
        constant: !1,
        inputs: [{
            name: "_from",
            type: "address"
        }, {
            name: "_to",
            type: "address"
        }, {
            name: "_tokenId",
            type: "uint256"
        }],
        name: "safeTransferFrom",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }],
    NTe = [{
        constant: !1,
        inputs: [{
            name: "_operator",
            type: "address"
        }, {
            name: "_approved",
            type: "bool"
        }],
        name: "setApprovalForAll",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }],
    OTe = [{
        constant: !1,
        inputs: [{
            name: "_from",
            type: "address"
        }, {
            name: "_to",
            type: "address"
        }, {
            name: "_tokenId",
            type: "uint256"
        }],
        name: "transferFrom",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }],
    jTe = [{
        constant: !1,
        inputs: [{
            name: "_from",
            type: "address"
        }, {
            name: "_to",
            type: "address"
        }, {
            name: "_tokenIds",
            type: "uint256[]"
        }, {
            name: "_amounts",
            type: "uint256[]"
        }, {
            name: "_data",
            type: "bytes"
        }],
        name: "safeBatchTransferFrom",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }],
    RTe = [{
        constant: !1,
        inputs: [{
            name: "_from",
            type: "address"
        }, {
            name: "_to",
            type: "address"
        }, {
            name: "_tokenId",
            type: "uint256"
        }, {
            name: "_amount",
            type: "uint256"
        }, {
            name: "_data",
            type: "bytes"
        }],
        name: "safeTransferFrom",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }],
    FB = (t, e) => {
        let r = So(STe, t);
        if (r) return {
            action: "approve",
            functionName: "approve",
            isErc20Ish: !0,
            isNFTIsh: !1,
            spender: r.args[0],
            amount: r.args[1]
        };
        let n = So(L4, t);
        if (n) return {
            action: "transfer",
            functionName: "transfer",
            isErc20Ish: !0,
            isNFTIsh: !1,
            transferTo: n.args[0],
            amount: n.args[1]
        };
        if (!e) return {
            action: "transaction",
            functionName: "",
            isErc20Ish: !1,
            isNFTIsh: !1
        };
        let i = So(ITe, t);
        if (i && typeof i.args[1] == "string") {
            let h = MTe(i.args[1]);
            if (h && h[4].encodedInitData) return FB(h[4].encodedInitData, e)
        }
        let s = So(NTe, t);
        if (s) return {
            action: "approve",
            functionName: "setApprovalForAll",
            isNFTIsh: !0,
            isErc20Ish: !1,
            operator: s.args[0],
            approved: s.args[1]
        };
        let a = So(OTe, t);
        if (a) return {
            action: "transfer",
            functionName: "transferFrom",
            isNFTIsh: !0,
            isErc20Ish: !1,
            transferFrom: a.args[0],
            transferTo: a.args[1],
            tokenId: a.args[2]
        };
        let o = So(PTe, t);
        if (o) return {
            action: "transfer",
            functionName: "safeTransferFrom",
            isNFTIsh: !0,
            isErc20Ish: !1,
            transferFrom: o.args[0],
            transferTo: o.args[1],
            tokenId: o.args[2]
        };
        let c = So(RTe, t);
        if (c) return {
            action: "transfer",
            functionName: "safeTransferFrom",
            isNFTIsh: !0,
            isErc20Ish: !1,
            transferFrom: c.args[0],
            transferTo: c.args[1],
            tokenId: c.args[2],
            amount: c.args[3]
        };
        let l = So(jTe, t);
        if (l) return {
            action: "batch transfer",
            functionName: "safeBatchTransferFrom",
            isNFTIsh: !0,
            isErc20Ish: !1,
            transferFrom: l.args[0],
            transferTo: l.args[1],
            tokenIds: l.args[2],
            amounts: l.args[3]
        };
        let u = So(TTe, t);
        return u ? {
            action: "mint",
            functionName: u.functionName,
            isNFTIsh: !0,
            isErc20Ish: !1,
            args: u.args
        } : {
            action: "transaction",
            isErc20Ish: !1,
            isNFTIsh: !1
        }
    };
let So = (t, e) => {
        try {
            let r = ET({
                abi: t,
                data: e
            });
            return {
                functionName: r.functionName,
                args: r.args || []
            }
        } catch {
            return null
        }
    },
    MTe = t => {
        try {
            if (typeof t == "string") return hh($Te, `0x${t.slice(10)}`)
        } catch {
            return null
        }
    },
    Mv = t => `${parseFloat(t).toFixed(2)}`;
const DTe = (t, e, r, n) => {
    let [i, s] = v.useState(null), {
        getAccessToken: a
    } = $t(), {
        walletProxy: o
    } = $e();
    return v.useEffect(() => {
        i && s(null), (async () => {
            if (!await a() || !o || !e) return null;
            let c = [],
                l = !0,
                u = await f1(t, r, e, n).catch(h => (h.message && h.message.includes("Insufficient balance for transaction") || h.details && h.details.includes("insufficient funds") ? l = !1 : c.push(h), t));
            return {
                tx: u,
                totalGasEstimate: u.gas,
                hasFunds: l,
                errors: c
            }
        })().then(s)
    }, [t]), i
};
let fS = new ni(new Hu("There was an issue preparing your transaction", da.E32603_DEFAULT_INTERNAL_ERROR.eipCode)),
    pS = (t, e) => t != null && t.sendTransaction ? "transactionRequest" in t.sendTransaction ? t.sendTransaction.transactionRequest : t.sendTransaction.transactionRequests[e] : void 0;
const BB = {
    component: () => {
        var mt, ur, Vr, pt, Un, ei, ti, Fn, L, B, Q, G, re, se, me, ve, Ze, kt;
        let {
            data: t,
            onUserCloseViaDialogOrKeybindRef: e,
            setModalData: r,
            navigate: n
        } = Ne(), {
            rpcConfig: i,
            chains: s,
            closePrivyModal: a,
            walletProxy: o,
            showFiatPrices: c
        } = $e(), {
            getAccessToken: l,
            user: u
        } = $t(), h = Gt(), [f, p] = v.useState(0), [g, m] = v.useState(0), [y, w] = v.useState(pS(t, f)), [x, E] = v.useState(null), [_, b] = v.useState(), [A, I] = v.useState(!1), [T, C] = v.useState(null), [$, P] = v.useState(null), [N, R] = v.useState(null), [D, S] = v.useState(void 0), [O, M] = v.useState(void 0), [U, k] = v.useState(!1), [F, q] = v.useState(!1), [W, K] = v.useState([]), [H, j] = v.useState([]), [V, Y] = v.useState("uninitiated"), [X, ne] = v.useState(void 0);
        if (!y || !(t != null && t.sendTransaction) || !(t != null && t.sendTransaction)) return d.jsx(L0, {
            error: Error("Invalid transaction request"),
            onClick: () => {
                var Re;
                (Re = t == null ? void 0 : t.sendTransaction) == null || Re.onFailure(fS), a({
                    shouldCallAuthOnSuccess: !1
                })
            }
        });
        let {
            transactingWalletAddress: ae
        } = t.sendTransaction, ue = v.useMemo(() => s.find(Re => Number(Re.id) === Number(y.chainId)), [y.chainId]), he = (ue == null ? void 0 : ue.nativeCurrency.symbol) ? ? "ETH", fe = v.useMemo(() => FB(y.data, !!h.embeddedWallets.extendedCalldataDecoding), [y.data]), {
            action: de,
            isErc20Ish: ye,
            isNFTIsh: Be,
            functionName: ce
        } = fe, {
            toAddress: Ie,
            tokenAddress: xe
        } = v.useMemo(() => ({
            toAddress: fe.isErc20Ish ? fe.transferTo : y.to ? ? void 0,
            tokenAddress: fe.isErc20Ish ? y.to : void 0
        }), [fe]);
        v.useEffect(() => {
            y.to && ue && ye && bB({
                address: y.to,
                chain: ue,
                rpcConfig: h.rpcConfig,
                privyAppId: h.id
            }).then(E).catch(console.error)
        }, [y.to, ue]);
        let {
            tokenPrice: ie,
            isTokenPriceLoading: Ee
        } = Oh(y.chainId), {
            balance: ft
        } = mB({
            rpcConfig: h.rpcConfig,
            appId: h.id,
            address: ae,
            chain: ue
        }), Ae = function({
            rpcConfig: Re,
            appId: ct,
            address: it,
            chain: lt,
            tokenInfo: Se
        }) {
            let {
                chains: yt
            } = $e(), [It, Mt] = v.useState(null), [jt, sr] = v.useState(!1), bt = v.useMemo(() => {
                let Ge = lt || yt[0];
                if (Ge) return nc({
                    chain: lt,
                    transport: rc(Ute(Ge, Re, ct))
                })
            }, [lt, Re, ct]), St = v.useCallback(async () => {
                if (it && bt && Se.address) try {
                    return sr(!0), await bt.readContract({
                        address: Se.address,
                        abi: xTe,
                        functionName: "balanceOf",
                        args: [it]
                    })
                } catch (Ge) {
                    console.error(Ge)
                } finally {
                    sr(!1)
                }
            }, [bt, it, Se == null ? void 0 : Se.address, lt]);
            return v.useEffect(() => {
                St().then(Ge => Ge != null && Mt(Ge))
            }, [St]), {
                balance: It,
                isLoading: jt && It == null,
                formattedBalance: ri({
                    amount: It ? ? BigInt(0),
                    decimals: Se.decimals
                })
            }
        }({
            rpcConfig: h.rpcConfig,
            appId: h.id,
            address: ae,
            tokenInfo: {
                address: xe || "",
                decimals: (x == null ? void 0 : x.decimals) ? ? 18
            },
            chain: ue
        }), Le = v.useMemo(() => oh(Number(y.chainId), s, i, {
            appId: h.id
        }), [y.chainId, i]), Te = DTe(y, ae, Le, (mt = t == null ? void 0 : t.sendTransaction) == null ? void 0 : mt.prepareTransactionRequest);
        v.useEffect(() => {
            w(pS(t, f))
        }, [f]), v.useEffect(() => {
            var Re;
            (Re = t.sendTransaction) != null && Re.getIsSponsored ? t.sendTransaction.getIsSponsored().then(b).catch(console.error) : b(!1)
        }, [t.sendTransaction.getIsSponsored]);
        let Ue = () => {
            var Re, ct, it;
            if (!A) return T ? (Re = t == null ? void 0 : t.sendTransaction) == null || Re.onSuccess({
                hash: T
            }) : N || Te != null && Te.errors[0] ? (ct = t == null ? void 0 : t.sendTransaction) == null || ct.onFailure(N ? ? (Te == null ? void 0 : Te.errors[0]) ? ? fS) : (it = t == null ? void 0 : t.sendTransaction) == null || it.onFailure(new ni(new Hu("The user rejected the request", da.E4001_USER_REJECTED_REQUEST.eipCode))), a({
                shouldCallAuthOnSuccess: !1
            })
        };
        e.current = Ue;
        let De = !!(t.funding && t.funding.supportedOptions.length > 0),
            We = ba(BigInt((Te == null ? void 0 : Te.totalGasEstimate) ? ? 0 n), he),
            dt = c && ie ? td(BigInt((Te == null ? void 0 : Te.totalGasEstimate) ? ? 0 n), ie) : void 0,
            He = ba(ft ? ? 0 n, he, void 0, !0),
            ut = c && ie ? td(ft ? ? 0 n, ie) : void 0,
            Ye = x && !Ae.isLoading && ye && de !== "approve" ? `${Ae.formattedBalance} ${x.symbol}` : void 0,
            we = (pt = (Vr = (ur = t.sendTransaction) == null ? void 0 : ur.uiOptions) == null ? void 0 : Vr.transactionInfo) == null ? void 0 : pt.title;
        we || (we = de === "approve" ? ye ? "Confirm address" : "Confirm action" : `Approve ${de}`);
        let vt = v.useMemo(() => {
                var Re, ct, it, lt, Se, yt, It, Mt;
                if ((ct = (Re = t.sendTransaction) == null ? void 0 : Re.uiOptions) != null && ct.description) return (lt = (it = t.sendTransaction) == null ? void 0 : it.uiOptions) == null ? void 0 : lt.description;
                if (de === "approve" && ce === "setApprovalForAll" && fe.approved) {
                    let jt = d.jsx(Rt, {
                        address: fe.operator || "",
                        url: (yt = (Se = ue == null ? void 0 : ue.blockExplorers) == null ? void 0 : Se.default) == null ? void 0 : yt.url
                    });
                    return d.jsxs(d.Fragment, {
                        children: [h.name, " would like your permission for ", jt, " to transfer tokens on your behalf."]
                    })
                }
                if (de === "approve" && ce === "setApprovalForAll" && !fe.approved) {
                    let jt = d.jsx(Rt, {
                        address: fe.operator || "",
                        url: (Mt = (It = ue == null ? void 0 : ue.blockExplorers) == null ? void 0 : It.default) == null ? void 0 : Mt.url
                    });
                    return d.jsxs(d.Fragment, {
                        children: [h.name, " would like your permission to revoke permissions of ", jt, " from transferring tokens on your behalf."]
                    })
                }
                return ye && de === "approve" || ye && de === "approve" ? `${h.name} would like your permission for ${Yn(fe.spender)} to spend tokens on your behalf.` : `${h.name} wants your permission to approve the following transaction.`
            }, [h.name, ye, fe, (Un = t.sendSolanaTransaction) == null ? void 0 : Un.uiOptions.description, ce]),
            Lt = (L = (Fn = (ti = (ei = t.sendTransaction) == null ? void 0 : ei.uiOptions) == null ? void 0 : ti.transactionInfo) == null ? void 0 : Fn.contractInfo) != null && L.imgUrl ? d.jsx("img", {
                src: t.sendTransaction.uiOptions.transactionInfo.contractInfo.imgUrl,
                alt: t.sendTransaction.uiOptions.transactionInfo.contractInfo.imgAltText
            }) : null,
            _t = !(!Te || Te.errors[0] || Te.hasFunds || _ !== !1),
            tr = _t && De,
            dr = tr ? "Add funds" : ((Q = (B = t.sendTransaction) == null ? void 0 : B.uiOptions) == null ? void 0 : Q.buttonText) || (f < g ? "Continue" : "Approve"),
            Yt = Re => {
                if (!Re) throw Error("Transaction scan failed");
                if (Re.validation.status === "Success" && (Re.validation.result_type === "Benign" ? M("safe") : Re.validation.result_type === "Warning" ? M("warn") : Re.validation.result_type === "Malicious" && (M("error"), q(!0))), Re.simulation.status !== "Success") throw Error("Simulation failed"); {
                    S(Re.simulation.params);
                    let {
                        assetsIn: ct,
                        assetsOut: it
                    } = function(lt, Se) {
                        var Mt, jt, sr, bt, St;
                        let yt = [],
                            It = new Map;
                        if (lt) {
                            for (let Ge of lt)
                                if (Ge.in[0]) {
                                    let Xe;
                                    Xe = Ge.asset.type === "ERC721" || Ge.in[0].value === "approve_for_all" ? {
                                        id: `nft:${Ge.asset.name}`,
                                        nftName: Ge.asset.name,
                                        nftCount: Ge.in.length
                                    } : {
                                        id: `token:${Ge.asset.type}:${Ge.asset.symbol}:${Ge.asset.name}`,
                                        iconUrl: Ge.asset.logo_url,
                                        value: Ge.in[0].value,
                                        symbol: Ge.asset.symbol,
                                        usdValue: Ge.in[0].usd_price ? Mv(Ge.in[0].usd_price) : void 0,
                                        decimals: Ge.asset.decimals
                                    }, yt.push(Xe)
                                } else if ((Mt = Ge.out[0]) != null && Mt.value) {
                                let Xe;
                                Xe = Ge.asset.type === "ERC721" || Ge.out[0].value === "approve_for_all" ? {
                                    id: `nft:${Ge.asset.name}`,
                                    nftName: Ge.asset.name
                                } : {
                                    id: `token:${Ge.asset.type}:${Ge.asset.symbol}:${Ge.asset.name}`,
                                    iconUrl: Ge.asset.logo_url,
                                    value: Ge.out[0].value,
                                    symbol: Ge.asset.symbol,
                                    usdValue: Ge.out[0].usd_price ? Mv(Ge.out[0].usd_price) : void 0,
                                    decimals: Ge.asset.decimals
                                }, It.has(Xe.id) || It.set(Xe.id, Xe)
                            }
                        }
                        for (let Ge of Se)
                            for (let Xe of Object.keys(Ge.spenders)) {
                                let mr;
                                mr = Ge.asset.type === "ERC721" || ((jt = Ge.spenders[Xe]) == null ? void 0 : jt.value) === "approve_for_all" ? {
                                    id: `nft:${Ge.asset.name}`,
                                    nftName: Ge.asset.name
                                } : {
                                    id: `token:${Ge.asset.type}:${Ge.asset.symbol}:${Ge.asset.name}`,
                                    iconUrl: Ge.asset.logo_url,
                                    value: (sr = Ge.spenders[Xe]) == null ? void 0 : sr.value,
                                    symbol: Ge.asset.symbol,
                                    usdValue: (bt = Ge.spenders[Xe]) != null && bt.usd_price ? Mv((St = Ge.spenders[Xe]) == null ? void 0 : St.usd_price) : void 0,
                                    decimals: Ge.asset.decimals
                                }, It.has(mr.id) || It.set(mr.id, mr)
                            }
                        return {
                            assetsIn: yt,
                            assetsOut: Array.from(It.values())
                        }
                    }(Re.simulation.assets_diffs, Re.simulation.exposures);
                    if (it.length === 0 && ct.length === 0) throw Error("No tokens found");
                    K(it), j(ct)
                }
            };
        if (v.useEffect(() => {
                var Re;
                (Re = t.sendTransaction) != null && Re.scanTransaction && h.embeddedWallets.transactionScanning.enabled && V === "uninitiated" && (Y("in progress"), t.sendTransaction.scanTransaction().then(ct => {
                    Yt(ct), Y("completed")
                }).catch(() => Y("failed")))
            }, [!!((G = t.sendTransaction) != null && G.scanTransaction)]), v.useEffect(() => {
                var Re;
                (Re = t.sendTransaction) != null && Re.scanTransaction && V !== "failed" || ((ct, it, lt) => {
                    if (m((Se => Se != null && Se.sendTransaction ? "transactionRequest" in Se.sendTransaction ? 0 : Se.sendTransaction.transactionRequests.length - 1 : 0)(t)), it.isErc20Ish && it.amount && lt) {
                        let Se = x1({
                            amount: it.amount,
                            decimals: lt.decimals
                        });
                        ne(Se), K([{
                            value: Se,
                            symbol: lt == null ? void 0 : lt.symbol,
                            decimals: lt == null ? void 0 : lt.decimals
                        }])
                    } else if (ct.value) {
                        let Se = BigInt(ct.value),
                            yt = ie ? td(Se, ie) : void 0;
                        K(c && yt ? [{
                            value: yt
                        }] : [{
                            value: HU(Se),
                            symbol: he,
                            decimals: 18,
                            usdValue: yt
                        }])
                    } else K(c ? [{
                        value: "$0"
                    }] : [{
                        value: "0",
                        symbol: he,
                        decimals: 18
                    }])
                })((Te == null ? void 0 : Te.tx) ? ? y, fe, x)
            }, [y, Te == null ? void 0 : Te.tx, fe, x, V]), $) return d.jsx(ATe, {
            txn: (Te == null ? void 0 : Te.tx) ? ? y,
            onClose: Ue,
            receipt: $,
            transactionInfo: (re = t.sendTransaction) == null ? void 0 : re.uiOptions.transactionInfo,
            tokenPrice: ie,
            tokenSymbol: he,
            receiptHeader: (se = t.sendTransaction) == null ? void 0 : se.uiOptions.successHeader,
            receiptDescription: (me = t.sendTransaction) == null ? void 0 : me.uiOptions.successDescription
        });
        if (N) return d.jsx(LB, {
            transactionError: N,
            transactionHash: T ? ? void 0,
            network: "ethereum",
            chainId: (Te == null ? void 0 : Te.tx.chainId) ? ? y.chainId,
            onClose: Ue,
            onRetry: ({
                resetNonce: Re
            }) => {
                R(null);
                let ct = { ...(Te == null ? void 0 : Te.tx) ? ? y
                };
                Re && (ct.nonce = void 0), w(ct)
            }
        });
        let Ot = g !== 0 && typeof f == "number" && f !== 0 ? () => {
            p(f - 1)
        } : void 0;
        return U && D ? d.jsx(_Te, {
            details: D,
            onBack: () => k(!1)
        }) : d.jsx(WSe, {
            transactionIndex: f,
            onBack: Ot,
            maxIndex: g,
            disabled: _t && !De || F,
            isSubmitting: A,
            submitError: N,
            isPreparing: !Te,
            isTokenPriceLoading: Ee,
            isTokenContractInfoLoading: !Be && !x,
            prepareError: Te == null ? void 0 : Te.errors[0],
            symbol: x == null ? void 0 : x.symbol,
            chain: ue,
            img: Lt,
            title: we,
            subtitle: vt,
            txValue: y.value,
            fee: dt ? ? We,
            isSponsored: _,
            from: ae ? ? "",
            to: Ie,
            tokenAddress: xe ? ? void 0,
            network: ((ve = h.chains.find(Re => Re.id === y.chainId)) == null ? void 0 : ve.name) ? ? "",
            transactionDetails: { ...fe,
                formattedAmount: X
            },
            cta: dr,
            missingFunds: _t,
            action: de,
            balance: Ye ? ? ut ? ? He,
            onClose: Ue,
            onClick: tr ? async () => {
                var Re;
                if (ae) {
                    if (!De) throw Error("Funding wallet is not enabled");
                    r({ ...t,
                        funding: { ...t.funding,
                            methodScreen: Ui,
                            chainType: "ethereum",
                            amount: Cd(BigInt((Te == null ? void 0 : Te.tx.value) ? ? 0) + BigInt(((Re = Te == null ? void 0 : Te.totalGasEstimate) == null ? void 0 : Re.toString()) ? ? 0)),
                            chain: ue
                        }
                    }), n(Ui)
                }
            } : async () => {
                var Re, ct;
                if (f < g) p(f + 1);
                else {
                    I(!0);
                    try {
                        let it = await l();
                        if (A || !it || !o || !u) return;
                        let lt = await t.sendTransaction.onConfirm({
                            transactionRequest: (Te == null ? void 0 : Te.tx) ? ? y
                        });
                        if (C(lt), (Re = t.sendTransaction) == null ? void 0 : Re.signOnly) return await new Promise(yt => setTimeout(yt, Ir)), (ct = t == null ? void 0 : t.sendTransaction) == null || ct.onSuccess({
                            hash: lt
                        }), a({
                            shouldCallAuthOnSuccess: !1
                        });
                        let Se = await Le.waitForTransactionReceipt({
                            hash: lt
                        });
                        if (Se.status === "reverted") throw Error("Transaction failed");
                        P(Se)
                    } catch (it) {
                        console.warn({
                            transaction: (Te == null ? void 0 : Te.tx) ? ? y,
                            error: it
                        }), R(it)
                    } finally {
                        I(!1)
                    }
                }
            },
            validation: O,
            hasScanDetails: !!D,
            setIsScanDetailsOpen: k,
            preventMaliciousTransaction: F,
            setPreventMaliciousTransaction: q,
            tokensSent: W,
            tokensReceived: H,
            isScanning: V === "in progress",
            isCancellable: ((kt = (Ze = t.sendTransaction) == null ? void 0 : Ze.uiOptions) == null ? void 0 : kt.isCancellable) ? ? !1,
            functionName: ce
        })
    }
};

function Bi({
    title: t
}) {
    var a, o;
    let {
        currentScreen: e,
        navigateBack: r,
        navigate: n,
        data: i,
        setModalData: s
    } = Ne();
    return d.jsx(Pe, {
        title: t,
        backFn: e === E1 ? r : e === ((a = i == null ? void 0 : i.funding) == null ? void 0 : a.methodScreen) ? i.funding.comingFromSendTransactionScreen ? () => n(BB) : void 0 : (o = i == null ? void 0 : i.funding) != null && o.methodScreen ? () => {
            let c = i.funding;
            c.usingDefaultFundingMethod && (c.usingDefaultFundingMethod = !1), s({
                funding: c
            }), n(c.methodScreen)
        } : void 0
    })
}
const WB = {
        component: () => {
            let {
                rpcConfig: t,
                appId: e,
                closePrivyModal: r,
                createAnalyticsEvent: n
            } = $e(), {
                navigate: i,
                setModalData: s,
                app: a,
                data: o
            } = Ne(), {
                wallets: c
            } = gl(), l = Rh(), [u, h] = v.useState(null), [f, p] = v.useState(null), [g, m] = v.useState([]), [y, w] = v.useState(0), [x, E] = v.useState(!1), [_, b] = v.useState(!1), [A, I] = v.useState(!1), [T, C] = v.useState(!1), [$, P] = v.useState(), [N, R] = v.useState();
            if (!(o != null && o.funding) || o.funding.chainType !== "solana") throw Error("Invalid funding data");
            let {
                address: D,
                cluster: S,
                connectedWalletAddress: O
            } = o.funding, [M, U] = v.useState(o.funding.amount), k = O ? c.find(({
                address: fe
            }) => fe === O) : c[0], F = mc((k == null ? void 0 : k.walletClientType) || "unknown"), q = (F == null ? void 0 : F.name) || "wallet", [W, K] = v.useState(null);
            v.useEffect(() => {
                (async () => {
                    if (!k) return;
                    let fe = await k.getEthereumProvider();
                    K(qP({
                        account: k.address,
                        transport: AP(fe)
                    }).extend(A6))
                })().catch(console.error)
            }, [k]);
            let [H, j] = v.useState(0 n), V = tl(H);
            v.useEffect(() => {
                let fe = l(W0);
                fe ? fe.getBalance({
                    address: D,
                    cluster: S
                }).then(de => j(BigInt(de))) : console.warn("Unable to load solana plugin, skipping balance")
            }, []);
            let [Y, X] = v.useState(), {
                tokenPrice: ne
            } = Oh("solana"), {
                fundingAmountInBaseUnit: ae,
                fundingAmountInUsd: ue
            } = VU({
                amount: M,
                fee: 0 n,
                tokenPrice: ne,
                isUsdc: o.funding.isUSDC
            });
            if (v.useEffect(() => {
                    (async () => {
                        if (!W || !k) return;
                        let fe = ["testnet", "devnet"].includes(S.name);
                        fe && console.warn("Solana testnets are not supported for bridging");
                        let de = S6(a.chains).filter(({
                                testnet: xe
                            }) => !!xe === fe),
                            ye = (await EB({
                                chains: de,
                                address: k.address,
                                appId: e,
                                rpcConfig: t
                            })).filter(xe => xe.balance > 0 n);
                        if (ye.length < 1) return void h(new J(`Wallet ${Yn(k.address)} does not have enough funds.`, void 0, ee.INSUFFICIENT_BALANCE));
                        ye.sort((xe, ie) => Number(ie.balance - xe.balance));
                        let Be = (await Promise.allSettled(ye.map(async xe => ({ ...xe,
                            quote: await Vp({
                                isTestnet: !1,
                                input: Gu({
                                    amount: ae.toString(),
                                    user: k.address,
                                    recipient: D,
                                    destinationChainId: b4,
                                    destinationCurrency: v4,
                                    originChainId: xe.chain.id
                                })
                            })
                        })))).filter(xe => xe.status === "fulfilled").map(xe => xe.value);
                        if (Be.length < 1) return void h(new J(`Unable to fetch quotes for bridging. Wallet ${Yn(k.address)} does not have enough funds.`, void 0, ee.INSUFFICIENT_BALANCE));
                        let ce = Be.map(({
                            quote: xe,
                            balance: ie,
                            chain: Ee
                        }) => ({
                            bridgeTx: y1(xe),
                            balance: ie,
                            chain: Ee,
                            isErc20Quote: !1
                        })).filter(({
                            bridgeTx: xe
                        }) => !!xe);
                        if (ce.length > 1) return void m(ce);
                        let Ie = ce.at(0);
                        Ie ? (b(!0), X({
                            data: Ie.bridgeTx.data,
                            to: Ie.bridgeTx.to,
                            value: Ie.bridgeTx.value,
                            chain: Ie.chain
                        })) : h(new J(`Unable to select bridge option from quotes. Wallet ${Yn(k.address)} does not have enough funds.`, void 0, ee.INSUFFICIENT_BALANCE))
                    })().catch(console.error)
                }, [W]), v.useEffect(() => {
                    (async () => {
                        let fe, de;
                        if (!W || !k || x || A || !Y) return;
                        E(!0);
                        let ye = nc({
                            chain: Y.chain,
                            transport: rc(cc(Y.chain, t, e))
                        });
                        try {
                            fe = await ye.prepareTransactionRequest({
                                account: k.address,
                                to: Y.to,
                                chain: Y.chain,
                                data: Y.data,
                                value: BigInt(Y.value ? ? 0)
                            })
                        } catch (Be) {
                            console.error(Be), g.length > 1 && p(Be.shortMessage ? ? "Something went wrong")
                        }
                        if (fe) {
                            E(!1), I(!0);
                            try {
                                await W.switchChain({
                                    id: Y.chain.id
                                })
                            } catch {
                                await W.addChain({
                                    chain: Y.chain
                                }), await W.switchChain({
                                    id: Y.chain.id
                                })
                            }
                            try {
                                de = await W.sendTransaction(fe)
                            } catch (Be) {
                                console.error(Be), Be.name === "TransactionExecutionError" && (g.length < 1 ? h(new J(Be.shortMessage, void 0, ee.TRANSACTION_FAILURE)) : p(Be.shortMessage ? ? "Something went wrong"))
                            }
                            if (de) return await W.waitForTransactionReceipt({
                                hash: de
                            }), _ ? (R("pending"), void P(de)) : (I(!1), C(!0), void n({
                                eventName: Na,
                                payload: {
                                    provider: "external",
                                    status: "success",
                                    txHash: de,
                                    address: k.address,
                                    chainId: Y.chain.id,
                                    chainType: "ethereum",
                                    value: Y.value ? Nn(BigInt(Y.value), 18) : void 0,
                                    token: "ETH",
                                    destination: D,
                                    destinationClusterName: "mainnet-beta",
                                    destinationChainType: "solana",
                                    destinationValue: Nn(ae, 9),
                                    destinationToken: "SOL"
                                }
                            }));
                            I(!1)
                        } else E(!1)
                    })().catch(console.error)
                }, [W, Y]), M8({
                    transactionHash: $,
                    wallet: k,
                    isTestnet: !1,
                    bridgingStatus: N,
                    setBridgingStatus: R,
                    onSuccess({
                        transactionHash: fe,
                        wallet: de
                    }) {
                        b(!1), C(!0), n({
                            eventName: Na,
                            payload: {
                                provider: "external",
                                status: "success",
                                txHash: fe,
                                address: de.address,
                                chainId: Y == null ? void 0 : Y.chain.id,
                                chainType: "ethereum",
                                value: Y != null && Y.value ? Nn(BigInt(Y.value), 18) : void 0,
                                token: "ETH",
                                destination: D,
                                destinationClusterName: "mainnet-beta",
                                destinationChainType: "solana",
                                destinationValue: Nn(ae, 9),
                                destinationToken: "SOL"
                            }
                        })
                    },
                    onFailure({
                        error: fe
                    }) {
                        b(!1), h(fe)
                    }
                }), v.useEffect(() => {
                    u && (s({
                        funding: o == null ? void 0 : o.funding,
                        sendTransaction: o == null ? void 0 : o.sendTransaction,
                        errorModalData: {
                            error: u,
                            previousScreen: Lh
                        }
                    }), i(Sr, !1))
                }, [u]), v.useEffect(() => {
                    if (!T) return;
                    let fe = setTimeout(r, Hy);
                    return () => clearTimeout(fe)
                }, [T]), T) return d.jsxs(d.Fragment, {
                children: [d.jsx(Bi, {}), d.jsx(er, {}), d.jsxs(wc, {
                    children: [d.jsx(gc, {
                        color: "var(--privy-color-success)",
                        width: "64px",
                        height: "64px"
                    }), d.jsx($r, {
                        title: "Success!",
                        description: `You’ve successfully added ${M} SOL to your ${a.name} wallet. It may take a minute before the funds are available to use.`
                    })]
                }), d.jsx(nr, {}), d.jsx(ot, {})]
            });
            let he = g[y];
            return g.length > 1 && he ? d.jsx(SB, {
                displayName: q,
                configuredFundingChain: S,
                formattedBalance: V,
                fundingAmount: M,
                fundingCurrency: "SOL",
                fundingAmountInUsd: ue,
                options: g,
                selectedOption: he,
                isPreparing: x,
                isSubmitting: A,
                addressToFund: D,
                fundingWalletAddress: (k == null ? void 0 : k.address) || "",
                errorMessage: f,
                onSubmit: () => {
                    var fe;
                    ((fe = o.funding) == null ? void 0 : fe.amount) !== M ? async function() {
                        if (k && he) try {
                            let de = await Vp({
                                    isTestnet: !1,
                                    input: Gu({
                                        amount: ae.toString(),
                                        user: k.address,
                                        recipient: D,
                                        destinationChainId: b4,
                                        destinationCurrency: v4,
                                        originChainId: he.chain.id
                                    })
                                }),
                                ye = y1(de);
                            if (!ye) throw Error("Invalid transaction request");
                            b(!0), X({
                                data: ye.data,
                                to: ye.to,
                                value: ye.value,
                                chain: he.chain
                            })
                        } catch (de) {
                            console.error(de), h(new J("Unable to fetch quotes for bridging", de, ee.INSUFFICIENT_BALANCE))
                        }
                    }().catch(console.error) : X({
                        to: he.bridgeTx.to,
                        data: he.bridgeTx.data,
                        value: he.bridgeTx.value,
                        chain: he.chain
                    })
                },
                onSelect: fe => {
                    fe !== y && (p(null), w(fe))
                },
                onAmountChange: U
            }) : A && k ? d.jsx(yw, {
                wallet: k,
                displayName: q,
                addressToFund: D,
                isBridging: _,
                isErc20Flow: !1,
                chainId: "solana",
                chainName: S.name,
                totalPriceInUsd: void 0,
                totalPriceInNativeCurrency: void 0,
                gasPriceInUsd: void 0,
                gasPriceInNativeCurrency: void 0
            }) : d.jsxs(d.Fragment, {
                children: [d.jsx(Bi, {}), d.jsx(Mh, {}), d.jsx("div", {
                    style: {
                        marginTop: "1rem"
                    }
                }), d.jsx(ot, {})]
            })
        }
    },
    Dv = new Map([
        [Ui, null],
        [Lh, "external"],
        [TB, "external"],
        [xB, "external"],
        [WB, "external"],
        [PB, "external"],
        [E1, "manual"],
        [NB, "moonpay"]
    ]),
    LTe = () => {
        let t = Gt(),
            {
                user: e,
                getAccessToken: r
            } = $t(),
            {
                refreshSessionAndUser: n,
                walletProxy: i
            } = $e();
        return {
            migrate: v.useCallback(async () => {
                if (t.embeddedWallets.mode === "legacy-embedded-wallets-only") return {
                    success: !0
                };
                if (!e) throw new J("User must be authenticated before migrating wallets", ee.MUST_BE_AUTHENTICATED);
                let s = Rs(e);
                if (!s || fn(s) || !lh(s)) return {
                    success: !0
                };
                if (!i) throw new J("Cannot connect to wallet proxy");
                let a = await r();
                if (!a) throw new J("User must be authenticated before migrating wallets", ee.MUST_BE_AUTHENTICATED);
                let o = s.imported ? [s] : e.linkedAccounts.filter(u => u.type === "wallet" && u.walletClientType === "privy" && !u.imported).filter(lh),
                    {
                        entropyId: c,
                        entropyIdVerifier: l
                    } = Sn(e, s);
                try {
                    await i.connect({
                        accessToken: a,
                        entropyId: c,
                        entropyIdVerifier: l
                    })
                } catch (u) {
                    if (!Hp(u) || s.recoveryMethod !== "privy") throw u;
                    await i.recover({
                        accessToken: a,
                        entropyId: c,
                        entropyIdVerifier: l
                    })
                }
                return await i.createDelegatedAction({
                    accessToken: a,
                    rootWallet: {
                        address: s.address,
                        chainType: s.chainType,
                        imported: s.imported
                    },
                    delegatedWallets: o
                }), await n(), {
                    success: !0
                }
            }, [t.embeddedWallets.mode, e, i, r, n])
        }
    },
    UTe = ({
        disabled: t
    }) => {
        let {
            migrate: e
        } = LTe(), {
            user: r
        } = $t(), {
            walletProxy: n
        } = $e();
        return v.useEffect(() => {
            !t && r && n && e().catch(i => {
                console.debug("Unable to migrate wallets: ", i)
            })
        }, [r, n, t, e]), null
    },
    FTe = t => ({
        id: t.id,
        raw_id: t.rawId,
        response: {
            client_data_json: t.response.clientDataJSON,
            authenticator_data: t.response.authenticatorData,
            signature: t.response.signature,
            user_handle: t.response.userHandle
        },
        authenticator_attachment: t.authenticatorAttachment,
        client_extension_results: {
            app_id: t.clientExtensionResults.appid,
            cred_props: t.clientExtensionResults.credProps,
            hmac_create_secret: t.clientExtensionResults.hmacCreateSecret
        },
        type: t.type
    }),
    BTe = {
        component: () => {
            var o, c, l, u;
            let {
                app: t,
                data: e
            } = Ne(), r = Gt(), n = (o = e == null ? void 0 : e.externalConnectWallet) == null ? void 0 : o.suggestedAddress, i = ((c = e == null ? void 0 : e.externalConnectWallet) == null ? void 0 : c.description) ? ? (n ? `Connect the wallet with address ${Yn(n)} ${t!=null&&t.name?`to ${t.name}.`:"."}` : `Connect a wallet to ${t==null?void 0:t.name}`), {
                connectors: s
            } = $e(), a = D8({
                walletList: ((l = e == null ? void 0 : e.externalConnectWallet) == null ? void 0 : l.walletList) ? ? t.appearance.walletList,
                walletChainType: ((u = e == null ? void 0 : e.externalConnectWallet) == null ? void 0 : u.walletChainType) ? ? t.appearance.walletChainType,
                connectors: s,
                connectOnly: !0,
                ignore: t.appearance.walletList,
                walletConnectEnabled: t.externalWallets.walletConnect.enabled
            });
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {}, "header"), a.length > 0 && d.jsx(tw, {
                    title: "Connect your wallet",
                    description: i
                }), d.jsx(RU, {
                    $colorScheme: r.appearance.palette.colorScheme,
                    children: d.jsx(c$e, {
                        wallets: a
                    })
                }), d.jsx(ot, {})]
            })
        }
    };

function WTe(t) {
    let {
        logout: e
    } = v.useContext(Td);
    return Wd("logout", t), {
        logout: e
    }
}
const zTe = {
    component: () => {
        let t = Gt(),
            {
                data: e,
                navigate: r,
                setModalData: n,
                onUserCloseViaDialogOrKeybindRef: i
            } = Ne(),
            {
                crossAppAuthFlow: s,
                updateWallets: a,
                closePrivyModal: o,
                createAnalyticsEvent: c
            } = $e(),
            {
                logout: l
            } = WTe(),
            [u, h] = v.useState({}),
            f = e == null ? void 0 : e.crossAppAuth,
            p = {
                id: f.appId,
                name: f.name,
                logoUrl: f.logoUrl
            },
            g = new J(`There was an issue connecting your ${p.name} account. Please try again.`),
            m = new di(async E => {
                var _, b, A, I, T, C, $, P, N, R, D, S, O, M, U;
                if (f.popup) try {
                    let k = await s({
                        appId: E,
                        popup: f.popup,
                        action: f.action
                    });
                    h({
                        data: k
                    })
                } catch (k) {
                    if (k instanceof J) h({
                        error: k
                    });
                    else if (k instanceof es) {
                        if (k.privyErrorCode === ee.ACCOUNT_TRANSFER_REQUIRED && ((b = (_ = k.data) == null ? void 0 : _.data) != null && b.nonce)) return n({
                            accountTransfer: {
                                nonce: (I = (A = k.data) == null ? void 0 : A.data) == null ? void 0 : I.nonce,
                                account: (C = (T = k.data) == null ? void 0 : T.data) == null ? void 0 : C.subject,
                                displayName: (N = (P = ($ = k.data) == null ? void 0 : $.data) == null ? void 0 : P.account) == null ? void 0 : N.displayName,
                                linkMethod: `privy:${p.id}`,
                                embeddedWalletAddress: (S = (D = (R = k.data) == null ? void 0 : R.data) == null ? void 0 : D.otherUser) == null ? void 0 : S.embeddedWalletAddress,
                                oAuthUserInfo: (U = (M = (O = k.data) == null ? void 0 : O.data) == null ? void 0 : M.otherUser) == null ? void 0 : U.oAuthUserInfo
                            }
                        }), void r(qd);
                        f.popup && f.popup.close(), h({
                            error: g
                        })
                    } else h({
                        error: g
                    })
                } else h({
                    error: g
                })
            }),
            y = () => {
                u.data && (a(), f.onSuccess(u.data), o({
                    shouldCallAuthOnSuccess: !0,
                    isSuccess: !0
                })), f.onError(u.error ? ? new J("User canceled flow")), o({
                    shouldCallAuthOnSuccess: !1,
                    isSuccess: !1
                })
            };
        i.current = y, v.useEffect(() => {
            p.id.length && m.execute(p.id)
        }, [p.id]), v.useEffect(() => {
            if (!u.data) return;
            let E = u.data;
            if (t.legal.requireUsersAcceptTerms && !E.hasAcceptedTerms) {
                let b = setTimeout(() => {
                    r(Hd)
                }, Ir);
                return () => clearTimeout(b)
            }
            if (yl(E, t.embeddedWallets)) {
                let b = setTimeout(() => {
                    n({
                        createWallet: {
                            onSuccess: () => {},
                            onFailure: A => {
                                console.error(A), c({
                                    eventName: "embedded_wallet_creation_failure_logout",
                                    payload: {
                                        error: A,
                                        provider: `privy:${p.id}`,
                                        screen: "CrossAppAuthScreen"
                                    }
                                }), l()
                            },
                            callAuthOnSuccessOnClose: !0
                        }
                    }), r(bc)
                }, Ir);
                return () => clearTimeout(b)
            }
            let _ = setTimeout(y, Ir);
            return () => clearTimeout(_)
        }, [u.data]);
        let {
            title: w,
            subtitle: x
        } = v.useMemo(() => u.data ? {
            title: `Successfully connected with ${p.name}`,
            subtitle: "You're good to go!"
        } : u.error ? {
            title: "Authentication failed",
            subtitle: u.error.message
        } : {
            title: `Connecting to ${p.name}`,
            subtitle: `Please check the pop-up from ${p.name} to continue`
        }, [u, p.name]);
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                onClose: y
            }), d.jsx(er, {}), d.jsxs(qTe, {
                children: [d.jsx(Fi, {
                    children: d.jsxs("div", {
                        children: [d.jsx(Ia, {
                            success: !!u.data,
                            fail: !!u.error
                        }), d.jsx(SF, {
                            name: p.name,
                            logoUrl: p.logoUrl
                        })]
                    })
                }), d.jsxs(ls, {
                    children: [d.jsx("h3", {
                        children: w
                    }), d.jsx("p", {
                        children: x
                    })]
                })]
            }), d.jsx(nr, {}), d.jsx(Wt, {})]
        })
    }
};
let qTe = z.div.withConfig({
    displayName: "ConnectContainer",
    componentId: "sc-90b9ae6b-0"
})(["display:flex;flex-direction:column;align-items:center;justify-content:center;margin-left:27px;margin-right:27px;gap:24px;"]);
const HTe = {
    component: () => {
        let {
            app: t,
            data: e
        } = Ne(), {
            closePrivyModal: r
        } = $e(), [n, i] = v.useState(!1), [s, a] = v.useState(), {
            address: o,
            onDelegate: c,
            onSuccess: l,
            onError: u
        } = e.delegatedActions.consent, h = async () => {
            n ? l() : u(s ? ? new J("User declined delegating actions.")), r({
                shouldCallAuthOnSuccess: !1
            })
        };
        return v.useEffect(() => {
            if (!n && !s) return;
            let f = setTimeout(h, o8);
            return () => clearTimeout(f)
        }, [n, s]), d.jsxs(d.Fragment, n || s ? {
            children: [d.jsx(Pe, {
                onClose: h
            }), d.jsx(er, {}), d.jsxs(E8, {
                children: [s ? d.jsx(Wy, {
                    stroke: "var(--privy-color-error)",
                    width: "64px",
                    height: "64px"
                }) : d.jsx(gc, {
                    stroke: "var(--privy-color-success)",
                    width: "64px",
                    height: "64px"
                }), d.jsx(C8, {
                    height: 20
                }), d.jsx($r, {
                    title: s ? "Something went wrong" : "Success!",
                    description: s ? "Please try again." : `You’ve successfully granted delegated action permissions to ${t.name}.`
                })]
            }), d.jsx(nr, {}), d.jsx(ot, {})]
        } : {
            children: [d.jsx(Pe, {
                closeable: !0,
                onClose: h
            }), d.jsx(X7e, {
                width: 56,
                height: 56,
                style: {
                    margin: "auto"
                }
            }), d.jsx(Cr, {
                style: {
                    marginTop: 24,
                    color: "var(--privy-color-foreground)"
                },
                children: "Enable offline access"
            }), d.jsxs(Ar, {
                style: {
                    marginBottom: 24,
                    textWrap: "pretty"
                },
                children: ["By confirming, ", t.name, " will be able to use your wallet for you even when you're not around. You can revoke this later."]
            }), d.jsx(GTe, {
                showIcon: !0,
                address: o,
                title: "Wallet",
                isLoading: !1
            }), d.jsxs(VTe, {
                style: {
                    marginTop: 24
                },
                children: [d.jsx(po, {
                    onClick: h,
                    children: "Not now"
                }), d.jsx(Qe, {
                    onClick: async () => {
                        try {
                            await c(), i(!0)
                        } catch (f) {
                            a(f)
                        }
                    },
                    children: "Accept"
                })]
            }), d.jsx(ot, {})]
        })
    }
};
let VTe = z.div.withConfig({
        displayName: "ButtonsContainer",
        componentId: "sc-bdb7bc51-0"
    })(["display:flex;gap:10px;"]),
    GTe = z(gw).withConfig({
        displayName: "StyledWalletInfoCard",
        componentId: "sc-bdb7bc51-1"
    })(["margin-top:1.5rem;"]);
const KTe = {
    component: () => {
        let {
            app: t,
            data: e
        } = Ne(), {
            closePrivyModal: r
        } = $e(), [n, i] = v.useState(!1), [s, a] = v.useState(), {
            onRevoke: o,
            onSuccess: c,
            onError: l
        } = e.delegatedActions.revoke, u = async () => {
            n ? c() : l(s ? ? new J("User declined revoking access to their delegated wallet.")), r({
                shouldCallAuthOnSuccess: !1
            })
        };
        return v.useEffect(() => {
            if (!n && !s) return;
            let h = setTimeout(u, o8);
            return () => clearTimeout(h)
        }, [n, s]), d.jsxs(d.Fragment, n || s ? {
            children: [d.jsx(Pe, {
                onClose: u
            }), d.jsx(er, {}), d.jsxs(E8, {
                children: [s ? d.jsx(Wy, {
                    stroke: "var(--privy-color-error)",
                    width: "64px",
                    height: "64px"
                }) : d.jsx(gc, {
                    stroke: "var(--privy-color-success)",
                    width: "64px",
                    height: "64px"
                }), d.jsx(C8, {
                    height: 20
                }), d.jsx($r, {
                    title: s ? "Something went wrong" : "Success!",
                    description: s ? "Please try again." : "You've successfully revoked permissions."
                })]
            }), d.jsx(nr, {}), d.jsx(ot, {})]
        } : {
            children: [d.jsx(Pe, {
                closeable: !0,
                onClose: u
            }), d.jsx(w_e, {
                width: 56,
                height: 56,
                style: {
                    margin: "auto"
                }
            }), d.jsx(Cr, {
                style: {
                    marginTop: 24
                },
                children: "Revoke offline access to wallet"
            }), d.jsxs(Ar, {
                children: ["By confirming, ", t.name, " will no longer be able to use this wallet on your behalf when you are not online."]
            }), d.jsxs(YTe, {
                style: {
                    marginTop: 24
                },
                children: [d.jsx(po, {
                    onClick: u,
                    children: "Deny"
                }), d.jsx(Qe, {
                    onClick: async () => {
                        try {
                            await o(), i(!0)
                        } catch (h) {
                            a(h)
                        }
                    },
                    children: "Confirm"
                })]
            }), d.jsx(ot, {})]
        })
    }
};
let YTe = z.div.withConfig({
        displayName: "ButtonsContainer",
        componentId: "sc-993a839-0"
    })(["display:flex;gap:10px;"]),
    gS = "#8a63d2";
const ZTe = {
    component: () => {
        let {
            lastScreen: t,
            navigateBack: e,
            data: r,
            app: n
        } = Ne(), {
            requestFarcasterSignerStatus: i,
            closePrivyModal: s
        } = $e(), [a, o] = v.useState(void 0), [c, l] = v.useState(!1), [u, h] = v.useState(!1), f = v.useRef([]), p = r == null ? void 0 : r.farcasterSigner;
        v.useEffect(() => {
            let m = Date.now(),
                y = setInterval(async () => {
                    if (!(p != null && p.public_key)) return clearInterval(y), void o({
                        retryable: !0,
                        message: "Connect failed",
                        detail: "Something went wrong. Please try again."
                    });
                    p.status === "approved" && (clearInterval(y), l(!1), h(!0), f.current.push(setTimeout(() => s({
                        shouldCallAuthOnSuccess: !1,
                        isSuccess: !0
                    }), Ir)));
                    let w = await i(p == null ? void 0 : p.public_key),
                        x = Date.now() - m;
                    w.status === "approved" ? (clearInterval(y), l(!1), h(!0), f.current.push(setTimeout(() => s({
                        shouldCallAuthOnSuccess: !1,
                        isSuccess: !0
                    }), Ir))) : x > 3e5 ? (clearInterval(y), o({
                        retryable: !0,
                        message: "Connect failed",
                        detail: "The request timed out. Try again."
                    })) : w.status === "revoked" && (clearInterval(y), o({
                        retryable: !0,
                        message: "Request rejected",
                        detail: "The request was rejected. Please try again."
                    }))
                }, 2e3);
            return () => {
                clearInterval(y), f.current.forEach(w => clearTimeout(w))
            }
        }, []);
        let g = (p == null ? void 0 : p.status) === "pending_approval" ? p.signer_approval_url : void 0;
        return d.jsxs(d.Fragment, gr.isMobile || c ? {
            children: [d.jsx(Pe, {
                backFn: t ? e : void 0,
                onClose: s
            }, "header"), d.jsx(er, {}), d.jsx(d.Fragment, gr.isIOS ? {
                children: d.jsxs(JTe, {
                    children: [d.jsx(Fi, {
                        children: d.jsxs("div", {
                            children: [d.jsx(Ia, {
                                success: u,
                                fail: !!a
                            }), d.jsx(rd, {
                                style: {
                                    width: "38px",
                                    height: "38px"
                                }
                            })]
                        })
                    }), d.jsxs(ls, {
                        children: [d.jsx(Cr, {
                            children: a ? a.message : "Add a signer to Farcaster"
                        }), d.jsx(Ar, {
                            children: a ? a.detail : "This will allow " + n.name + " to add casts, likes, follows, and more on your behalf."
                        })]
                    }), g && d.jsx(Qe, {
                        onClick: m => {
                            m.preventDefault(), window.location.href = g
                        },
                        children: "Open Farcaster app"
                    })]
                })
            } : {
                children: d.jsxs(mS, {
                    children: [d.jsx(Fi, {
                        children: d.jsxs("div", {
                            children: [d.jsx(Ia, {
                                success: u,
                                fail: !!a
                            }), d.jsx(rd, {
                                style: {
                                    width: "38px",
                                    height: "38px"
                                }
                            })]
                        })
                    }), d.jsxs(ls, {
                        children: [d.jsx(Cr, {
                            children: a ? a.message : "Requesting signer from Farcaster"
                        }), d.jsx(Ar, {
                            children: a ? a.detail : "This should only take a moment"
                        }), d.jsx(ol, {
                            children: g && gr.isMobile && d.jsx(YF, {
                                text: "Take me to Farcaster",
                                url: g,
                                color: gS
                            })
                        })]
                    })]
                })
            }), d.jsx(Wt, {})]
        } : {
            children: [d.jsx(Pe, {
                backFn: t ? e : void 0,
                onClose: s
            }, "header"), d.jsx(er, {}), d.jsx(mS, {
                children: d.jsxs("div", {
                    children: [d.jsx(Cr, {
                        children: "Add a signer to Farcaster"
                    }), d.jsxs(Ar, {
                        children: ["This will allow ", n.name, " to add casts, likes, follows, and more on your behalf."]
                    }), d.jsx(_8, {
                        children: (p == null ? void 0 : p.status) === "pending_approval" ? d.jsx(U0, {
                            url: p.signer_approval_url,
                            size: 275,
                            squareLogoElement: rd
                        }) : d.jsx(Ls, {})
                    }), d.jsxs(ol, {
                        children: [d.jsx(Ar, {
                            children: "Or copy this link and paste it into a phone browser to open the Farcaster app."
                        }), (p == null ? void 0 : p.status) === "pending_approval" && d.jsx(hw, {
                            text: p.signer_approval_url,
                            itemName: "link",
                            color: gS
                        })]
                    })]
                })
            }), d.jsx(Wt, {})]
        })
    }
};
let mS = z.div.withConfig({
        displayName: "ConnectContainer",
        componentId: "sc-4eb46726-0"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;margin-left:27px;margin-right:27px;gap:24px;"]),
    JTe = z.div.withConfig({
        displayName: "ConnectContainerButton",
        componentId: "sc-4eb46726-1"
    })(["display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;width:100%;"]);
const yS = {
    component: () => {
        let {
            closePrivyModal: t
        } = $e();
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {}, "header"), d.jsx(QTe, {
                children: d.jsx(c4, {
                    style: {
                        width: 32,
                        height: 32
                    }
                })
            }), d.jsx(tw, {
                title: "Could not log in with provider",
                description: "It looks like you're using an in-app browser.  To log in, please try again using an external browser.",
                style: {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    justifyContent: "center",
                    textAlign: "center"
                }
            }), d.jsx(zd, {
                children: d.jsx(Qe, {
                    onClick: () => t(),
                    children: "Close"
                })
            }), d.jsx(nr, {}), d.jsx(ot, {})]
        })
    }
};
let QTe = z.div.withConfig({
    displayName: "StyledCircle",
    componentId: "sc-7bde5742-0"
})(["border-radius:50%;height:68px;width:68px;display:flex;align-items:center;justify-content:center;background-color:var(--privy-color-accent);color:white;margin:0 auto 24px auto;"]);
const XTe = {
        component: () => {
            let {
                app: t
            } = Ne();
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {}, "header"), d.jsx(er, {}), d.jsx($r, {
                    title: "Connect your email",
                    description: `Add your email to your ${t==null?void 0:t.name} account`,
                    icon: d.jsx(Ld, {
                        color: "var(--privy-color-accent)",
                        strokeWidth: 2,
                        height: "48px",
                        width: "48px"
                    })
                }), d.jsx(zd, {
                    children: d.jsx(sB, {
                        stacked: !0
                    })
                }), d.jsx(nr, {}), d.jsx(ot, {})]
            })
        }
    },
    B8 = {
        component: () => {
            let {
                app: t,
                currentScreen: e,
                data: r,
                navigate: n,
                setModalData: i
            } = Ne(), {
                initLoginWithSms: s
            } = $e();
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {}, "header"), d.jsx(er, {}), d.jsx($r, {
                    title: "Connect your phone",
                    description: `Add your number to your ${t==null?void 0:t.name} account`,
                    icon: d.jsx(Ca, {
                        color: "var(--privy-color-accent)",
                        strokeWidth: 2,
                        height: "40px",
                        width: "40px"
                    })
                }), d.jsx(zd, {
                    children: d.jsx(fw, {
                        stacked: !0,
                        onSubmit: async function({
                            qualifiedPhoneNumber: a
                        }) {
                            var o;
                            try {
                                await s({
                                    phoneNumber: a,
                                    withPrivyUi: !0
                                }), n(uc)
                            } catch (c) {
                                i({
                                    errorModalData: {
                                        error: c,
                                        previousScreen: ((o = r == null ? void 0 : r.errorModalData) == null ? void 0 : o.previousScreen) || e || B8
                                    }
                                }), n(Sr)
                            }
                        },
                        hideRecent: !0
                    })
                }), d.jsx(nr, {}), d.jsx(ot, {})]
            })
        }
    },
    ePe = ({
        style: t,
        ...e
    }) => d.jsxs("svg", {
        width: "164",
        height: "164",
        viewBox: "0 0 164 164",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: {
            height: "26px",
            width: "26px",
            ...t
        },
        ...e,
        children: [d.jsx("circle", {
            cx: "82",
            cy: "82",
            r: "80",
            stroke: "#EC6351",
            "stroke-width": "4",
            "stroke-linecap": "round"
        }), d.jsx("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M81.9999 100.788C93.3288 100.788 102.513 91.6043 102.513 80.2754C102.513 68.9465 93.3288 59.7626 81.9999 59.7626C70.671 59.7626 61.4871 68.9465 61.4871 80.2754C61.4871 91.6043 70.671 100.788 81.9999 100.788ZM88.3236 71.8304C88.9093 71.2446 89.8591 71.2446 90.4449 71.8304C91.0307 72.4161 91.0307 73.3659 90.4449 73.9517L84.121 80.2756L90.445 86.5996C91.0308 87.1854 91.0308 88.1351 90.445 88.7209C89.8592 89.3067 88.9095 89.3067 88.3237 88.7209L81.9997 82.3969L75.6756 88.7209C75.0899 89.3067 74.1401 89.3067 73.5543 88.7209C72.9685 88.1351 72.9685 87.1854 73.5543 86.5996L79.8783 80.2756L73.5544 73.9517C72.9686 73.3659 72.9686 72.4161 73.5544 71.8304C74.1402 71.2446 75.09 71.2446 75.6758 71.8304L81.9997 78.1543L88.3236 71.8304Z",
            fill: "#EC6351"
        })]
    }),
    tPe = {
        component: () => {
            let {
                closePrivyModal: t
            } = $e(), {
                navigate: e
            } = Ne();
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {}, "header"), d.jsx(er, {}), d.jsx(ePe, {
                    style: {
                        width: "160px",
                        height: "160px",
                        margin: "0 auto 20px"
                    }
                }), d.jsx(tw, {
                    title: "Could not connect with wallet",
                    description: "Please check that Phantom multichain is enabled and try again.",
                    style: {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        justifyContent: "center",
                        textAlign: "center"
                    }
                }), d.jsxs(zd, {
                    children: [d.jsx(Qe, {
                        onClick: () => e(Xn),
                        children: "Try again"
                    }), d.jsx(po, {
                        onClick: () => t(),
                        children: "Cancel"
                    })]
                }), d.jsx(nr, {}), d.jsx(ot, {})]
            })
        }
    };

function zB() {
    let {
        initEnrollmentWithSms: t,
        initEnrollmentWithTotp: e,
        initEnrollmentWithPasskey: r,
        submitEnrollmentWithSms: n,
        submitEnrollmentWithTotp: i,
        submitEnrollmentWithPasskey: s,
        unenroll: a,
        enrollInMfa: o
    } = v.useContext(Td);
    return {
        initEnrollmentWithSms: t,
        initEnrollmentWithTotp: e,
        initEnrollmentWithPasskey: r,
        submitEnrollmentWithSms: n,
        submitEnrollmentWithTotp: i,
        submitEnrollmentWithPasskey: s,
        unenrollWithSms: () => a("sms"),
        unenrollWithTotp: () => a("totp"),
        unenrollWithPasskey: c => a("passkey", c),
        showMfaEnrollmentModal: () => o(!0),
        closeMfaEnrollmentModal: () => o(!1)
    }
}
const rPe = t => d.jsxs(nPe, {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    width: "88",
    height: "89",
    viewBox: "0 0 88 89",
    ...t,
    children: [d.jsx("rect", {
        y: "0.666016",
        width: "88",
        height: "88",
        rx: "44"
    }), d.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M45.2463 20.9106C44.5473 20.2486 43.4527 20.2486 42.7537 20.9106C37.8798 25.5263 31.3034 28.3546 24.0625 28.3546C23.9473 28.3546 23.8323 28.3539 23.7174 28.3525C22.9263 28.3427 22.2202 28.8471 21.9731 29.5987C20.9761 32.6311 20.4375 35.8693 20.4375 39.2297C20.4375 53.5896 30.259 65.651 43.5482 69.0714C43.8446 69.1477 44.1554 69.1477 44.4518 69.0714C57.741 65.651 67.5625 53.5896 67.5625 39.2297C67.5625 35.8693 67.0239 32.6311 66.0269 29.5987C65.7798 28.8471 65.0737 28.3427 64.2826 28.3525C64.1677 28.3539 64.0527 28.3546 63.9375 28.3546C56.6966 28.3546 50.1202 25.5263 45.2463 20.9106ZM52.7249 40.2829C53.3067 39.4683 53.1181 38.3363 52.3035 37.7545C51.4889 37.1726 50.3569 37.3613 49.7751 38.1759L41.9562 49.1223L38.0316 45.1977C37.3238 44.4899 36.1762 44.4899 35.4684 45.1977C34.7605 45.9056 34.7605 47.0532 35.4684 47.761L40.9059 53.1985C41.2826 53.5752 41.806 53.7671 42.337 53.7232C42.868 53.6792 43.3527 53.4039 43.6624 52.9704L52.7249 40.2829Z"
    })]
});
let nPe = z.svg.withConfig({
    displayName: "StyledSvg",
    componentId: "sc-59fa943f-0"
})(["height:90px;width:90px;> rect{", "}> path{fill:white;}"], t => t.color === "success" ? "fill: var(--privy-color-success);" : "fill: var(--privy-color-accent);");
const iPe = ({
    showIntro: t,
    userMfaMethods: e,
    appMfaMethods: r,
    userHasAuthSms: n,
    isTotpLoading: i,
    isPasskeyLoading: s,
    error: a,
    onClose: o,
    onBackToIntro: c,
    handleSelectMethod: l,
    setRemovingMfaMethod: u
}) => {
    let h = e.reduce((p, g) => ({ ...p,
            [g]: !0
        }), {}),
        f = r.reduce((p, g) => ({ ...p,
            [g]: !0
        }), {});
    return d.jsxs(d.Fragment, {
        children: [d.jsx(Pe, {
            backFn: t ? c : void 0,
            onClose: o
        }, "header"), d.jsx(Oi, {
            style: {
                marginBottom: "1.5rem"
            },
            children: d.jsx(hd, {})
        }), d.jsx(Cr, {
            children: "Choose a verification method"
        }), e.length > 0 ? d.jsx(Ar, {
            children: "To add or delete verification methods, verification is required."
        }) : d.jsx(Ar, {
            children: "How would you like to verify your identity?"
        }), a && d.jsx(FU, {
            style: {
                marginTop: "1.25rem"
            },
            children: a.message
        }), d.jsxs(LU, {
            children: [(f.passkey || h.passkey) && d.jsxs(_v, {
                children: [d.jsx(Pr, {
                    style: {
                        justifyContent: "center"
                    },
                    onClick: () => l("passkey"),
                    disabled: h.passkey || s,
                    children: s ? d.jsx(Ls, {
                        style: {
                            height: 24,
                            width: 24,
                            borderWidth: 2
                        },
                        color: "var(--privy-color-foreground-3)"
                    }) : d.jsxs(kv, {
                        children: [d.jsxs(Av, {
                            children: [d.jsx(sx, {}), "Passkey"]
                        }), h.passkey ? d.jsx(Lv, {
                            color: "green",
                            children: "Enabled"
                        }) : d.jsx(b$, {
                            $isAccent: !0,
                            children: d.jsx(s8, {})
                        })]
                    })
                }), h.passkey && d.jsx(Cv, {
                    style: {
                        position: "absolute",
                        right: 0
                    },
                    onClick: () => u("passkey"),
                    children: d.jsx(Bb, {})
                })]
            }, "passkey"), (f.totp || h.totp) && d.jsxs(_v, {
                children: [d.jsx(Pr, {
                    style: {
                        justifyContent: "center"
                    },
                    disabled: h.totp || i,
                    onClick: () => l("totp"),
                    children: i ? d.jsx(Ls, {
                        style: {
                            height: 24,
                            width: 24,
                            borderWidth: 2
                        },
                        color: "var(--privy-color-foreground-3)"
                    }) : d.jsxs(kv, {
                        children: [d.jsxs(Av, {
                            children: [d.jsx(oy, {}), "Authenticator app"]
                        }), h.totp && d.jsx(Lv, {
                            color: "green",
                            children: "Enabled"
                        })]
                    })
                }), h.totp && d.jsx(Cv, {
                    style: {
                        position: "absolute",
                        right: 0
                    },
                    onClick: () => u("totp"),
                    children: d.jsx(Bb, {})
                })]
            }, "totp"), (f.sms || h.sms) && d.jsxs(_v, {
                children: [d.jsx(Pr, {
                    disabled: h.sms || n,
                    onClick: () => l("sms"),
                    children: d.jsxs(kv, {
                        children: [d.jsxs(Av, {
                            children: [d.jsx(Ca, {}), "SMS"]
                        }), h.sms && d.jsx(Lv, {
                            color: "green",
                            children: "Enabled"
                        }), n && d.jsx(b$, {
                            children: "Disabled"
                        })]
                    })
                }), h.sms && d.jsx(Cv, {
                    style: {
                        position: "absolute",
                        right: 0
                    },
                    onClick: () => u("sms"),
                    children: d.jsx(Bb, {})
                })]
            }, "sms")]
        }), d.jsx(sPe, {
            children: "You can always change your selection later"
        }), d.jsx(Wt, {})]
    })
};
let Lv = z(Ta).withConfig({
        displayName: "StyledChip",
        componentId: "sc-24f8b314-0"
    })(["margin-right:1.5rem;"]),
    sPe = z(UU).withConfig({
        displayName: "StyledTerms",
        componentId: "sc-24f8b314-1"
    })(["&&{margin-top:1rem;}text-align:center;"]);
const aPe = ({
    onClose: t,
    onReset: e,
    submitEnrollmentWithPasskey: r
}) => {
    let {
        user: n
    } = $t(), {
        initLinkWithPasskey: i,
        linkWithPasskey: s
    } = $e(), [a, o] = v.useState(!1), [c, l] = v.useState(!1), [u, h] = v.useState(null), f = v.useMemo(() => (n == null ? void 0 : n.linkedAccounts.filter(m => m.type === "passkey")) ? ? [], [n]), p = async m => {
        o(!0);
        try {
            await r(m)
        } catch (y) {
            h(y)
        } finally {
            o(!1)
        }
    }, g = async () => {
        l(!0), h(null);
        try {
            await i();
            let m = await s(),
                y = (m == null ? void 0 : m.linkedAccounts.filter(w => w.type === "passkey").map(w => w.credentialId)) ? ? [];
            await p(y)
        } catch (m) {
            h(m)
        } finally {
            l(!1)
        }
    };
    return f.length === 0 || c ? d.jsx(oPe, {
        onReset: e,
        onClose: t,
        onClick: g,
        isCreating: c
    }) : u ? d.jsx(L0, {
        error: u,
        backFn: () => h(null),
        onClick: () => h(null)
    }) : d.jsx(cPe, {
        passkeys: f,
        isSubmitting: a,
        isCreating: c,
        onReset: e,
        onClose: t,
        onSubmitEnrollment: () => p(f.map(m => m.credentialId)),
        onAddPasskey: g
    })
};
let oPe = ({
        onReset: t,
        onClose: e,
        onClick: r,
        isCreating: n
    }) => d.jsxs(d.Fragment, {
        children: [d.jsx(Pe, {
            backFn: t,
            onClose: e
        }, "header"), d.jsx(O0, {
            children: d.jsxs(F8, {
                children: [d.jsx(M0, {}), d.jsx(B0, {})]
            })
        }), d.jsx(Cr, {
            children: "Set up passkey verification"
        }), d.jsxs(Zy, {
            children: [d.jsxs(co, {
                children: [d.jsx(oo, {
                    children: d.jsx(hd, {})
                }), "Verify with Touch ID, Face ID, PIN, or hardware key"]
            }), d.jsxs(co, {
                children: [d.jsx(oo, {
                    children: d.jsx(LL, {})
                }), "Takes seconds to set up and use"]
            }), d.jsxs(co, {
                children: [d.jsx(oo, {
                    children: d.jsx(H7e, {})
                }), "Use your passkey to verify transactions and login to your account"]
            })]
        }), d.jsx(Qe, {
            style: {
                marginTop: "2.25rem"
            },
            onClick: r,
            loading: n,
            children: "Add a new passkey"
        }), d.jsx(Wt, {})]
    }),
    cPe = ({
        onReset: t,
        onClose: e,
        onAddPasskey: r,
        onSubmitEnrollment: n,
        passkeys: i,
        isSubmitting: s,
        isCreating: a
    }) => {
        let [o, c] = v.useState(!1), l = o ? i.length : i.length > 3 ? 2 : 3;
        return d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {
                backFn: o ? () => c(!1) : t,
                onClose: e
            }, "header"), !o && d.jsx(O0, {
                children: d.jsxs(F8, {
                    children: [d.jsx(M0, {}), d.jsx(B0, {})]
                })
            }), d.jsx(Cr, {
                children: "Enable your passkeys for verification"
            }), d.jsxs(Zy, {
                children: [i.slice(0, l).map(u => {
                    var h;
                    return d.jsxs(lPe, {
                        children: [d.jsx(dPe, {
                            children: hPe(u)
                        }), d.jsxs(uPe, {
                            children: ["Last used: ", (h = u.latestVerifiedAt) == null ? void 0 : h.toLocaleString()]
                        })]
                    }, u.credentialId)
                }), !o && i.length > 3 && d.jsx(wS, {
                    onClick: () => c(!0),
                    children: "View All"
                })]
            }), d.jsx(Qe, {
                style: {
                    marginTop: "1.5rem"
                },
                onClick: n,
                loading: s,
                children: "Enable passkeys"
            }), i.length < 5 && d.jsx(wS, {
                style: {
                    marginTop: "0.5rem"
                },
                onClick: r,
                disabled: a,
                children: a ? d.jsx(Ls, {
                    style: {
                        height: "1rem",
                        width: "1rem",
                        borderWidth: 2
                    }
                }) : "Add new passkey"
            }), d.jsx(Wt, {})]
        })
    },
    lPe = z.div.withConfig({
        displayName: "PasskeyItem",
        componentId: "sc-bae3649d-0"
    })(["&&{padding:0.75rem 1rem;text-align:left;border-radius:0.5rem;border:1px solid var(--privy-color-foreground-4);width:100%;}"]),
    dPe = z.div.withConfig({
        displayName: "PasskeyItemTitle",
        componentId: "sc-bae3649d-1"
    })(["font-size:0.875rem;line-height:1.375rem;font-weight:500;color:var(--privy-color-foreground-1);"]),
    uPe = z.div.withConfig({
        displayName: "PasskeyItemSubtitle",
        componentId: "sc-bae3649d-2"
    })(["font-size:0.75rem;font-weight:400;line-height:1.125rem;color:var(--privy-color-foreground-2);"]),
    hPe = t => t.authenticatorName ? t.createdWithBrowser ? `${t.authenticatorName} on ${t.createdWithBrowser}` : t.authenticatorName : t.createdWithBrowser ? t.createdWithOs ? `${t.createdWithBrowser} on ${t.createdWithOs}` : `${t.createdWithBrowser}` : "Unknown device";
const wS = z.button.withConfig({
        displayName: "StyledLink",
        componentId: "sc-bae3649d-3"
    })(["&&{width:100%;font-size:0.875rem;line-height:1rem;@media (min-width:440px){font-size:14px;}display:flex;gap:12px;justify-content:center;padding:0.75rem 1rem;background-color:var(--privy-color-background);transition:background-color 200ms ease;color:var(--privy-color-accent);:focus{outline:none;box-shadow:none;}}"]),
    fPe = ({
        appName: t,
        onComplete: e,
        onReset: r,
        onClose: n
    }) => {
        let [i, s] = v.useState(""), [a, o] = v.useState(!1), [c, l] = v.useState(null), [u, h] = v.useState("enroll"), {
            initEnrollmentWithSms: f,
            submitEnrollmentWithSms: p
        } = zB(), {
            app: g,
            data: m
        } = Ne();

        function y() {
            var w;
            (w = m == null ? void 0 : m.mfaEnrollmentFlow) == null || w.onSuccess(), e()
        }
        return c ? d.jsx(L0, {
            error: c,
            backFn: () => l(null),
            onClick: () => l(null)
        }) : d.jsxs(d.Fragment, u === "enroll" ? {
            children: [d.jsx(Pe, {
                backFn: r,
                onClose: n
            }, "header"), d.jsx(Oi, {
                style: {
                    marginBottom: "1.5rem"
                },
                children: d.jsx(Ca, {})
            }), d.jsx(Cr, {
                children: "Set up SMS verification"
            }), d.jsxs(Ar, {
                children: ["We'll text a verification code to this mobile device whenever you use your ", t, " ", "wallet."]
            }), d.jsxs(xd, {
                children: [d.jsx(fw, {
                    onSubmit: async function({
                        qualifiedPhoneNumber: w
                    }) {
                        try {
                            await f({
                                phoneNumber: w
                            }), s(w), h("verify")
                        } catch (x) {
                            l(x)
                        }
                    },
                    hideRecent: !0
                }), d.jsxs(UU, {
                    children: ["By providing your mobile number, you agree to receive text messages from ", g == null ? void 0 : g.name, ". Some carrier charges may apply"]
                })]
            }), d.jsx(Wt, {})]
        } : a ? {
            children: [d.jsx(Pe, {
                onClose: y
            }, "header"), d.jsx(Oi, {
                style: {
                    marginBottom: "1.5rem"
                },
                children: d.jsx(gc, {})
            }), d.jsx(Cr, {
                children: "SMS verification added"
            }), d.jsxs(Ar, {
                children: ["From now on, you'll enter the verification code sent to your mobile device whenever you use your ", t, " wallet."]
            }), d.jsx(Bo, {
                children: d.jsx(Qe, {
                    onClick: y,
                    children: "Done"
                })
            }), d.jsx(Wt, {})]
        } : {
            children: [d.jsx(Pe, {
                backFn: function() {
                    u === "verify" ? h("enroll") : r()
                },
                onClose: n
            }, "header"), d.jsx(Oi, {
                style: {
                    marginBottom: "1.5rem"
                },
                children: d.jsx(Ca, {})
            }), d.jsx(Cr, {
                children: "Enter enrollment code"
            }), d.jsxs(xd, {
                children: [d.jsx(p1, {
                    onChange: async function(w) {
                        try {
                            if (!w) return;
                            await p({
                                phoneNumber: i,
                                mfaCode: w
                            }), o(!0)
                        } catch (x) {
                            throw aF(x) ? Error("You have exceeded the maximum number of attempts. Please close this window and try again in 10 seconds.") : k8(x) ? Error("The code you entered is not valid") : A8(x) ? Error("You have exceeded the time limit for code entry. Please try again in 30 seconds.") : oF(x) ? Error("Verification canceled") : Error("Unknown error")
                        }
                    }
                }), d.jsxs(Ar, {
                    children: ["To continue, enter the 6-digit code sent to ", d.jsx("strong", {
                        children: Yre(i)
                    })]
                })]
            }), d.jsx(Wt, {})]
        })
    },
    pPe = ({
        size: t,
        authUrl: e
    }) => d.jsx(U0, {
        url: e,
        squareLogoElement: e9e,
        size: t,
        fgColor: "#1F1F1F"
    }),
    gPe = ({
        onClose: t,
        onReset: e,
        totpInfo: r,
        submitEnrollmentWithTotp: n,
        error: i
    }) => {
        let [s, a] = v.useState("enroll");
        return d.jsxs(d.Fragment, s === "enroll" ? {
            children: [d.jsx(Pe, {
                backFn: e,
                onClose: t
            }, "header"), d.jsx(Pa, {
                children: "Scan QR code"
            }), d.jsx($a, {
                children: "Open your authenticator app and scan this code to continue"
            }), d.jsx(_8, {
                children: d.jsx(pPe, {
                    authUrl: r.authUrl,
                    size: 240
                })
            }), d.jsx(Yi, {
                style: {
                    textAlign: "left"
                },
                children: "Setup key"
            }), d.jsxs(pw, {
                style: {
                    marginTop: "0.25rem"
                },
                children: [d.jsx(pB, {
                    children: "•".repeat(16)
                }), d.jsx(hw, {
                    itemName: " ",
                    text: r.secret
                })]
            }), d.jsx(Qe, {
                style: {
                    marginTop: "1rem"
                },
                onClick: function() {
                    a("verify")
                },
                children: "Continue"
            }), d.jsx(Wt, {})]
        } : {
            children: [d.jsx(Pe, {
                backFn: function() {
                    s === "verify" ? a("enroll") : e()
                },
                onClose: t
            }, "header"), d.jsx(Oi, {
                style: {
                    marginBottom: "1.5rem"
                },
                children: d.jsx(oy, {})
            }), d.jsx(Pa, {
                children: "Enter enrollment code"
            }), d.jsx($a, {
                children: "To continue, enter the 6-digit code generated from your authenticator app"
            }), d.jsx(xd, {
                children: d.jsx(p1, {
                    onChange: async function(o) {
                        try {
                            if (!o) return;
                            await n({
                                mfaCode: o
                            })
                        } catch (c) {
                            throw aF(c) ? Error("You have exceeded the maximum number of attempts. Please close this window and try again in 10 seconds.") : k8(c) ? Error("The code you entered is not valid") : A8(c) ? Error("You have exceeded the time limit for code entry. Please try again in 30 seconds.") : oF(c) ? Error("Verification canceled") : Error("Unknown error")
                        }
                    },
                    errorReasonOverride: i == null ? void 0 : i.message
                })
            }), d.jsx(Wt, {})]
        })
    },
    mPe = {
        component: () => {
            var q;
            let {
                user: t,
                enrollInMfa: e,
                ready: r
            } = $t(), [n, i] = v.useState(null), {
                unenrollWithSms: s,
                unenrollWithTotp: a,
                unenrollWithPasskey: o,
                submitEnrollmentWithTotp: c,
                initEnrollmentWithPasskey: l,
                submitEnrollmentWithPasskey: u,
                initEnrollmentWithTotp: h
            } = zB(), {
                app: f,
                data: p,
                onUserCloseViaDialogOrKeybindRef: g
            } = Ne(), {
                closePrivyModal: m
            } = $e(), {
                promptMfa: y
            } = cF(), [w, x] = v.useState(!1), [E, _] = v.useState(null), [b, A] = v.useState(null), I = () => {
                m({
                    shouldCallAuthOnSuccess: !0
                }), e(!1), setTimeout(() => {
                    i(null), _(null)
                }, 500)
            }, [T, C] = v.useState(!1), [$, P] = v.useState();
            g.current = I;
            let N = t == null ? void 0 : t.mfaMethods.includes("sms"),
                R = !!(t != null && t.phone),
                D = t == null ? void 0 : t.mfaMethods.includes("totp"),
                S = t == null ? void 0 : t.mfaMethods.includes("passkey"),
                O = N || D || S,
                M = (t == null ? void 0 : t.linkedAccounts.filter(W => W.type === "passkey").map(W => W.credentialId)) ? ? [];

            function U() {
                i(null), _(null)
            }
            async function k(W = M) {
                var K, H;
                C(!0);
                try {
                    return await l(), await u({
                        credentialIds: W
                    }, {
                        removeForLogin: (K = p == null ? void 0 : p.mfaEnrollmentFlow) == null ? void 0 : K.shouldUnlinkOnUnenrollMfa
                    }), (H = p == null ? void 0 : p.mfaEnrollmentFlow) == null || H.onSuccess(), I()
                } catch (j) {
                    P(j)
                } finally {
                    C(!1)
                }
            }
            if (v.useEffect(() => {
                    O && x(!0)
                }, [O]), !r || !t || !f) return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    onClose: I
                }, "header"), d.jsx(O0, {
                    children: d.jsx(rPe, {})
                }), d.jsx(xd, {
                    children: d.jsx(Ls, {})
                }), d.jsx(Wt, {})]
            });
            if (n === "sms") return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    backFn: U,
                    onClose: I
                }, "header"), d.jsx(Oi, {
                    style: {
                        marginBottom: "1.5rem"
                    },
                    children: d.jsx(Ql, {})
                }), d.jsx(Cr, {
                    children: "Remove SMS verification?"
                }), d.jsxs(Ar, {
                    children: ["MFA adds an extra layer of security to your ", f == null ? void 0 : f.name, " account. Make sure you have other methods to secure your account."]
                }), d.jsx(Bo, {
                    children: d.jsx(Qe, {
                        $warn: !0,
                        onClick: async function() {
                            i(null);
                            try {
                                await s()
                            } catch {
                                i(null)
                            }
                        },
                        children: "Remove"
                    })
                }), d.jsx(Wt, {})]
            });
            if (n === "totp") return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    backFn: U,
                    onClose: I
                }, "header"), d.jsx(Oi, {
                    style: {
                        marginBottom: "1.5rem"
                    },
                    children: d.jsx(Ql, {})
                }), d.jsx(Cr, {
                    children: "Remove authenticator app verification?"
                }), d.jsxs(Ar, {
                    children: ["MFA adds an extra layer of security to your ", f == null ? void 0 : f.name, " account. Make sure you have other methods to secure your account."]
                }), d.jsx(Bo, {
                    children: d.jsx(Qe, {
                        $warn: !0,
                        onClick: async function() {
                            i(null);
                            try {
                                await a()
                            } catch {
                                i(null)
                            }
                        },
                        children: "Remove"
                    })
                }), d.jsx(Wt, {})]
            });
            if (n === "passkey") {
                let W = ((q = p == null ? void 0 : p.mfaEnrollmentFlow) == null ? void 0 : q.shouldUnlinkOnUnenrollMfa) ? ? !0;
                return d.jsxs(d.Fragment, {
                    children: [d.jsx(Pe, {
                        backFn: U,
                        onClose: I
                    }, "header"), d.jsx(Oi, {
                        style: {
                            marginBottom: "1.5rem"
                        },
                        children: d.jsx(Ql, {})
                    }), d.jsx(Cr, {
                        children: "Are you sure you want to remove this passkey?"
                    }), d.jsx(Ar, {
                        children: W ? "Removing your passkey will remove as both a verification method and a login method." : "Removing your passkey will remove as a verification method."
                    }), d.jsx(Bo, {
                        children: d.jsx(Qe, {
                            $warn: !0,
                            onClick: async function() {
                                var K;
                                i(null);
                                try {
                                    await o({
                                        removeForLogin: (K = p == null ? void 0 : p.mfaEnrollmentFlow) == null ? void 0 : K.shouldUnlinkOnUnenrollMfa
                                    })
                                } catch {
                                    i(null)
                                }
                            },
                            children: "Remove"
                        })
                    }), d.jsx(Wt, {})]
                })
            }
            if (p.mfaEnrollmentFlow.mfaMethods.length === 0 && !O) return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    onClose: I
                }, "header"), d.jsx(Oi, {
                    style: {
                        marginBottom: "1.5rem"
                    },
                    children: d.jsx(hd, {})
                }), d.jsx(Cr, {
                    children: "Add more security"
                }), d.jsxs(Ar, {
                    children: [f == null ? void 0 : f.name, " does not have any verification methods enabled."]
                }), d.jsx(Bo, {
                    children: d.jsx(Qe, {
                        onClick: I,
                        children: "Close"
                    })
                }), d.jsx(Wt, {})]
            });
            let F = !O && !w;
            return F ? d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {
                    onClose: I
                }, "header"), d.jsx(Oi, {
                    style: {
                        marginBottom: "1.5rem"
                    },
                    children: d.jsx(hd, {})
                }), d.jsx(Cr, {
                    children: "Transaction Protection"
                }), d.jsx(Ar, {
                    children: "Set up transaction protection to add an extra layer of security to your account"
                }), d.jsxs(Zy, {
                    children: [d.jsxs(co, {
                        children: [d.jsx(oo, {
                            children: d.jsx(VL, {})
                        }), "Enable 2-Step verification for your ", f == null ? void 0 : f.name, " wallet."]
                    }), d.jsxs(co, {
                        children: [d.jsx(oo, {
                            children: d.jsx(Q_e, {})
                        }), "You'll be prompted to authenticate to complete transactions."]
                    })]
                }), d.jsxs(Bo, {
                    children: [d.jsx(Qe, {
                        onClick: () => x(!0),
                        children: "Continue"
                    }), d.jsx(po, {
                        onClick: I,
                        children: "Not now"
                    })]
                }), d.jsx(Wt, {})]
            }) : E === "sms" ? d.jsx(fPe, {
                appName: (f == null ? void 0 : f.name) || "Privy",
                onComplete: I,
                onReset: U,
                onClose: I
            }) : E === "totp" && b ? d.jsx(gPe, {
                onClose: I,
                onReset: U,
                submitEnrollmentWithTotp: ({
                    mfaCode: W
                }) => async function(K) {
                    var H;
                    try {
                        return P(void 0), await c({
                            mfaCode: K
                        }), (H = p == null ? void 0 : p.mfaEnrollmentFlow) == null || H.onSuccess(), I()
                    } catch (j) {
                        P(j)
                    } finally {
                        i(null)
                    }
                }(W),
                totpInfo: { ...b,
                    appName: (f == null ? void 0 : f.name) || "Privy"
                }
            }) : E === "passkey" ? d.jsx(aPe, {
                onReset: U,
                onClose: I,
                submitEnrollmentWithPasskey: k
            }) : d.jsx(iPe, {
                showIntro: F,
                userMfaMethods: t.mfaMethods,
                appMfaMethods: f.mfa.methods,
                userHasAuthSms: R,
                onBackToIntro: function() {
                    x(!1)
                },
                handleSelectMethod: async function(W) {
                    try {
                        await y()
                    } catch (K) {
                        return void P(K)
                    }
                    return W === "totp" ? (_(W), A(null), void h().then(K => {
                        A(K)
                    }).catch(() => {
                        A(null), U()
                    })) : W === "passkey" && M.length === 1 ? await k() : void _(W)
                },
                isTotpLoading: E === "totp" && !b,
                isPasskeyLoading: T,
                error: $,
                onClose: I,
                setRemovingMfaMethod: async W => {
                    try {
                        await y()
                    } catch (K) {
                        return void P(K)
                    }
                    i(W)
                }
            })
        }
    },
    yPe = {
        component: () => {
            var T;
            let {
                authenticated: t,
                logout: e,
                ready: r,
                user: n
            } = $t(), {
                app: i,
                setModalData: s,
                navigate: a,
                resetNavigation: o
            } = Ne(), {
                getAuthMeta: c,
                initLoginWithOAuth: l,
                loginWithOAuth: u,
                updateWallets: h,
                setReadyToTrue: f,
                closePrivyModal: p,
                createAnalyticsEvent: g
            } = $e(), [m, y] = v.useState(!1), [w, x] = v.useState(void 0), E = ((T = c()) == null ? void 0 : T.provider) || "google", {
                name: _,
                component: b
            } = pv(E);
            v.useEffect(() => {
                u(E).then(() => {
                    y(!0), f(!0)
                }).catch(C => {
                    var N, R, D, S, O, M, U, k, F, q, W, K, H, j, V, Y;
                    if (f(!1), (C == null ? void 0 : C.privyErrorCode) === ee.ALLOWLIST_REJECTED) return x(void 0), o(), void a(dw);
                    if ((C == null ? void 0 : C.privyErrorCode) === ee.USER_LIMIT_REACHED) return console.error(new l0(C).toString()), x(void 0), o(), void a(F0);
                    if ((C == null ? void 0 : C.privyErrorCode) === ee.USER_DOES_NOT_EXIST) return x(void 0), o(), void a(D0);
                    if ((C == null ? void 0 : C.privyErrorCode) === ee.ACCOUNT_TRANSFER_REQUIRED && ((R = (N = C.data) == null ? void 0 : N.data) != null && R.nonce)) return x(void 0), o(), s({
                        accountTransfer: {
                            nonce: (S = (D = C.data) == null ? void 0 : D.data) == null ? void 0 : S.nonce,
                            account: (M = (O = C.data) == null ? void 0 : O.data) == null ? void 0 : M.subject,
                            displayName: (F = (k = (U = C.data) == null ? void 0 : U.data) == null ? void 0 : k.account) == null ? void 0 : F.displayName,
                            linkMethod: (q = c()) == null ? void 0 : q.provider,
                            embeddedWalletAddress: (H = (K = (W = C.data) == null ? void 0 : W.data) == null ? void 0 : K.otherUser) == null ? void 0 : H.embeddedWalletAddress,
                            oAuthUserInfo: (Y = (V = (j = C.data) == null ? void 0 : j.data) == null ? void 0 : V.otherUser) == null ? void 0 : Y.oAuthUserInfo
                        }
                    }), void a(qd);
                    let {
                        retryable: $,
                        detail: P
                    } = function(X, ne) {
                        let ae = {
                                detail: "",
                                retryable: !1
                            },
                            ue = eU(ne);
                        if ((X == null ? void 0 : X.privyErrorCode) === ee.LINKED_TO_ANOTHER_USER && (ae.detail = "This account has already been linked to another user."), (X == null ? void 0 : X.privyErrorCode) === ee.INVALID_CREDENTIALS && (ae.retryable = !0, ae.detail = "Something went wrong. Try again."), X.privyErrorCode === ee.OAUTH_USER_DENIED && (ae.detail = `Retry and check ${ue} to finish connecting your account.`, ae.retryable = !0), (X == null ? void 0 : X.privyErrorCode) === ee.TOO_MANY_REQUESTS && (ae.detail = "Too many requests. Please wait before trying again."), (X == null ? void 0 : X.privyErrorCode) === ee.TOO_MANY_REQUESTS && X.message.includes("provider rate limit")) {
                            let he = pv(ne).name;
                            ae.detail = `Request limit reached for ${he}. Please wait a moment and try again.`
                        }
                        if ((X == null ? void 0 : X.privyErrorCode) === ee.OAUTH_ACCOUNT_SUSPENDED) {
                            let he = pv(ne).name;
                            ae.detail = `Your ${he} account is suspended. Please try another login method.`
                        }
                        return (X == null ? void 0 : X.privyErrorCode) === ee.CANNOT_LINK_MORE_OF_TYPE && (ae.detail = "You cannot authorize more than one account for this user."), (X == null ? void 0 : X.privyErrorCode) === ee.OAUTH_UNEXPECTED && ne.startsWith("privy:") && (ae.detail = "Something went wrong. Please try again."), ae
                    }(C, E);
                    x({
                        retryable: $,
                        detail: P,
                        message: "Authentication failed"
                    })
                }).finally(() => {
                    p4()
                })
            }, [_, E]), v.useEffect(() => {
                if (r && t && m && n) {
                    if (i != null && i.legal.requireUsersAcceptTerms && !n.hasAcceptedTerms) {
                        let C = setTimeout(() => {
                            a(Hd)
                        }, Ir);
                        return () => clearTimeout(C)
                    }
                    if (yl(n, i.embeddedWallets)) {
                        let C = setTimeout(() => {
                            s({
                                createWallet: {
                                    onSuccess: () => {},
                                    onFailure: $ => {
                                        console.error($), g({
                                            eventName: "embedded_wallet_creation_failure_logout",
                                            payload: {
                                                error: $,
                                                provider: E,
                                                screen: "OAuthStatusScreen"
                                            }
                                        }), e()
                                    },
                                    callAuthOnSuccessOnClose: !0
                                }
                            }), a(bc)
                        }, Ir);
                        return () => clearTimeout(C)
                    } {
                        let C = setTimeout(() => p({
                            shouldCallAuthOnSuccess: !0,
                            isSuccess: !0
                        }), Ir);
                        return h(), () => clearTimeout(C)
                    }
                }
            }, [r, t, m, n]);
            let A = m ? `Successfully connected with ${_}` : w ? w.message : `Verifying connection to ${_}`,
                I = "";
            return I = m ? "You’re good to go!" : w ? w.detail : "Just a few moments more", d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {}), d.jsx(er, {}), d.jsxs(wPe, {
                    children: [d.jsx(Fi, {
                        children: d.jsxs("div", {
                            children: [d.jsx(Ia, {
                                success: m,
                                fail: !!w
                            }), d.jsx(b, {
                                style: {
                                    width: "38px",
                                    height: "38px"
                                }
                            })]
                        })
                    }), d.jsxs(ls, {
                        children: [d.jsx("h3", {
                            children: A
                        }), d.jsx("p", {
                            children: I
                        })]
                    }), w && (w != null && w.retryable) ? d.jsx(b8, {
                        onClick: () => {
                            p4(), l(E), x(void 0)
                        },
                        disabled: !m && !(w != null && w.retryable),
                        children: "Retry"
                    }) : null]
                }), d.jsx(nr, {}), d.jsx(Wt, {})]
            })
        }
    };
let wPe = z.div.withConfig({
    displayName: "ConnectContainer",
    componentId: "sc-89bb91a9-0"
})(["display:flex;flex-direction:column;align-items:center;justify-content:center;margin-left:27px;margin-right:27px;gap:24px;"]);
const bPe = v.forwardRef((t, e) => {
    let [r, n] = v.useState(""), [i, s] = v.useState(""), [a, o] = v.useState(!1), {
        authenticated: c,
        user: l
    } = $t(), {
        initUpdateEmail: u
    } = $e(), {
        navigate: h,
        setModalData: f,
        currentScreen: p
    } = Ne(), {
        enabled: g,
        token: m
    } = qi(), y = Gt(), w = pU(r) && (y.disablePlusEmails && r.includes("+") ? (i || s("Please enter a valid email address without a '+'."), !1) : (i && s(""), !0)), x = a || !w, E = () => {
        !g || m || c ? (async _ => {
            if (!(l != null && l.email)) throw Error("User is required to have an email address to update it.");
            o(!0);
            try {
                await u({
                    oldAddress: l.email.address,
                    newAddress: r,
                    captchaToken: _
                }), h(uc)
            } catch (b) {
                f({
                    errorModalData: {
                        error: b,
                        previousScreen: p || Xn
                    }
                })
            }
            o(!1)
        })(m) : (f({
            captchaModalData: {
                callback: _ => {
                    if (!(l != null && l.email)) throw Error("User is required to have an email address to update it.");
                    return u({
                        oldAddress: l.email.address,
                        newAddress: r,
                        captchaToken: _
                    })
                },
                userIntentRequired: !1,
                onSuccessNavigateTo: uc,
                onErrorNavigateTo: Sr
            }
        }), h(Sa))
    };
    return d.jsxs(d.Fragment, {
        children: [d.jsxs(vPe, {
            children: [i && d.jsx(dc, {
                style: {
                    marginTop: "0.25rem",
                    textAlign: "left"
                },
                children: i
            }), d.jsxs(xPe, {
                $error: !!i,
                children: [d.jsx(Ld, {}), d.jsx("input", {
                    ref: e,
                    id: "email-input",
                    type: "email",
                    placeholder: "your@email.com",
                    onChange: _ => n(_.target.value),
                    onKeyUp: _ => {
                        _.key === "Enter" && E()
                    },
                    value: r,
                    autoComplete: "email"
                }), t.stacked ? null : d.jsx(j0, {
                    isSubmitting: a,
                    onClick: E,
                    disabled: x,
                    children: "Submit"
                })]
            })]
        }), t.stacked ? d.jsx(Qe, {
            loadingText: null,
            loading: a,
            disabled: x,
            onClick: E,
            children: "Submit"
        }) : null]
    })
});
let vPe = BF,
    xPe = FF;
const EPe = {
        component: () => d.jsxs(d.Fragment, {
            children: [d.jsx(Pe, {}, "header"), d.jsx(er, {}), d.jsx($r, {
                title: "Update your email",
                description: "Add the email address you'd like to use going forward. We'll send you a confirmation code",
                icon: d.jsx(Ld, {
                    color: "var(--privy-color-accent)",
                    strokeWidth: 2,
                    height: "48px",
                    width: "48px"
                })
            }), d.jsx(zd, {
                children: d.jsx(bPe, {
                    stacked: !0
                })
            }), d.jsx(nr, {}), d.jsx(ot, {})]
        })
    },
    _Pe = {
        component: () => {
            let {
                currentScreen: t,
                data: e,
                navigate: r,
                setModalData: n
            } = Ne(), {
                user: i
            } = $t(), {
                initUpdatePhone: s
            } = $e();
            return d.jsxs(d.Fragment, {
                children: [d.jsx(Pe, {}, "header"), d.jsx(er, {}), d.jsx($r, {
                    title: "Update your phone number",
                    description: "Add the phone number you'd like to use going forward. We'll send you a confirmation code",
                    icon: d.jsx(Ca, {
                        color: "var(--privy-color-accent)",
                        strokeWidth: 2,
                        height: "48px",
                        width: "48px"
                    })
                }), d.jsx(zd, {
                    children: d.jsx(fw, {
                        stacked: !0,
                        onSubmit: async function({
                            qualifiedPhoneNumber: a
                        }) {
                            var o, c, l;
                            try {
                                if (!((o = i == null ? void 0 : i.phone) != null && o.number)) throw Error("User is required to have an phone number to update it.");
                                await s((c = i == null ? void 0 : i.phone) == null ? void 0 : c.number, a), r(uc)
                            } catch (u) {
                                n({
                                    errorModalData: {
                                        error: u,
                                        previousScreen: ((l = e == null ? void 0 : e.errorModalData) == null ? void 0 : l.previousScreen) || t || B8
                                    }
                                }), r(Sr)
                            }
                        },
                        hideRecent: !0
                    })
                }), d.jsx(nr, {}), d.jsx(ot, {})]
            })
        }
    };

function CPe({
    subscribe: t,
    getExternalJwt: e,
    enabled: r = !0,
    onAuthenticated: n,
    onUnauthenticated: i,
    onError: s
}) {
    let {
        client: a,
        onCustomAuthAuthenticated: o
    } = $e(), {
        logout: c,
        authenticated: l,
        ready: u
    } = mw();
    if (!a) throw new J("`useSyncJwtBasedAuthState` must be used within a `PrivyProvider`");
    let [h, f] = v.useState({
        status: "initial"
    }), p = v.useRef(), g = v.useRef(!1), m = v.useRef(e);
    v.useEffect(() => {
        m.current = e
    }, [e]);
    let y = v.useRef(n);
    v.useEffect(() => {
        y.current = n
    }, [n]);
    let w = v.useRef(i);
    v.useEffect(() => {
        w.current = i
    }, [i]);
    let x = v.useRef(s);
    return v.useEffect(() => {
        x.current = s
    }, [s]), v.useEffect(() => {
        if (!r || !u) return;
        let E = async () => {
            var _, b, A, I;
            if (!g.current) {
                g.current = !0;
                try {
                    f({
                        status: "loading"
                    });
                    let T = await m.current();
                    if (p.current !== void 0 && p.current === T) return void f({
                        status: "done"
                    });
                    if (!T) return l && (await c(), (_ = w.current) == null || _.call(w)), p.current = T, void f({
                        status: "done"
                    });
                    a.startAuthFlow(new PU(T));
                    let {
                        user: C,
                        isNewUser: $ = !1
                    } = await a.authenticate();
                    if (!C) throw new J("Failed to sync with custom auth provider");
                    (b = y.current) == null || b.call(y, {
                        user: C,
                        isNewUser: $
                    }), o(C, $), p.current = T, f({
                        status: "done"
                    })
                } catch (T) {
                    if (console.warn(T), await c().catch(() => {}), (A = w.current) == null || A.call(w), T instanceof es && T.privyErrorCode === ee.LINKED_TO_ANOTHER_USER) return f({
                        status: "initial"
                    }), void setTimeout(() => {
                        E()
                    }, 0);
                    (I = x.current) == null || I.call(x, T), f({
                        status: "error",
                        error: T
                    })
                } finally {
                    g.current = !1
                }
            }
        };
        return E(), t(E)
    }, [t, a, o, l, c, r, u]), r ? {
        state: h
    } : {
        state: {
            status: "not-enabled"
        }
    }
}
let APe = vh(() => ({
    jwtAuthFlowState: {
        status: "not-enabled"
    }
}));

function kPe({
    customAuth: t
}) {
    let {
        jwtAuthFlowState: e
    } = function({
        customAuth: r
    }) {
        let n = yc(),
            i = v.useRef(),
            s = v.useCallback(c => (i.current = c, () => {
                i.current = void 0
            }), []),
            a = (r == null ? void 0 : r.getCustomAccessToken) ? ? (() => Promise.resolve(void 0)),
            {
                state: o
            } = CPe({
                enabled: (r == null ? void 0 : r.enabled) === !0,
                subscribe: s,
                getExternalJwt: a,
                onAuthenticated: ({
                    user: c,
                    isNewUser: l
                }) => {
                    n("login", "onComplete", {
                        user: c,
                        isNewUser: l,
                        wasAlreadyAuthenticated: !1,
                        loginMethod: "custom",
                        loginAccount: null
                    }), n("customAuth", "onAuthenticated", {
                        user: c
                    })
                },
                onUnauthenticated: () => {
                    n("customAuth", "onUnauthenticated")
                },
                onError: c => {
                    n("login", "onError", c.privyErrorCode || ee.UNKNOWN_AUTH_ERROR)
                }
            });
        return v.useEffect(() => {
            (async () => {
                var c;
                r && !r.isLoading && ((c = i.current) == null || c.call(i))
            })()
        }, [r == null ? void 0 : r.enabled, r == null ? void 0 : r.getCustomAccessToken, r == null ? void 0 : r.isLoading]), {
            jwtAuthFlowState: o
        }
    }({
        customAuth: t
    });
    return v.useEffect(() => {
        APe.setState({
            jwtAuthFlowState: e
        })
    }, [e]), null
}
const qB = v.createContext(!1);
let Jc, HB, VB, GB, KB, YB, ZB;

function Tje() {
    return Jc ? Jc.getCustomerAccessToken() : Promise.resolve(rt.get(Nu) || null)
}
async function ir() {
    return Jc ? Jc.getAccessToken() : Promise.resolve(rt.get(sm) || rt.get(Nu) || null)
}
const IPe = (t, e) => HB(t, e),
    $Pe = (t, e) => VB(t, e),
    SPe = (t, e) => GB(t, e),
    TPe = (t, e) => KB(t, e),
    PPe = t => YB(t),
    NPe = t => ZB(t),
    Pje = ({
        config: t,
        ...e
    }) => {
        var r;
        if ((() => {
                if (v.useContext(qB)) throw new J("Multiple PrivyProvider instances found", "Found multiple instances of PrivyProvider, ensure there is only one mounted in your application tree.")
            })(), typeof window < "u" && 0 > ["localhost", "127.0.0.1"].indexOf(window.location.hostname) && window.location.protocol !== "https:") throw new J("Embedded wallet is only available over HTTPS");
        if (typeof(r = e.appId) != "string" || r.length !== 25) throw new J("Cannot initialize the Privy provider with an invalid Privy app ID");
        Jc || (Jc = new V9e({
            appId: e.appId,
            appClientId: e.clientId,
            apiUrl: e.apiUrl
        }));
        let n = Object.assign({}, t),
            i = v.useMemo(() => new qre({
                appId: e.appId,
                clientId: e.clientId,
                storage: rt,
                baseUrl: e.apiUrl,
                sdkVersion: "react-auth:2.21.0"
            }), []);
        return d.jsx(O9e, {
            client: i,
            legacyClient: Jc,
            clientConfig: n,
            children: d.jsx(Mke, {
                children: d.jsx(OPe, { ...e,
                    client: Jc,
                    privy: i
                })
            })
        })
    };
let OPe = t => {
    var Fn;
    let e = t.client,
        r = t.privy,
        n = Rh();
    xAe();
    let [i, s] = v.useState(!1), [a, o] = v.useState(!1), [c, l] = v.useState(!1), [u, h] = v.useState(null), [f, p] = v.useState([]), [g, m] = v.useState([]), [y, w] = v.useState(void 0), [x, E] = v.useState(!1), [_, b] = v.useState(null), [A, I] = v.useState(!1), [T, C] = v.useState({
        status: "disconnected",
        connectedWallet: null,
        connectError: null,
        connector: null,
        connectRetry: le
    }), [$, P] = v.useState({
        status: "initial"
    }), [N, R] = v.useState({
        status: "initial"
    }), [D, S] = v.useState({
        status: "initial"
    }), [O, M] = v.useState({
        status: "initial"
    }), [U, k] = v.useState({
        status: "initial"
    }), [F, q] = v.useState({
        status: "initial"
    }), [W, K] = v.useState(null), H = Gt(), j = SU(), [V, Y] = v.useState({}), [X, ne] = v.useState(null), ae = v.useRef(null), [ue, he] = v.useState(!1), [fe, de] = v.useState(!1), ye = v.useRef(null), Be = v.useRef(null), ce = v.useRef(Z9e), [Ie, xe] = v.useState(!1);
    e.onStoreCustomerAccessToken = L => {
        L && _e(ce, "accessToken", "onAccessTokenGranted", {
            accessToken: L
        })
    }, e.onDeleteCustomerAccessToken = () => {
        h(null), l(!1), _e(ce, "accessToken", "onAccessTokenRemoved")
    };
    let ie = v.useRef(null),
        Ee = v.useRef(null),
        ft = v.useRef(!1),
        Ae = ({
            showWalletUIs: L
        }) => ft.current ? ft.current : L !== void 0 ? !L : !H.embeddedWallets.showWalletUIs,
        Le = L => {
            b(L), setTimeout(() => {
                s(!0)
            }, 15)
        };
    v.useEffect(() => {
        var G, re, se;
        if (!u) return void((G = e.connectors) == null ? void 0 : G.removeEmbeddedWalletConnectors());
        let L = Xa(u),
            B = uO(u),
            Q = R3(u);
        L && B.length || ((re = e.connectors) == null || re.removeEmbeddedWalletConnectors()), Q || ((se = e.connectors) == null || se.removeImportedWalletConnector()), e.connectors ? W ? (L && e.connectors.addEmbeddedWalletConnectors({
            walletProxy: W,
            user: u,
            embeddedWallets: B,
            defaultChain: H.defaultChain,
            appId: t.appId,
            privyClient: r
        }), Q && e.connectors.addImportedWalletConnector(W, Q.address, H.defaultChain, t.appId)) : console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized") : console.debug("Failed to add embedded wallet connector: Client connectors not initialized")
    }, [W, u]), v.useEffect(() => {
        var L;
        W && ((L = ae.current) == null || L.call(ae, W))
    }, [W]);
    let Te = v.useCallback((L, B) => {
        h(L), E(B), l(!0), de(!0)
    }, []);
    v.useEffect(() => {
        fe && W && u && (async () => {
            var G;
            let L = O8(u, H.embeddedWallets.ethereum.createOnLogin),
                B = j8(u, H.embeddedWallets.solana.createOnLogin),
                Q = await ir();
            if (Q) {
                if (L && B) {
                    let re = await W.create({
                        accessToken: Q
                    });
                    return await W.createSolana({
                        accessToken: Q,
                        ethereumAddress: re == null ? void 0 : re.address
                    }), void de(!1)
                }
                if (B) return await W.createSolana({
                    accessToken: Q,
                    ethereumAddress: (G = Xa(u)) == null ? void 0 : G.address
                }), await pt.refreshSessionAndUser(), void de(!1);
                if (L) return await W.create({
                    accessToken: Q
                }), void de(!1)
            }
        })().catch(console.error)
    }, [fe && W && u]), v.useEffect(() => {
        if (H.externalWallets.solana.connectors) return H.externalWallets.solana.connectors.onMount(), () => {
            var L;
            return (L = H.externalWallets.solana.connectors) == null ? void 0 : L.onUnmount()
        }
    }, [H.externalWallets.solana.connectors]), v.useEffect(() => {
        !a && j && async function() {
            var me, ve, Ze;
            let L, B = Ue(),
                Q = De(),
                G = qW();
            e.initializeConnectorManager({
                walletConnectCloudProjectId: H.walletConnectCloudProjectId,
                rpcConfig: H.rpcConfig,
                chains: H.chains,
                defaultChain: H.defaultChain,
                store: G,
                walletList: H.appearance.walletList,
                shouldEnforceDefaultChainOnConnect: H.shouldEnforceDefaultChainOnConnect,
                externalWalletConfig: H.externalWallets,
                appName: H.name ? ? "Privy",
                walletChainType: H.appearance.walletChainType,
                appKit: H.externalWallets.walletConnect.appKit,
                setBaseAccountSdk: w
            }), (me = e.connectors) == null || me.on("connectorInitialized", () => {
                L && clearTimeout(L);
                let kt = e.connectors.walletConnectors.length,
                    Re = e.connectors.walletConnectors.reduce((ct, it) => ct + (it.initialized ? 1 : 0), 0);
                Re === kt ? xe(!0) : L = setTimeout(() => {
                    console.debug({
                        message: "Unable to initialize all expected connectors before timeout",
                        initialized: Re,
                        expected: kt
                    }), xe(!0)
                }, 1500)
            }), (ve = e.connectors) == null || ve.initialize().then(() => {
                Ye()
            });
            let re = await e.getAuthenticatedUser(),
                se = !!re;
            H.legal.requireUsersAcceptTerms && re && !re.hasAcceptedTerms ? (await e.logout(), pt.setReadyToTrue(!0), _e(ce, "logout", "onSuccess")) : ((Ze = H.customAuth) != null && Ze.enabled || (l(!!re), re && _e(ce, "login", "onComplete", {
                user: re,
                isNewUser: !1,
                wasAlreadyAuthenticated: !0,
                loginMethod: null,
                loginAccount: null
            }), h(re)), B ? Ee.current = se ? "link" : "login" : Q && !se ? (Ee.current = "login", Y({
                telegramAuthModalData: {
                    seamlessAuth: !0
                }
            }), Le(hm)) : pt.setReadyToTrue(!!re))
        }()
    }, [e, X, a, j]), v.useEffect(() => {
        if (a) {
            if (!u || !u.linkedAccounts.find(L => L.type === "wallet" && L.walletClientType === "privy")) return void he(!!W);
            if ([...f].some(L => L.walletClientType === "privy")) return void he(!0);
            he(!!W)
        }
    }, [a, u, f, W]), v.useEffect(() => {
        var L;
        (L = e.connectors) == null || L.setWalletList(H.appearance.walletList)
    }, [H.appearance.walletList.join()]);
    let Ue = () => {
            let L = l9e();
            return L.inProgress && L.popupFlow ? window.opener.location.origin !== window.location.origin ? void window.opener.postMessage({
                type: "PRIVY_OAUTH_ERROR",
                error: "Origins between parent and child windows do not match."
            }) : L.authorizationCode === "error" ? void window.opener.postMessage({
                type: "PRIVY_OAUTH_ERROR",
                error: "Something went wrong. Try again."
            }) : void window.opener.postMessage({
                type: "PRIVY_OAUTH_RESPONSE",
                stateCode: L.stateCode,
                authorizationCode: L.authorizationCode
            }) : (L.inProgress && function(B) {
                return B.startsWith("privy:")
            }(L.provider) && !L.popupFlow && (new BroadcastChannel(S$).postMessage({
                type: "PRIVY_OAUTH_RESPONSE",
                stateCode: L.stateCode,
                authorizationCode: L.authorizationCode
            }), window.close()), !!L.inProgress && !!L.withPrivyUi && (e.startAuthFlow(new Au(L)), Le(yPe), !0))
        },
        De = () => {
            var Q;
            let L = function() {
                let G;
                return (G = function() {
                    let re = new URLSearchParams(window.location.search),
                        se = Number(re.get("id") || ""),
                        me = re.get("hash"),
                        ve = Number(re.get("auth_date") || ""),
                        Ze = re.get("first_name");
                    if (se && Ze && ve && me) return Object.fromEntries(re.entries())
                }()) ? (o$(), {
                    flowType: "login-url",
                    authData: G
                }) : (G = function() {
                    let re = window.location.hash;
                    if (!re || !re.startsWith("#tgWebAppData")) return;
                    let se = a$(re.replace("#tgWebAppData=", "")),
                        {
                            user: me,
                            auth_date: ve,
                            hash: Ze
                        } = se;
                    return me && ve && Ze ? se : void 0
                }()) ? (o$(), {
                    flowType: "web-app",
                    authData: G
                }) : void 0
            }();
            if (!L || !H.loginMethods.telegram || !((Q = H.loginConfig.telegramAuthConfiguration) != null && Q.seamlessAuthEnabled)) return;
            let B = new hf;
            return e.startAuthFlow(B), L.flowType === "login-url" && (B.meta.telegramWebAppData = void 0, B.meta.telegramAuthResult = L.authData), L.flowType === "web-app" && (B.meta.telegramAuthResult = void 0, B.meta.telegramWebAppData = L.authData), !0
        },
        We = async (L, B, Q, G) => {
            var re, se;
            if (L !== "solana_adapter") dt(await ((re = e.connectors) == null ? void 0 : re.createEthereumWalletConnector({
                connectorType: L,
                walletClientType: B
            })) || null, B, Q, G);
            else {
                let me = (se = e.connectors) == null ? void 0 : se.findSolanaWalletConnector(B);
                if (!me) return;
                dt(me, B, Q, G)
            }
        };
    async function dt(L, B, Q, G) {
        if (!L) return C({
            status: "disconnected",
            connectedWallet: null,
            connectError: new br("Unable to connect to wallet."),
            connector: null,
            connectRetry: le
        }), G == null ? void 0 : G(null, Q);
        C({
            status: "disconnected",
            connectedWallet: null,
            connectError: null,
            connector: L,
            connectRetry: le
        }), L instanceof Vu && B && await L.resetConnection(B), C({
            connector: L,
            status: "connecting",
            connectedWallet: null,
            connectError: null,
            connectRetry: () => dt(L, B, Q, G)
        });
        try {
            let re = await L.connect({
                showPrompt: !0
            });
            if ((!re || Uo(re)) && H.shouldEnforceDefaultChainOnConnect && !H.chains.find(se => se.id === Number(re == null ? void 0 : re.chainId.replace("eip155:", ""))) && ((re == null ? void 0 : re.connectorType) !== "wallet_connect_v2" || (re == null ? void 0 : re.walletClientType) !== "metamask")) {
                C(se => ({ ...se,
                    connector: L,
                    status: "switching_to_supported_chain",
                    connectedWallet: null,
                    connectError: null,
                    connectRetry: le
                }));
                try {
                    await (re == null ? void 0 : re.switchChain(H.defaultChain.id)), re && (re.chainId = am(cn(H.defaultChain.id)))
                } catch {
                    console.warn(`Unable to switch to default chain: ${H.defaultChain.id}`)
                }
            }
            return C(se => ({ ...se,
                status: "connected",
                connectedWallet: re,
                connectError: null,
                connectRetry: le
            })), re && _e(ce, "connectWallet", "onSuccess", {
                wallet: re
            }), G == null ? void 0 : G(re, Q)
        } catch (re) {
            return re instanceof Qn ? (console.warn(re.cause ? re.cause : re.message), _e(ce, "connectWallet", "onError", re.privyErrorCode || ee.GENERIC_CONNECT_WALLET_ERROR)) : (console.warn(re), _e(ce, "connectWallet", "onError", ee.UNKNOWN_CONNECT_WALLET_ERROR)), C(se => ({ ...se,
                status: "disconnected",
                connectedWallet: null,
                connectError: re
            })), G == null ? void 0 : G(null, Q)
        }
    }
    let He = async (L, B, Q) => {
            if (L === null || !Uo(L)) return;
            let G = new qu(e, L, B, Q);
            e.startAuthFlow(G)
        },
        ut = async (L, B, Q, G = "plain") => {
            let re = n(zF);
            if (G === "transaction" && !re) throw new J("useSolanaLedger plugin hook must be mounted");
            if (L === null || !u$(L)) return;
            let se = new c1(L, e, B, Q, G, re ? {
                deserializeTransactionFromB64String: re.deserializeTransactionFromB64String,
                prepareSiwsTransactionWithMemo: re.prepareSiwsTransactionWithMemo
            } : void 0);
            e.startAuthFlow(se)
        },
        Ye = () => {
            let L = new URLSearchParams(window.location.search),
                B = L.get("privy_connector"),
                Q = L.get("privy_wallet_client"),
                G = L.get("privy_connect_only") === "true";
            if (!B || !Q) return;
            let re = AU({
                connectorType: B,
                walletClientType: Q
            });
            if (!re || !re.isInstalled) return Le(tPe);
            if (!e.connectors) throw new J("Connector not initialized");
            Le(G ? M4 : Yo);
            let se = new URL(window.location.href);
            se.searchParams.delete("privy_connector"), se.searchParams.delete("privy_wallet_client"), se.searchParams.delete("privy_connect_only"), window.history.pushState({}, "", se), We(B, Q, void 0, G ? void 0 : B === "solana_adapter" ? ut : He)
        };
    v.useEffect(() => {
        a && c && u === null && e.getAuthenticatedUser().then(h)
    }, [a, c, u, e]);
    let we = L => {
            if (!c) throw _e(ce, "linkAccount", "onError", ee.MUST_BE_AUTHENTICATED, {
                linkMethod: L
            }), new J("User must be authenticated before linking an account.")
        },
        vt = L => {
            if (!c || !u) return !1;
            if (L.walletClientType === "privy") return !0;
            for (let B of u.linkedAccounts)
                if (B.type === "wallet" && B.address === L.address && B.walletClientType !== "privy") return !0;
            return !1
        },
        Lt = async L => {
            let B;
            if (!e.connectors) throw new J("Connector not initialized");
            B = L.type === "ethereum" ? e.connectors.findWalletConnector(L.connectorType, L.walletClientType) || null : e.connectors.findSolanaWalletConnector(L.walletClientType) || null, C(Q => ({ ...Q,
                connector: B,
                status: "connected",
                connectedWallet: L,
                connectError: null,
                connectRetry: le
            })), H.captchaEnabled && !c ? (Y({
                captchaModalData: {
                    callback: Q => Uo(L) ? He(L, Q) : ut(L, Q),
                    userIntentRequired: !1,
                    onSuccessNavigateTo: Yo,
                    onErrorNavigateTo: Sr
                }
            }), Le(Sa)) : (Uo(L) ? await He(L) : await ut(L), Le(Yo))
        },
        _t = () => {
            p(L => {
                var Q;
                let B = ((Q = e.connectors) == null ? void 0 : Q.wallets.filter(Uo).map(G => ({ ...G,
                    linked: vt(G),
                    loginOrLink: async () => {
                        if (!await G.isConnected()) throw new J("Wallet is not connected");
                        if (G.connectorType === "embedded" && G.walletClientType === "privy") throw new J("Cannot link or login with embedded wallet");
                        Lt(G)
                    },
                    fund: async re => {
                        await pt.fundWallet(G.address, re)
                    },
                    unlink: async () => {
                        if (!c) throw new J("User is not authenticated.");
                        if (G.connectorType === "embedded" && G.walletClientType === "privy") throw new J("Cannot unlink an embedded wallet");
                        h(await e.unlinkEthereumWallet(G.address))
                    }
                }))) || [];
                return w4(L, B) ? L : B
            }), m(L => {
                var Q;
                let B = (((Q = e.connectors) == null ? void 0 : Q.wallets) ? ? []).filter(u$).map(G => ({ ...G,
                    linked: vt(G),
                    loginOrLink: async () => {
                        if (!await G.isConnected()) throw new J("Wallet is not connected");
                        if (G.connectorType === "embedded" && G.walletClientType === "privy") throw new J("Cannot link or login with embedded wallet");
                        Lt(G)
                    },
                    fund: async () => {
                        throw new J("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")
                    },
                    unlink: async () => {
                        if (!c) throw new J("User is not authenticated.");
                        if (G.connectorType === "embedded" && G.walletClientType === "privy") throw new J("Cannot unlink an embedded wallet");
                        h(await e.unlinkSolanaWallet(G.address))
                    }
                }));
                return w4(L, B) ? L : B
            })
        };
    v.useEffect(() => {
        _t()
    }, [u == null ? void 0 : u.linkedAccounts, c, a]), v.useEffect(() => {
        if (a) {
            if (!e.connectors) throw new J("Connector not initialized");
            _t(), e.connectors.on("walletsUpdated", _t)
        }
    }, [a]), v.useEffect(() => {
        var L, B;
        [...((L = H.loginMethodsAndOrder) == null ? void 0 : L.primary) ? ? [], ...((B = H.loginMethodsAndOrder) == null ? void 0 : B.overflow) ? ? []].filter(Q => Q.startsWith("privy:")).forEach(Q => e.getCrossAppProviderDetails(Q.replace("privy:", "")))
    }, [!!e]);
    let tr = ({
        transaction: L,
        uiOptions: B,
        fundWalletConfig: Q,
        address: G,
        signOnly: re
    }) => new Promise(async (se, me) => {
        let {
            requesterAppId: ve
        } = B || {}, Ze = re ? "signTransaction" : "sendTransaction", kt = G ? $s(u, G) : Xa(u);
        if (!kt && G) {
            let Xe = w2(f, G);
            if (Xe) try {
                let mr = await Xe.getEthereumProvider(),
                    Ut = { ...L,
                        from: G,
                        chainId: L.chainId || Number(Xe.chainId.replace("eip155:", "")),
                        value: L.value !== void 0 ? cn(L.value) : void 0
                    },
                    bi = await mr.request({
                        method: Ze === "sendTransaction" ? "eth_sendTransaction" : "eth_signTransaction",
                        params: [Ut]
                    });
                return _e(ce, Ze, "onSuccess", {
                    hash: bi
                }), void se({
                    hash: bi
                })
            } catch (mr) {
                return _e(ce, Ze, "onError", ee.TRANSACTION_FAILURE), void me(mr ? ? new ni("Unable to " + Ze + mr))
            }
        }
        if (!kt) return _e(ce, Ze, "onError", ee.EMBEDDED_WALLET_NOT_FOUND), void me(new J("No embedded or connected wallet found for address."));
        if (!c || !u) return _e(ce, Ze, "onError", ee.MUST_BE_AUTHENTICATED), void me(Error("User must be authenticated before signing with a Privy wallet"));
        let Re = kt.address,
            ct = kt.walletIndex ? ? 0,
            {
                entropyId: it,
                entropyIdVerifier: lt
            } = Sn(u, kt),
            Se = Un.wallets.find(Xe => Xe.walletClientType === "privy" && Zr(Xe.address) === Zr(Re));
        if (!Se) return _e(ce, Ze, "onError", ee.EMBEDDED_WALLET_NOT_FOUND), void me(Error("Must have a Privy wallet before signing"));
        let yt = await Se.getEthereumProvider(),
            It = await yt.request({
                method: "eth_chainId"
            }),
            Mt = L.chainId ? Number(L.chainId) : uF(It);
        (Xe => {
            if (!H.chains.map(mr => mr.id).includes(Xe)) throw new br(`Chain ID ${Xe} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`, ee.UNSUPPORTED_CHAIN_ID)
        })(Mt);
        let jt = { ...L,
                from: L.from ? ? Re,
                chainId: Mt
            },
            sr = await ir();
        if (!sr || !W) return _e(ce, Ze, "onError", ee.EMBEDDED_WALLET_NOT_FOUND), void me(Error("Must have valid access token and Privy wallet to send transaction"));
        let bt = oh(jt.chainId, H.chains, H.rpcConfig, {
                appId: t.appId
            }),
            St = fn(kt),
            Ge = async ({
                transactionRequest: Xe
            }) => {
                try {
                    let mr;
                    if (!await pt.recoverEmbeddedWallet({
                            address: Re
                        })) throw _e(ce, Ze, "onError", ee.UNKNOWN_CONNECT_WALLET_ERROR), me(Error("Unable to connect to wallet")), Error("Unable to connect to wallet");
                    if (St) {
                        let Ut = Gs => Gs == null ? void 0 : cn(Gs),
                            bi = await Ni(r, async ({
                                message: Gs
                            }) => await W.signWithUserSigner({
                                accessToken: sr,
                                requesterAppId: ve,
                                message: Gs
                            }), {
                                chain_type: "ethereum",
                                method: "eth_signTransaction",
                                params: {
                                    transaction: {
                                        from: Xe.from,
                                        to: Xe.to,
                                        nonce: Ut(Xe.nonce),
                                        chain_id: Ut(Xe.chainId),
                                        data: Jn(Xe.data) ? Xe.data ? Xe.data : cn(Uint8Array.from(Xe.data)) : void 0,
                                        value: Ut(Xe.value),
                                        type: Xe.type,
                                        gas_limit: Ut(Xe.gasLimit ? ? Xe.gas),
                                        gas_price: Ut(Xe.gasPrice ? ? Xe.gas),
                                        max_fee_per_gas: Ut(Xe.maxFeePerGas),
                                        max_priority_fee_per_gas: Ut(Xe.maxPriorityFeePerGas)
                                    }
                                },
                                wallet_id: kt.id
                            });
                        if (!bi.data || !("signed_transaction" in bi.data)) throw new ni("Unable to sign transaction");
                        mr = bi.data.signed_transaction
                    } else mr = await async function({
                        accessToken: Ut,
                        entropyId: bi,
                        entropyIdVerifier: Gs,
                        transactingWalletIndex: Vd,
                        walletProxy: Gd,
                        transactionRequest: ww,
                        requesterAppId: bw
                    }) {
                        return (await Gd.rpc({
                            entropyId: bi,
                            entropyIdVerifier: Gs,
                            hdWalletIndex: Vd ? ? 0,
                            chainType: "ethereum",
                            accessToken: Ut,
                            requesterAppId: bw,
                            request: {
                                method: "eth_signTransaction",
                                params: [ww]
                            }
                        })).response.data
                    }({
                        accessToken: sr,
                        entropyId: it,
                        entropyIdVerifier: lt,
                        transactingWalletIndex: ct,
                        walletProxy: W,
                        transactionRequest: Xe,
                        requesterAppId: ve
                    });
                    if (re) return _e(ce, "signTransaction", "onSuccess", {
                        signature: mr
                    }), mr; {
                        let Ut = await bt.sendRawTransaction({
                            serializedTransaction: mr
                        });
                        return _e(ce, "sendTransaction", "onSuccess", {
                            hash: Ut
                        }), Ut
                    }
                } catch (mr) {
                    throw _e(ce, Ze, "onError", ee.TRANSACTION_FAILURE), mr
                }
            };
        if (Ae({
                showWalletUIs: B == null ? void 0 : B.showWalletUIs
            })) Ge({
            transactionRequest: re ? jt : await f1(jt, bt, jt.from)
        }).then(Xe => {
            re ? _e(ce, "signTransaction", "onSuccess", {
                signature: Xe
            }) : _e(ce, "sendTransaction", "onSuccess", {
                hash: Xe
            }), se({
                hash: Xe
            })
        }).catch(Xe => {
            _e(ce, Ze, "onError", ee.TRANSACTION_FAILURE), me(Xe)
        });
        else {
            let Xe = {
                    connectingWalletAddress: Re,
                    recoveryMethod: kt.recoveryMethod,
                    entropyId: it,
                    entropyIdVerifier: lt,
                    onCompleteNavigateTo: BB,
                    isUnifiedWallet: St,
                    onFailure: Ut => {
                        _e(ce, Ze, "onError", ee.UNKNOWN_CONNECT_WALLET_ERROR), me(Ut)
                    }
                },
                mr = wB(H) ? iS({
                    address: Re,
                    appConfig: H,
                    fundWalletConfig: Q,
                    methodScreen: Ui,
                    chainIdOverride: jt.chainId,
                    comingFromSendTransactionScreen: !0
                }) : void 0;
            Y({
                connectWallet: Xe,
                sendTransaction: {
                    transactionRequest: jt,
                    transactingWalletIndex: ct,
                    transactingWalletAddress: Re,
                    entropyId: it,
                    entropyIdVerifier: lt,
                    signOnly: re,
                    scanTransaction: async () => {
                        var bi, Gs, Vd, Gd;
                        let Ut = await f1(jt, bt, jt.from);
                        return await e.scanTransaction({
                            metadata: {
                                domain: H.embeddedWallets.transactionScanning.domain
                            },
                            chain_id: Ut.chainId.toString(),
                            request: {
                                method: "eth_sendTransaction",
                                params: [{
                                    from: Ut.from,
                                    to: Ut.to,
                                    value: (bi = Ut.value) == null ? void 0 : bi.toString(),
                                    gas: (Gs = Ut.gas) == null ? void 0 : Gs.toString(),
                                    gasPrice: (Vd = Ut.gasPrice) == null ? void 0 : Vd.toString(),
                                    nonce: (Gd = Ut.nonce) == null ? void 0 : Gd.toString(),
                                    data: Ut.data
                                }]
                            }
                        })
                    },
                    onConfirm: ({
                        transactionRequest: Ut
                    }) => Ge({
                        transactionRequest: Ut
                    }),
                    onSuccess: Ut => {
                        re ? _e(ce, "signTransaction", "onSuccess", {
                            signature: Ut.hash
                        }) : _e(ce, "sendTransaction", "onSuccess", {
                            hash: Ut.hash
                        }), se(Ut)
                    },
                    onFailure: Ut => {
                        _e(ce, Ze, "onError", ee.TRANSACTION_FAILURE), me(Ut)
                    },
                    uiOptions: B || {},
                    fundWalletConfig: Q,
                    requesterAppId: ve
                },
                funding: mr
            }), Le(Lc)
        }
    });

    function dr() {
        return new Promise(async (L, B) => {
            let Q = await ir();
            if (!Q || !W) throw Error("Must have valid access token to enroll in MFA");
            try {
                await W.verifyMfa({
                    accessToken: Q
                }), L()
            } catch (G) {
                B(G)
            }
        })
    }
    let Yt = L => L == null ? void 0 : L.linkedAccounts.filter(B => B.latestVerifiedAt !== null && !(B.type === "wallet" && B.walletClientType === "privy")).sort((B, Q) => Q.latestVerifiedAt.getTime() - B.latestVerifiedAt.getTime())[0],
        Ot = L => {
            let B = (u == null ? void 0 : u.linkedAccounts.filter(re => re.type === L).length) ? ? 0,
                {
                    displayName: Q,
                    loginMethod: G
                } = lw(L);
            if (L === "passkey" && B >= 5 || L !== "passkey" && B >= 1) throw _e(ce, "linkAccount", "onError", ee.CANNOT_LINK_MORE_OF_TYPE, {
                linkMethod: G
            }), new J(`User already has an account of type ${Q} linked.`)
        };
    async function mt({
        showAutomaticRecovery: L = !1,
        legacySetWalletPasswordFlow: B = !1
    }) {
        b(null);
        let Q = B ? "setWalletPassword" : "setWalletRecovery";
        if (!c || !u) throw _e(ce, Q, "onError", ee.MUST_BE_AUTHENTICATED), Error("User must be authenticated before adding recovery method to Privy wallet");
        let G = Rs(u);
        if (!G || !W) throw _e(ce, Q, "onError", ee.EMBEDDED_WALLET_NOT_FOUND), Error("Must have a Privy wallet to add a recovery method");
        let re = fn(G);
        if (re) throw _e(ce, Q, "onError", ee.UNSUPPORTED_WALLET_TYPE), new J("User owned wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");
        try {
            await dr()
        } catch (se) {
            throw _e(ce, Q, "onError", ee.MISSING_MFA_CREDENTIALS), se
        }
        return new Promise((se, me) => {
            let ve = G.recoveryMethod === "user-passcode",
                Ze = uB({
                    walletAction: "update",
                    availableRecoveryMethods: H.embeddedWallets.userOwnedRecoveryOptions,
                    legacySetWalletPasswordFlow: B,
                    isResettingPassword: ve,
                    showAutomaticRecovery: L
                }),
                {
                    entropyId: kt,
                    entropyIdVerifier: Re
                } = Sn(u),
                ct = {
                    recoveryMethod: G.recoveryMethod,
                    connectingWalletAddress: G.address,
                    onCompleteNavigateTo: Ze,
                    shouldForceMFA: !1,
                    entropyId: kt,
                    isUnifiedWallet: re,
                    entropyIdVerifier: Re,
                    onFailure: it => {
                        _e(ce, Q, "onError", ee.UNKNOWN_CONNECT_WALLET_ERROR), me(it)
                    }
                };
            Y({
                setWalletPassword: {
                    onSuccess: it => {
                        _e(ce, Q, "onSuccess", {
                            method: "user-passcode",
                            wallet: it
                        }), se(it)
                    },
                    onFailure: it => {
                        _e(ce, Q, "onError", ee.USER_EXITED_SET_PASSWORD_FLOW), me(it)
                    },
                    callAuthOnSuccessOnClose: !1
                },
                recoverWallet: {
                    entropyId: kt,
                    entropyIdVerifier: Re,
                    onFailure: me
                },
                connectWallet: ct,
                recoverySelection: {
                    isInAccountCreateFlow: !1,
                    isResettingPassword: ve,
                    shouldCreateEth: !1,
                    shouldCreateSol: !1
                }
            }), Le(Lc)
        })
    }
    async function ur({
        appId: L,
        action: B
    }) {
        let Q = await ir();
        if (B === "link" && !Q) throw _e(ce, "linkAccount", "onError", ee.MUST_BE_AUTHENTICATED, {
            linkMethod: `privy:${L}`
        }), new J("User must be authenticated before linking an account.");
        if (B === "login" && Q) throw _e(ce, "login", "onError", ee.UNKNOWN_AUTH_ERROR), new J("Attempted to log in, but user is already logged in. Use a `link` helper instead.");
        ie.current = `privy:${L}`, Ee.current = B;
        let G = ew();
        return e.createAnalyticsEvent({
            eventName: "cross_app_auth_started",
            payload: {
                providerAppId: L
            }
        }), new Promise(async (re, se) => {
            let {
                name: me,
                logoUrl: ve
            } = await hF({
                api: e.api,
                providerAppId: L,
                requesterAppId: H.id
            });
            Y({
                crossAppAuth: {
                    appId: L,
                    name: me,
                    logoUrl: ve,
                    action: B,
                    popup: G,
                    onSuccess: re,
                    onError: se
                }
            }), Le(zTe)
        })
    }
    let Vr = {
        ready: a,
        authenticated: c,
        user: u,
        walletConnectors: e.connectors || null,
        connectWallet: L => {
            L && "target" in L && L && (L = void 0), Y({
                externalConnectWallet: {
                    walletList: L != null && L.walletList && (L == null ? void 0 : L.walletList.length) > 0 ? L.walletList : void 0,
                    suggestedAddress: L == null ? void 0 : L.suggestedAddress,
                    walletChainType: L == null ? void 0 : L.walletChainType,
                    description: L == null ? void 0 : L.description
                }
            }), Le(c ? BTe : N4)
        },
        linkWallet: L => {
            L && "target" in L && L && (L = void 0), we("siwe"), ie.current = "siwe", Ee.current = "link", Y({ ...V,
                externalConnectWallet: { ...V.externalConnectWallet,
                    suggestedAddress: L == null ? void 0 : L.suggestedAddress,
                    walletList: L == null ? void 0 : L.walletList,
                    walletChainType: L == null ? void 0 : L.walletChainType,
                    description: L != null && L.suggestedAddress ? d.jsxs("span", {
                        children: ["Link the wallet with address", " ", d.jsx(Rt, {
                            showCopyIcon: !1,
                            address: L == null ? void 0 : L.suggestedAddress
                        }), " ", H != null && H.name ? `to ${H.name}.` : "."]
                    }) : `Link a wallet to your ${H==null?void 0:H.name} account`
                }
            }), Le(um)
        },
        startCrossAppAuthFlow: ur,
        linkEmail: () => {
            we("email"), Ot("email"), ie.current = "email", Ee.current = "link", Le(XTe)
        },
        linkPhone: () => {
            we("sms"), Ot("phone"), ie.current = "sms", Ee.current = "link", Le(B8)
        },
        linkGoogle: async () => {
            we("google"), Ot("google_oauth"), Ee.current = "link", await pt.initLoginWithOAuth("google")
        },
        linkTwitter: async () => {
            we("twitter"), Ot("twitter_oauth"), Ee.current = "link", await pt.initLoginWithOAuth("twitter")
        },
        linkDiscord: async () => {
            we("discord"), Ot("discord_oauth"), Ee.current = "link", await pt.initLoginWithOAuth("discord")
        },
        linkGithub: async () => {
            we("github"), Ot("github_oauth"), Ee.current = "link", await pt.initLoginWithOAuth("github")
        },
        linkSpotify: async () => {
            we("spotify"), Ot("spotify_oauth"), Ee.current = "link", await pt.initLoginWithOAuth("spotify")
        },
        linkInstagram: async () => {
            we("instagram"), Ot("instagram_oauth"), Ee.current = "link", await pt.initLoginWithOAuth("instagram")
        },
        linkTiktok: async () => {
            we("tiktok"), Ot("tiktok_oauth"), Ee.current = "link", await pt.initLoginWithOAuth("tiktok")
        },
        linkLine: async () => {
            we("line"), Ot("line_oauth"), Ee.current = "link", await pt.initLoginWithOAuth("line")
        },
        linkLinkedIn: async () => {
            we("linkedin"), Ot("linkedin_oauth"), Ee.current = "link", await pt.initLoginWithOAuth("linkedin")
        },
        linkApple: async () => {
            we("apple"), Ot("apple_oauth"), Ee.current = "link", await pt.initLoginWithOAuth("apple")
        },
        linkPasskey: async () => {
            we("passkey"), Ot("passkey"), await pt.initLinkWithPasskey(), Le(J$e)
        },
        linkTelegram: async L => {
            if (we("telegram"), Ot("telegram"), Ee.current = "link", ie.current = "telegram", L == null ? void 0 : L.launchParams)
                if (L.launchParams.initDataRaw) {
                    let B = new hf;
                    e.startAuthFlow(B), B.meta.telegramAuthResult = void 0, B.meta.telegramWebAppData = a$(L.launchParams.initDataRaw), Y({
                        telegramAuthModalData: {
                            seamlessAuth: !0
                        }
                    }), Le(hm)
                } else _e(ce, "linkAccount", "onError", ee.INVALID_DATA, {
                    linkMethod: "telegram"
                });
            else await pt.initLoginWithTelegram();
            Le(hm)
        },
        linkFarcaster: async () => {
            we("farcaster"), Ot("farcaster"), await pt.initLoginWithFarcaster(), Ee.current = "link", ie.current = "farcaster", Le(j4)
        },
        updateEmail: () => {
            if (we("email"), !(u != null && u.email)) throw new J("User does not have an email linked to their account.");
            Ee.current = "update", ie.current = "email", Le(EPe)
        },
        updatePhone: () => {
            if (we("sms"), !(u != null && u.phone)) throw new J("User does not have a phone number linked to their account.");
            Ee.current = "update", ie.current = "sms", Le(_Pe)
        },
        login: async L => {
            L && "target" in L && L && (L = void 0);
            let B = "Attempted to log in, but user is already logged in. Use a `link` helper instead.";
            if (!a) {
                let Q = await new Promise(G => {
                    ne(re => G.bind(re))
                });
                if (ne(null), Q) return void console.warn(B)
            }!u || u.isGuest ? (Ee.current = "login", Y({
                login: L
            }), Le(Xn)) : console.warn(B)
        },
        connectOrCreateWallet: async () => {
            a || (await new Promise(L => {
                ne(() => L)
            }), ne(null)), c ? console.warn("User must be unauthenticated to `connectOrCreateWallet`") : (Ee.current = "connect-or-create", Le(iB))
        },
        logout: async () => {
            if (Ee.current = null, ie.current = null, u && e.clearProviderAcccessTokens(u), b(null), await e.logout(), u && W) try {
                await W.clearMfa({
                    userId: u.id
                })
            } catch {}
            h(null), l(!1), _e(ce, "logout", "onSuccess"), s(!1), rt.del(h4), rt.del(JL(H.id))
        },
        getAccessToken: v.useCallback(() => e.getCustomerAccessToken(), [e]),
        unlinkWallet: async L => {
            let B;
            return h(B = L.startsWith("0x") ? await e.unlinkEthereumWallet(L) : await e.unlinkSolanaWallet(L)), B
        },
        unlinkEmail: async L => {
            let B = await e.unlinkEmail(L);
            return h(B), B
        },
        unlinkPhone: async L => {
            let B = await e.unlinkPhone(L);
            return h(B), B
        },
        unlinkGoogle: async L => {
            let B = await e.unlinkOAuth("google", L);
            return h(B), B
        },
        unlinkTwitter: async L => {
            let B = await e.unlinkOAuth("twitter", L);
            return h(B), B
        },
        unlinkDiscord: async L => {
            let B = await e.unlinkOAuth("discord", L);
            return h(B), B
        },
        unlinkGithub: async L => {
            let B = await e.unlinkOAuth("github", L);
            return h(B), B
        },
        unlinkSpotify: async L => {
            let B = await e.unlinkOAuth("spotify", L);
            return h(B), B
        },
        unlinkInstagram: async L => {
            let B = await e.unlinkOAuth("instagram", L);
            return h(B), B
        },
        unlinkTiktok: async L => {
            let B = await e.unlinkOAuth("tiktok", L);
            return h(B), B
        },
        unlinkLine: async L => {
            let B = await e.unlinkOAuth("line", L);
            return h(B), B
        },
        unlinkLinkedIn: async L => {
            let B = await e.unlinkOAuth("linkedin", L);
            return h(B), B
        },
        unlinkApple: async L => {
            let B = await e.unlinkOAuth("apple", L);
            return h(B), B
        },
        unlinkFarcaster: async L => {
            let B = await e.unlinkFarcaster(L);
            return h(B), B
        },
        unlinkTelegram: async L => {
            let B = await e.unlinkTelegram(L);
            return h(B), B
        },
        unlinkPasskey: async L => {
            let B = await ir();
            if (!B) throw Error("Must have valid access token to enroll in MFA");
            if (!W) throw Error("Wallet proxy not initialized.");
            let Q = H.passkeys.shouldUnenrollMfaOnUnlink;
            await W.unlinkPasskeyAccount({
                credentialId: L,
                accessToken: B,
                removeAsMfa: Q
            });
            let G = await e.getAuthenticatedUser();
            return h(G), G
        },
        unlinkCrossAppAccount: async ({
            subject: L
        }) => {
            var G;
            let B = (G = u == null ? void 0 : u.linkedAccounts.find(re => re.type === "cross_app" && re.subject === L)) == null ? void 0 : G.providerApp;
            if (!B) throw new J("Invalid subject");
            e.storeProviderAccessToken(B.id, null);
            let Q = await e.unlinkOAuth(`privy:${B.id}`, L);
            return h(Q), Q
        },
        setWalletRecovery: async L => mt({
            legacySetWalletPasswordFlow: !1,
            showAutomaticRecovery: (L == null ? void 0 : L.showAutomaticRecovery) ? ? !1
        }),
        setWalletPassword: async () => mt({
            legacySetWalletPasswordFlow: !0,
            showAutomaticRecovery: !1
        }),
        signMessage: (L, B) => new Promise(async (Q, G) => {
            var lt;
            let {
                requesterAppId: re
            } = (B == null ? void 0 : B.uiOptions) || {}, se = L.message, me = B != null && B.address ? $s(u, B.address) : Xa(u);
            if (!me && (B == null ? void 0 : B.address) !== void 0) {
                let Se = w2(f, B.address);
                if (Se) try {
                    let yt = await Se.getEthereumProvider(),
                        It = await yt.request({
                            method: "personal_sign",
                            params: [se, Se.address]
                        });
                    return _e(ce, "signMessage", "onSuccess", {
                        signature: It
                    }), void Q({
                        signature: It
                    })
                } catch (yt) {
                    return _e(ce, "signMessage", "onError", ee.UNABLE_TO_SIGN), void G(yt ? ? new ni("Unable to sign message"))
                }
            }
            if (!me) throw new J("No embedded or connected wallet found for address.");
            if (!c || !u) return _e(ce, "signMessage", "onError", ee.MUST_BE_AUTHENTICATED), void G(Error("User must be authenticated before signing with a Privy wallet"));
            let ve = me.address,
                Ze = me.walletIndex ? ? 0,
                {
                    entropyId: kt,
                    entropyIdVerifier: Re
                } = Sn(u, me),
                ct = fn(me);
            if (typeof se != "string" || se.length < 1) return _e(ce, "signMessage", "onError", ee.INVALID_MESSAGE), void G(Error("Message must be a non-empty string"));
            let it = async () => {
                let Se;
                if (!c) throw Error("User must be authenticated before signing with a Privy wallet");
                let yt = await ir();
                if (!W || !yt || !await pt.recoverEmbeddedWallet({
                        address: ve
                    })) throw Error("Unable to connect to wallet");
                if (e.createAnalyticsEvent({
                        eventName: "embedded_wallet_sign_message_started",
                        payload: {
                            walletAddress: ve,
                            requesterAppId: re
                        }
                    }), ct) {
                    let It = Jn(L.message, {
                            strict: !0
                        }),
                        Mt = await Ni(r, async ({
                            message: jt
                        }) => await W.signWithUserSigner({
                            accessToken: yt,
                            requesterAppId: re,
                            message: jt
                        }), {
                            chain_type: "ethereum",
                            method: "personal_sign",
                            params: It ? {
                                message: se.slice(2),
                                encoding: "hex"
                            } : {
                                message: se,
                                encoding: "utf-8"
                            },
                            wallet_id: me.id
                        });
                    if (!Mt.data || !("signature" in Mt.data)) throw new ni("Unable to sign message");
                    Se = Mt.data.signature
                } else {
                    let {
                        response: It
                    } = await W.rpc({
                        accessToken: yt,
                        entropyId: kt,
                        entropyIdVerifier: Re,
                        chainType: "ethereum",
                        hdWalletIndex: Ze,
                        requesterAppId: re,
                        request: {
                            method: "personal_sign",
                            params: [se, ve]
                        }
                    });
                    Se = It.data
                }
                return e.createAnalyticsEvent({
                    eventName: "embedded_wallet_sign_message_completed",
                    payload: {
                        walletAddress: ve,
                        requesterAppId: re
                    }
                }), Se
            };
            if (Ae({
                    showWalletUIs: (lt = B == null ? void 0 : B.uiOptions) == null ? void 0 : lt.showWalletUIs
                })) try {
                let Se = await it();
                _e(ce, "signMessage", "onSuccess", {
                    signature: Se
                }), Q({
                    signature: Se
                })
            } catch (Se) {
                _e(ce, "signMessage", "onError", ee.UNABLE_TO_SIGN), G(Se ? ? new ni("Unable to sign message"))
            } else Y({
                signMessage: {
                    method: "personal_sign",
                    data: se,
                    confirmAndSign: it,
                    onSuccess: Se => {
                        _e(ce, "signMessage", "onSuccess", {
                            signature: Se
                        }), Q({
                            signature: Se
                        })
                    },
                    onFailure: Se => {
                        _e(ce, "signMessage", "onError", ee.UNABLE_TO_SIGN), G(Se)
                    },
                    uiOptions: (B == null ? void 0 : B.uiOptions) || {}
                },
                connectWallet: {
                    recoveryMethod: me.recoveryMethod,
                    connectingWalletAddress: ve,
                    entropyId: kt,
                    entropyIdVerifier: Re,
                    onCompleteNavigateTo: z4,
                    isUnifiedWallet: ct,
                    onFailure: Se => {
                        _e(ce, "signMessage", "onError", ee.UNKNOWN_CONNECT_WALLET_ERROR), G(Se)
                    }
                }
            }), Le(Lc)
        }),
        signTypedData: (L, B) => new Promise(async (Q, G) => {
            var lt;
            let {
                requesterAppId: re
            } = (B == null ? void 0 : B.uiOptions) || {}, se = B != null && B.address ? $s(u, B.address) : Xa(u);
            if (!se && (B != null && B.address)) {
                let Se = w2(f, B.address);
                if (Se) try {
                    let yt = await Se.getEthereumProvider(),
                        It = om(L),
                        Mt = await yt.request({
                            method: "eth_signTypedData_v4",
                            params: [Se.address, It]
                        });
                    return _e(ce, "signTypedData", "onSuccess", {
                        signature: Mt
                    }), void Q({
                        signature: Mt
                    })
                } catch (yt) {
                    return _e(ce, "signTypedData", "onError", ee.UNABLE_TO_SIGN), void G(yt ? ? new ni("Unable to sign typed data " + yt))
                }
            }
            if (!se) throw new J("No embedded or connected wallet found for address.");
            if (!c || !u) return _e(ce, "signTypedData", "onError", ee.MUST_BE_AUTHENTICATED), void G(Error("User must be authenticated before signing with a Privy wallet"));
            let me = se.address,
                ve = se.walletIndex ? ? 0,
                {
                    entropyId: Ze,
                    entropyIdVerifier: kt
                } = Sn(u, se),
                Re = fn(se),
                ct = om(L),
                it = async () => {
                    let Se;
                    if (!c) throw Error("User must be authenticated before signing with a Privy wallet");
                    let yt = await ir();
                    if (!W || !yt || !await pt.recoverEmbeddedWallet({
                            address: me
                        })) throw Error("Unable to connect to wallet");
                    if (e.createAnalyticsEvent({
                            eventName: "embedded_wallet_sign_typed_data_started",
                            payload: {
                                walletAddress: me,
                                requesterAppId: re
                            }
                        }), Re) {
                        let {
                            domain: It,
                            types: Mt,
                            primaryType: jt,
                            message: sr
                        } = ct, bt = await Ni(r, async ({
                            message: St
                        }) => await W.signWithUserSigner({
                            accessToken: yt,
                            requesterAppId: re,
                            message: St
                        }), {
                            chain_type: "ethereum",
                            method: "eth_signTypedData_v4",
                            params: {
                                typed_data: {
                                    domain: It,
                                    types: Mt,
                                    primary_type: jt,
                                    message: sr
                                }
                            },
                            wallet_id: se.id
                        });
                        if (!bt.data || !("signature" in bt.data)) throw new ni("Unable to sign message");
                        Se = bt.data.signature
                    } else {
                        let {
                            response: It
                        } = await W.rpc({
                            accessToken: yt,
                            entropyId: Ze,
                            entropyIdVerifier: kt,
                            chainType: "ethereum",
                            hdWalletIndex: ve,
                            requesterAppId: re,
                            request: {
                                method: "eth_signTypedData_v4",
                                params: [me, ct]
                            }
                        });
                        Se = It.data
                    }
                    return e.createAnalyticsEvent({
                        eventName: "embedded_wallet_sign_typed_data_completed",
                        payload: {
                            walletAddress: me,
                            requesterAppId: re
                        }
                    }), Se
                };
            if (Ae({
                    showWalletUIs: (lt = B == null ? void 0 : B.uiOptions) == null ? void 0 : lt.showWalletUIs
                })) try {
                let Se = await it();
                _e(ce, "signTypedData", "onSuccess", {
                    signature: Se
                }), Q({
                    signature: Se
                })
            } catch (Se) {
                _e(ce, "signTypedData", "onError", ee.UNABLE_TO_SIGN), G(Se ? ? new ni("Unable to sign message"))
            } else Y({
                signMessage: {
                    method: "eth_signTypedData_v4",
                    data: ct,
                    confirmAndSign: it,
                    onSuccess: Se => {
                        _e(ce, "signTypedData", "onSuccess", {
                            signature: Se
                        }), Q({
                            signature: Se
                        })
                    },
                    onFailure: Se => {
                        _e(ce, "signTypedData", "onError", ee.UNABLE_TO_SIGN), G(Se)
                    },
                    uiOptions: (B == null ? void 0 : B.uiOptions) || {}
                },
                connectWallet: {
                    recoveryMethod: se.recoveryMethod,
                    connectingWalletAddress: se.address,
                    entropyId: Ze,
                    isUnifiedWallet: Re,
                    entropyIdVerifier: kt,
                    onCompleteNavigateTo: z4,
                    onFailure: Se => {
                        _e(ce, "signMessage", "onError", ee.UNKNOWN_CONNECT_WALLET_ERROR), G(Se)
                    }
                }
            }), Le(Lc)
        }),
        sendTransaction: async (L, B) => await tr({
            transaction: L,
            uiOptions: B == null ? void 0 : B.uiOptions,
            fundWalletConfig: B == null ? void 0 : B.fundWalletConfig,
            address: B == null ? void 0 : B.address,
            signOnly: !1
        }),
        signTransaction: async (L, B) => ({
            signature: (await tr({
                transaction: L,
                uiOptions: B == null ? void 0 : B.uiOptions,
                address: B == null ? void 0 : B.address,
                signOnly: !0
            })).hash
        }),
        exportWallet: L => new Promise(async (B, Q) => {
            if (!c || !u) return void Q(Error("User must be authenticated before exporting their Privy wallet"));
            L && "target" in L && L && (L = void 0);
            let G = L != null && L.address ? $s(u, L.address) : Xa(u);
            if (!G) return void Q(new J("User must have an embedded wallet."));
            let re = G.address,
                {
                    entropyId: se,
                    entropyIdVerifier: me
                } = Sn(u, G),
                ve = fn(G);
            if (!re) return void Q(Error("User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`."));
            if (!gi(re)) return void Q(Error("Must provide a valid Ethereum address."));
            let Ze = {
                recoveryMethod: G.recoveryMethod,
                connectingWalletAddress: G.address,
                isUnifiedWallet: ve,
                entropyId: se,
                entropyIdVerifier: me,
                onCompleteNavigateTo: B4,
                onFailure: Q,
                shouldForceMFA: !0
            };
            Y(V), await ir() && W ? W ? lh(G) ? (Y({
                keyExport: {
                    appId: t.appId,
                    appClientId: t.clientId,
                    origin: e.apiUrl,
                    address: G.address,
                    entropyId: se,
                    entropyIdVerifier: me,
                    hdWalletIndex: G.walletIndex,
                    chainType: G.chainType,
                    walletId: G.id,
                    isUnifiedWallet: ve,
                    imported: G.imported,
                    onSuccess: B,
                    onFailure: Q
                },
                connectWallet: Ze
            }), Le(Lc)) : Q(Error(`Export is not supported for ${G.chainType} wallets`)) : Q(Error("Must have a Privy wallet before exporting")) : Q(Error("Must have valid access token to enroll in MFA"))
        }),
        promptMfa: dr,
        async init(L) {
            switch (L) {
                case "sms":
                    return void await e.initMfaSmsVerification();
                case "passkey":
                    return await e.initMfaPasskeyVerification();
                case "totp":
                    return;
                default:
                    throw Error(`Unsupported MFA method: ${L}`)
            }
        },
        async submit(L, B) {
            var Q, G, re;
            switch (L) {
                case "totp":
                case "sms":
                    if (typeof B != "string") throw new J("Invalid MFA code");
                    (Q = ye.current) == null || Q.resolve({
                        mfaMethod: L,
                        mfaCode: B,
                        relyingParty: window.origin
                    }), await new Promise((ve, Ze) => {
                        Be.current = {
                            resolve: ve,
                            reject: Ze
                        }
                    });
                    break;
                case "passkey":
                    if (typeof B == "string") throw new J("Invalid authenticator response");
                    let se = await ma(() =>
                            import ("./index-CFBQExMV.js"), []),
                        me = FTe(await se.startAuthentication(B));
                    (G = ye.current) == null || G.resolve({
                        mfaMethod: L,
                        mfaCode: me,
                        relyingParty: window.origin
                    }), await new Promise((ve, Ze) => {
                        Be.current = {
                            resolve: ve,
                            reject: Ze
                        }
                    });
                    break;
                default:
                    throw (re = ye.current) == null || re.reject(new J("Unsupported MFA method")), new J(`Unsupported MFA method: ${L}`)
            }
        },
        cancel() {
            var L;
            (L = ye.current) == null || L.reject(new J("MFA canceled"))
        },
        async initEnrollmentWithSms(L) {
            let B = await ir();
            if (!B || !W) throw Error("Must have valid access token to enroll in MFA");
            await W.initEnrollMfa({
                method: "sms",
                accessToken: B,
                phoneNumber: L.phoneNumber
            })
        },
        enrollInMfa: L => new Promise((B, Q) => {
            if (!L) return pt.closePrivyModal(), void B();
            H.mfa.noPromptOnMfaRequired && console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."), Y({
                mfaEnrollmentFlow: {
                    mfaMethods: H.mfa.methods,
                    shouldUnlinkOnUnenrollMfa: H.passkeys.shouldUnlinkOnUnenrollMfa,
                    onSuccess: B,
                    onFailure: Q
                }
            }), Le(mPe)
        }),
        async initEnrollmentWithTotp() {
            let L = await ir();
            if (!L || !W) throw Error("Must have valid access token to enroll in MFA");
            let B = await W.initEnrollMfa({
                method: "totp",
                accessToken: L
            });
            return {
                secret: B.secret,
                authUrl: B.authUrl
            }
        },
        async submitEnrollmentWithSms(L) {
            let B = await ir();
            if (!B || !W) throw Error("Must have valid access token to enroll in MFA");
            await W.submitEnrollMfa({
                method: "sms",
                accessToken: B,
                phoneNumber: L.phoneNumber,
                code: L.mfaCode
            }), h(await e.getAuthenticatedUser())
        },
        async submitEnrollmentWithTotp(L) {
            let B = await ir();
            if (!B || !W) throw Error("Must have valid access token to enroll in MFA");
            await W.submitEnrollMfa({
                method: "totp",
                accessToken: B,
                code: L.mfaCode
            }), h(await e.getAuthenticatedUser())
        },
        async initEnrollmentWithPasskey() {},
        async submitEnrollmentWithPasskey({
            credentialIds: L
        }, B = {}) {
            let Q = await ir();
            if (!Q || !W) throw Error("Must have valid access token to enroll in MFA");
            await W.submitEnrollMfa({
                method: "passkey",
                accessToken: Q,
                credentialIds: L,
                removeForLogin: B.removeForLogin
            }), h(await e.getAuthenticatedUser())
        },
        async unenroll(L, B = {}) {
            let Q = await ir();
            if (!Q || !W) throw Error("Must have valid access token to remove MFA");
            L === "passkey" ? await W.submitEnrollMfa({
                method: "passkey",
                accessToken: Q,
                credentialIds: [],
                removeForLogin: B.removeForLogin
            }) : await W.unenrollMfa({
                method: L,
                accessToken: Q
            }), h(await e.getAuthenticatedUser())
        },
        requestFarcasterSignerFromWarpcast: async () => {
            var G;
            let L = await ir(),
                B = u == null ? void 0 : u.linkedAccounts.find(re => re.type === "wallet" && re.walletClientType === "privy");
            if (!L) throw Error("Must have valid access token to connect with Farcaster");
            if (!W || !B) throw Error("Must have an embedded wallet to use Farcaster signers");
            if (fn(B)) throw new J("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");
            if (!((G = u == null ? void 0 : u.farcaster) != null && G.fid)) throw Error("Must have Farcaster account to use Farcaster signers");
            if (!await pt.recoverEmbeddedWallet({
                    address: B.address
                })) throw Error("Unable to connect to wallet");
            let Q = await W.initFarcasterSigner({
                address: B.address,
                hdWalletIndex: null,
                accessToken: L,
                mfaCode: null,
                mfaMethod: null,
                relyingParty: window.origin
            });
            Q.status === "approved" && h(await e.getAuthenticatedUser() || u || null), Y({
                farcasterSigner: Q
            }), Le(ZTe)
        },
        getFarcasterSignerPublicKey: async () => {
            var G, re;
            let L, B = await ir(),
                Q = u == null ? void 0 : u.linkedAccounts.find(se => se.type === "wallet" && se.walletClientType === "privy");
            if (!B) throw Error("Must have valid access token to connect with Farcaster");
            if (!W || !Q) throw Error("Must have an embedded wallet to use Farcaster signers");
            if (fn(Q)) throw new J("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");
            if (!((G = u == null ? void 0 : u.farcaster) != null && G.fid)) throw Error("Must have Farcaster account to use Farcaster signers");
            if (!await pt.recoverEmbeddedWallet({
                    address: Q.address
                })) throw Error("Unable to connect to wallet");
            if (!((re = u.farcaster) != null && re.signerPublicKey)) throw Error("Must have a Farcaster signer public key to sign");
            return L = u.farcaster.signerPublicKey.slice(2), Uint8Array.from(L.match(/.{1,2}/g).map(se => parseInt(se, 16)))
        },
        signFarcasterMessage: async L => {
            var se, me;
            let B = await ir(),
                Q = u == null ? void 0 : u.linkedAccounts.find(ve => ve.type === "wallet" && ve.walletClientType === "privy");
            if (!B) throw Error("Must have valid access token to connect with Farcaster");
            if (!W || !Q) throw Error("Must have an embedded wallet to use Farcaster signers");
            if (fn(Q)) throw new J("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");
            if (!((se = u == null ? void 0 : u.farcaster) != null && se.fid)) throw Error("Must have Farcaster account to use Farcaster signers");
            if (!await pt.recoverEmbeddedWallet({
                    address: Q.address
                })) throw Error("Unable to connect to wallet");
            if (!((me = u.farcaster) != null && me.signerPublicKey)) throw Error("Must have a Farcaster signer public key to sign");
            let G = await ma(() =>
                    import ("./index-CFBQExMV.js"), []),
                re = await W.signFarcasterMessage({
                    address: Q.address,
                    hdWalletIndex: null,
                    accessToken: B,
                    mfaCode: null,
                    mfaMethod: null,
                    payload: {
                        hash: G.bufferToBase64URLString(L)
                    },
                    fid: BigInt(u.farcaster.fid),
                    relyingParty: window.origin
                });
            return new Uint8Array(G.base64URLStringToBuffer(re.signature))
        },
        signMessageWithCrossAppWallet(L, {
            address: B,
            chainId: Q
        }) {
            let G = u == null ? void 0 : u.linkedAccounts.some(re => re.type === "cross_app" && re.smartWallets.some(se => se.address === B));
            return Sv({
                user: u,
                client: e,
                address: B,
                requesterAppId: H.id,
                request: {
                    method: G ? "privy_signSmartWalletMessage" : "personal_sign",
                    params: [L, B],
                    chainId: Q
                },
                reconnect: ur
            })
        },
        signTypedDataWithCrossAppWallet(L, {
            address: B,
            chainId: Q
        }) {
            let G = u == null ? void 0 : u.linkedAccounts.some(se => se.type === "cross_app" && se.smartWallets.some(me => me.address === B)),
                re = om(L);
            return Sv({
                user: u,
                client: e,
                address: B,
                requesterAppId: H.id,
                request: {
                    method: G ? "privy_signSmartWalletTypedData" : "eth_signTypedData_v4",
                    params: [B, re],
                    chainId: Q
                },
                reconnect: ur
            })
        },
        sendTransactionWithCrossAppWallet(L, {
            address: B
        }) {
            let Q = u == null ? void 0 : u.linkedAccounts.some(G => G.type === "cross_app" && G.smartWallets.some(re => re.address === B));
            return Sv({
                user: u,
                client: e,
                address: B,
                requesterAppId: H.id,
                request: {
                    method: Q ? "privy_sendSmartWalletTx" : "eth_sendTransaction",
                    params: [L],
                    chainId: L.chainId
                },
                reconnect: ur
            })
        },
        isModalOpen: i,
        mfaMethods: H.mfa.methods
    };
    HB = Vr.signMessage, VB = Vr.signTypedData, KB = async (L, B) => await tr({
        transaction: L,
        ...B,
        signOnly: !1
    }), GB = async (L, B) => ({
        signature: (await tr({
            transaction: L,
            ...B,
            signOnly: !0
        })).hash
    });
    let pt = {
        privy: r,
        setAuthenticated: l,
        setUser: h,
        setIsNewUser: E,
        isNewUserThisSession: x,
        pendingTransaction: null,
        walletConnectionStatus: T,
        setWalletConnectionStatus: C,
        connectors: ((Fn = e.connectors) == null ? void 0 : Fn.walletConnectors) ? ? [],
        solanaWallets: g,
        rpcConfig: H.rpcConfig,
        chains: H.chains,
        appId: t.appId,
        showFiatPrices: H.embeddedWallets.priceDisplay.primary !== "native-token",
        clientAnalyticsId: e.clientAnalyticsId,
        onCustomAuthAuthenticated: Te,
        hideWalletUIs: ft,
        isHeadlessSigning: v.useCallback(Ae, [H.embeddedWallets.showWalletUIs]),
        emailOtpState: N,
        setEmailOtpState: R,
        smsOtpState: D,
        setSmsOtpState: S,
        oAuthState: U,
        setOAuthState: k,
        telegramAuthState: F,
        setTelegramAuthState: q,
        siweState: O,
        setSiweState: M,
        isHeadlessOAuthLoading: A,
        baseAccountSdk: y,
        setBaseAccountSdk: w,
        nativeTokenSymbolForChainId: L => {
            var B;
            return (B = H.chains.find(Q => Q.id === Number(L))) == null ? void 0 : B.nativeCurrency.symbol
        },
        initializeWalletProxy: async L => {
            if (W) return W;
            let B = new Promise(re => {
                    ae.current = re
                }),
                Q = new Promise(re => setTimeout(() => re(null), L)),
                G = await Promise.race([B, Q]);
            return ae.current = null, G
        },
        getAuthFlow: () => e.authFlow,
        getAuthMeta: () => {
            var L;
            return (L = e.authFlow) == null ? void 0 : L.meta
        },
        client: e,
        closePrivyModal: async (L = {
            shouldCallAuthOnSuccess: !0,
            isSuccess: !1
        }) => {
            let B, Q = a && c && u;
            Q && ie.current && (B = Yt(u)), Ee.current === "login" ? L.shouldCallAuthOnSuccess && Q && ie.current ? _e(ce, "login", "onComplete", {
                user: u,
                isNewUser: x,
                wasAlreadyAuthenticated: !1,
                loginMethod: ie.current,
                loginAccount: B ? ? null
            }) : _e(ce, "login", "onError", ee.USER_EXITED_AUTH_FLOW) : Ee.current === "link" && B ? L.isSuccess && Q && ie.current ? _e(ce, "linkAccount", "onSuccess", {
                user: u,
                linkMethod: ie.current,
                linkedAccount: B
            }) : ie.current && _e(ce, "linkAccount", "onError", ee.USER_EXITED_LINK_FLOW, {
                linkMethod: ie.current
            }) : Ee.current === "update" && B ? L.isSuccess && Q && ie.current ? _e(ce, "update", "onSuccess", {
                user: u,
                updateMethod: ie.current,
                updatedAccount: B
            }) : ie.current && _e(ce, "update", "onError", ee.USER_EXITED_UPDATE_FLOW, {
                linkMethod: ie.current
            }) : Ee.current === "connect-or-create" && (f[0] ? _e(ce, "connectOrCreateWallet", "onSuccess", {
                wallet: f[0]
            }) : _e(ce, "connectOrCreateWallet", "onError", ee.USER_EXITED_AUTH_FLOW));
            let G = _ && Dv.has(_),
                re = _ === Sr && V.errorModalData && Dv.has(V.errorModalData.previousScreen);
            if ((G || re) && V.funding) {
                let se, me = Dv.get(_) ? ? null;
                if (V.funding.chainType === "solana") {
                    let ve = n(W0);
                    if (ve) try {
                        se = BigInt(await ve.getBalance({
                            address: V.funding.address,
                            cluster: V.funding.cluster
                        }))
                    } catch {
                        console.error("Unable to pull wallet balance")
                    } else console.warn("Unable to load solana plugin, skipping balance");
                    _e(ce, "fundSolanaWallet", "onUserExited", {
                        address: V.funding.address,
                        cluster: V.funding.cluster,
                        fundingMethod: me,
                        balance: se
                    })
                } else {
                    let ve = oh(V.funding.chain.id, H.chains, H.rpcConfig, {
                        appId: t.appId
                    });
                    try {
                        se = await ve.getBalance({
                            address: V.funding.address
                        })
                    } catch {
                        console.error("Unable to pull wallet balance")
                    }
                    _e(ce, "fundWallet", "onUserExited", {
                        address: V.funding.address,
                        chain: V.funding.chain,
                        fundingMethod: me,
                        balance: se
                    })
                }
            }
            Y(se => ({ ...se,
                externalConnectWallet: {
                    suggestedAddress: void 0
                }
            })), Ee.current = null, ie.current = null, E(!1), s(!1), setTimeout(() => {
                e.authFlow = void 0
            }, 200)
        },
        openPrivyModal: Le,
        connectWallet: dt,
        initLoginWithWallet: async (L, B, Q, G) => {
            Uo(L) ? (ie.current = "siwe", He(L, B, Q)) : (ie.current = "siws", ut(L, B, Q, G))
        },
        loginWithWallet: async () => {
            let L, B, Q;
            if (!a) throw new xl;
            if (e.authFlow instanceof qu ? L = "siwe" : e.authFlow instanceof c1 && (L = "siws"), !L) throw new J("Must initialize SIWE/SIWS flow first.");
            if (await e.getAccessToken() !== null) try {
                ({
                    user: B
                } = await e.link()), ie.current = L
            } catch (G) {
                throw _e(ce, "linkAccount", "onError", G.privyErrorCode || ee.FAILED_TO_LINK_ACCOUNT, {
                    linkMethod: L
                }), G
            } else try {
                ({
                    user: B,
                    isNewUser: Q
                } = await e.authenticate()), ie.current = L
            } catch (G) {
                throw _e(ce, "login", "onError", G.privyErrorCode || ee.GENERIC_CONNECT_WALLET_ERROR), G
            }
            h(B || u || null), E(Q || !1), l(!0)
        },
        delegateWallet: async ({
            address: L,
            chainType: B,
            showDelegationUIs: Q
        }) => new Promise(async (G, re) => {
            let se = await ir();
            if (!c || !u || !se) throw new J("User must be authenticated and have an embedded wallet to delegate actions.");
            if (B !== "solana" && B !== "ethereum") throw new J("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");
            let me = pt.walletProxy ? ? await pt.initializeWalletProxy(15e3);
            if (!me) throw new J("Wallet proxy not initialized.");
            if ((({
                    address: ct,
                    user: it
                }) => !!$$(it).find(lt => lt.address === ct))({
                    address: L,
                    user: u
                })) return G();
            let ve = $s(u, L);
            if (!ve) throw new J("Address to delegate is not associated with current user.");
            if (fn(ve)) throw new J("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");
            let Ze = bAe({
                    address: L,
                    user: u
                }),
                kt = vAe({
                    address: L,
                    user: u
                }),
                Re = async () => {
                    await me.createDelegatedAction({
                        accessToken: se,
                        rootWallet: kt,
                        delegatedWallets: [Ze]
                    }), await pt.refreshSessionAndUser()
                };
            if (await pt.recoverEmbeddedWallet({
                    address: L
                }), Q) Y({
                delegatedActions: {
                    consent: {
                        address: L,
                        onDelegate: Re,
                        onSuccess: async () => {
                            G()
                        },
                        onError: async ct => {
                            re(ct)
                        }
                    }
                }
            }), Le(HTe);
            else try {
                await Re(), G()
            } catch (ct) {
                re(ct)
            }
        }),
        revokeDelegatedWallets: async ({
            showDelegationUIs: L
        }) => new Promise(async (B, Q) => {
            if (!c || !u) throw new J("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");
            let G = $$(u);
            if (G.length === 0) throw new J("User has no delegated wallets to revoke.");
            if (G.some(fn)) throw new J("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");
            let re = async () => {
                await e.revokeDelegatedWallet(), await pt.refreshSessionAndUser()
            };
            if (L) Y({
                delegatedActions: {
                    revoke: {
                        onRevoke: re,
                        onSuccess: async () => {
                            B()
                        },
                        onError: async se => {
                            Q(se)
                        }
                    }
                }
            }), Le(KTe);
            else try {
                await re(), B()
            } catch (se) {
                Q(se)
            }
        }),
        initLoginWithFarcaster: async (L, B) => {
            let Q = new XI(L, B);
            e.startAuthFlow(Q);
            try {
                ie.current = "farcaster", await Q.initializeFarcasterConnect()
            } catch (G) {
                throw Ee.current === "login" ? _e(ce, "login", "onError", G.privyErrorCode || ee.UNKNOWN_AUTH_ERROR) : Ee.current === "link" && _e(ce, "linkAccount", "onError", G.privyErrorCode || ee.UNKNOWN_AUTH_ERROR, {
                    linkMethod: "farcaster"
                }), G
            }
        },
        loginWithFarcaster: async () => {
            let L, B;
            if (!a) throw new xl;
            if (!(e.authFlow instanceof XI)) throw new J("Must initialize Farcaster flow first.");
            if (await e.getAccessToken() !== null) try {
                ({
                    user: L
                } = await e.link()), ie.current = "farcaster"
            } catch (Q) {
                throw _e(ce, "linkAccount", "onError", Q.privyErrorCode || ee.FAILED_TO_LINK_ACCOUNT, {
                    linkMethod: "farcaster"
                }), Q
            } else try {
                ({
                    user: L,
                    isNewUser: B
                } = await e.authenticate()), ie.current = "farcaster"
            } catch (Q) {
                throw _e(ce, "login", "onError", Q.privyErrorCode || ee.UNKNOWN_AUTH_ERROR), Q
            }
            h(L || null), E(B || !1), l(!0)
        },
        async crossAppAuthFlow({
            appId: L,
            popup: B,
            action: Q
        }) {
            let G = `privy:${L}`;
            ie.current = G;
            let {
                url: re,
                stateCode: se,
                codeVerifier: me
            } = await async function({
                api: ve,
                appId: Ze
            }) {
                let kt = Gy(),
                    Re = c8(),
                    ct = await l8(kt);
                try {
                    let {
                        url: it
                    } = await ve.post(aO, {
                        provider: `privy:${Ze}`,
                        redirect_to: window.location.href,
                        code_challenge: ct,
                        state_code: Re
                    });
                    return {
                        url: it,
                        stateCode: Re,
                        codeVerifier: kt
                    }
                } catch (it) {
                    throw qt(it)
                }
            }({
                api: e.api,
                appId: L
            });
            if (!re) throw e.createAnalyticsEvent({
                eventName: "cross_app_auth_error",
                payload: {
                    error: "Unable to open cross-app auth popup",
                    appId: L
                }
            }), new J("No authorization URL returned for cross-app auth.");
            try {
                let ve = await async function({
                        url: it,
                        popup: lt
                    }) {
                        return lt.location = it, new Promise((Se, yt) => {
                            let It, Mt = setTimeout(() => {
                                yt(new J("Authorization request timed out after 2 minutes.")), jt()
                            }, 12e4);

                            function jt() {
                                lt == null || lt.close(), window.removeEventListener("message", bt)
                            }
                            let sr = setInterval(() => {
                                lt != null && lt.closed && !It && (jt(), clearInterval(sr), clearTimeout(Mt), yt(new J("User rejected request")))
                            }, 300);

                            function bt(St) {
                                St.data && (St.data.type === "PRIVY_OAUTH_RESPONSE" && St.data.stateCode && St.data.authorizationCode && (clearTimeout(Mt), Se(St.data), jt()), St.data.type === "PRIVY_OAUTH_ERROR" && (clearTimeout(Mt), yt(new J(St.data.error)), jt()), St.data.type === T$ && ((It = new BroadcastChannel(S$)).onmessage = bt))
                            }
                            window.addEventListener("message", bt)
                        })
                    }({
                        url: re,
                        popup: B,
                        provider: G
                    }),
                    Ze = ve.stateCode,
                    kt = ve.authorizationCode;
                if (Ze !== se) throw e.createAnalyticsEvent({
                    eventName: "possible_phishing_attempt",
                    payload: {
                        provider: G,
                        storedStateCode: se ? ? "",
                        returnedStateCode: Ze ? ? ""
                    }
                }), new J("Unexpected auth flow. This may be a phishing attempt.", void 0, ee.OAUTH_UNEXPECTED);
                let Re = await async function({
                    appId: it,
                    stateCode: lt,
                    codeVerifier: Se,
                    authorizationCode: yt,
                    action: It,
                    client: Mt
                }) {
                    var jt;
                    if (!yt || !lt) throw new J("[Cross-App AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");
                    if (yt === "undefined") throw new J("User denied confirmation during cross-app auth flow");
                    try {
                        let sr = new EAe({
                            authorizationCode: yt,
                            stateCode: lt,
                            codeVerifier: Se,
                            provider: `privy:${it}`
                        });
                        Mt.startAuthFlow(sr);
                        let bt = It === "link" ? await Mt.link() : await Mt.authenticate(),
                            St = (jt = bt.oAuthTokens) == null ? void 0 : jt.accessToken;
                        return console.debug(), St
                    } catch (sr) {
                        let bt = qt(sr);
                        throw bt.privyErrorCode === ee.ACCOUNT_TRANSFER_REQUIRED ? bt : bt.privyErrorCode ? new J(bt.message || "Invalid code during cross-app auth flow.", void 0, bt.privyErrorCode) : bt.message === "User denied confirmation during cross-app auth flow" ? new J("Invalid code during cross-app auth flow.", void 0, ee.OAUTH_USER_DENIED) : new J("Invalid code during cross-app auth flow.", void 0, ee.UNKNOWN_AUTH_ERROR)
                    }
                }({
                    appId: L,
                    codeVerifier: me,
                    stateCode: Ze,
                    authorizationCode: kt,
                    action: Q,
                    client: e
                });
                Re && e.storeProviderAccessToken(L, Re);
                let ct = await pt.refreshSessionAndUser();
                if (!ct) throw new J("Unable to update user");
                return e.createAnalyticsEvent({
                    eventName: "cross_app_auth_completed",
                    payload: {
                        providerAppId: L
                    }
                }), ct
            } catch (ve) {
                throw e.createAnalyticsEvent({
                    eventName: "cross_app_auth_error",
                    payload: {
                        error: ve.toString(),
                        provider: G
                    }
                }), ve
            }
        },
        async initLoginWithOAuth(L, B, Q) {
            if (ie.current = L, !l4() || L === "google" && R4(window.navigator.userAgent)) return void Le(yS);
            L === "twitter" && window.opener && window.opener.postMessage({
                type: T$
            }, "*"), rt.del(o1), rt.del(Jf);
            let G = new Au({
                provider: L,
                disableSignup: !!Q,
                withPrivyUi: !0
            });
            B && G.addCaptchaToken(B), e.startAuthFlow(G);
            let re = await e.authFlow.getAuthorizationUrl();
            re && re.url && (L === "twitter" && gr.isAndroid && (re.url = re.url.replace("x.com", "twitter.com")), window.location.assign(re.url))
        },
        async initLoginWithTelegram(L, B) {
            if (!a) throw new xl;
            ie.current = "telegram";
            let Q = new hf(L, B);
            e.startAuthFlow(Q), q({
                status: "loading"
            }), Q.meta.telegramWebAppData = void 0, Q.meta.telegramAuthResult = await new Promise((G, re) => H.loginConfig.telegramAuthConfiguration ? window.Telegram ? void window.Telegram.Login.auth({
                bot_id: H.loginConfig.telegramAuthConfiguration.botId,
                request_access: !0
            }, se => se ? G(se) : re(new J("Telegram auth failed or was canceled by the client"))) : re(new J("Telegram was not initialized")) : re(new J("Telegram Auth configuration is not loaded")))
        },
        async loginWithTelegram(L) {
            var me;
            let B, Q;
            if (!(e.authFlow instanceof hf)) throw new J("Must initialize Telegram flow before calling loginWithTelegram");
            (me = e.authFlow.meta).captchaToken || (me.captchaToken = L == null ? void 0 : L.captchaToken);
            let G = await ir(),
                re = (L == null ? void 0 : L.intent) || Ee.current;
            if (re === "login") try {
                let ve = await e.authenticate();
                B = ve.user, Q = ve.isNewUser, ie.current = "telegram"
            } catch (ve) {
                throw _e(ce, "login", "onError", ve.privyErrorCode || ee.UNKNOWN_AUTH_ERROR), ve
            } else {
                if (re !== "link") throw new J("Unknown auth intent");
                try {
                    B = (await e.link()).user, ie.current = "telegram"
                } catch (ve) {
                    throw _e(ce, "linkAccount", "onError", ve.privyErrorCode || ee.FAILED_TO_LINK_ACCOUNT, {
                        linkMethod: "telegram"
                    }), ve
                }
            }
            h(B), E(Q || !1), l(!0), q({
                status: "done"
            });
            let se = (B == null ? void 0 : B.linkedAccounts.find(({
                type: ve
            }) => ve === "telegram")) || null;
            return {
                user: B,
                isNewUser: Q || !1,
                wasAlreadyAuthenticated: !!G,
                loginAccount: se
            }
        },
        async loginWithOAuth(L) {
            let B, Q, G;
            if (!(e.authFlow instanceof Au)) throw new J("Must initialize OAuth flow before calling loginWithOAuth");
            let re = rt.get(a1),
                se = e.authFlow.meta.stateCode;
            if (re !== se) throw e.createAnalyticsEvent({
                eventName: "possible_phishing_attempt",
                payload: {
                    provider: L,
                    storedStateCode: re ? ? "",
                    returnedStateCode: se ? ? ""
                }
            }), new J("Unexpected auth flow. This may be a phishing attempt.", void 0, ee.OAUTH_UNEXPECTED);
            if (await e.getAccessToken() !== null) try {
                let me = await e.link();
                B = me.user, G = me.oAuthTokens, ie.current = L
            } catch (me) {
                throw _e(ce, "linkAccount", "onError", me.privyErrorCode || ee.FAILED_TO_LINK_ACCOUNT, {
                    linkMethod: L
                }), me
            } else try {
                let me = await e.authenticate();
                B = me.user, Q = me.isNewUser, G = me.oAuthTokens, ie.current = L
            } catch (me) {
                throw Ee.current === "login" ? _e(ce, "login", "onError", me.privyErrorCode || ee.UNKNOWN_AUTH_ERROR) : Ee.current === "link" && _e(ce, "linkAccount", "onError", me.privyErrorCode || ee.FAILED_TO_LINK_ACCOUNT, {
                    linkMethod: L
                }), me
            }
            return h(B), E(Q || !1), l(!0), G && B && _e(ce, "oAuthAuthorization", "onOAuthTokenGrant", {
                oAuthTokens: G,
                user: B
            }), G
        },
        passkeyAuthState: $,
        setPasskeyAuthState: P,
        async initSignupWithPasskey({
            captchaToken: L,
            withPrivyUi: B
        }) {
            let Q = new vu({
                captchaToken: L,
                setPasskeyAuthState: P
            });
            e.startAuthFlow(Q), Ee.current = "login";
            try {
                ie.current = "passkey", P({
                    status: "generating-challenge"
                }), await Q.initRegisterFlow(B), P({
                    status: "awaiting-passkey"
                })
            } catch (G) {
                throw P({
                    status: "error",
                    error: G
                }), _e(ce, "login", "onError", G.privyErrorCode || ee.UNKNOWN_AUTH_ERROR), G
            }
        },
        async signupWithPasskey() {
            let L, B;
            if (!a) throw new xl;
            if (!(e.authFlow instanceof vu)) throw new J("Must initialize Passkey flow first.");
            if (ie.current !== "passkey") {
                let re = new J("Must init login with Passkey flow first.");
                throw P({
                    status: "error",
                    error: re
                }), re
            }
            let Q = await ir();
            try {
                ie.current = "passkey", P({
                    status: "awaiting-passkey"
                }), {
                    user: L,
                    isNewUser: B
                } = await e.authenticate()
            } catch (re) {
                throw P({
                    status: "error",
                    error: re
                }), _e(ce, "login", "onError", re.privyErrorCode || ee.UNKNOWN_AUTH_ERROR), re
            }
            h(L), E(B || !1), l(!0), P({
                status: "done"
            });
            let G = (L == null ? void 0 : L.linkedAccounts.find(({
                type: re
            }) => re === "passkey")) || null;
            return {
                user: L,
                isNewUser: B || !1,
                wasAlreadyAuthenticated: !!Q,
                loginAccount: G
            }
        },
        async initLoginWithPasskey({
            captchaToken: L,
            withPrivyUi: B
        }) {
            let Q = new vu({
                captchaToken: L,
                setPasskeyAuthState: P
            });
            e.startAuthFlow(Q), Ee.current = "login";
            try {
                ie.current = "passkey", P({
                    status: "generating-challenge"
                }), await Q.initAuthenticationFlow(B), P({
                    status: "awaiting-passkey"
                })
            } catch (G) {
                throw P({
                    status: "error",
                    error: G
                }), _e(ce, "login", "onError", G.privyErrorCode || ee.UNKNOWN_AUTH_ERROR), G
            }
        },
        async loginWithPasskey(L) {
            let B, Q;
            if (!a) throw new xl;
            if (!(e.authFlow instanceof vu)) throw new J("Must initialize Passkey flow first.");
            if (L != null && L.credentialIds && (e.authFlow.meta.allowedCredentialsIds = L.credentialIds), ie.current !== "passkey") {
                let se = new J("Must init login with Passkey flow first.");
                throw P({
                    status: "error",
                    error: se
                }), se
            }
            let G = await ir();
            try {
                ie.current = "passkey", P({
                    status: "awaiting-passkey"
                }), {
                    user: B,
                    isNewUser: Q
                } = await e.authenticate()
            } catch (se) {
                throw P({
                    status: "error",
                    error: se
                }), _e(ce, "login", "onError", se.privyErrorCode || ee.UNKNOWN_AUTH_ERROR), se
            }
            h(B), E(Q || !1), l(!0), P({
                status: "done"
            });
            let re = (B == null ? void 0 : B.linkedAccounts.find(({
                type: se
            }) => se === "passkey")) || null;
            return {
                user: B,
                isNewUser: Q || !1,
                wasAlreadyAuthenticated: !!G,
                loginAccount: re
            }
        },
        async initLinkWithPasskey(L) {
            let B = new vu({
                captchaToken: L
            });
            e.startAuthFlow(B), Ee.current = "link", ie.current = "passkey", P({
                status: "generating-challenge"
            });
            try {
                await B.initLinkFlow(), P({
                    status: "awaiting-passkey"
                })
            } catch (Q) {
                throw _e(ce, "linkAccount", "onError", Q.privyErrorCode || ee.UNKNOWN_AUTH_ERROR, {
                    linkMethod: "passkey"
                }), P({
                    status: "error",
                    error: Q
                }), Q
            }
        },
        async linkWithPasskey() {
            let L;
            if (!a) throw new xl;
            if (!(e.authFlow instanceof vu)) throw new J("Must initialize Passkey flow first.");
            if (ie.current !== "passkey") throw new J("Must init login with Passkey flow first.");
            try {
                ie.current = "passkey", {
                    user: L
                } = await e.link()
            } catch (B) {
                throw _e(ce, "linkAccount", "onError", B.privyErrorCode || ee.FAILED_TO_LINK_ACCOUNT, {
                    linkMethod: "passkey"
                }), B
            }
            return h(L || u || null), P({
                status: "done"
            }), L
        },
        async initLoginWithHeadlessOAuth(L, B, Q) {
            if (!l4() || L === "google" && R4(window.navigator.userAgent)) throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");
            let G = new Au({
                provider: L,
                withPrivyUi: !1,
                disableSignup: Q ? ? !1
            });
            B && G.addCaptchaToken(B), k({
                status: "loading"
            });
            let re = await e.startAuthFlow(G).getAuthorizationUrl();
            re != null && re.url && window.location.assign(re.url)
        },
        async loginWithHeadlessOAuth(L) {
            let B, Q, G;
            I(!0), k({
                status: "loading"
            }), e.startAuthFlow(new Au(L));
            let re = rt.get(a1),
                se = L.stateCode;
            if (re !== se) throw e.createAnalyticsEvent({
                eventName: "possible_phishing_attempt",
                payload: {
                    provider: L.provider,
                    storedStateCode: re ? ? "",
                    returnedStateCode: se ? ? ""
                }
            }), I(!1), new J("Unexpected auth flow. This may be a phishing attempt.", void 0, ee.OAUTH_UNEXPECTED);
            if (await e.getAccessToken() !== null) try {
                ({
                    user: B,
                    oAuthTokens: G
                } = await e.link()), ie.current = L.provider;
                let me = Yt(B);
                B && me && _e(ce, "linkAccount", "onSuccess", {
                    user: B,
                    linkMethod: ie.current,
                    linkedAccount: me
                })
            } catch (me) {
                throw I(!1), _e(ce, "linkAccount", "onError", me.privyErrorCode || ee.FAILED_TO_LINK_ACCOUNT, {
                    linkMethod: L.provider
                }), me
            } else try {
                ({
                    user: B,
                    isNewUser: Q,
                    oAuthTokens: G
                } = await e.authenticate()), ie.current = L.provider;
                let me = Yt(B);
                B && me && Q !== void 0 && _e(ce, "login", "onComplete", {
                    user: B,
                    isNewUser: Q,
                    wasAlreadyAuthenticated: !1,
                    loginMethod: ie.current,
                    loginAccount: me
                })
            } catch (me) {
                throw I(!1), k({
                    status: "error",
                    error: me
                }), _e(ce, "login", "onError", me.privyErrorCode || ee.UNKNOWN_AUTH_ERROR), me
            }
            return h(B), E(Q || !1), l(!0), I(!1), k({
                status: "done"
            }), G && B && _e(ce, "oAuthAuthorization", "onOAuthTokenGrant", {
                oAuthTokens: G,
                user: B
            }), B ? ? void 0
        },
        initLoginWithEmail: async ({
            email: L,
            captchaToken: B,
            disableSignup: Q,
            withPrivyUi: G
        }) => {
            let re = new Pu({
                email: L,
                captchaToken: B,
                disableSignup: Q
            });
            e.startAuthFlow(re);
            try {
                ie.current = "email", R({
                    status: "sending-code"
                }), await re.sendCodeEmail({
                    withPrivyUi: G
                }), R({
                    status: "awaiting-code-input"
                })
            } catch (se) {
                throw R({
                    status: "error",
                    error: se
                }), Ee.current === "login" ? _e(ce, "login", "onError", se.privyErrorCode || ee.UNKNOWN_AUTH_ERROR) : Ee.current === "link" && _e(ce, "linkAccount", "onError", se.privyErrorCode || ee.FAILED_TO_LINK_ACCOUNT, {
                    linkMethod: "email"
                }), se
            }
        },
        initUpdateEmail: async ({
            oldAddress: L,
            newAddress: B,
            captchaToken: Q
        }) => {
            let G = new t9e(L, B, Q);
            e.startAuthFlow(G);
            try {
                await G.sendCodeEmail({
                    withPrivyUi: !0
                })
            } catch (re) {
                _e(ce, "update", "onError", re.privyErrorCode || ee.UNKNOWN_AUTH_ERROR, {
                    linkMethod: ie.current
                })
            }
        },
        initUpdatePhone: async (L, B, Q) => {
            let G = new u9e(L, B, Q);
            e.startAuthFlow(G);
            try {
                await G.sendSmsCode({
                    withPrivyUi: !0
                })
            } catch (re) {
                _e(ce, "update", "onError", re.privyErrorCode || ee.UNKNOWN_AUTH_ERROR, {
                    linkMethod: ie.current
                })
            }
        },
        initLoginWithSms: async ({
            phoneNumber: L,
            captchaToken: B,
            disableSignup: Q,
            withPrivyUi: G
        }) => {
            S({
                status: "sending-code"
            });
            let re = new Ou({
                phoneNumber: L,
                captchaToken: B,
                disableSignup: Q
            });
            e.startAuthFlow(re);
            try {
                ie.current = "sms", await re.sendSmsCode({
                    withPrivyUi: G
                }), S({
                    status: "awaiting-code-input"
                })
            } catch (se) {
                throw S({
                    status: "error",
                    error: se
                }), Ee.current === "login" ? _e(ce, "login", "onError", se.privyErrorCode || ee.UNKNOWN_AUTH_ERROR) : Ee.current === "link" && _e(ce, "linkAccount", "onError", se.privyErrorCode || ee.FAILED_TO_LINK_ACCOUNT, {
                    linkMethod: "sms"
                }), se
            }
        },
        resendEmailCode: async () => {
            var L;
            await ((L = e.authFlow) == null ? void 0 : L.sendCodeEmail({
                withPrivyUi: !0
            }))
        },
        resendSmsCode: async () => {
            var L;
            await ((L = e.authFlow) == null ? void 0 : L.sendSmsCode({
                withPrivyUi: !0
            }))
        },
        loginWithCode: async L => {
            let B, Q;

            function G(ve) {
                e.authFlow instanceof Pu ? R(ve) : e.authFlow instanceof Ou && S(ve)
            }
            if (G({
                    status: "submitting-code"
                }), !a) {
                let ve = new xl;
                throw G({
                    status: "error",
                    error: ve
                }), ve
            }
            if (e.authFlow instanceof Pu) e.authFlow.meta.emailCode = L.trim();
            else {
                if (!(e.authFlow instanceof Ou)) {
                    let ve = new J("Must initialize a passwordless code flow first");
                    throw G({
                        status: "error",
                        error: ve
                    }), ve
                }
                e.authFlow.meta.smsCode = L.trim()
            }
            let re = await ir();
            if (Ee.current === "link") try {
                ({
                    user: B
                } = await e.link())
            } catch (ve) {
                throw G({
                    status: "error",
                    error: ve
                }), _e(ce, "linkAccount", "onError", ve.privyErrorCode || ee.FAILED_TO_LINK_ACCOUNT, {
                    linkMethod: ie.current
                }), ve
            } else if (Ee.current === "update") try {
                ({
                    user: B
                } = await e.link())
            } catch (ve) {
                throw G({
                    status: "error",
                    error: ve
                }), _e(ce, "update", "onError", ve.privyErrorCode || ee.FAILED_TO_UPDATE_ACCOUNT, {
                    linkMethod: ie.current
                }), ve
            } else try {
                ({
                    user: B,
                    isNewUser: Q
                } = await e.authenticate())
            } catch (ve) {
                throw G({
                    status: "error",
                    error: ve
                }), _e(ce, "login", "onError", ve.privyErrorCode || ee.UNKNOWN_AUTH_ERROR), ve
            }
            let se = B || u;
            h(se || null), E(Q || !1), l(!0), G({
                status: "done"
            });
            let me = null;
            return e.authFlow instanceof Pu ? me = (se == null ? void 0 : se.linkedAccounts.find(({
                type: ve
            }) => ve === "email")) || null : e.authFlow instanceof Ou && (me = (se == null ? void 0 : se.linkedAccounts.find(({
                type: ve
            }) => ve === "phone")) || null), {
                user: se,
                isNewUser: Q || !1,
                wasAlreadyAuthenticated: !!re,
                linkedAccount: me
            }
        },
        generateSiweMessage: async ({
            address: L,
            chainId: B,
            captchaToken: Q
        }) => {
            Ee.current = c ? "link" : "login", ie.current = "siwe", M({
                status: "generating-message"
            });
            let G = await e.generateSiweNonce({
                address: L,
                captchaToken: Q
            });
            return M({
                status: "awaiting-signature"
            }), g4({
                address: L,
                chainId: B.replace("eip155:", ""),
                nonce: G
            })
        },
        generateSiweMessageForSmartWallet: async ({
            address: L,
            chainId: B
        }) => {
            let Q = await e.generateSiweNonce({
                address: L
            });
            return g4({
                address: L,
                chainId: B.replace("eip155:", ""),
                nonce: Q
            })
        },
        linkSmartWallet: async ({
            message: L,
            signature: B,
            smartWalletType: Q,
            smartWalletVersion: G
        }) => {
            let re;
            re = await e.linkSmartWallet({
                message: L,
                signature: B,
                smartWalletType: Q,
                smartWalletVersion: G
            }), h((re = await pt.refreshSessionAndUser() ? ? re) || u || null)
        },
        loginWithSiwe: async ({
            message: L,
            signature: B,
            captchaToken: Q,
            disableSignup: G
        }) => {
            let re, se = null;
            try {
                if (u) throw Error("User already authenticated");
                let me = new qu(e, void 0, Q, G, {
                    message: L,
                    signature: B
                });
                if (e.startAuthFlow(me), ie.current = "siwe", Ee.current = "login", M({
                        status: "submitting-signature"
                    }), {
                        user: se,
                        isNewUser: re
                    } = await e.authenticate(), !se) throw Error("Authentication failed - no user returned")
            } catch (me) {
                throw _e(ce, "login", "onError", me.privyErrorCode || ee.UNKNOWN_AUTH_ERROR), M({
                    status: "error",
                    error: me
                }), me
            }
            return h(se), E(re || !1), l(!0), M({
                status: "done"
            }), Ee.current = null, ie.current = null, se
        },
        linkWithSiwe: async ({
            message: L,
            signature: B,
            chainId: Q,
            walletClientType: G,
            connectorType: re
        }) => {
            let se;
            we("siwe");
            let me = null;
            try {
                M({
                    status: "submitting-signature"
                }), se = await e.linkWithSiwe({
                    message: L,
                    signature: B,
                    chainId: Q,
                    walletClientType: G,
                    connectorType: re
                }), se = await pt.refreshSessionAndUser() ? ? se, M({
                    status: "done"
                }), (me = Yt(se) || null) && _e(ce, "linkAccount", "onSuccess", {
                    user: se,
                    linkMethod: "siwe",
                    linkedAccount: me
                })
            } catch (Ze) {
                throw _e(ce, "linkAccount", "onError", Ze.privyErrorCode || ee.FAILED_TO_LINK_ACCOUNT, {
                    linkMethod: "siwe"
                }), Ee.current = null, ie.current = null, M({
                    status: "error",
                    error: Ze
                }), Ze
            }
            let ve = se || u;
            return h(ve || null), Ee.current = null, ie.current = null, {
                user: ve,
                linkedAccount: me
            }
        },
        refreshSessionAndUser: async () => {
            let L = await e.getAuthenticatedUser();
            return l(!!L), h(L), L
        },
        walletProxy: W,
        createAnalyticsEvent: ({
            eventName: L,
            payload: B,
            timestamp: Q
        }) => e.createAnalyticsEvent({
            eventName: L,
            payload: B,
            timestamp: Q
        }),
        acceptTerms: async () => {
            let L = await e.acceptTerms();
            return h(L), L
        },
        getUsdTokenPrice: L => e.getUsdTokenPrice(L),
        getUsdPriceForSol: () => e.getUsdPriceForSol(),
        getSplTokenMetadata: L => e.getSplTokenMetadata(L),
        recoverEmbeddedWallet: async L => new Promise(async (B, Q) => {
            if (!u) return void B(!0);
            let G = L != null && L.address ? $s(u, L.address) : Rs(u) || R3(u) || ry(u);
            if (!G || fn(G)) return void B(!0);
            let re = await ir();
            if (!re || !W || !G) return void Q(Error("Must have valid access token and Privy wallet to recover wallet"));
            let {
                entropyId: se,
                entropyIdVerifier: me
            } = Sn(u, G);
            try {
                await W.connect({
                    accessToken: re,
                    entropyId: se,
                    entropyIdVerifier: me
                }), B(!0)
            } catch (ve) {
                if (Hp(ve) && G.recoveryMethod === "privy") {
                    let Ze;
                    e.createAnalyticsEvent({
                        eventName: "embedded_wallet_pinless_recovery_started",
                        payload: {
                            walletAddress: G.address
                        }
                    });
                    try {
                        Ze = await W.recover({
                            entropyId: se,
                            entropyIdVerifier: me,
                            accessToken: re
                        })
                    } catch (kt) {
                        return void Q(kt)
                    }
                    Ze.entropyId || Q(Error("Unable to recover wallet")), e.createAnalyticsEvent({
                        eventName: "embedded_wallet_recovery_completed",
                        payload: {
                            walletAddress: G.address
                        }
                    }), B(!0)
                } else Hp(ve) && G.recoveryMethod !== "privy" && G.recoveryMethod !== "privy-v2" ? (Y({
                    recoverWallet: {
                        entropyId: se,
                        entropyIdVerifier: me,
                        onFailure: Q,
                        onSuccess: () => B(!0)
                    },
                    recoveryOAuthStatus: {
                        provider: G.recoveryMethod,
                        action: "recover",
                        shouldCreateEth: !1,
                        shouldCreateSol: !1
                    }
                }), Le(hB(G.recoveryMethod))) : Q(ve)
            }
        }),
        exportSolanaWallet: L => new Promise(async (B, Q) => {
            if (!c || !u) return void Q(Error("User must be authenticated before exporting their Privy wallet"));
            let G = L != null && L.address ? $s(u, L.address) : Sd(u);
            if (!G) return void Q(new J("User must have an embedded wallet."));
            let {
                entropyId: re,
                entropyIdVerifier: se
            } = Sn(u, G), me = fn(G);
            if (!await ir() || !W) return void Q(Error("Must have valid access token to enroll in MFA"));
            if (!W) return void Q(Error("Must have a Privy wallet before exporting"));
            let ve = {
                recoveryMethod: G.recoveryMethod,
                connectingWalletAddress: G.address,
                isUnifiedWallet: me,
                entropyId: re,
                entropyIdVerifier: se,
                onCompleteNavigateTo: B4,
                onFailure: Q,
                shouldForceMFA: !0
            };
            lh(G) ? (Y({
                connectWallet: ve,
                keyExport: {
                    appId: t.appId,
                    appClientId: t.clientId,
                    origin: e.apiUrl,
                    address: G.address,
                    entropyId: re,
                    entropyIdVerifier: se,
                    hdWalletIndex: G.walletIndex,
                    chainType: G.chainType,
                    walletId: G.id,
                    isUnifiedWallet: me,
                    imported: G.imported,
                    onSuccess: B,
                    onFailure: Q
                }
            }), Le(Lc)) : Q(Error(`Export is not supported for ${G.chainType} wallets`))
        }),
        setReadyToTrue: L => {
            o(!0), X == null || X(L)
        },
        updateWallets: () => _t(),
        fundWallet: async (L, B) => {
            Y({
                funding: iS({
                    address: L,
                    appConfig: H,
                    fundWalletConfig: B,
                    methodScreen: Ui
                })
            }), Le(Ui)
        },
        openModal: Le,
        requestFarcasterSignerStatus: async L => {
            var re;
            let B = await ir(),
                Q = u == null ? void 0 : u.linkedAccounts.find(se => se.type === "wallet" && se.walletClientType === "privy");
            if (!B) throw Error("Must have valid access token to connect with Farcaster");
            if (!W || !Q) throw Error("Must have an embedded wallet to use Farcaster signers");
            if (!((re = u == null ? void 0 : u.farcaster) != null && re.fid)) throw Error("Must have Farcaster account to use Farcaster signers");
            let G = await e.requestFarcasterSignerStatus(L);
            return G.status === "approved" && h(await e.getAuthenticatedUser() || u || null), G
        },
        connectCoinbaseSmartWallet: async () => {
            var B, Q;
            H.externalWallets.coinbaseWallet.config.preference = { ...H.externalWallets.coinbaseWallet.config.preference,
                options: "smartWalletOnly"
            };
            let L = ((B = e.connectors) == null ? void 0 : B.findWalletConnector("coinbase_wallet", "coinbase_smart_wallet")) || ((Q = e.connectors) == null ? void 0 : Q.findWalletConnector("coinbase_wallet", "coinbase_wallet"));
            if (L) return L.updateConnectionPreference("smartWalletOnly"), dt(L);
            await We("coinbase_wallet", "coinbase_smart_wallet")
        },
        connectBaseAccount: async () => {
            var B;
            let L = (B = e.connectors) == null ? void 0 : B.findWalletConnector("base_account", "base_account");
            if (L) return dt(L);
            await We("base_account", "base_account")
        },
        initiateAccountTransfer: async ({
            nonce: L,
            account: B,
            accountType: Q,
            externalWalletMetadata: G,
            telegramAuthResult: re,
            telegramWebAppData: se,
            farcasterEmbeddedAddress: me,
            oAuthUserInfo: ve
        }) => {
            let Ze = await e.sendAccountTransferRequest({
                nonce: L,
                account: B,
                accountType: Q,
                externalWalletMetadata: G,
                telegramAuthResult: re,
                telegramWebAppData: se,
                farcasterEmbeddedAddress: me,
                oAuthUserInfo: ve
            });
            return h(Ze), Ze
        },
        inProgressAuthFlowRef: Ee,
        inProgressLoginOrLinkMethodRef: ie
    };
    YB = pt.recoverEmbeddedWallet, ZB = pt.recoverEmbeddedWallet;
    let Un = v.useMemo(() => ({
            wallets: f,
            ready: ue && Ie
        }), [f, ue, Ie]),
        ei = e.authFlow instanceof hf,
        ti = !H.headless && H.captchaEnabled && !c && (a || ei);
    return d.jsx(qB.Provider, {
        value: !0,
        children: d.jsx(Td.Provider, {
            value: Vr,
            children: d.jsx(NU.Provider, {
                value: ce,
                children: d.jsx(nF.Provider, {
                    value: Un,
                    children: d.jsx(g9e, { ...H,
                        children: d.jsxs(dO.Provider, {
                            value: pt,
                            children: [d.jsx(tke, {
                                children: d.jsxs(j9e, {
                                    data: V,
                                    setModalData: Y,
                                    setInitialScreen: b,
                                    initialScreen: _,
                                    authenticated: c,
                                    open: i,
                                    children: [t.children, d.jsx(kPe, {
                                        customAuth: H.customAuth
                                    }), ti && d.jsx(K9e, {
                                        delayedExecution: !1
                                    }), d.jsx(gAe, {}), d.jsx(UTe, {
                                        disabled: H.embeddedWallets.disableAutomaticMigration
                                    }), d.jsx(nAe, {
                                        theme: { ...H.appearance.palette || {}
                                        }
                                    }), !H.render.standalone && d.jsx(uAe, {
                                        open: i
                                    })]
                                })
                            }), d.jsx(wAe, {
                                appId: t.appId,
                                appClientId: t.clientId,
                                clientAnalyticsId: e.clientAnalyticsId,
                                origin: e.apiUrl,
                                mfaMethods: u == null ? void 0 : u.mfaMethods,
                                mfaPromise: ye,
                                mfaSubmitPromise: Be,
                                onLoad: K,
                                onLoadFailed: () => null
                            }), H.loginConfig.telegramAuthConfiguration && d.jsx(ch, {
                                $if: !0,
                                children: d.jsx(fAe, {
                                    scriptHost: t.apiUrl || u4,
                                    botUsername: H.loginConfig.telegramAuthConfiguration.botName
                                })
                            })]
                        })
                    })
                })
            })
        })
    })
};

function Nje(t) {
    let {
        connectWallet: e
    } = v.useContext(Td);
    return Wd("connectWallet", t), {
        connectWallet: e
    }
}
export {
    fc as $, Uve as A, yd as B, k1e as C, Gl as D, wi as E, Ly as F, KEe as G, Ja as H, Od as I, Is as J, Za as K, Ra as L, kr as M, _x as N, $0 as O, JC as P, WM as Q, z3 as R, r9 as S, Lf as T, Qse as U, iOe as V, as as W, qo as X, nt as Y, GH as Z, or as _, nNe as a, Pn as a0, rNe as a1, CV as a2, ht as a3, d7 as a4, ec as a5, FS as a6, be as a7, Qp as a8, Di as a9, GT as aA, Xu as aB, VZ as aC, Zl as aD, Ns as aE, Ho as aF, ET as aG, sd as aH, Rr as aI, sNe as aJ, tNe as aK, sz as aL, hh as aM, ZPe as aN, va as aO, t0 as aP, i6 as aQ, kV as aR, I9e as aS, Hh as aT, cOe as aU, al as aV, mw as aW, z0 as aX, Nje as aY, Tje as aZ, Pje as a_, fT as aa, xH as ab, Jv as ac, vH as ad, ss as ae, Id as af, qr as ag, hs as ah, OZ as ai, zP as aj, gh as ak, n6 as al, Qo as am, yV as an, zr as ao, tc as ap, mh as aq, CP as ar, eNe as as, nc as at, gi as au, Jn as av, GD as aw, ove as ax, cve as ay, rk as az, b0 as b, QC as c, Me as d, sc as e, Nn as f, bhe as g, rc as h, tfe as i, gs as j, My as k, Gbe as l, Eve as m, Zc as n, jd as o, Hs as p, Y3e as q, F_e as r, A5 as s, cn as t, Xx as u, Uy as v, Dy as w, Sme as x, zi as y, ac as z
};